var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var require_index_001 = __commonJS({
  "assets/index-74d6cc4c.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(script) {
        const fetchOpts = {};
        if (script.integrity)
          fetchOpts.integrity = script.integrity;
        if (script.referrerpolicy)
          fetchOpts.referrerPolicy = script.referrerpolicy;
        if (script.crossorigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (script.crossorigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    function getAugmentedNamespace(n2) {
      var f2 = n2.default;
      if (typeof f2 == "function") {
        var a = function a2() {
          if (this instanceof a2) {
            var args = [null];
            args.push.apply(args, arguments);
            var Ctor = Function.bind.apply(f2, args);
            return new Ctor();
          }
          return f2.apply(this, arguments);
        };
        a.prototype = f2.prototype;
      } else
        a = {};
      Object.defineProperty(a, "__esModule", { value: true });
      Object.keys(n2).forEach(function(k) {
        var d = Object.getOwnPropertyDescriptor(n2, k);
        Object.defineProperty(a, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return n2[k];
          }
        });
      });
      return a;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production_min = {};
    var react = { exports: {} };
    var react_production_min = {};
    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject$1(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to2 = toObject$1(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from2 = Object(arguments[s]);
        for (var key in from2) {
          if (hasOwnProperty$2.call(from2, key)) {
            to2[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from2, symbols[i])) {
              to2[symbols[i]] = from2[symbols[i]];
            }
          }
        }
      }
      return to2;
    };
    /** @license React v16.14.0
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l = objectAssign, n$2 = "function" === typeof Symbol && Symbol.for, p$2 = n$2 ? Symbol.for("react.element") : 60103, q$1 = n$2 ? Symbol.for("react.portal") : 60106, r$1 = n$2 ? Symbol.for("react.fragment") : 60107, t = n$2 ? Symbol.for("react.strict_mode") : 60108, u$1 = n$2 ? Symbol.for("react.profiler") : 60114, v$1 = n$2 ? Symbol.for("react.provider") : 60109, w = n$2 ? Symbol.for("react.context") : 60110, x$1 = n$2 ? Symbol.for("react.forward_ref") : 60112, y = n$2 ? Symbol.for("react.suspense") : 60113, z = n$2 ? Symbol.for("react.memo") : 60115, A = n$2 ? Symbol.for("react.lazy") : 60116, B = "function" === typeof Symbol && Symbol.iterator;
    function C$1(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var D = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, E$1 = {};
    function F$1(a, b, c) {
      this.props = a;
      this.context = b;
      this.refs = E$1;
      this.updater = c || D;
    }
    F$1.prototype.isReactComponent = {};
    F$1.prototype.setState = function(a, b) {
      if ("object" !== typeof a && "function" !== typeof a && null != a)
        throw Error(C$1(85));
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    F$1.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function G$1() {
    }
    G$1.prototype = F$1.prototype;
    function H$1(a, b, c) {
      this.props = a;
      this.context = b;
      this.refs = E$1;
      this.updater = c || D;
    }
    var I$1 = H$1.prototype = new G$1();
    I$1.constructor = H$1;
    l(I$1, F$1.prototype);
    I$1.isPureReactComponent = true;
    var J$1 = { current: null }, K$1 = Object.prototype.hasOwnProperty, L$1 = { key: true, ref: true, __self: true, __source: true };
    function M$1(a, b, c) {
      var e, d = {}, g2 = null, k = null;
      if (null != b)
        for (e in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (g2 = "" + b.key), b)
          K$1.call(b, e) && !L$1.hasOwnProperty(e) && (d[e] = b[e]);
      var f2 = arguments.length - 2;
      if (1 === f2)
        d.children = c;
      else if (1 < f2) {
        for (var h2 = Array(f2), m2 = 0; m2 < f2; m2++)
          h2[m2] = arguments[m2 + 2];
        d.children = h2;
      }
      if (a && a.defaultProps)
        for (e in f2 = a.defaultProps, f2)
          void 0 === d[e] && (d[e] = f2[e]);
      return { $$typeof: p$2, type: a, key: g2, ref: k, props: d, _owner: J$1.current };
    }
    function N$1(a, b) {
      return { $$typeof: p$2, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O$1(a) {
      return "object" === typeof a && null !== a && a.$$typeof === p$2;
    }
    function escape$2(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + ("" + a).replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P$1 = /\/+/g, Q$1 = [];
    function R$1(a, b, c, e) {
      if (Q$1.length) {
        var d = Q$1.pop();
        d.result = a;
        d.keyPrefix = b;
        d.func = c;
        d.context = e;
        d.count = 0;
        return d;
      }
      return { result: a, keyPrefix: b, func: c, context: e, count: 0 };
    }
    function S$1(a) {
      a.result = null;
      a.keyPrefix = null;
      a.func = null;
      a.context = null;
      a.count = 0;
      10 > Q$1.length && Q$1.push(a);
    }
    function T$1(a, b, c, e) {
      var d = typeof a;
      if ("undefined" === d || "boolean" === d)
        a = null;
      var g2 = false;
      if (null === a)
        g2 = true;
      else
        switch (d) {
          case "string":
          case "number":
            g2 = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case p$2:
              case q$1:
                g2 = true;
            }
        }
      if (g2)
        return c(e, a, "" === b ? "." + U$1(a, 0) : b), 1;
      g2 = 0;
      b = "" === b ? "." : b + ":";
      if (Array.isArray(a))
        for (var k = 0; k < a.length; k++) {
          d = a[k];
          var f2 = b + U$1(d, k);
          g2 += T$1(d, f2, c, e);
        }
      else if (null === a || "object" !== typeof a ? f2 = null : (f2 = B && a[B] || a["@@iterator"], f2 = "function" === typeof f2 ? f2 : null), "function" === typeof f2)
        for (a = f2.call(a), k = 0; !(d = a.next()).done; )
          d = d.value, f2 = b + U$1(d, k++), g2 += T$1(d, f2, c, e);
      else if ("object" === d)
        throw c = "" + a, Error(C$1(31, "[object Object]" === c ? "object with keys {" + Object.keys(a).join(", ") + "}" : c, ""));
      return g2;
    }
    function V$1(a, b, c) {
      return null == a ? 0 : T$1(a, "", b, c);
    }
    function U$1(a, b) {
      return "object" === typeof a && null !== a && null != a.key ? escape$2(a.key) : b.toString(36);
    }
    function W$1(a, b) {
      a.func.call(a.context, b, a.count++);
    }
    function aa$1(a, b, c) {
      var e = a.result, d = a.keyPrefix;
      a = a.func.call(a.context, b, a.count++);
      Array.isArray(a) ? X$1(a, e, c, function(a2) {
        return a2;
      }) : null != a && (O$1(a) && (a = N$1(a, d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(P$1, "$&/") + "/") + c)), e.push(a));
    }
    function X$1(a, b, c, e, d) {
      var g2 = "";
      null != c && (g2 = ("" + c).replace(P$1, "$&/") + "/");
      b = R$1(b, g2, e, d);
      V$1(a, aa$1, b);
      S$1(b);
    }
    var Y$1 = { current: null };
    function Z$1() {
      var a = Y$1.current;
      if (null === a)
        throw Error(C$1(321));
      return a;
    }
    var ba$1 = { ReactCurrentDispatcher: Y$1, ReactCurrentBatchConfig: { suspense: null }, ReactCurrentOwner: J$1, IsSomeRendererActing: { current: false }, assign: l };
    react_production_min.Children = { map: function(a, b, c) {
      if (null == a)
        return a;
      var e = [];
      X$1(a, e, null, b, c);
      return e;
    }, forEach: function(a, b, c) {
      if (null == a)
        return a;
      b = R$1(null, null, b, c);
      V$1(a, W$1, b);
      S$1(b);
    }, count: function(a) {
      return V$1(a, function() {
        return null;
      }, null);
    }, toArray: function(a) {
      var b = [];
      X$1(a, b, null, function(a2) {
        return a2;
      });
      return b;
    }, only: function(a) {
      if (!O$1(a))
        throw Error(C$1(143));
      return a;
    } };
    react_production_min.Component = F$1;
    react_production_min.Fragment = r$1;
    react_production_min.Profiler = u$1;
    react_production_min.PureComponent = H$1;
    react_production_min.StrictMode = t;
    react_production_min.Suspense = y;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ba$1;
    react_production_min.cloneElement = function(a, b, c) {
      if (null === a || void 0 === a)
        throw Error(C$1(267, a));
      var e = l({}, a.props), d = a.key, g2 = a.ref, k = a._owner;
      if (null != b) {
        void 0 !== b.ref && (g2 = b.ref, k = J$1.current);
        void 0 !== b.key && (d = "" + b.key);
        if (a.type && a.type.defaultProps)
          var f2 = a.type.defaultProps;
        for (h2 in b)
          K$1.call(b, h2) && !L$1.hasOwnProperty(h2) && (e[h2] = void 0 === b[h2] && void 0 !== f2 ? f2[h2] : b[h2]);
      }
      var h2 = arguments.length - 2;
      if (1 === h2)
        e.children = c;
      else if (1 < h2) {
        f2 = Array(h2);
        for (var m2 = 0; m2 < h2; m2++)
          f2[m2] = arguments[m2 + 2];
        e.children = f2;
      }
      return {
        $$typeof: p$2,
        type: a.type,
        key: d,
        ref: g2,
        props: e,
        _owner: k
      };
    };
    react_production_min.createContext = function(a, b) {
      void 0 === b && (b = null);
      a = { $$typeof: w, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
      a.Provider = { $$typeof: v$1, _context: a };
      return a.Consumer = a;
    };
    react_production_min.createElement = M$1;
    react_production_min.createFactory = function(a) {
      var b = M$1.bind(null, a);
      b.type = a;
      return b;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a) {
      return { $$typeof: x$1, render: a };
    };
    react_production_min.isValidElement = O$1;
    react_production_min.lazy = function(a) {
      return { $$typeof: A, _ctor: a, _status: -1, _result: null };
    };
    react_production_min.memo = function(a, b) {
      return { $$typeof: z, type: a, compare: void 0 === b ? null : b };
    };
    react_production_min.useCallback = function(a, b) {
      return Z$1().useCallback(a, b);
    };
    react_production_min.useContext = function(a, b) {
      return Z$1().useContext(a, b);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useEffect = function(a, b) {
      return Z$1().useEffect(a, b);
    };
    react_production_min.useImperativeHandle = function(a, b, c) {
      return Z$1().useImperativeHandle(a, b, c);
    };
    react_production_min.useLayoutEffect = function(a, b) {
      return Z$1().useLayoutEffect(a, b);
    };
    react_production_min.useMemo = function(a, b) {
      return Z$1().useMemo(a, b);
    };
    react_production_min.useReducer = function(a, b, c) {
      return Z$1().useReducer(a, b, c);
    };
    react_production_min.useRef = function(a) {
      return Z$1().useRef(a);
    };
    react_production_min.useState = function(a) {
      return Z$1().useState(a);
    };
    react_production_min.version = "16.14.0";
    (function(module2) {
      {
        module2.exports = react_production_min;
      }
    })(react);
    const React = /* @__PURE__ */ getDefaultExportFromCjs(react.exports);
    /** @license React v16.14.0
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f = react.exports, g = 60103;
    reactJsxRuntime_production_min.Fragment = 60107;
    if ("function" === typeof Symbol && Symbol.for) {
      var h = Symbol.for;
      g = h("react.element");
      reactJsxRuntime_production_min.Fragment = h("react.fragment");
    }
    var m = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n$1 = Object.prototype.hasOwnProperty, p$1 = { key: true, ref: true, __self: true, __source: true };
    function q(c, a, k) {
      var b, d = {}, e = null, l2 = null;
      void 0 !== k && (e = "" + k);
      void 0 !== a.key && (e = "" + a.key);
      void 0 !== a.ref && (l2 = a.ref);
      for (b in a)
        n$1.call(a, b) && !p$1.hasOwnProperty(b) && (d[b] = a[b]);
      if (c && c.defaultProps)
        for (b in a = c.defaultProps, a)
          void 0 === d[b] && (d[b] = a[b]);
      return { $$typeof: g, type: c, key: e, ref: l2, props: d, _owner: m.current };
    }
    reactJsxRuntime_production_min.jsx = q;
    reactJsxRuntime_production_min.jsxs = q;
    (function(module2) {
      {
        module2.exports = reactJsxRuntime_production_min;
      }
    })(jsxRuntime);
    const Fragment = jsxRuntime.exports.Fragment;
    const jsx = jsxRuntime.exports.jsx;
    const jsxs = jsxRuntime.exports.jsxs;
    var reactDom = { exports: {} };
    var reactDom_production_min = {};
    var scheduler = { exports: {} };
    var scheduler_production_min = {};
    /** @license React v0.19.1
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      var f2, g2, h2, k, l2;
      if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
        var p2 = null, q2 = null, t2 = function() {
          if (null !== p2)
            try {
              var a = exports2.unstable_now();
              p2(true, a);
              p2 = null;
            } catch (b) {
              throw setTimeout(t2, 0), b;
            }
        }, u2 = Date.now();
        exports2.unstable_now = function() {
          return Date.now() - u2;
        };
        f2 = function(a) {
          null !== p2 ? setTimeout(f2, 0, a) : (p2 = a, setTimeout(t2, 0));
        };
        g2 = function(a, b) {
          q2 = setTimeout(a, b);
        };
        h2 = function() {
          clearTimeout(q2);
        };
        k = function() {
          return false;
        };
        l2 = exports2.unstable_forceFrameRate = function() {
        };
      } else {
        var w2 = window.performance, x2 = window.Date, y2 = window.setTimeout, z2 = window.clearTimeout;
        if ("undefined" !== typeof console) {
          var A2 = window.cancelAnimationFrame;
          "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
          "function" !== typeof A2 && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
        }
        if ("object" === typeof w2 && "function" === typeof w2.now)
          exports2.unstable_now = function() {
            return w2.now();
          };
        else {
          var B2 = x2.now();
          exports2.unstable_now = function() {
            return x2.now() - B2;
          };
        }
        var C2 = false, D2 = null, E2 = -1, F2 = 5, G2 = 0;
        k = function() {
          return exports2.unstable_now() >= G2;
        };
        l2 = function() {
        };
        exports2.unstable_forceFrameRate = function(a) {
          0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported") : F2 = 0 < a ? Math.floor(1e3 / a) : 5;
        };
        var H2 = new MessageChannel(), I2 = H2.port2;
        H2.port1.onmessage = function() {
          if (null !== D2) {
            var a = exports2.unstable_now();
            G2 = a + F2;
            try {
              D2(true, a) ? I2.postMessage(null) : (C2 = false, D2 = null);
            } catch (b) {
              throw I2.postMessage(null), b;
            }
          } else
            C2 = false;
        };
        f2 = function(a) {
          D2 = a;
          C2 || (C2 = true, I2.postMessage(null));
        };
        g2 = function(a, b) {
          E2 = y2(function() {
            a(exports2.unstable_now());
          }, b);
        };
        h2 = function() {
          z2(E2);
          E2 = -1;
        };
      }
      function J2(a, b) {
        var c = a.length;
        a.push(b);
        a:
          for (; ; ) {
            var d = c - 1 >>> 1, e = a[d];
            if (void 0 !== e && 0 < K2(e, b))
              a[d] = b, a[c] = e, c = d;
            else
              break a;
          }
      }
      function L2(a) {
        a = a[0];
        return void 0 === a ? null : a;
      }
      function M2(a) {
        var b = a[0];
        if (void 0 !== b) {
          var c = a.pop();
          if (c !== b) {
            a[0] = c;
            a:
              for (var d = 0, e = a.length; d < e; ) {
                var m2 = 2 * (d + 1) - 1, n2 = a[m2], v2 = m2 + 1, r2 = a[v2];
                if (void 0 !== n2 && 0 > K2(n2, c))
                  void 0 !== r2 && 0 > K2(r2, n2) ? (a[d] = r2, a[v2] = c, d = v2) : (a[d] = n2, a[m2] = c, d = m2);
                else if (void 0 !== r2 && 0 > K2(r2, c))
                  a[d] = r2, a[v2] = c, d = v2;
                else
                  break a;
              }
          }
          return b;
        }
        return null;
      }
      function K2(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      var N2 = [], O2 = [], P2 = 1, Q2 = null, R2 = 3, S2 = false, T2 = false, U2 = false;
      function V2(a) {
        for (var b = L2(O2); null !== b; ) {
          if (null === b.callback)
            M2(O2);
          else if (b.startTime <= a)
            M2(O2), b.sortIndex = b.expirationTime, J2(N2, b);
          else
            break;
          b = L2(O2);
        }
      }
      function W2(a) {
        U2 = false;
        V2(a);
        if (!T2)
          if (null !== L2(N2))
            T2 = true, f2(X2);
          else {
            var b = L2(O2);
            null !== b && g2(W2, b.startTime - a);
          }
      }
      function X2(a, b) {
        T2 = false;
        U2 && (U2 = false, h2());
        S2 = true;
        var c = R2;
        try {
          V2(b);
          for (Q2 = L2(N2); null !== Q2 && (!(Q2.expirationTime > b) || a && !k()); ) {
            var d = Q2.callback;
            if (null !== d) {
              Q2.callback = null;
              R2 = Q2.priorityLevel;
              var e = d(Q2.expirationTime <= b);
              b = exports2.unstable_now();
              "function" === typeof e ? Q2.callback = e : Q2 === L2(N2) && M2(N2);
              V2(b);
            } else
              M2(N2);
            Q2 = L2(N2);
          }
          if (null !== Q2)
            var m2 = true;
          else {
            var n2 = L2(O2);
            null !== n2 && g2(W2, n2.startTime - b);
            m2 = false;
          }
          return m2;
        } finally {
          Q2 = null, R2 = c, S2 = false;
        }
      }
      function Y2(a) {
        switch (a) {
          case 1:
            return -1;
          case 2:
            return 250;
          case 5:
            return 1073741823;
          case 4:
            return 1e4;
          default:
            return 5e3;
        }
      }
      var Z2 = l2;
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        T2 || S2 || (T2 = true, f2(X2));
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return R2;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return L2(N2);
      };
      exports2.unstable_next = function(a) {
        switch (R2) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = R2;
        }
        var c = R2;
        R2 = b;
        try {
          return a();
        } finally {
          R2 = c;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = Z2;
      exports2.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = R2;
        R2 = a;
        try {
          return b();
        } finally {
          R2 = c;
        }
      };
      exports2.unstable_scheduleCallback = function(a, b, c) {
        var d = exports2.unstable_now();
        if ("object" === typeof c && null !== c) {
          var e = c.delay;
          e = "number" === typeof e && 0 < e ? d + e : d;
          c = "number" === typeof c.timeout ? c.timeout : Y2(a);
        } else
          c = Y2(a), e = d;
        c = e + c;
        a = { id: P2++, callback: b, priorityLevel: a, startTime: e, expirationTime: c, sortIndex: -1 };
        e > d ? (a.sortIndex = e, J2(O2, a), null === L2(N2) && a === L2(O2) && (U2 ? h2() : U2 = true, g2(W2, e - d))) : (a.sortIndex = c, J2(N2, a), T2 || S2 || (T2 = true, f2(X2)));
        return a;
      };
      exports2.unstable_shouldYield = function() {
        var a = exports2.unstable_now();
        V2(a);
        var b = L2(N2);
        return b !== Q2 && null !== Q2 && null !== b && null !== b.callback && b.startTime <= a && b.expirationTime < Q2.expirationTime || k();
      };
      exports2.unstable_wrapCallback = function(a) {
        var b = R2;
        return function() {
          var c = R2;
          R2 = b;
          try {
            return a.apply(this, arguments);
          } finally {
            R2 = c;
          }
        };
      };
    })(scheduler_production_min);
    (function(module2) {
      {
        module2.exports = scheduler_production_min;
      }
    })(scheduler);
    /** @license React v16.14.0
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = react.exports, n = objectAssign, r = scheduler.exports;
    function u(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    if (!aa)
      throw Error(u(227));
    function ba(a, b, c, d, e, f2, g2, h2, k) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l2);
      } catch (m2) {
        this.onError(m2);
      }
    }
    var da = false, ea = null, fa = false, ha = null, ia = { onError: function(a) {
      da = true;
      ea = a;
    } };
    function ja(a, b, c, d, e, f2, g2, h2, k) {
      da = false;
      ea = null;
      ba.apply(ia, arguments);
    }
    function ka(a, b, c, d, e, f2, g2, h2, k) {
      ja.apply(this, arguments);
      if (da) {
        if (da) {
          var l2 = ea;
          da = false;
          ea = null;
        } else
          throw Error(u(198));
        fa || (fa = true, ha = l2);
      }
    }
    var la = null, ma = null, na = null;
    function oa(a, b, c) {
      var d = a.type || "unknown-event";
      a.currentTarget = na(c);
      ka(d, b, void 0, a);
      a.currentTarget = null;
    }
    var pa = null, qa = {};
    function ra() {
      if (pa)
        for (var a in qa) {
          var b = qa[a], c = pa.indexOf(a);
          if (!(-1 < c))
            throw Error(u(96, a));
          if (!sa[c]) {
            if (!b.extractEvents)
              throw Error(u(97, a));
            sa[c] = b;
            c = b.eventTypes;
            for (var d in c) {
              var e = void 0;
              var f2 = c[d], g2 = b, h2 = d;
              if (ta.hasOwnProperty(h2))
                throw Error(u(99, h2));
              ta[h2] = f2;
              var k = f2.phasedRegistrationNames;
              if (k) {
                for (e in k)
                  k.hasOwnProperty(e) && ua(k[e], g2, h2);
                e = true;
              } else
                f2.registrationName ? (ua(f2.registrationName, g2, h2), e = true) : e = false;
              if (!e)
                throw Error(u(98, d, a));
            }
          }
        }
    }
    function ua(a, b, c) {
      if (va[a])
        throw Error(u(100, a));
      va[a] = b;
      wa[a] = b.eventTypes[c].dependencies;
    }
    var sa = [], ta = {}, va = {}, wa = {};
    function xa(a) {
      var b = false, c;
      for (c in a)
        if (a.hasOwnProperty(c)) {
          var d = a[c];
          if (!qa.hasOwnProperty(c) || qa[c] !== d) {
            if (qa[c])
              throw Error(u(102, c));
            qa[c] = d;
            b = true;
          }
        }
      b && ra();
    }
    var ya = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), za = null, Aa = null, Ba = null;
    function Ca(a) {
      if (a = ma(a)) {
        if ("function" !== typeof za)
          throw Error(u(280));
        var b = a.stateNode;
        b && (b = la(b), za(a.stateNode, a.type, b));
      }
    }
    function Da(a) {
      Aa ? Ba ? Ba.push(a) : Ba = [a] : Aa = a;
    }
    function Ea() {
      if (Aa) {
        var a = Aa, b = Ba;
        Ba = Aa = null;
        Ca(a);
        if (b)
          for (a = 0; a < b.length; a++)
            Ca(b[a]);
      }
    }
    function Fa(a, b) {
      return a(b);
    }
    function Ga(a, b, c, d, e) {
      return a(b, c, d, e);
    }
    function Ha() {
    }
    var Ia = Fa, Ja = false, Ka = false;
    function La() {
      if (null !== Aa || null !== Ba)
        Ha(), Ea();
    }
    function Ma(a, b, c) {
      if (Ka)
        return a(b, c);
      Ka = true;
      try {
        return Ia(a, b, c);
      } finally {
        Ka = false, La();
      }
    }
    var Na = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Oa = Object.prototype.hasOwnProperty, Pa = {}, Qa = {};
    function Ra(a) {
      if (Oa.call(Qa, a))
        return true;
      if (Oa.call(Pa, a))
        return false;
      if (Na.test(a))
        return Qa[a] = true;
      Pa[a] = true;
      return false;
    }
    function Sa(a, b, c, d) {
      if (null !== c && 0 === c.type)
        return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d)
            return false;
          if (null !== c)
            return !c.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    function Ta(a, b, c, d) {
      if (null === b || "undefined" === typeof b || Sa(a, b, c, d))
        return true;
      if (d)
        return false;
      if (null !== c)
        switch (c.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
      return false;
    }
    function v(a, b, c, d, e, f2) {
      this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
      this.attributeName = d;
      this.attributeNamespace = e;
      this.mustUseProperty = c;
      this.propertyName = a;
      this.type = b;
      this.sanitizeURL = f2;
    }
    var C = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      C[a] = new v(a, 0, false, a, null, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      C[b] = new v(b, 1, false, a[1], null, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      C[a] = new v(a, 2, false, a.toLowerCase(), null, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      C[a] = new v(a, 2, false, a, null, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      C[a] = new v(a, 3, false, a.toLowerCase(), null, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      C[a] = new v(a, 3, true, a, null, false);
    });
    ["capture", "download"].forEach(function(a) {
      C[a] = new v(a, 4, false, a, null, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      C[a] = new v(a, 6, false, a, null, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      C[a] = new v(a, 5, false, a.toLowerCase(), null, false);
    });
    var Ua = /[\-:]([a-z])/g;
    function Va(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        Ua,
        Va
      );
      C[b] = new v(b, 1, false, a, null, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(Ua, Va);
      C[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(Ua, Va);
      C[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      C[a] = new v(a, 1, false, a.toLowerCase(), null, false);
    });
    C.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      C[a] = new v(a, 1, false, a.toLowerCase(), null, true);
    });
    var Wa = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    Wa.hasOwnProperty("ReactCurrentDispatcher") || (Wa.ReactCurrentDispatcher = { current: null });
    Wa.hasOwnProperty("ReactCurrentBatchConfig") || (Wa.ReactCurrentBatchConfig = { suspense: null });
    function Xa(a, b, c, d) {
      var e = C.hasOwnProperty(b) ? C[b] : null;
      var f2 = null !== e ? 0 === e.type : d ? false : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? false : true;
      f2 || (Ta(b, c, e, d) && (c = null), d || null === e ? Ra(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
    }
    var Ya = /^(.*)[\\\/]/, E = "function" === typeof Symbol && Symbol.for, Za = E ? Symbol.for("react.element") : 60103, $a = E ? Symbol.for("react.portal") : 60106, ab = E ? Symbol.for("react.fragment") : 60107, bb = E ? Symbol.for("react.strict_mode") : 60108, cb$1 = E ? Symbol.for("react.profiler") : 60114, db = E ? Symbol.for("react.provider") : 60109, eb = E ? Symbol.for("react.context") : 60110, fb = E ? Symbol.for("react.concurrent_mode") : 60111, gb = E ? Symbol.for("react.forward_ref") : 60112, hb = E ? Symbol.for("react.suspense") : 60113, ib = E ? Symbol.for("react.suspense_list") : 60120, jb = E ? Symbol.for("react.memo") : 60115, kb = E ? Symbol.for("react.lazy") : 60116, lb = E ? Symbol.for("react.block") : 60121, mb = "function" === typeof Symbol && Symbol.iterator;
    function nb(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = mb && a[mb] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    function ob(a) {
      if (-1 === a._status) {
        a._status = 0;
        var b = a._ctor;
        b = b();
        a._result = b;
        b.then(function(b2) {
          0 === a._status && (b2 = b2.default, a._status = 1, a._result = b2);
        }, function(b2) {
          0 === a._status && (a._status = 2, a._result = b2);
        });
      }
    }
    function pb(a) {
      if (null == a)
        return null;
      if ("function" === typeof a)
        return a.displayName || a.name || null;
      if ("string" === typeof a)
        return a;
      switch (a) {
        case ab:
          return "Fragment";
        case $a:
          return "Portal";
        case cb$1:
          return "Profiler";
        case bb:
          return "StrictMode";
        case hb:
          return "Suspense";
        case ib:
          return "SuspenseList";
      }
      if ("object" === typeof a)
        switch (a.$$typeof) {
          case eb:
            return "Context.Consumer";
          case db:
            return "Context.Provider";
          case gb:
            var b = a.render;
            b = b.displayName || b.name || "";
            return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");
          case jb:
            return pb(a.type);
          case lb:
            return pb(a.render);
          case kb:
            if (a = 1 === a._status ? a._result : null)
              return pb(a);
        }
      return null;
    }
    function qb(a) {
      var b = "";
      do {
        a:
          switch (a.tag) {
            case 3:
            case 4:
            case 6:
            case 7:
            case 10:
            case 9:
              var c = "";
              break a;
            default:
              var d = a._debugOwner, e = a._debugSource, f2 = pb(a.type);
              c = null;
              d && (c = pb(d.type));
              d = f2;
              f2 = "";
              e ? f2 = " (at " + e.fileName.replace(Ya, "") + ":" + e.lineNumber + ")" : c && (f2 = " (created by " + c + ")");
              c = "\n    in " + (d || "Unknown") + f2;
          }
        b += c;
        a = a.return;
      } while (a);
      return b;
    }
    function rb(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "object":
        case "string":
        case "undefined":
          return a;
        default:
          return "";
      }
    }
    function sb(a) {
      var b = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
    }
    function tb(a) {
      var b = sb(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
      if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
        var e = c.get, f2 = c.set;
        Object.defineProperty(a, b, { configurable: true, get: function() {
          return e.call(this);
        }, set: function(a2) {
          d = "" + a2;
          f2.call(this, a2);
        } });
        Object.defineProperty(a, b, { enumerable: c.enumerable });
        return { getValue: function() {
          return d;
        }, setValue: function(a2) {
          d = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null;
          delete a[b];
        } };
      }
    }
    function xb(a) {
      a._valueTracker || (a._valueTracker = tb(a));
    }
    function yb(a) {
      if (!a)
        return false;
      var b = a._valueTracker;
      if (!b)
        return true;
      var c = b.getValue();
      var d = "";
      a && (d = sb(a) ? a.checked ? "true" : "false" : a.value);
      a = d;
      return a !== c ? (b.setValue(a), true) : false;
    }
    function zb(a, b) {
      var c = b.checked;
      return n({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
    }
    function Ab(a, b) {
      var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
      c = rb(null != b.value ? b.value : c);
      a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
    }
    function Bb(a, b) {
      b = b.checked;
      null != b && Xa(a, "checked", b, false);
    }
    function Cb(a, b) {
      Bb(a, b);
      var c = rb(b.value), d = b.type;
      if (null != c)
        if ("number" === d) {
          if (0 === c && "" === a.value || a.value != c)
            a.value = "" + c;
        } else
          a.value !== "" + c && (a.value = "" + c);
      else if ("submit" === d || "reset" === d) {
        a.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? Db(a, b.type, c) : b.hasOwnProperty("defaultValue") && Db(a, b.type, rb(b.defaultValue));
      null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
    }
    function Eb(a, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value))
          return;
        b = "" + a._wrapperState.initialValue;
        c || b === a.value || (a.value = b);
        a.defaultValue = b;
      }
      c = a.name;
      "" !== c && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c && (a.name = c);
    }
    function Db(a, b, c) {
      if ("number" !== b || a.ownerDocument.activeElement !== a)
        null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
    }
    function Fb(a) {
      var b = "";
      aa.Children.forEach(a, function(a2) {
        null != a2 && (b += a2);
      });
      return b;
    }
    function Gb(a, b) {
      a = n({ children: void 0 }, b);
      if (b = Fb(b.children))
        a.children = b;
      return a;
    }
    function Hb(a, b, c, d) {
      a = a.options;
      if (b) {
        b = {};
        for (var e = 0; e < c.length; e++)
          b["$" + c[e]] = true;
        for (c = 0; c < a.length; c++)
          e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
      } else {
        c = "" + rb(c);
        b = null;
        for (e = 0; e < a.length; e++) {
          if (a[e].value === c) {
            a[e].selected = true;
            d && (a[e].defaultSelected = true);
            return;
          }
          null !== b || a[e].disabled || (b = a[e]);
        }
        null !== b && (b.selected = true);
      }
    }
    function Ib(a, b) {
      if (null != b.dangerouslySetInnerHTML)
        throw Error(u(91));
      return n({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function Jb(a, b) {
      var c = b.value;
      if (null == c) {
        c = b.children;
        b = b.defaultValue;
        if (null != c) {
          if (null != b)
            throw Error(u(92));
          if (Array.isArray(c)) {
            if (!(1 >= c.length))
              throw Error(u(93));
            c = c[0];
          }
          b = c;
        }
        null == b && (b = "");
        c = b;
      }
      a._wrapperState = { initialValue: rb(c) };
    }
    function Kb(a, b) {
      var c = rb(b.value), d = rb(b.defaultValue);
      null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
      null != d && (a.defaultValue = "" + d);
    }
    function Lb(a) {
      var b = a.textContent;
      b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
    }
    var Mb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
    function Nb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function Ob(a, b) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? Nb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
    }
    var Pb, Qb = function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b, c, d, e);
        });
      } : a;
    }(function(a, b) {
      if (a.namespaceURI !== Mb.svg || "innerHTML" in a)
        a.innerHTML = b;
      else {
        Pb = Pb || document.createElement("div");
        Pb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = Pb.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; b.firstChild; )
          a.appendChild(b.firstChild);
      }
    });
    function Rb(a, b) {
      if (b) {
        var c = a.firstChild;
        if (c && c === a.lastChild && 3 === c.nodeType) {
          c.nodeValue = b;
          return;
        }
      }
      a.textContent = b;
    }
    function Sb(a, b) {
      var c = {};
      c[a.toLowerCase()] = b.toLowerCase();
      c["Webkit" + a] = "webkit" + b;
      c["Moz" + a] = "moz" + b;
      return c;
    }
    var Tb = { animationend: Sb("Animation", "AnimationEnd"), animationiteration: Sb("Animation", "AnimationIteration"), animationstart: Sb("Animation", "AnimationStart"), transitionend: Sb("Transition", "TransitionEnd") }, Ub = {}, Vb = {};
    ya && (Vb = document.createElement("div").style, "AnimationEvent" in window || (delete Tb.animationend.animation, delete Tb.animationiteration.animation, delete Tb.animationstart.animation), "TransitionEvent" in window || delete Tb.transitionend.transition);
    function Wb(a) {
      if (Ub[a])
        return Ub[a];
      if (!Tb[a])
        return a;
      var b = Tb[a], c;
      for (c in b)
        if (b.hasOwnProperty(c) && c in Vb)
          return Ub[a] = b[c];
      return a;
    }
    var Xb = Wb("animationend"), Yb = Wb("animationiteration"), Zb = Wb("animationstart"), $b = Wb("transitionend"), ac = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), bc = new ("function" === typeof WeakMap ? WeakMap : Map)();
    function cc(a) {
      var b = bc.get(a);
      void 0 === b && (b = /* @__PURE__ */ new Map(), bc.set(a, b));
      return b;
    }
    function dc(a) {
      var b = a, c = a;
      if (a.alternate)
        for (; b.return; )
          b = b.return;
      else {
        a = b;
        do
          b = a, 0 !== (b.effectTag & 1026) && (c = b.return), a = b.return;
        while (a);
      }
      return 3 === b.tag ? c : null;
    }
    function ec(a) {
      if (13 === a.tag) {
        var b = a.memoizedState;
        null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
        if (null !== b)
          return b.dehydrated;
      }
      return null;
    }
    function fc(a) {
      if (dc(a) !== a)
        throw Error(u(188));
    }
    function gc(a) {
      var b = a.alternate;
      if (!b) {
        b = dc(a);
        if (null === b)
          throw Error(u(188));
        return b !== a ? null : a;
      }
      for (var c = a, d = b; ; ) {
        var e = c.return;
        if (null === e)
          break;
        var f2 = e.alternate;
        if (null === f2) {
          d = e.return;
          if (null !== d) {
            c = d;
            continue;
          }
          break;
        }
        if (e.child === f2.child) {
          for (f2 = e.child; f2; ) {
            if (f2 === c)
              return fc(e), a;
            if (f2 === d)
              return fc(e), b;
            f2 = f2.sibling;
          }
          throw Error(u(188));
        }
        if (c.return !== d.return)
          c = e, d = f2;
        else {
          for (var g2 = false, h2 = e.child; h2; ) {
            if (h2 === c) {
              g2 = true;
              c = e;
              d = f2;
              break;
            }
            if (h2 === d) {
              g2 = true;
              d = e;
              c = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c) {
                g2 = true;
                c = f2;
                d = e;
                break;
              }
              if (h2 === d) {
                g2 = true;
                d = f2;
                c = e;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2)
              throw Error(u(189));
          }
        }
        if (c.alternate !== d)
          throw Error(u(190));
      }
      if (3 !== c.tag)
        throw Error(u(188));
      return c.stateNode.current === c ? a : b;
    }
    function hc(a) {
      a = gc(a);
      if (!a)
        return null;
      for (var b = a; ; ) {
        if (5 === b.tag || 6 === b.tag)
          return b;
        if (b.child)
          b.child.return = b, b = b.child;
        else {
          if (b === a)
            break;
          for (; !b.sibling; ) {
            if (!b.return || b.return === a)
              return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return null;
    }
    function ic(a, b) {
      if (null == b)
        throw Error(u(30));
      if (null == a)
        return b;
      if (Array.isArray(a)) {
        if (Array.isArray(b))
          return a.push.apply(a, b), a;
        a.push(b);
        return a;
      }
      return Array.isArray(b) ? [a].concat(b) : [a, b];
    }
    function jc(a, b, c) {
      Array.isArray(a) ? a.forEach(b, c) : a && b.call(c, a);
    }
    var kc = null;
    function lc(a) {
      if (a) {
        var b = a._dispatchListeners, c = a._dispatchInstances;
        if (Array.isArray(b))
          for (var d = 0; d < b.length && !a.isPropagationStopped(); d++)
            oa(a, b[d], c[d]);
        else
          b && oa(a, b, c);
        a._dispatchListeners = null;
        a._dispatchInstances = null;
        a.isPersistent() || a.constructor.release(a);
      }
    }
    function mc(a) {
      null !== a && (kc = ic(kc, a));
      a = kc;
      kc = null;
      if (a) {
        jc(a, lc);
        if (kc)
          throw Error(u(95));
        if (fa)
          throw a = ha, fa = false, ha = null, a;
      }
    }
    function nc(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    function oc(a) {
      if (!ya)
        return false;
      a = "on" + a;
      var b = a in document;
      b || (b = document.createElement("div"), b.setAttribute(a, "return;"), b = "function" === typeof b[a]);
      return b;
    }
    var pc = [];
    function qc(a) {
      a.topLevelType = null;
      a.nativeEvent = null;
      a.targetInst = null;
      a.ancestors.length = 0;
      10 > pc.length && pc.push(a);
    }
    function rc(a, b, c, d) {
      if (pc.length) {
        var e = pc.pop();
        e.topLevelType = a;
        e.eventSystemFlags = d;
        e.nativeEvent = b;
        e.targetInst = c;
        return e;
      }
      return { topLevelType: a, eventSystemFlags: d, nativeEvent: b, targetInst: c, ancestors: [] };
    }
    function sc(a) {
      var b = a.targetInst, c = b;
      do {
        if (!c) {
          a.ancestors.push(c);
          break;
        }
        var d = c;
        if (3 === d.tag)
          d = d.stateNode.containerInfo;
        else {
          for (; d.return; )
            d = d.return;
          d = 3 !== d.tag ? null : d.stateNode.containerInfo;
        }
        if (!d)
          break;
        b = c.tag;
        5 !== b && 6 !== b || a.ancestors.push(c);
        c = tc(d);
      } while (c);
      for (c = 0; c < a.ancestors.length; c++) {
        b = a.ancestors[c];
        var e = nc(a.nativeEvent);
        d = a.topLevelType;
        var f2 = a.nativeEvent, g2 = a.eventSystemFlags;
        0 === c && (g2 |= 64);
        for (var h2 = null, k = 0; k < sa.length; k++) {
          var l2 = sa[k];
          l2 && (l2 = l2.extractEvents(d, b, f2, e, g2)) && (h2 = ic(h2, l2));
        }
        mc(h2);
      }
    }
    function uc(a, b, c) {
      if (!c.has(a)) {
        switch (a) {
          case "scroll":
            vc(b, "scroll", true);
            break;
          case "focus":
          case "blur":
            vc(b, "focus", true);
            vc(b, "blur", true);
            c.set("blur", null);
            c.set("focus", null);
            break;
          case "cancel":
          case "close":
            oc(a) && vc(b, a, true);
            break;
          case "invalid":
          case "submit":
          case "reset":
            break;
          default:
            -1 === ac.indexOf(a) && F(a, b);
        }
        c.set(a, null);
      }
    }
    var wc, xc, yc, zc = false, Ac = [], Bc = null, Cc = null, Dc = null, Ec = /* @__PURE__ */ new Map(), Fc = /* @__PURE__ */ new Map(), Gc = [], Hc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "), Ic = "focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" ");
    function Jc(a, b) {
      var c = cc(b);
      Hc.forEach(function(a2) {
        uc(a2, b, c);
      });
      Ic.forEach(function(a2) {
        uc(a2, b, c);
      });
    }
    function Kc(a, b, c, d, e) {
      return { blockedOn: a, topLevelType: b, eventSystemFlags: c | 32, nativeEvent: e, container: d };
    }
    function Lc(a, b) {
      switch (a) {
        case "focus":
        case "blur":
          Bc = null;
          break;
        case "dragenter":
        case "dragleave":
          Cc = null;
          break;
        case "mouseover":
        case "mouseout":
          Dc = null;
          break;
        case "pointerover":
        case "pointerout":
          Ec.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Fc.delete(b.pointerId);
      }
    }
    function Mc(a, b, c, d, e, f2) {
      if (null === a || a.nativeEvent !== f2)
        return a = Kc(b, c, d, e, f2), null !== b && (b = Nc(b), null !== b && xc(b)), a;
      a.eventSystemFlags |= d;
      return a;
    }
    function Oc(a, b, c, d, e) {
      switch (b) {
        case "focus":
          return Bc = Mc(Bc, a, b, c, d, e), true;
        case "dragenter":
          return Cc = Mc(Cc, a, b, c, d, e), true;
        case "mouseover":
          return Dc = Mc(Dc, a, b, c, d, e), true;
        case "pointerover":
          var f2 = e.pointerId;
          Ec.set(f2, Mc(Ec.get(f2) || null, a, b, c, d, e));
          return true;
        case "gotpointercapture":
          return f2 = e.pointerId, Fc.set(f2, Mc(Fc.get(f2) || null, a, b, c, d, e)), true;
      }
      return false;
    }
    function Pc(a) {
      var b = tc(a.target);
      if (null !== b) {
        var c = dc(b);
        if (null !== c) {
          if (b = c.tag, 13 === b) {
            if (b = ec(c), null !== b) {
              a.blockedOn = b;
              r.unstable_runWithPriority(a.priority, function() {
                yc(c);
              });
              return;
            }
          } else if (3 === b && c.stateNode.hydrate) {
            a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Qc(a) {
      if (null !== a.blockedOn)
        return false;
      var b = Rc(a.topLevelType, a.eventSystemFlags, a.container, a.nativeEvent);
      if (null !== b) {
        var c = Nc(b);
        null !== c && xc(c);
        a.blockedOn = b;
        return false;
      }
      return true;
    }
    function Sc(a, b, c) {
      Qc(a) && c.delete(b);
    }
    function Tc() {
      for (zc = false; 0 < Ac.length; ) {
        var a = Ac[0];
        if (null !== a.blockedOn) {
          a = Nc(a.blockedOn);
          null !== a && wc(a);
          break;
        }
        var b = Rc(a.topLevelType, a.eventSystemFlags, a.container, a.nativeEvent);
        null !== b ? a.blockedOn = b : Ac.shift();
      }
      null !== Bc && Qc(Bc) && (Bc = null);
      null !== Cc && Qc(Cc) && (Cc = null);
      null !== Dc && Qc(Dc) && (Dc = null);
      Ec.forEach(Sc);
      Fc.forEach(Sc);
    }
    function Uc(a, b) {
      a.blockedOn === b && (a.blockedOn = null, zc || (zc = true, r.unstable_scheduleCallback(r.unstable_NormalPriority, Tc)));
    }
    function Vc(a) {
      function b(b2) {
        return Uc(b2, a);
      }
      if (0 < Ac.length) {
        Uc(Ac[0], a);
        for (var c = 1; c < Ac.length; c++) {
          var d = Ac[c];
          d.blockedOn === a && (d.blockedOn = null);
        }
      }
      null !== Bc && Uc(Bc, a);
      null !== Cc && Uc(Cc, a);
      null !== Dc && Uc(Dc, a);
      Ec.forEach(b);
      Fc.forEach(b);
      for (c = 0; c < Gc.length; c++)
        d = Gc[c], d.blockedOn === a && (d.blockedOn = null);
      for (; 0 < Gc.length && (c = Gc[0], null === c.blockedOn); )
        Pc(c), null === c.blockedOn && Gc.shift();
    }
    var Wc = {}, Yc = /* @__PURE__ */ new Map(), Zc = /* @__PURE__ */ new Map(), $c = [
      "abort",
      "abort",
      Xb,
      "animationEnd",
      Yb,
      "animationIteration",
      Zb,
      "animationStart",
      "canplay",
      "canPlay",
      "canplaythrough",
      "canPlayThrough",
      "durationchange",
      "durationChange",
      "emptied",
      "emptied",
      "encrypted",
      "encrypted",
      "ended",
      "ended",
      "error",
      "error",
      "gotpointercapture",
      "gotPointerCapture",
      "load",
      "load",
      "loadeddata",
      "loadedData",
      "loadedmetadata",
      "loadedMetadata",
      "loadstart",
      "loadStart",
      "lostpointercapture",
      "lostPointerCapture",
      "playing",
      "playing",
      "progress",
      "progress",
      "seeking",
      "seeking",
      "stalled",
      "stalled",
      "suspend",
      "suspend",
      "timeupdate",
      "timeUpdate",
      $b,
      "transitionEnd",
      "waiting",
      "waiting"
    ];
    function ad(a, b) {
      for (var c = 0; c < a.length; c += 2) {
        var d = a[c], e = a[c + 1], f2 = "on" + (e[0].toUpperCase() + e.slice(1));
        f2 = { phasedRegistrationNames: { bubbled: f2, captured: f2 + "Capture" }, dependencies: [d], eventPriority: b };
        Zc.set(d, b);
        Yc.set(d, f2);
        Wc[e] = f2;
      }
    }
    ad("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
    ad("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
    ad($c, 2);
    for (var bd = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), cd = 0; cd < bd.length; cd++)
      Zc.set(bd[cd], 0);
    var dd = r.unstable_UserBlockingPriority, ed = r.unstable_runWithPriority, fd = true;
    function F(a, b) {
      vc(b, a, false);
    }
    function vc(a, b, c) {
      var d = Zc.get(b);
      switch (void 0 === d ? 2 : d) {
        case 0:
          d = gd.bind(null, b, 1, a);
          break;
        case 1:
          d = hd.bind(null, b, 1, a);
          break;
        default:
          d = id.bind(null, b, 1, a);
      }
      c ? a.addEventListener(b, d, true) : a.addEventListener(b, d, false);
    }
    function gd(a, b, c, d) {
      Ja || Ha();
      var e = id, f2 = Ja;
      Ja = true;
      try {
        Ga(e, a, b, c, d);
      } finally {
        (Ja = f2) || La();
      }
    }
    function hd(a, b, c, d) {
      ed(dd, id.bind(null, a, b, c, d));
    }
    function id(a, b, c, d) {
      if (fd)
        if (0 < Ac.length && -1 < Hc.indexOf(a))
          a = Kc(null, a, b, c, d), Ac.push(a);
        else {
          var e = Rc(a, b, c, d);
          if (null === e)
            Lc(a, d);
          else if (-1 < Hc.indexOf(a))
            a = Kc(e, a, b, c, d), Ac.push(a);
          else if (!Oc(e, a, b, c, d)) {
            Lc(a, d);
            a = rc(a, d, null, b);
            try {
              Ma(sc, a);
            } finally {
              qc(a);
            }
          }
        }
    }
    function Rc(a, b, c, d) {
      c = nc(d);
      c = tc(c);
      if (null !== c) {
        var e = dc(c);
        if (null === e)
          c = null;
        else {
          var f2 = e.tag;
          if (13 === f2) {
            c = ec(e);
            if (null !== c)
              return c;
            c = null;
          } else if (3 === f2) {
            if (e.stateNode.hydrate)
              return 3 === e.tag ? e.stateNode.containerInfo : null;
            c = null;
          } else
            e !== c && (c = null);
        }
      }
      a = rc(a, d, c, b);
      try {
        Ma(sc, a);
      } finally {
        qc(a);
      }
      return null;
    }
    var jd = {
      animationIterationCount: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, kd = ["Webkit", "ms", "Moz", "O"];
    Object.keys(jd).forEach(function(a) {
      kd.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1);
        jd[b] = jd[a];
      });
    });
    function ld(a, b, c) {
      return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || jd.hasOwnProperty(a) && jd[a] ? ("" + b).trim() : b + "px";
    }
    function md(a, b) {
      a = a.style;
      for (var c in b)
        if (b.hasOwnProperty(c)) {
          var d = 0 === c.indexOf("--"), e = ld(c, b[c], d);
          "float" === c && (c = "cssFloat");
          d ? a.setProperty(c, e) : a[c] = e;
        }
    }
    var nd = n({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function od(a, b) {
      if (b) {
        if (nd[a] && (null != b.children || null != b.dangerouslySetInnerHTML))
          throw Error(u(137, a, ""));
        if (null != b.dangerouslySetInnerHTML) {
          if (null != b.children)
            throw Error(u(60));
          if (!("object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML))
            throw Error(u(61));
        }
        if (null != b.style && "object" !== typeof b.style)
          throw Error(u(62, ""));
      }
    }
    function pd(a, b) {
      if (-1 === a.indexOf("-"))
        return "string" === typeof b.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var qd = Mb.html;
    function rd(a, b) {
      a = 9 === a.nodeType || 11 === a.nodeType ? a : a.ownerDocument;
      var c = cc(a);
      b = wa[b];
      for (var d = 0; d < b.length; d++)
        uc(b[d], a, c);
    }
    function sd() {
    }
    function td(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a)
        return null;
      try {
        return a.activeElement || a.body;
      } catch (b) {
        return a.body;
      }
    }
    function ud(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function vd(a, b) {
      var c = ud(a);
      a = 0;
      for (var d; c; ) {
        if (3 === c.nodeType) {
          d = a + c.textContent.length;
          if (a <= b && d >= b)
            return { node: c, offset: b - a };
          a = d;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = ud(c);
      }
    }
    function wd(a, b) {
      return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? wd(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
    }
    function xd() {
      for (var a = window, b = td(); b instanceof a.HTMLIFrameElement; ) {
        try {
          var c = "string" === typeof b.contentWindow.location.href;
        } catch (d) {
          c = false;
        }
        if (c)
          a = b.contentWindow;
        else
          break;
        b = td(a.document);
      }
      return b;
    }
    function yd(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
    }
    var zd = "$", Ad = "/$", Bd = "$?", Cd = "$!", Dd = null, Ed = null;
    function Fd(a, b) {
      switch (a) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!b.autoFocus;
      }
      return false;
    }
    function Gd(a, b) {
      return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
    }
    var Hd = "function" === typeof setTimeout ? setTimeout : void 0, Id = "function" === typeof clearTimeout ? clearTimeout : void 0;
    function Jd(a) {
      for (; null != a; a = a.nextSibling) {
        var b = a.nodeType;
        if (1 === b || 3 === b)
          break;
      }
      return a;
    }
    function Kd(a) {
      a = a.previousSibling;
      for (var b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if (c === zd || c === Cd || c === Bd) {
            if (0 === b)
              return a;
            b--;
          } else
            c === Ad && b++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Ld = Math.random().toString(36).slice(2), Md = "__reactInternalInstance$" + Ld, Nd = "__reactEventHandlers$" + Ld, Od = "__reactContainere$" + Ld;
    function tc(a) {
      var b = a[Md];
      if (b)
        return b;
      for (var c = a.parentNode; c; ) {
        if (b = c[Od] || c[Md]) {
          c = b.alternate;
          if (null !== b.child || null !== c && null !== c.child)
            for (a = Kd(a); null !== a; ) {
              if (c = a[Md])
                return c;
              a = Kd(a);
            }
          return b;
        }
        a = c;
        c = a.parentNode;
      }
      return null;
    }
    function Nc(a) {
      a = a[Md] || a[Od];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    function Pd(a) {
      if (5 === a.tag || 6 === a.tag)
        return a.stateNode;
      throw Error(u(33));
    }
    function Qd(a) {
      return a[Nd] || null;
    }
    function Rd(a) {
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    function Sd(a, b) {
      var c = a.stateNode;
      if (!c)
        return null;
      var d = la(c);
      if (!d)
        return null;
      c = d[b];
      a:
        switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d;
            break a;
          default:
            a = false;
        }
      if (a)
        return null;
      if (c && "function" !== typeof c)
        throw Error(u(
          231,
          b,
          typeof c
        ));
      return c;
    }
    function Td(a, b, c) {
      if (b = Sd(a, c.dispatchConfig.phasedRegistrationNames[b]))
        c._dispatchListeners = ic(c._dispatchListeners, b), c._dispatchInstances = ic(c._dispatchInstances, a);
    }
    function Ud(a) {
      if (a && a.dispatchConfig.phasedRegistrationNames) {
        for (var b = a._targetInst, c = []; b; )
          c.push(b), b = Rd(b);
        for (b = c.length; 0 < b--; )
          Td(c[b], "captured", a);
        for (b = 0; b < c.length; b++)
          Td(c[b], "bubbled", a);
      }
    }
    function Vd(a, b, c) {
      a && c && c.dispatchConfig.registrationName && (b = Sd(a, c.dispatchConfig.registrationName)) && (c._dispatchListeners = ic(c._dispatchListeners, b), c._dispatchInstances = ic(c._dispatchInstances, a));
    }
    function Wd(a) {
      a && a.dispatchConfig.registrationName && Vd(a._targetInst, null, a);
    }
    function Xd(a) {
      jc(a, Ud);
    }
    var Yd = null, Zd = null, $d = null;
    function ae() {
      if ($d)
        return $d;
      var a, b = Zd, c = b.length, d, e = "value" in Yd ? Yd.value : Yd.textContent, f2 = e.length;
      for (a = 0; a < c && b[a] === e[a]; a++)
        ;
      var g2 = c - a;
      for (d = 1; d <= g2 && b[c - d] === e[f2 - d]; d++)
        ;
      return $d = e.slice(a, 1 < d ? 1 - d : void 0);
    }
    function be() {
      return true;
    }
    function ce() {
      return false;
    }
    function G(a, b, c, d) {
      this.dispatchConfig = a;
      this._targetInst = b;
      this.nativeEvent = c;
      a = this.constructor.Interface;
      for (var e in a)
        a.hasOwnProperty(e) && ((b = a[e]) ? this[e] = b(c) : "target" === e ? this.target = d : this[e] = c[e]);
      this.isDefaultPrevented = (null != c.defaultPrevented ? c.defaultPrevented : false === c.returnValue) ? be : ce;
      this.isPropagationStopped = ce;
      return this;
    }
    n(G.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a = this.nativeEvent;
      a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = false), this.isDefaultPrevented = be);
    }, stopPropagation: function() {
      var a = this.nativeEvent;
      a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = true), this.isPropagationStopped = be);
    }, persist: function() {
      this.isPersistent = be;
    }, isPersistent: ce, destructor: function() {
      var a = this.constructor.Interface, b;
      for (b in a)
        this[b] = null;
      this.nativeEvent = this._targetInst = this.dispatchConfig = null;
      this.isPropagationStopped = this.isDefaultPrevented = ce;
      this._dispatchInstances = this._dispatchListeners = null;
    } });
    G.Interface = { type: null, target: null, currentTarget: function() {
      return null;
    }, eventPhase: null, bubbles: null, cancelable: null, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: null, isTrusted: null };
    G.extend = function(a) {
      function b() {
      }
      function c() {
        return d.apply(this, arguments);
      }
      var d = this;
      b.prototype = d.prototype;
      var e = new b();
      n(e, c.prototype);
      c.prototype = e;
      c.prototype.constructor = c;
      c.Interface = n({}, d.Interface, a);
      c.extend = d.extend;
      de(c);
      return c;
    };
    de(G);
    function ee(a, b, c, d) {
      if (this.eventPool.length) {
        var e = this.eventPool.pop();
        this.call(e, a, b, c, d);
        return e;
      }
      return new this(a, b, c, d);
    }
    function fe(a) {
      if (!(a instanceof this))
        throw Error(u(279));
      a.destructor();
      10 > this.eventPool.length && this.eventPool.push(a);
    }
    function de(a) {
      a.eventPool = [];
      a.getPooled = ee;
      a.release = fe;
    }
    var ge = G.extend({ data: null }), he = G.extend({ data: null }), ie = [9, 13, 27, 32], je = ya && "CompositionEvent" in window, ke = null;
    ya && "documentMode" in document && (ke = document.documentMode);
    var le = ya && "TextEvent" in window && !ke, me = ya && (!je || ke && 8 < ke && 11 >= ke), ne = String.fromCharCode(32), oe = { beforeInput: { phasedRegistrationNames: { bubbled: "onBeforeInput", captured: "onBeforeInputCapture" }, dependencies: ["compositionend", "keypress", "textInput", "paste"] }, compositionEnd: { phasedRegistrationNames: { bubbled: "onCompositionEnd", captured: "onCompositionEndCapture" }, dependencies: "blur compositionend keydown keypress keyup mousedown".split(" ") }, compositionStart: { phasedRegistrationNames: {
      bubbled: "onCompositionStart",
      captured: "onCompositionStartCapture"
    }, dependencies: "blur compositionstart keydown keypress keyup mousedown".split(" ") }, compositionUpdate: { phasedRegistrationNames: { bubbled: "onCompositionUpdate", captured: "onCompositionUpdateCapture" }, dependencies: "blur compositionupdate keydown keypress keyup mousedown".split(" ") } }, pe = false;
    function qe(a, b) {
      switch (a) {
        case "keyup":
          return -1 !== ie.indexOf(b.keyCode);
        case "keydown":
          return 229 !== b.keyCode;
        case "keypress":
        case "mousedown":
        case "blur":
          return true;
        default:
          return false;
      }
    }
    function re(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    var se = false;
    function te(a, b) {
      switch (a) {
        case "compositionend":
          return re(b);
        case "keypress":
          if (32 !== b.which)
            return null;
          pe = true;
          return ne;
        case "textInput":
          return a = b.data, a === ne && pe ? null : a;
        default:
          return null;
      }
    }
    function ue(a, b) {
      if (se)
        return "compositionend" === a || !je && qe(a, b) ? (a = ae(), $d = Zd = Yd = null, se = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length)
              return b.char;
            if (b.which)
              return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return me && "ko" !== b.locale ? null : b.data;
        default:
          return null;
      }
    }
    var ve = { eventTypes: oe, extractEvents: function(a, b, c, d) {
      var e;
      if (je)
        b: {
          switch (a) {
            case "compositionstart":
              var f2 = oe.compositionStart;
              break b;
            case "compositionend":
              f2 = oe.compositionEnd;
              break b;
            case "compositionupdate":
              f2 = oe.compositionUpdate;
              break b;
          }
          f2 = void 0;
        }
      else
        se ? qe(a, c) && (f2 = oe.compositionEnd) : "keydown" === a && 229 === c.keyCode && (f2 = oe.compositionStart);
      f2 ? (me && "ko" !== c.locale && (se || f2 !== oe.compositionStart ? f2 === oe.compositionEnd && se && (e = ae()) : (Yd = d, Zd = "value" in Yd ? Yd.value : Yd.textContent, se = true)), f2 = ge.getPooled(
        f2,
        b,
        c,
        d
      ), e ? f2.data = e : (e = re(c), null !== e && (f2.data = e)), Xd(f2), e = f2) : e = null;
      (a = le ? te(a, c) : ue(a, c)) ? (b = he.getPooled(oe.beforeInput, b, c, d), b.data = a, Xd(b)) : b = null;
      return null === e ? b : null === b ? e : [e, b];
    } }, we = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function xe(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b ? !!we[a.type] : "textarea" === b ? true : false;
    }
    var ye = { change: { phasedRegistrationNames: { bubbled: "onChange", captured: "onChangeCapture" }, dependencies: "blur change click focus input keydown keyup selectionchange".split(" ") } };
    function ze(a, b, c) {
      a = G.getPooled(ye.change, a, b, c);
      a.type = "change";
      Da(c);
      Xd(a);
      return a;
    }
    var Ae = null, Be = null;
    function Ce(a) {
      mc(a);
    }
    function De(a) {
      var b = Pd(a);
      if (yb(b))
        return a;
    }
    function Ee(a, b) {
      if ("change" === a)
        return b;
    }
    var Fe = false;
    ya && (Fe = oc("input") && (!document.documentMode || 9 < document.documentMode));
    function Ge() {
      Ae && (Ae.detachEvent("onpropertychange", He), Be = Ae = null);
    }
    function He(a) {
      if ("value" === a.propertyName && De(Be))
        if (a = ze(Be, a, nc(a)), Ja)
          mc(a);
        else {
          Ja = true;
          try {
            Fa(Ce, a);
          } finally {
            Ja = false, La();
          }
        }
    }
    function Ie(a, b, c) {
      "focus" === a ? (Ge(), Ae = b, Be = c, Ae.attachEvent("onpropertychange", He)) : "blur" === a && Ge();
    }
    function Je(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a)
        return De(Be);
    }
    function Ke(a, b) {
      if ("click" === a)
        return De(b);
    }
    function Le(a, b) {
      if ("input" === a || "change" === a)
        return De(b);
    }
    var Me = { eventTypes: ye, _isInputEventSupported: Fe, extractEvents: function(a, b, c, d) {
      var e = b ? Pd(b) : window, f2 = e.nodeName && e.nodeName.toLowerCase();
      if ("select" === f2 || "input" === f2 && "file" === e.type)
        var g2 = Ee;
      else if (xe(e))
        if (Fe)
          g2 = Le;
        else {
          g2 = Je;
          var h2 = Ie;
        }
      else
        (f2 = e.nodeName) && "input" === f2.toLowerCase() && ("checkbox" === e.type || "radio" === e.type) && (g2 = Ke);
      if (g2 && (g2 = g2(a, b)))
        return ze(g2, c, d);
      h2 && h2(a, e, b);
      "blur" === a && (a = e._wrapperState) && a.controlled && "number" === e.type && Db(e, "number", e.value);
    } }, Ne = G.extend({ view: null, detail: null }), Oe = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pe(a) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a) : (a = Oe[a]) ? !!b[a] : false;
    }
    function Qe() {
      return Pe;
    }
    var Re = 0, Se = 0, Te = false, Ue = false, Ve = Ne.extend({ screenX: null, screenY: null, clientX: null, clientY: null, pageX: null, pageY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: Qe, button: null, buttons: null, relatedTarget: function(a) {
      return a.relatedTarget || (a.fromElement === a.srcElement ? a.toElement : a.fromElement);
    }, movementX: function(a) {
      if ("movementX" in a)
        return a.movementX;
      var b = Re;
      Re = a.screenX;
      return Te ? "mousemove" === a.type ? a.screenX - b : 0 : (Te = true, 0);
    }, movementY: function(a) {
      if ("movementY" in a)
        return a.movementY;
      var b = Se;
      Se = a.screenY;
      return Ue ? "mousemove" === a.type ? a.screenY - b : 0 : (Ue = true, 0);
    } }), We = Ve.extend({ pointerId: null, width: null, height: null, pressure: null, tangentialPressure: null, tiltX: null, tiltY: null, twist: null, pointerType: null, isPrimary: null }), Xe = { mouseEnter: { registrationName: "onMouseEnter", dependencies: ["mouseout", "mouseover"] }, mouseLeave: { registrationName: "onMouseLeave", dependencies: ["mouseout", "mouseover"] }, pointerEnter: { registrationName: "onPointerEnter", dependencies: ["pointerout", "pointerover"] }, pointerLeave: {
      registrationName: "onPointerLeave",
      dependencies: ["pointerout", "pointerover"]
    } }, Ye = { eventTypes: Xe, extractEvents: function(a, b, c, d, e) {
      var f2 = "mouseover" === a || "pointerover" === a, g2 = "mouseout" === a || "pointerout" === a;
      if (f2 && 0 === (e & 32) && (c.relatedTarget || c.fromElement) || !g2 && !f2)
        return null;
      f2 = d.window === d ? d : (f2 = d.ownerDocument) ? f2.defaultView || f2.parentWindow : window;
      if (g2) {
        if (g2 = b, b = (b = c.relatedTarget || c.toElement) ? tc(b) : null, null !== b) {
          var h2 = dc(b);
          if (b !== h2 || 5 !== b.tag && 6 !== b.tag)
            b = null;
        }
      } else
        g2 = null;
      if (g2 === b)
        return null;
      if ("mouseout" === a || "mouseover" === a) {
        var k = Ve;
        var l2 = Xe.mouseLeave;
        var m2 = Xe.mouseEnter;
        var p2 = "mouse";
      } else if ("pointerout" === a || "pointerover" === a)
        k = We, l2 = Xe.pointerLeave, m2 = Xe.pointerEnter, p2 = "pointer";
      a = null == g2 ? f2 : Pd(g2);
      f2 = null == b ? f2 : Pd(b);
      l2 = k.getPooled(l2, g2, c, d);
      l2.type = p2 + "leave";
      l2.target = a;
      l2.relatedTarget = f2;
      c = k.getPooled(m2, b, c, d);
      c.type = p2 + "enter";
      c.target = f2;
      c.relatedTarget = a;
      d = g2;
      p2 = b;
      if (d && p2)
        a: {
          k = d;
          m2 = p2;
          g2 = 0;
          for (a = k; a; a = Rd(a))
            g2++;
          a = 0;
          for (b = m2; b; b = Rd(b))
            a++;
          for (; 0 < g2 - a; )
            k = Rd(k), g2--;
          for (; 0 < a - g2; )
            m2 = Rd(m2), a--;
          for (; g2--; ) {
            if (k === m2 || k === m2.alternate)
              break a;
            k = Rd(k);
            m2 = Rd(m2);
          }
          k = null;
        }
      else
        k = null;
      m2 = k;
      for (k = []; d && d !== m2; ) {
        g2 = d.alternate;
        if (null !== g2 && g2 === m2)
          break;
        k.push(d);
        d = Rd(d);
      }
      for (d = []; p2 && p2 !== m2; ) {
        g2 = p2.alternate;
        if (null !== g2 && g2 === m2)
          break;
        d.push(p2);
        p2 = Rd(p2);
      }
      for (p2 = 0; p2 < k.length; p2++)
        Vd(k[p2], "bubbled", l2);
      for (p2 = d.length; 0 < p2--; )
        Vd(d[p2], "captured", c);
      return 0 === (e & 64) ? [l2] : [l2, c];
    } };
    function Ze(a, b) {
      return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var $e = "function" === typeof Object.is ? Object.is : Ze, af = Object.prototype.hasOwnProperty;
    function bf(a, b) {
      if ($e(a, b))
        return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b || null === b)
        return false;
      var c = Object.keys(a), d = Object.keys(b);
      if (c.length !== d.length)
        return false;
      for (d = 0; d < c.length; d++)
        if (!af.call(b, c[d]) || !$e(a[c[d]], b[c[d]]))
          return false;
      return true;
    }
    var cf = ya && "documentMode" in document && 11 >= document.documentMode, df = { select: { phasedRegistrationNames: { bubbled: "onSelect", captured: "onSelectCapture" }, dependencies: "blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ") } }, ef = null, ff = null, gf = null, hf = false;
    function jf(a, b) {
      var c = b.window === b ? b.document : 9 === b.nodeType ? b : b.ownerDocument;
      if (hf || null == ef || ef !== td(c))
        return null;
      c = ef;
      "selectionStart" in c && yd(c) ? c = { start: c.selectionStart, end: c.selectionEnd } : (c = (c.ownerDocument && c.ownerDocument.defaultView || window).getSelection(), c = { anchorNode: c.anchorNode, anchorOffset: c.anchorOffset, focusNode: c.focusNode, focusOffset: c.focusOffset });
      return gf && bf(gf, c) ? null : (gf = c, a = G.getPooled(df.select, ff, a, b), a.type = "select", a.target = ef, Xd(a), a);
    }
    var kf = { eventTypes: df, extractEvents: function(a, b, c, d, e, f2) {
      e = f2 || (d.window === d ? d.document : 9 === d.nodeType ? d : d.ownerDocument);
      if (!(f2 = !e)) {
        a: {
          e = cc(e);
          f2 = wa.onSelect;
          for (var g2 = 0; g2 < f2.length; g2++)
            if (!e.has(f2[g2])) {
              e = false;
              break a;
            }
          e = true;
        }
        f2 = !e;
      }
      if (f2)
        return null;
      e = b ? Pd(b) : window;
      switch (a) {
        case "focus":
          if (xe(e) || "true" === e.contentEditable)
            ef = e, ff = b, gf = null;
          break;
        case "blur":
          gf = ff = ef = null;
          break;
        case "mousedown":
          hf = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          return hf = false, jf(c, d);
        case "selectionchange":
          if (cf)
            break;
        case "keydown":
        case "keyup":
          return jf(c, d);
      }
      return null;
    } }, lf = G.extend({ animationName: null, elapsedTime: null, pseudoElement: null }), mf = G.extend({ clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } }), nf = Ne.extend({ relatedTarget: null });
    function of(a) {
      var b = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    var pf = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, qf = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, rf = Ne.extend({ key: function(a) {
      if (a.key) {
        var b = pf[a.key] || a.key;
        if ("Unidentified" !== b)
          return b;
      }
      return "keypress" === a.type ? (a = of(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? qf[a.keyCode] || "Unidentified" : "";
    }, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: Qe, charCode: function(a) {
      return "keypress" === a.type ? of(a) : 0;
    }, keyCode: function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, which: function(a) {
      return "keypress" === a.type ? of(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    } }), sf = Ve.extend({ dataTransfer: null }), tf = Ne.extend({ touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: Qe }), uf = G.extend({ propertyName: null, elapsedTime: null, pseudoElement: null }), vf = Ve.extend({ deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    }, deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    }, deltaZ: null, deltaMode: null }), wf = { eventTypes: Wc, extractEvents: function(a, b, c, d) {
      var e = Yc.get(a);
      if (!e)
        return null;
      switch (a) {
        case "keypress":
          if (0 === of(c))
            return null;
        case "keydown":
        case "keyup":
          a = rf;
          break;
        case "blur":
        case "focus":
          a = nf;
          break;
        case "click":
          if (2 === c.button)
            return null;
        case "auxclick":
        case "dblclick":
        case "mousedown":
        case "mousemove":
        case "mouseup":
        case "mouseout":
        case "mouseover":
        case "contextmenu":
          a = Ve;
          break;
        case "drag":
        case "dragend":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "dragstart":
        case "drop":
          a = sf;
          break;
        case "touchcancel":
        case "touchend":
        case "touchmove":
        case "touchstart":
          a = tf;
          break;
        case Xb:
        case Yb:
        case Zb:
          a = lf;
          break;
        case $b:
          a = uf;
          break;
        case "scroll":
          a = Ne;
          break;
        case "wheel":
          a = vf;
          break;
        case "copy":
        case "cut":
        case "paste":
          a = mf;
          break;
        case "gotpointercapture":
        case "lostpointercapture":
        case "pointercancel":
        case "pointerdown":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "pointerup":
          a = We;
          break;
        default:
          a = G;
      }
      b = a.getPooled(e, b, c, d);
      Xd(b);
      return b;
    } };
    if (pa)
      throw Error(u(101));
    pa = Array.prototype.slice.call("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
    ra();
    var xf = Nc;
    la = Qd;
    ma = xf;
    na = Pd;
    xa({ SimpleEventPlugin: wf, EnterLeaveEventPlugin: Ye, ChangeEventPlugin: Me, SelectEventPlugin: kf, BeforeInputEventPlugin: ve });
    var yf = [], zf = -1;
    function H(a) {
      0 > zf || (a.current = yf[zf], yf[zf] = null, zf--);
    }
    function I(a, b) {
      zf++;
      yf[zf] = a.current;
      a.current = b;
    }
    var Af = {}, J = { current: Af }, K = { current: false }, Bf = Af;
    function Cf(a, b) {
      var c = a.type.contextTypes;
      if (!c)
        return Af;
      var d = a.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
        return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f2;
      for (f2 in c)
        e[f2] = b[f2];
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    function L(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    function Df() {
      H(K);
      H(J);
    }
    function Ef(a, b, c) {
      if (J.current !== Af)
        throw Error(u(168));
      I(J, b);
      I(K, c);
    }
    function Ff(a, b, c) {
      var d = a.stateNode;
      a = b.childContextTypes;
      if ("function" !== typeof d.getChildContext)
        return c;
      d = d.getChildContext();
      for (var e in d)
        if (!(e in a))
          throw Error(u(108, pb(b) || "Unknown", e));
      return n({}, c, {}, d);
    }
    function Gf(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Af;
      Bf = J.current;
      I(J, a);
      I(K, K.current);
      return true;
    }
    function Hf(a, b, c) {
      var d = a.stateNode;
      if (!d)
        throw Error(u(169));
      c ? (a = Ff(a, b, Bf), d.__reactInternalMemoizedMergedChildContext = a, H(K), H(J), I(J, a)) : H(K);
      I(K, c);
    }
    var If = r.unstable_runWithPriority, Jf = r.unstable_scheduleCallback, Kf = r.unstable_cancelCallback, Lf = r.unstable_requestPaint, Mf = r.unstable_now, Nf = r.unstable_getCurrentPriorityLevel, Of = r.unstable_ImmediatePriority, Pf = r.unstable_UserBlockingPriority, Qf = r.unstable_NormalPriority, Rf = r.unstable_LowPriority, Sf = r.unstable_IdlePriority, Tf = {}, Uf = r.unstable_shouldYield, Vf = void 0 !== Lf ? Lf : function() {
    }, Wf = null, Xf = null, Yf = false, Zf = Mf(), $f = 1e4 > Zf ? Mf : function() {
      return Mf() - Zf;
    };
    function ag() {
      switch (Nf()) {
        case Of:
          return 99;
        case Pf:
          return 98;
        case Qf:
          return 97;
        case Rf:
          return 96;
        case Sf:
          return 95;
        default:
          throw Error(u(332));
      }
    }
    function bg(a) {
      switch (a) {
        case 99:
          return Of;
        case 98:
          return Pf;
        case 97:
          return Qf;
        case 96:
          return Rf;
        case 95:
          return Sf;
        default:
          throw Error(u(332));
      }
    }
    function cg(a, b) {
      a = bg(a);
      return If(a, b);
    }
    function dg(a, b, c) {
      a = bg(a);
      return Jf(a, b, c);
    }
    function eg(a) {
      null === Wf ? (Wf = [a], Xf = Jf(Of, fg)) : Wf.push(a);
      return Tf;
    }
    function gg() {
      if (null !== Xf) {
        var a = Xf;
        Xf = null;
        Kf(a);
      }
      fg();
    }
    function fg() {
      if (!Yf && null !== Wf) {
        Yf = true;
        var a = 0;
        try {
          var b = Wf;
          cg(99, function() {
            for (; a < b.length; a++) {
              var c = b[a];
              do
                c = c(true);
              while (null !== c);
            }
          });
          Wf = null;
        } catch (c) {
          throw null !== Wf && (Wf = Wf.slice(a + 1)), Jf(Of, gg), c;
        } finally {
          Yf = false;
        }
      }
    }
    function hg(a, b, c) {
      c /= 10;
      return 1073741821 - (((1073741821 - a + b / 10) / c | 0) + 1) * c;
    }
    function ig(a, b) {
      if (a && a.defaultProps) {
        b = n({}, b);
        a = a.defaultProps;
        for (var c in a)
          void 0 === b[c] && (b[c] = a[c]);
      }
      return b;
    }
    var jg = { current: null }, kg = null, lg = null, mg = null;
    function ng() {
      mg = lg = kg = null;
    }
    function og(a) {
      var b = jg.current;
      H(jg);
      a.type._context._currentValue = b;
    }
    function pg(a, b) {
      for (; null !== a; ) {
        var c = a.alternate;
        if (a.childExpirationTime < b)
          a.childExpirationTime = b, null !== c && c.childExpirationTime < b && (c.childExpirationTime = b);
        else if (null !== c && c.childExpirationTime < b)
          c.childExpirationTime = b;
        else
          break;
        a = a.return;
      }
    }
    function qg(a, b) {
      kg = a;
      mg = lg = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (a.expirationTime >= b && (rg = true), a.firstContext = null);
    }
    function sg(a, b) {
      if (mg !== a && false !== b && 0 !== b) {
        if ("number" !== typeof b || 1073741823 === b)
          mg = a, b = 1073741823;
        b = { context: a, observedBits: b, next: null };
        if (null === lg) {
          if (null === kg)
            throw Error(u(308));
          lg = b;
          kg.dependencies = { expirationTime: 0, firstContext: b, responders: null };
        } else
          lg = lg.next = b;
      }
      return a._currentValue;
    }
    var tg = false;
    function ug(a) {
      a.updateQueue = { baseState: a.memoizedState, baseQueue: null, shared: { pending: null }, effects: null };
    }
    function vg(a, b) {
      a = a.updateQueue;
      b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, baseQueue: a.baseQueue, shared: a.shared, effects: a.effects });
    }
    function wg(a, b) {
      a = { expirationTime: a, suspenseConfig: b, tag: 0, payload: null, callback: null, next: null };
      return a.next = a;
    }
    function xg(a, b) {
      a = a.updateQueue;
      if (null !== a) {
        a = a.shared;
        var c = a.pending;
        null === c ? b.next = b : (b.next = c.next, c.next = b);
        a.pending = b;
      }
    }
    function yg(a, b) {
      var c = a.alternate;
      null !== c && vg(c, a);
      a = a.updateQueue;
      c = a.baseQueue;
      null === c ? (a.baseQueue = b.next = b, b.next = b) : (b.next = c.next, c.next = b);
    }
    function zg(a, b, c, d) {
      var e = a.updateQueue;
      tg = false;
      var f2 = e.baseQueue, g2 = e.shared.pending;
      if (null !== g2) {
        if (null !== f2) {
          var h2 = f2.next;
          f2.next = g2.next;
          g2.next = h2;
        }
        f2 = g2;
        e.shared.pending = null;
        h2 = a.alternate;
        null !== h2 && (h2 = h2.updateQueue, null !== h2 && (h2.baseQueue = g2));
      }
      if (null !== f2) {
        h2 = f2.next;
        var k = e.baseState, l2 = 0, m2 = null, p2 = null, x2 = null;
        if (null !== h2) {
          var z2 = h2;
          do {
            g2 = z2.expirationTime;
            if (g2 < d) {
              var ca = { expirationTime: z2.expirationTime, suspenseConfig: z2.suspenseConfig, tag: z2.tag, payload: z2.payload, callback: z2.callback, next: null };
              null === x2 ? (p2 = x2 = ca, m2 = k) : x2 = x2.next = ca;
              g2 > l2 && (l2 = g2);
            } else {
              null !== x2 && (x2 = x2.next = { expirationTime: 1073741823, suspenseConfig: z2.suspenseConfig, tag: z2.tag, payload: z2.payload, callback: z2.callback, next: null });
              Ag(g2, z2.suspenseConfig);
              a: {
                var D2 = a, t2 = z2;
                g2 = b;
                ca = c;
                switch (t2.tag) {
                  case 1:
                    D2 = t2.payload;
                    if ("function" === typeof D2) {
                      k = D2.call(ca, k, g2);
                      break a;
                    }
                    k = D2;
                    break a;
                  case 3:
                    D2.effectTag = D2.effectTag & -4097 | 64;
                  case 0:
                    D2 = t2.payload;
                    g2 = "function" === typeof D2 ? D2.call(ca, k, g2) : D2;
                    if (null === g2 || void 0 === g2)
                      break a;
                    k = n({}, k, g2);
                    break a;
                  case 2:
                    tg = true;
                }
              }
              null !== z2.callback && (a.effectTag |= 32, g2 = e.effects, null === g2 ? e.effects = [z2] : g2.push(z2));
            }
            z2 = z2.next;
            if (null === z2 || z2 === h2)
              if (g2 = e.shared.pending, null === g2)
                break;
              else
                z2 = f2.next = g2.next, g2.next = h2, e.baseQueue = f2 = g2, e.shared.pending = null;
          } while (1);
        }
        null === x2 ? m2 = k : x2.next = p2;
        e.baseState = m2;
        e.baseQueue = x2;
        Bg(l2);
        a.expirationTime = l2;
        a.memoizedState = k;
      }
    }
    function Cg(a, b, c) {
      a = b.effects;
      b.effects = null;
      if (null !== a)
        for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (null !== e) {
            d.callback = null;
            d = e;
            e = c;
            if ("function" !== typeof d)
              throw Error(u(191, d));
            d.call(e);
          }
        }
    }
    var Dg = Wa.ReactCurrentBatchConfig, Eg = new aa.Component().refs;
    function Fg(a, b, c, d) {
      b = a.memoizedState;
      c = c(d, b);
      c = null === c || void 0 === c ? b : n({}, b, c);
      a.memoizedState = c;
      0 === a.expirationTime && (a.updateQueue.baseState = c);
    }
    var Jg = { isMounted: function(a) {
      return (a = a._reactInternalFiber) ? dc(a) === a : false;
    }, enqueueSetState: function(a, b, c) {
      a = a._reactInternalFiber;
      var d = Gg(), e = Dg.suspense;
      d = Hg(d, a, e);
      e = wg(d, e);
      e.payload = b;
      void 0 !== c && null !== c && (e.callback = c);
      xg(a, e);
      Ig(a, d);
    }, enqueueReplaceState: function(a, b, c) {
      a = a._reactInternalFiber;
      var d = Gg(), e = Dg.suspense;
      d = Hg(d, a, e);
      e = wg(d, e);
      e.tag = 1;
      e.payload = b;
      void 0 !== c && null !== c && (e.callback = c);
      xg(a, e);
      Ig(a, d);
    }, enqueueForceUpdate: function(a, b) {
      a = a._reactInternalFiber;
      var c = Gg(), d = Dg.suspense;
      c = Hg(c, a, d);
      d = wg(c, d);
      d.tag = 2;
      void 0 !== b && null !== b && (d.callback = b);
      xg(a, d);
      Ig(a, c);
    } };
    function Kg(a, b, c, d, e, f2, g2) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f2, g2) : b.prototype && b.prototype.isPureReactComponent ? !bf(c, d) || !bf(e, f2) : true;
    }
    function Lg(a, b, c) {
      var d = false, e = Af;
      var f2 = b.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = sg(f2) : (e = L(b) ? Bf : J.current, d = b.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Cf(a, e) : Af);
      b = new b(c, f2);
      a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = Jg;
      a.stateNode = b;
      b._reactInternalFiber = a;
      d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f2);
      return b;
    }
    function Mg(a, b, c, d) {
      a = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
      b.state !== a && Jg.enqueueReplaceState(b, b.state, null);
    }
    function Ng(a, b, c, d) {
      var e = a.stateNode;
      e.props = c;
      e.state = a.memoizedState;
      e.refs = Eg;
      ug(a);
      var f2 = b.contextType;
      "object" === typeof f2 && null !== f2 ? e.context = sg(f2) : (f2 = L(b) ? Bf : J.current, e.context = Cf(a, f2));
      zg(a, c, e, d);
      e.state = a.memoizedState;
      f2 = b.getDerivedStateFromProps;
      "function" === typeof f2 && (Fg(a, b, f2, c), e.state = a.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Jg.enqueueReplaceState(e, e.state, null), zg(a, c, e, d), e.state = a.memoizedState);
      "function" === typeof e.componentDidMount && (a.effectTag |= 4);
    }
    var Og = Array.isArray;
    function Pg(a, b, c) {
      a = c.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c._owner) {
          c = c._owner;
          if (c) {
            if (1 !== c.tag)
              throw Error(u(309));
            var d = c.stateNode;
          }
          if (!d)
            throw Error(u(147, a));
          var e = "" + a;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e)
            return b.ref;
          b = function(a2) {
            var b2 = d.refs;
            b2 === Eg && (b2 = d.refs = {});
            null === a2 ? delete b2[e] : b2[e] = a2;
          };
          b._stringRef = e;
          return b;
        }
        if ("string" !== typeof a)
          throw Error(u(284));
        if (!c._owner)
          throw Error(u(290, a));
      }
      return a;
    }
    function Qg(a, b) {
      if ("textarea" !== a.type)
        throw Error(u(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, ""));
    }
    function Rg(a) {
      function b(b2, c2) {
        if (a) {
          var d2 = b2.lastEffect;
          null !== d2 ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
          c2.nextEffect = null;
          c2.effectTag = 8;
        }
      }
      function c(c2, d2) {
        if (!a)
          return null;
        for (; null !== d2; )
          b(c2, d2), d2 = d2.sibling;
        return null;
      }
      function d(a2, b2) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b2; )
          null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
        return a2;
      }
      function e(a2, b2) {
        a2 = Sg(a2, b2);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      function f2(b2, c2, d2) {
        b2.index = d2;
        if (!a)
          return c2;
        d2 = b2.alternate;
        if (null !== d2)
          return d2 = d2.index, d2 < c2 ? (b2.effectTag = 2, c2) : d2;
        b2.effectTag = 2;
        return c2;
      }
      function g2(b2) {
        a && null === b2.alternate && (b2.effectTag = 2);
        return b2;
      }
      function h2(a2, b2, c2, d2) {
        if (null === b2 || 6 !== b2.tag)
          return b2 = Tg(c2, a2.mode, d2), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function k(a2, b2, c2, d2) {
        if (null !== b2 && b2.elementType === c2.type)
          return d2 = e(b2, c2.props), d2.ref = Pg(a2, b2, c2), d2.return = a2, d2;
        d2 = Ug(c2.type, c2.key, c2.props, null, a2.mode, d2);
        d2.ref = Pg(a2, b2, c2);
        d2.return = a2;
        return d2;
      }
      function l2(a2, b2, c2, d2) {
        if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
          return b2 = Vg(c2, a2.mode, d2), b2.return = a2, b2;
        b2 = e(b2, c2.children || []);
        b2.return = a2;
        return b2;
      }
      function m2(a2, b2, c2, d2, f3) {
        if (null === b2 || 7 !== b2.tag)
          return b2 = Wg(c2, a2.mode, d2, f3), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      function p2(a2, b2, c2) {
        if ("string" === typeof b2 || "number" === typeof b2)
          return b2 = Tg("" + b2, a2.mode, c2), b2.return = a2, b2;
        if ("object" === typeof b2 && null !== b2) {
          switch (b2.$$typeof) {
            case Za:
              return c2 = Ug(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Pg(a2, null, b2), c2.return = a2, c2;
            case $a:
              return b2 = Vg(b2, a2.mode, c2), b2.return = a2, b2;
          }
          if (Og(b2) || nb(b2))
            return b2 = Wg(b2, a2.mode, c2, null), b2.return = a2, b2;
          Qg(a2, b2);
        }
        return null;
      }
      function x2(a2, b2, c2, d2) {
        var e2 = null !== b2 ? b2.key : null;
        if ("string" === typeof c2 || "number" === typeof c2)
          return null !== e2 ? null : h2(a2, b2, "" + c2, d2);
        if ("object" === typeof c2 && null !== c2) {
          switch (c2.$$typeof) {
            case Za:
              return c2.key === e2 ? c2.type === ab ? m2(a2, b2, c2.props.children, d2, e2) : k(a2, b2, c2, d2) : null;
            case $a:
              return c2.key === e2 ? l2(a2, b2, c2, d2) : null;
          }
          if (Og(c2) || nb(c2))
            return null !== e2 ? null : m2(a2, b2, c2, d2, null);
          Qg(a2, c2);
        }
        return null;
      }
      function z2(a2, b2, c2, d2, e2) {
        if ("string" === typeof d2 || "number" === typeof d2)
          return a2 = a2.get(c2) || null, h2(b2, a2, "" + d2, e2);
        if ("object" === typeof d2 && null !== d2) {
          switch (d2.$$typeof) {
            case Za:
              return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, d2.type === ab ? m2(b2, a2, d2.props.children, e2, d2.key) : k(b2, a2, d2, e2);
            case $a:
              return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l2(b2, a2, d2, e2);
          }
          if (Og(d2) || nb(d2))
            return a2 = a2.get(c2) || null, m2(b2, a2, d2, e2, null);
          Qg(b2, d2);
        }
        return null;
      }
      function ca(e2, g3, h3, k2) {
        for (var l3 = null, t2 = null, m3 = g3, y2 = g3 = 0, A2 = null; null !== m3 && y2 < h3.length; y2++) {
          m3.index > y2 ? (A2 = m3, m3 = null) : A2 = m3.sibling;
          var q2 = x2(e2, m3, h3[y2], k2);
          if (null === q2) {
            null === m3 && (m3 = A2);
            break;
          }
          a && m3 && null === q2.alternate && b(e2, m3);
          g3 = f2(q2, g3, y2);
          null === t2 ? l3 = q2 : t2.sibling = q2;
          t2 = q2;
          m3 = A2;
        }
        if (y2 === h3.length)
          return c(e2, m3), l3;
        if (null === m3) {
          for (; y2 < h3.length; y2++)
            m3 = p2(e2, h3[y2], k2), null !== m3 && (g3 = f2(m3, g3, y2), null === t2 ? l3 = m3 : t2.sibling = m3, t2 = m3);
          return l3;
        }
        for (m3 = d(e2, m3); y2 < h3.length; y2++)
          A2 = z2(m3, e2, y2, h3[y2], k2), null !== A2 && (a && null !== A2.alternate && m3.delete(null === A2.key ? y2 : A2.key), g3 = f2(A2, g3, y2), null === t2 ? l3 = A2 : t2.sibling = A2, t2 = A2);
        a && m3.forEach(function(a2) {
          return b(e2, a2);
        });
        return l3;
      }
      function D2(e2, g3, h3, l3) {
        var k2 = nb(h3);
        if ("function" !== typeof k2)
          throw Error(u(150));
        h3 = k2.call(h3);
        if (null == h3)
          throw Error(u(151));
        for (var m3 = k2 = null, t2 = g3, y2 = g3 = 0, A2 = null, q2 = h3.next(); null !== t2 && !q2.done; y2++, q2 = h3.next()) {
          t2.index > y2 ? (A2 = t2, t2 = null) : A2 = t2.sibling;
          var D3 = x2(e2, t2, q2.value, l3);
          if (null === D3) {
            null === t2 && (t2 = A2);
            break;
          }
          a && t2 && null === D3.alternate && b(e2, t2);
          g3 = f2(D3, g3, y2);
          null === m3 ? k2 = D3 : m3.sibling = D3;
          m3 = D3;
          t2 = A2;
        }
        if (q2.done)
          return c(e2, t2), k2;
        if (null === t2) {
          for (; !q2.done; y2++, q2 = h3.next())
            q2 = p2(e2, q2.value, l3), null !== q2 && (g3 = f2(q2, g3, y2), null === m3 ? k2 = q2 : m3.sibling = q2, m3 = q2);
          return k2;
        }
        for (t2 = d(e2, t2); !q2.done; y2++, q2 = h3.next())
          q2 = z2(t2, e2, y2, q2.value, l3), null !== q2 && (a && null !== q2.alternate && t2.delete(null === q2.key ? y2 : q2.key), g3 = f2(q2, g3, y2), null === m3 ? k2 = q2 : m3.sibling = q2, m3 = q2);
        a && t2.forEach(function(a2) {
          return b(e2, a2);
        });
        return k2;
      }
      return function(a2, d2, f3, h3) {
        var k2 = "object" === typeof f3 && null !== f3 && f3.type === ab && null === f3.key;
        k2 && (f3 = f3.props.children);
        var l3 = "object" === typeof f3 && null !== f3;
        if (l3)
          switch (f3.$$typeof) {
            case Za:
              a: {
                l3 = f3.key;
                for (k2 = d2; null !== k2; ) {
                  if (k2.key === l3) {
                    switch (k2.tag) {
                      case 7:
                        if (f3.type === ab) {
                          c(a2, k2.sibling);
                          d2 = e(k2, f3.props.children);
                          d2.return = a2;
                          a2 = d2;
                          break a;
                        }
                        break;
                      default:
                        if (k2.elementType === f3.type) {
                          c(
                            a2,
                            k2.sibling
                          );
                          d2 = e(k2, f3.props);
                          d2.ref = Pg(a2, k2, f3);
                          d2.return = a2;
                          a2 = d2;
                          break a;
                        }
                    }
                    c(a2, k2);
                    break;
                  } else
                    b(a2, k2);
                  k2 = k2.sibling;
                }
                f3.type === ab ? (d2 = Wg(f3.props.children, a2.mode, h3, f3.key), d2.return = a2, a2 = d2) : (h3 = Ug(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Pg(a2, d2, f3), h3.return = a2, a2 = h3);
              }
              return g2(a2);
            case $a:
              a: {
                for (k2 = f3.key; null !== d2; ) {
                  if (d2.key === k2)
                    if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                      c(a2, d2.sibling);
                      d2 = e(d2, f3.children || []);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                  else
                    b(a2, d2);
                  d2 = d2.sibling;
                }
                d2 = Vg(f3, a2.mode, h3);
                d2.return = a2;
                a2 = d2;
              }
              return g2(a2);
          }
        if ("string" === typeof f3 || "number" === typeof f3)
          return f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Tg(f3, a2.mode, h3), d2.return = a2, a2 = d2), g2(a2);
        if (Og(f3))
          return ca(a2, d2, f3, h3);
        if (nb(f3))
          return D2(a2, d2, f3, h3);
        l3 && Qg(a2, f3);
        if ("undefined" === typeof f3 && !k2)
          switch (a2.tag) {
            case 1:
            case 0:
              throw a2 = a2.type, Error(u(152, a2.displayName || a2.name || "Component"));
          }
        return c(a2, d2);
      };
    }
    var Xg = Rg(true), Yg = Rg(false), Zg = {}, $g = { current: Zg }, ah = { current: Zg }, bh = { current: Zg };
    function ch(a) {
      if (a === Zg)
        throw Error(u(174));
      return a;
    }
    function dh(a, b) {
      I(bh, b);
      I(ah, a);
      I($g, Zg);
      a = b.nodeType;
      switch (a) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : Ob(null, "");
          break;
        default:
          a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = Ob(b, a);
      }
      H($g);
      I($g, b);
    }
    function eh() {
      H($g);
      H(ah);
      H(bh);
    }
    function fh(a) {
      ch(bh.current);
      var b = ch($g.current);
      var c = Ob(b, a.type);
      b !== c && (I(ah, a), I($g, c));
    }
    function gh(a) {
      ah.current === a && (H($g), H(ah));
    }
    var M = { current: 0 };
    function hh(a) {
      for (var b = a; null !== b; ) {
        if (13 === b.tag) {
          var c = b.memoizedState;
          if (null !== c && (c = c.dehydrated, null === c || c.data === Bd || c.data === Cd))
            return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.effectTag & 64))
            return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a)
          break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a)
            return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    function ih(a, b) {
      return { responder: a, props: b };
    }
    var jh = Wa.ReactCurrentDispatcher, kh = Wa.ReactCurrentBatchConfig, lh = 0, N = null, O = null, P = null, mh = false;
    function Q() {
      throw Error(u(321));
    }
    function nh(a, b) {
      if (null === b)
        return false;
      for (var c = 0; c < b.length && c < a.length; c++)
        if (!$e(a[c], b[c]))
          return false;
      return true;
    }
    function oh(a, b, c, d, e, f2) {
      lh = f2;
      N = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.expirationTime = 0;
      jh.current = null === a || null === a.memoizedState ? ph : qh;
      a = c(d, e);
      if (b.expirationTime === lh) {
        f2 = 0;
        do {
          b.expirationTime = 0;
          if (!(25 > f2))
            throw Error(u(301));
          f2 += 1;
          P = O = null;
          b.updateQueue = null;
          jh.current = rh;
          a = c(d, e);
        } while (b.expirationTime === lh);
      }
      jh.current = sh;
      b = null !== O && null !== O.next;
      lh = 0;
      P = O = N = null;
      mh = false;
      if (b)
        throw Error(u(300));
      return a;
    }
    function th() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === P ? N.memoizedState = P = a : P = P.next = a;
      return P;
    }
    function uh() {
      if (null === O) {
        var a = N.alternate;
        a = null !== a ? a.memoizedState : null;
      } else
        a = O.next;
      var b = null === P ? N.memoizedState : P.next;
      if (null !== b)
        P = b, O = a;
      else {
        if (null === a)
          throw Error(u(310));
        O = a;
        a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
        null === P ? N.memoizedState = P = a : P = P.next = a;
      }
      return P;
    }
    function vh(a, b) {
      return "function" === typeof b ? b(a) : b;
    }
    function wh(a) {
      var b = uh(), c = b.queue;
      if (null === c)
        throw Error(u(311));
      c.lastRenderedReducer = a;
      var d = O, e = d.baseQueue, f2 = c.pending;
      if (null !== f2) {
        if (null !== e) {
          var g2 = e.next;
          e.next = f2.next;
          f2.next = g2;
        }
        d.baseQueue = e = f2;
        c.pending = null;
      }
      if (null !== e) {
        e = e.next;
        d = d.baseState;
        var h2 = g2 = f2 = null, k = e;
        do {
          var l2 = k.expirationTime;
          if (l2 < lh) {
            var m2 = { expirationTime: k.expirationTime, suspenseConfig: k.suspenseConfig, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null };
            null === h2 ? (g2 = h2 = m2, f2 = d) : h2 = h2.next = m2;
            l2 > N.expirationTime && (N.expirationTime = l2, Bg(l2));
          } else
            null !== h2 && (h2 = h2.next = { expirationTime: 1073741823, suspenseConfig: k.suspenseConfig, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), Ag(l2, k.suspenseConfig), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);
          k = k.next;
        } while (null !== k && k !== e);
        null === h2 ? f2 = d : h2.next = g2;
        $e(d, b.memoizedState) || (rg = true);
        b.memoizedState = d;
        b.baseState = f2;
        b.baseQueue = h2;
        c.lastRenderedState = d;
      }
      return [b.memoizedState, c.dispatch];
    }
    function xh(a) {
      var b = uh(), c = b.queue;
      if (null === c)
        throw Error(u(311));
      c.lastRenderedReducer = a;
      var d = c.dispatch, e = c.pending, f2 = b.memoizedState;
      if (null !== e) {
        c.pending = null;
        var g2 = e = e.next;
        do
          f2 = a(f2, g2.action), g2 = g2.next;
        while (g2 !== e);
        $e(f2, b.memoizedState) || (rg = true);
        b.memoizedState = f2;
        null === b.baseQueue && (b.baseState = f2);
        c.lastRenderedState = f2;
      }
      return [f2, d];
    }
    function yh(a) {
      var b = th();
      "function" === typeof a && (a = a());
      b.memoizedState = b.baseState = a;
      a = b.queue = { pending: null, dispatch: null, lastRenderedReducer: vh, lastRenderedState: a };
      a = a.dispatch = zh.bind(null, N, a);
      return [b.memoizedState, a];
    }
    function Ah(a, b, c, d) {
      a = { tag: a, create: b, destroy: c, deps: d, next: null };
      b = N.updateQueue;
      null === b ? (b = { lastEffect: null }, N.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
      return a;
    }
    function Bh() {
      return uh().memoizedState;
    }
    function Ch(a, b, c, d) {
      var e = th();
      N.effectTag |= a;
      e.memoizedState = Ah(1 | b, c, void 0, void 0 === d ? null : d);
    }
    function Dh(a, b, c, d) {
      var e = uh();
      d = void 0 === d ? null : d;
      var f2 = void 0;
      if (null !== O) {
        var g2 = O.memoizedState;
        f2 = g2.destroy;
        if (null !== d && nh(d, g2.deps)) {
          Ah(b, c, f2, d);
          return;
        }
      }
      N.effectTag |= a;
      e.memoizedState = Ah(1 | b, c, f2, d);
    }
    function Eh(a, b) {
      return Ch(516, 4, a, b);
    }
    function Fh(a, b) {
      return Dh(516, 4, a, b);
    }
    function Gh(a, b) {
      return Dh(4, 2, a, b);
    }
    function Hh(a, b) {
      if ("function" === typeof b)
        return a = a(), b(a), function() {
          b(null);
        };
      if (null !== b && void 0 !== b)
        return a = a(), b.current = a, function() {
          b.current = null;
        };
    }
    function Ih(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return Dh(4, 2, Hh.bind(null, b, a), c);
    }
    function Jh() {
    }
    function Kh(a, b) {
      th().memoizedState = [a, void 0 === b ? null : b];
      return a;
    }
    function Lh(a, b) {
      var c = uh();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && nh(b, d[1]))
        return d[0];
      c.memoizedState = [a, b];
      return a;
    }
    function Mh(a, b) {
      var c = uh();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && nh(b, d[1]))
        return d[0];
      a = a();
      c.memoizedState = [a, b];
      return a;
    }
    function Nh(a, b, c) {
      var d = ag();
      cg(98 > d ? 98 : d, function() {
        a(true);
      });
      cg(97 < d ? 97 : d, function() {
        var d2 = kh.suspense;
        kh.suspense = void 0 === b ? null : b;
        try {
          a(false), c();
        } finally {
          kh.suspense = d2;
        }
      });
    }
    function zh(a, b, c) {
      var d = Gg(), e = Dg.suspense;
      d = Hg(d, a, e);
      e = { expirationTime: d, suspenseConfig: e, action: c, eagerReducer: null, eagerState: null, next: null };
      var f2 = b.pending;
      null === f2 ? e.next = e : (e.next = f2.next, f2.next = e);
      b.pending = e;
      f2 = a.alternate;
      if (a === N || null !== f2 && f2 === N)
        mh = true, e.expirationTime = lh, N.expirationTime = lh;
      else {
        if (0 === a.expirationTime && (null === f2 || 0 === f2.expirationTime) && (f2 = b.lastRenderedReducer, null !== f2))
          try {
            var g2 = b.lastRenderedState, h2 = f2(g2, c);
            e.eagerReducer = f2;
            e.eagerState = h2;
            if ($e(h2, g2))
              return;
          } catch (k) {
          } finally {
          }
        Ig(
          a,
          d
        );
      }
    }
    var sh = { readContext: sg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useResponder: Q, useDeferredValue: Q, useTransition: Q }, ph = { readContext: sg, useCallback: Kh, useContext: sg, useEffect: Eh, useImperativeHandle: function(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return Ch(4, 2, Hh.bind(null, b, a), c);
    }, useLayoutEffect: function(a, b) {
      return Ch(4, 2, a, b);
    }, useMemo: function(a, b) {
      var c = th();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [
        a,
        b
      ];
      return a;
    }, useReducer: function(a, b, c) {
      var d = th();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
      a = a.dispatch = zh.bind(null, N, a);
      return [d.memoizedState, a];
    }, useRef: function(a) {
      var b = th();
      a = { current: a };
      return b.memoizedState = a;
    }, useState: yh, useDebugValue: Jh, useResponder: ih, useDeferredValue: function(a, b) {
      var c = yh(a), d = c[0], e = c[1];
      Eh(function() {
        var c2 = kh.suspense;
        kh.suspense = void 0 === b ? null : b;
        try {
          e(a);
        } finally {
          kh.suspense = c2;
        }
      }, [a, b]);
      return d;
    }, useTransition: function(a) {
      var b = yh(false), c = b[0];
      b = b[1];
      return [Kh(Nh.bind(null, b, a), [b, a]), c];
    } }, qh = { readContext: sg, useCallback: Lh, useContext: sg, useEffect: Fh, useImperativeHandle: Ih, useLayoutEffect: Gh, useMemo: Mh, useReducer: wh, useRef: Bh, useState: function() {
      return wh(vh);
    }, useDebugValue: Jh, useResponder: ih, useDeferredValue: function(a, b) {
      var c = wh(vh), d = c[0], e = c[1];
      Fh(function() {
        var c2 = kh.suspense;
        kh.suspense = void 0 === b ? null : b;
        try {
          e(a);
        } finally {
          kh.suspense = c2;
        }
      }, [a, b]);
      return d;
    }, useTransition: function(a) {
      var b = wh(vh), c = b[0];
      b = b[1];
      return [Lh(Nh.bind(null, b, a), [b, a]), c];
    } }, rh = { readContext: sg, useCallback: Lh, useContext: sg, useEffect: Fh, useImperativeHandle: Ih, useLayoutEffect: Gh, useMemo: Mh, useReducer: xh, useRef: Bh, useState: function() {
      return xh(vh);
    }, useDebugValue: Jh, useResponder: ih, useDeferredValue: function(a, b) {
      var c = xh(vh), d = c[0], e = c[1];
      Fh(function() {
        var c2 = kh.suspense;
        kh.suspense = void 0 === b ? null : b;
        try {
          e(a);
        } finally {
          kh.suspense = c2;
        }
      }, [a, b]);
      return d;
    }, useTransition: function(a) {
      var b = xh(vh), c = b[0];
      b = b[1];
      return [Lh(Nh.bind(
        null,
        b,
        a
      ), [b, a]), c];
    } }, Oh = null, Ph = null, Qh = false;
    function Rh(a, b) {
      var c = Sh(5, null, null, 0);
      c.elementType = "DELETED";
      c.type = "DELETED";
      c.stateNode = b;
      c.return = a;
      c.effectTag = 8;
      null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
    }
    function Th(a, b) {
      switch (a.tag) {
        case 5:
          var c = a.type;
          b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
          return null !== b ? (a.stateNode = b, true) : false;
        case 6:
          return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, true) : false;
        case 13:
          return false;
        default:
          return false;
      }
    }
    function Uh(a) {
      if (Qh) {
        var b = Ph;
        if (b) {
          var c = b;
          if (!Th(a, b)) {
            b = Jd(c.nextSibling);
            if (!b || !Th(a, b)) {
              a.effectTag = a.effectTag & -1025 | 2;
              Qh = false;
              Oh = a;
              return;
            }
            Rh(Oh, c);
          }
          Oh = a;
          Ph = Jd(b.firstChild);
        } else
          a.effectTag = a.effectTag & -1025 | 2, Qh = false, Oh = a;
      }
    }
    function Vh(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
        a = a.return;
      Oh = a;
    }
    function Wh(a) {
      if (a !== Oh)
        return false;
      if (!Qh)
        return Vh(a), Qh = true, false;
      var b = a.type;
      if (5 !== a.tag || "head" !== b && "body" !== b && !Gd(b, a.memoizedProps))
        for (b = Ph; b; )
          Rh(a, b), b = Jd(b.nextSibling);
      Vh(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a)
          throw Error(u(317));
        a: {
          a = a.nextSibling;
          for (b = 0; a; ) {
            if (8 === a.nodeType) {
              var c = a.data;
              if (c === Ad) {
                if (0 === b) {
                  Ph = Jd(a.nextSibling);
                  break a;
                }
                b--;
              } else
                c !== zd && c !== Cd && c !== Bd || b++;
            }
            a = a.nextSibling;
          }
          Ph = null;
        }
      } else
        Ph = Oh ? Jd(a.stateNode.nextSibling) : null;
      return true;
    }
    function Xh() {
      Ph = Oh = null;
      Qh = false;
    }
    var Yh = Wa.ReactCurrentOwner, rg = false;
    function R(a, b, c, d) {
      b.child = null === a ? Yg(b, null, c, d) : Xg(b, a.child, c, d);
    }
    function Zh(a, b, c, d, e) {
      c = c.render;
      var f2 = b.ref;
      qg(b, e);
      d = oh(a, b, c, d, f2, e);
      if (null !== a && !rg)
        return b.updateQueue = a.updateQueue, b.effectTag &= -517, a.expirationTime <= e && (a.expirationTime = 0), $h(a, b, e);
      b.effectTag |= 1;
      R(a, b, d, e);
      return b.child;
    }
    function ai(a, b, c, d, e, f2) {
      if (null === a) {
        var g2 = c.type;
        if ("function" === typeof g2 && !bi(g2) && void 0 === g2.defaultProps && null === c.compare && void 0 === c.defaultProps)
          return b.tag = 15, b.type = g2, ci(a, b, g2, d, e, f2);
        a = Ug(c.type, null, d, null, b.mode, f2);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      g2 = a.child;
      if (e < f2 && (e = g2.memoizedProps, c = c.compare, c = null !== c ? c : bf, c(e, d) && a.ref === b.ref))
        return $h(a, b, f2);
      b.effectTag |= 1;
      a = Sg(g2, d);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    function ci(a, b, c, d, e, f2) {
      return null !== a && bf(a.memoizedProps, d) && a.ref === b.ref && (rg = false, e < f2) ? (b.expirationTime = a.expirationTime, $h(a, b, f2)) : di(a, b, c, d, f2);
    }
    function ei(a, b) {
      var c = b.ref;
      if (null === a && null !== c || null !== a && a.ref !== c)
        b.effectTag |= 128;
    }
    function di(a, b, c, d, e) {
      var f2 = L(c) ? Bf : J.current;
      f2 = Cf(b, f2);
      qg(b, e);
      c = oh(a, b, c, d, f2, e);
      if (null !== a && !rg)
        return b.updateQueue = a.updateQueue, b.effectTag &= -517, a.expirationTime <= e && (a.expirationTime = 0), $h(a, b, e);
      b.effectTag |= 1;
      R(a, b, c, e);
      return b.child;
    }
    function fi(a, b, c, d, e) {
      if (L(c)) {
        var f2 = true;
        Gf(b);
      } else
        f2 = false;
      qg(b, e);
      if (null === b.stateNode)
        null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2), Lg(b, c, d), Ng(b, c, d, e), d = true;
      else if (null === a) {
        var g2 = b.stateNode, h2 = b.memoizedProps;
        g2.props = h2;
        var k = g2.context, l2 = c.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = sg(l2) : (l2 = L(c) ? Bf : J.current, l2 = Cf(b, l2));
        var m2 = c.getDerivedStateFromProps, p2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
        p2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d || k !== l2) && Mg(b, g2, d, l2);
        tg = false;
        var x2 = b.memoizedState;
        g2.state = x2;
        zg(b, d, g2, e);
        k = b.memoizedState;
        h2 !== d || x2 !== k || K.current || tg ? ("function" === typeof m2 && (Fg(b, c, m2, d), k = b.memoizedState), (h2 = tg || Kg(b, c, h2, d, x2, k, l2)) ? (p2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b.effectTag |= 4)) : ("function" === typeof g2.componentDidMount && (b.effectTag |= 4), b.memoizedProps = d, b.memoizedState = k), g2.props = d, g2.state = k, g2.context = l2, d = h2) : ("function" === typeof g2.componentDidMount && (b.effectTag |= 4), d = false);
      } else
        g2 = b.stateNode, vg(a, b), h2 = b.memoizedProps, g2.props = b.type === b.elementType ? h2 : ig(b.type, h2), k = g2.context, l2 = c.contextType, "object" === typeof l2 && null !== l2 ? l2 = sg(l2) : (l2 = L(c) ? Bf : J.current, l2 = Cf(b, l2)), m2 = c.getDerivedStateFromProps, (p2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d || k !== l2) && Mg(b, g2, d, l2), tg = false, k = b.memoizedState, g2.state = k, zg(b, d, g2, e), x2 = b.memoizedState, h2 !== d || k !== x2 || K.current || tg ? ("function" === typeof m2 && (Fg(b, c, m2, d), x2 = b.memoizedState), (m2 = tg || Kg(b, c, h2, d, k, x2, l2)) ? (p2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(
          d,
          x2,
          l2
        ), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d, x2, l2)), "function" === typeof g2.componentDidUpdate && (b.effectTag |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b.effectTag |= 256)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && k === a.memoizedState || (b.effectTag |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && k === a.memoizedState || (b.effectTag |= 256), b.memoizedProps = d, b.memoizedState = x2), g2.props = d, g2.state = x2, g2.context = l2, d = m2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && k === a.memoizedState || (b.effectTag |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && k === a.memoizedState || (b.effectTag |= 256), d = false);
      return gi(a, b, c, d, f2, e);
    }
    function gi(a, b, c, d, e, f2) {
      ei(a, b);
      var g2 = 0 !== (b.effectTag & 64);
      if (!d && !g2)
        return e && Hf(b, c, false), $h(a, b, f2);
      d = b.stateNode;
      Yh.current = b;
      var h2 = g2 && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
      b.effectTag |= 1;
      null !== a && g2 ? (b.child = Xg(b, a.child, null, f2), b.child = Xg(b, null, h2, f2)) : R(a, b, h2, f2);
      b.memoizedState = d.state;
      e && Hf(b, c, true);
      return b.child;
    }
    function hi(a) {
      var b = a.stateNode;
      b.pendingContext ? Ef(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Ef(a, b.context, false);
      dh(a, b.containerInfo);
    }
    var ii = { dehydrated: null, retryTime: 0 };
    function ji(a, b, c) {
      var d = b.mode, e = b.pendingProps, f2 = M.current, g2 = false, h2;
      (h2 = 0 !== (b.effectTag & 64)) || (h2 = 0 !== (f2 & 2) && (null === a || null !== a.memoizedState));
      h2 ? (g2 = true, b.effectTag &= -65) : null !== a && null === a.memoizedState || void 0 === e.fallback || true === e.unstable_avoidThisFallback || (f2 |= 1);
      I(M, f2 & 1);
      if (null === a) {
        void 0 !== e.fallback && Uh(b);
        if (g2) {
          g2 = e.fallback;
          e = Wg(null, d, 0, null);
          e.return = b;
          if (0 === (b.mode & 2))
            for (a = null !== b.memoizedState ? b.child.child : b.child, e.child = a; null !== a; )
              a.return = e, a = a.sibling;
          c = Wg(g2, d, c, null);
          c.return = b;
          e.sibling = c;
          b.memoizedState = ii;
          b.child = e;
          return c;
        }
        d = e.children;
        b.memoizedState = null;
        return b.child = Yg(b, null, d, c);
      }
      if (null !== a.memoizedState) {
        a = a.child;
        d = a.sibling;
        if (g2) {
          e = e.fallback;
          c = Sg(a, a.pendingProps);
          c.return = b;
          if (0 === (b.mode & 2) && (g2 = null !== b.memoizedState ? b.child.child : b.child, g2 !== a.child))
            for (c.child = g2; null !== g2; )
              g2.return = c, g2 = g2.sibling;
          d = Sg(d, e);
          d.return = b;
          c.sibling = d;
          c.childExpirationTime = 0;
          b.memoizedState = ii;
          b.child = c;
          return d;
        }
        c = Xg(b, a.child, e.children, c);
        b.memoizedState = null;
        return b.child = c;
      }
      a = a.child;
      if (g2) {
        g2 = e.fallback;
        e = Wg(null, d, 0, null);
        e.return = b;
        e.child = a;
        null !== a && (a.return = e);
        if (0 === (b.mode & 2))
          for (a = null !== b.memoizedState ? b.child.child : b.child, e.child = a; null !== a; )
            a.return = e, a = a.sibling;
        c = Wg(g2, d, c, null);
        c.return = b;
        e.sibling = c;
        c.effectTag |= 2;
        e.childExpirationTime = 0;
        b.memoizedState = ii;
        b.child = e;
        return c;
      }
      b.memoizedState = null;
      return b.child = Xg(b, a, e.children, c);
    }
    function ki(a, b) {
      a.expirationTime < b && (a.expirationTime = b);
      var c = a.alternate;
      null !== c && c.expirationTime < b && (c.expirationTime = b);
      pg(a.return, b);
    }
    function li(a, b, c, d, e, f2) {
      var g2 = a.memoizedState;
      null === g2 ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailExpiration: 0, tailMode: e, lastEffect: f2 } : (g2.isBackwards = b, g2.rendering = null, g2.renderingStartTime = 0, g2.last = d, g2.tail = c, g2.tailExpiration = 0, g2.tailMode = e, g2.lastEffect = f2);
    }
    function mi(a, b, c) {
      var d = b.pendingProps, e = d.revealOrder, f2 = d.tail;
      R(a, b, d.children, c);
      d = M.current;
      if (0 !== (d & 2))
        d = d & 1 | 2, b.effectTag |= 64;
      else {
        if (null !== a && 0 !== (a.effectTag & 64))
          a:
            for (a = b.child; null !== a; ) {
              if (13 === a.tag)
                null !== a.memoizedState && ki(a, c);
              else if (19 === a.tag)
                ki(a, c);
              else if (null !== a.child) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b)
                break a;
              for (; null === a.sibling; ) {
                if (null === a.return || a.return === b)
                  break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
        d &= 1;
      }
      I(M, d);
      if (0 === (b.mode & 2))
        b.memoizedState = null;
      else
        switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; null !== c; )
              a = c.alternate, null !== a && null === hh(a) && (e = c), c = c.sibling;
            c = e;
            null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
            li(b, false, e, c, f2, b.lastEffect);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a = e.alternate;
              if (null !== a && null === hh(a)) {
                b.child = e;
                break;
              }
              a = e.sibling;
              e.sibling = c;
              c = e;
              e = a;
            }
            li(b, true, c, null, f2, b.lastEffect);
            break;
          case "together":
            li(b, false, null, null, void 0, b.lastEffect);
            break;
          default:
            b.memoizedState = null;
        }
      return b.child;
    }
    function $h(a, b, c) {
      null !== a && (b.dependencies = a.dependencies);
      var d = b.expirationTime;
      0 !== d && Bg(d);
      if (b.childExpirationTime < c)
        return null;
      if (null !== a && b.child !== a.child)
        throw Error(u(153));
      if (null !== b.child) {
        a = b.child;
        c = Sg(a, a.pendingProps);
        b.child = c;
        for (c.return = b; null !== a.sibling; )
          a = a.sibling, c = c.sibling = Sg(a, a.pendingProps), c.return = b;
        c.sibling = null;
      }
      return b.child;
    }
    var ni, oi, pi, qi;
    ni = function(a, b) {
      for (var c = b.child; null !== c; ) {
        if (5 === c.tag || 6 === c.tag)
          a.appendChild(c.stateNode);
        else if (4 !== c.tag && null !== c.child) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b)
          break;
        for (; null === c.sibling; ) {
          if (null === c.return || c.return === b)
            return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    };
    oi = function() {
    };
    pi = function(a, b, c, d, e) {
      var f2 = a.memoizedProps;
      if (f2 !== d) {
        var g2 = b.stateNode;
        ch($g.current);
        a = null;
        switch (c) {
          case "input":
            f2 = zb(g2, f2);
            d = zb(g2, d);
            a = [];
            break;
          case "option":
            f2 = Gb(g2, f2);
            d = Gb(g2, d);
            a = [];
            break;
          case "select":
            f2 = n({}, f2, { value: void 0 });
            d = n({}, d, { value: void 0 });
            a = [];
            break;
          case "textarea":
            f2 = Ib(g2, f2);
            d = Ib(g2, d);
            a = [];
            break;
          default:
            "function" !== typeof f2.onClick && "function" === typeof d.onClick && (g2.onclick = sd);
        }
        od(c, d);
        var h2, k;
        c = null;
        for (h2 in f2)
          if (!d.hasOwnProperty(h2) && f2.hasOwnProperty(h2) && null != f2[h2])
            if ("style" === h2)
              for (k in g2 = f2[h2], g2)
                g2.hasOwnProperty(k) && (c || (c = {}), c[k] = "");
            else
              "dangerouslySetInnerHTML" !== h2 && "children" !== h2 && "suppressContentEditableWarning" !== h2 && "suppressHydrationWarning" !== h2 && "autoFocus" !== h2 && (va.hasOwnProperty(h2) ? a || (a = []) : (a = a || []).push(h2, null));
        for (h2 in d) {
          var l2 = d[h2];
          g2 = null != f2 ? f2[h2] : void 0;
          if (d.hasOwnProperty(h2) && l2 !== g2 && (null != l2 || null != g2))
            if ("style" === h2)
              if (g2) {
                for (k in g2)
                  !g2.hasOwnProperty(k) || l2 && l2.hasOwnProperty(k) || (c || (c = {}), c[k] = "");
                for (k in l2)
                  l2.hasOwnProperty(k) && g2[k] !== l2[k] && (c || (c = {}), c[k] = l2[k]);
              } else
                c || (a || (a = []), a.push(h2, c)), c = l2;
            else
              "dangerouslySetInnerHTML" === h2 ? (l2 = l2 ? l2.__html : void 0, g2 = g2 ? g2.__html : void 0, null != l2 && g2 !== l2 && (a = a || []).push(h2, l2)) : "children" === h2 ? g2 === l2 || "string" !== typeof l2 && "number" !== typeof l2 || (a = a || []).push(h2, "" + l2) : "suppressContentEditableWarning" !== h2 && "suppressHydrationWarning" !== h2 && (va.hasOwnProperty(h2) ? (null != l2 && rd(e, h2), a || g2 === l2 || (a = [])) : (a = a || []).push(h2, l2));
        }
        c && (a = a || []).push("style", c);
        e = a;
        if (b.updateQueue = e)
          b.effectTag |= 4;
      }
    };
    qi = function(a, b, c, d) {
      c !== d && (b.effectTag |= 4);
    };
    function ri(a, b) {
      switch (a.tailMode) {
        case "hidden":
          b = a.tail;
          for (var c = null; null !== b; )
            null !== b.alternate && (c = b), b = b.sibling;
          null === c ? a.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = a.tail;
          for (var d = null; null !== c; )
            null !== c.alternate && (d = c), c = c.sibling;
          null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
      }
    }
    function si(a, b, c) {
      var d = b.pendingProps;
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return null;
        case 1:
          return L(b.type) && Df(), null;
        case 3:
          return eh(), H(K), H(J), c = b.stateNode, c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), null !== a && null !== a.child || !Wh(b) || (b.effectTag |= 4), oi(b), null;
        case 5:
          gh(b);
          c = ch(bh.current);
          var e = b.type;
          if (null !== a && null != b.stateNode)
            pi(a, b, e, d, c), a.ref !== b.ref && (b.effectTag |= 128);
          else {
            if (!d) {
              if (null === b.stateNode)
                throw Error(u(166));
              return null;
            }
            a = ch($g.current);
            if (Wh(b)) {
              d = b.stateNode;
              e = b.type;
              var f2 = b.memoizedProps;
              d[Md] = b;
              d[Nd] = f2;
              switch (e) {
                case "iframe":
                case "object":
                case "embed":
                  F("load", d);
                  break;
                case "video":
                case "audio":
                  for (a = 0; a < ac.length; a++)
                    F(ac[a], d);
                  break;
                case "source":
                  F("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  F("error", d);
                  F("load", d);
                  break;
                case "form":
                  F("reset", d);
                  F("submit", d);
                  break;
                case "details":
                  F("toggle", d);
                  break;
                case "input":
                  Ab(d, f2);
                  F("invalid", d);
                  rd(c, "onChange");
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!f2.multiple };
                  F("invalid", d);
                  rd(c, "onChange");
                  break;
                case "textarea":
                  Jb(d, f2), F("invalid", d), rd(c, "onChange");
              }
              od(e, f2);
              a = null;
              for (var g2 in f2)
                if (f2.hasOwnProperty(g2)) {
                  var h2 = f2[g2];
                  "children" === g2 ? "string" === typeof h2 ? d.textContent !== h2 && (a = ["children", h2]) : "number" === typeof h2 && d.textContent !== "" + h2 && (a = ["children", "" + h2]) : va.hasOwnProperty(g2) && null != h2 && rd(c, g2);
                }
              switch (e) {
                case "input":
                  xb(d);
                  Eb(d, f2, true);
                  break;
                case "textarea":
                  xb(d);
                  Lb(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d.onclick = sd);
              }
              c = a;
              b.updateQueue = c;
              null !== c && (b.effectTag |= 4);
            } else {
              g2 = 9 === c.nodeType ? c : c.ownerDocument;
              a === qd && (a = Nb(e));
              a === qd ? "script" === e ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g2.createElement(e, { is: d.is }) : (a = g2.createElement(e), "select" === e && (g2 = a, d.multiple ? g2.multiple = true : d.size && (g2.size = d.size))) : a = g2.createElementNS(a, e);
              a[Md] = b;
              a[Nd] = d;
              ni(a, b, false, false);
              b.stateNode = a;
              g2 = pd(e, d);
              switch (e) {
                case "iframe":
                case "object":
                case "embed":
                  F(
                    "load",
                    a
                  );
                  h2 = d;
                  break;
                case "video":
                case "audio":
                  for (h2 = 0; h2 < ac.length; h2++)
                    F(ac[h2], a);
                  h2 = d;
                  break;
                case "source":
                  F("error", a);
                  h2 = d;
                  break;
                case "img":
                case "image":
                case "link":
                  F("error", a);
                  F("load", a);
                  h2 = d;
                  break;
                case "form":
                  F("reset", a);
                  F("submit", a);
                  h2 = d;
                  break;
                case "details":
                  F("toggle", a);
                  h2 = d;
                  break;
                case "input":
                  Ab(a, d);
                  h2 = zb(a, d);
                  F("invalid", a);
                  rd(c, "onChange");
                  break;
                case "option":
                  h2 = Gb(a, d);
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!d.multiple };
                  h2 = n({}, d, { value: void 0 });
                  F("invalid", a);
                  rd(c, "onChange");
                  break;
                case "textarea":
                  Jb(
                    a,
                    d
                  );
                  h2 = Ib(a, d);
                  F("invalid", a);
                  rd(c, "onChange");
                  break;
                default:
                  h2 = d;
              }
              od(e, h2);
              var k = h2;
              for (f2 in k)
                if (k.hasOwnProperty(f2)) {
                  var l2 = k[f2];
                  "style" === f2 ? md(a, l2) : "dangerouslySetInnerHTML" === f2 ? (l2 = l2 ? l2.__html : void 0, null != l2 && Qb(a, l2)) : "children" === f2 ? "string" === typeof l2 ? ("textarea" !== e || "" !== l2) && Rb(a, l2) : "number" === typeof l2 && Rb(a, "" + l2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (va.hasOwnProperty(f2) ? null != l2 && rd(c, f2) : null != l2 && Xa(a, f2, l2, g2));
                }
              switch (e) {
                case "input":
                  xb(a);
                  Eb(a, d, false);
                  break;
                case "textarea":
                  xb(a);
                  Lb(a);
                  break;
                case "option":
                  null != d.value && a.setAttribute("value", "" + rb(d.value));
                  break;
                case "select":
                  a.multiple = !!d.multiple;
                  c = d.value;
                  null != c ? Hb(a, !!d.multiple, c, false) : null != d.defaultValue && Hb(a, !!d.multiple, d.defaultValue, true);
                  break;
                default:
                  "function" === typeof h2.onClick && (a.onclick = sd);
              }
              Fd(e, d) && (b.effectTag |= 4);
            }
            null !== b.ref && (b.effectTag |= 128);
          }
          return null;
        case 6:
          if (a && null != b.stateNode)
            qi(a, b, a.memoizedProps, d);
          else {
            if ("string" !== typeof d && null === b.stateNode)
              throw Error(u(166));
            c = ch(bh.current);
            ch($g.current);
            Wh(b) ? (c = b.stateNode, d = b.memoizedProps, c[Md] = b, c.nodeValue !== d && (b.effectTag |= 4)) : (c = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), c[Md] = b, b.stateNode = c);
          }
          return null;
        case 13:
          H(M);
          d = b.memoizedState;
          if (0 !== (b.effectTag & 64))
            return b.expirationTime = c, b;
          c = null !== d;
          d = false;
          null === a ? void 0 !== b.memoizedProps.fallback && Wh(b) : (e = a.memoizedState, d = null !== e, c || null === e || (e = a.child.sibling, null !== e && (f2 = b.firstEffect, null !== f2 ? (b.firstEffect = e, e.nextEffect = f2) : (b.firstEffect = b.lastEffect = e, e.nextEffect = null), e.effectTag = 8)));
          if (c && !d && 0 !== (b.mode & 2))
            if (null === a && true !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (M.current & 1))
              S === ti && (S = ui);
            else {
              if (S === ti || S === ui)
                S = vi;
              0 !== wi && null !== T && (xi(T, U), yi(T, wi));
            }
          if (c || d)
            b.effectTag |= 4;
          return null;
        case 4:
          return eh(), oi(b), null;
        case 10:
          return og(b), null;
        case 17:
          return L(b.type) && Df(), null;
        case 19:
          H(M);
          d = b.memoizedState;
          if (null === d)
            return null;
          e = 0 !== (b.effectTag & 64);
          f2 = d.rendering;
          if (null === f2)
            if (e)
              ri(d, false);
            else {
              if (S !== ti || null !== a && 0 !== (a.effectTag & 64))
                for (f2 = b.child; null !== f2; ) {
                  a = hh(f2);
                  if (null !== a) {
                    b.effectTag |= 64;
                    ri(d, false);
                    e = a.updateQueue;
                    null !== e && (b.updateQueue = e, b.effectTag |= 4);
                    null === d.lastEffect && (b.firstEffect = null);
                    b.lastEffect = d.lastEffect;
                    for (d = b.child; null !== d; )
                      e = d, f2 = c, e.effectTag &= 2, e.nextEffect = null, e.firstEffect = null, e.lastEffect = null, a = e.alternate, null === a ? (e.childExpirationTime = 0, e.expirationTime = f2, e.child = null, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null) : (e.childExpirationTime = a.childExpirationTime, e.expirationTime = a.expirationTime, e.child = a.child, e.memoizedProps = a.memoizedProps, e.memoizedState = a.memoizedState, e.updateQueue = a.updateQueue, f2 = a.dependencies, e.dependencies = null === f2 ? null : { expirationTime: f2.expirationTime, firstContext: f2.firstContext, responders: f2.responders }), d = d.sibling;
                    I(M, M.current & 1 | 2);
                    return b.child;
                  }
                  f2 = f2.sibling;
                }
            }
          else {
            if (!e)
              if (a = hh(f2), null !== a) {
                if (b.effectTag |= 64, e = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.effectTag |= 4), ri(d, true), null === d.tail && "hidden" === d.tailMode && !f2.alternate)
                  return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
              } else
                2 * $f() - d.renderingStartTime > d.tailExpiration && 1 < c && (b.effectTag |= 64, e = true, ri(d, false), b.expirationTime = b.childExpirationTime = c - 1);
            d.isBackwards ? (f2.sibling = b.child, b.child = f2) : (c = d.last, null !== c ? c.sibling = f2 : b.child = f2, d.last = f2);
          }
          return null !== d.tail ? (0 === d.tailExpiration && (d.tailExpiration = $f() + 500), c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = $f(), c.sibling = null, b = M.current, I(M, e ? b & 1 | 2 : b & 1), c) : null;
      }
      throw Error(u(
        156,
        b.tag
      ));
    }
    function zi(a) {
      switch (a.tag) {
        case 1:
          L(a.type) && Df();
          var b = a.effectTag;
          return b & 4096 ? (a.effectTag = b & -4097 | 64, a) : null;
        case 3:
          eh();
          H(K);
          H(J);
          b = a.effectTag;
          if (0 !== (b & 64))
            throw Error(u(285));
          a.effectTag = b & -4097 | 64;
          return a;
        case 5:
          return gh(a), null;
        case 13:
          return H(M), b = a.effectTag, b & 4096 ? (a.effectTag = b & -4097 | 64, a) : null;
        case 19:
          return H(M), null;
        case 4:
          return eh(), null;
        case 10:
          return og(a), null;
        default:
          return null;
      }
    }
    function Ai(a, b) {
      return { value: a, source: b, stack: qb(b) };
    }
    var Bi = "function" === typeof WeakSet ? WeakSet : Set;
    function Ci(a, b) {
      var c = b.source, d = b.stack;
      null === d && null !== c && (d = qb(c));
      null !== c && pb(c.type);
      b = b.value;
      null !== a && 1 === a.tag && pb(a.type);
      try {
        console.error(b);
      } catch (e) {
        setTimeout(function() {
          throw e;
        });
      }
    }
    function Di(a, b) {
      try {
        b.props = a.memoizedProps, b.state = a.memoizedState, b.componentWillUnmount();
      } catch (c) {
        Ei(a, c);
      }
    }
    function Fi(a) {
      var b = a.ref;
      if (null !== b)
        if ("function" === typeof b)
          try {
            b(null);
          } catch (c) {
            Ei(a, c);
          }
        else
          b.current = null;
    }
    function Gi(a, b) {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          return;
        case 1:
          if (b.effectTag & 256 && null !== a) {
            var c = a.memoizedProps, d = a.memoizedState;
            a = b.stateNode;
            b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : ig(b.type, c), d);
            a.__reactInternalSnapshotBeforeUpdate = b;
          }
          return;
        case 3:
        case 5:
        case 6:
        case 4:
        case 17:
          return;
      }
      throw Error(u(163));
    }
    function Hi(a, b) {
      b = b.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        var c = b = b.next;
        do {
          if ((c.tag & a) === a) {
            var d = c.destroy;
            c.destroy = void 0;
            void 0 !== d && d();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    function Ii(a, b) {
      b = b.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        var c = b = b.next;
        do {
          if ((c.tag & a) === a) {
            var d = c.create;
            c.destroy = d();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    function Ji(a, b, c) {
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          Ii(3, c);
          return;
        case 1:
          a = c.stateNode;
          if (c.effectTag & 4)
            if (null === b)
              a.componentDidMount();
            else {
              var d = c.elementType === c.type ? b.memoizedProps : ig(c.type, b.memoizedProps);
              a.componentDidUpdate(d, b.memoizedState, a.__reactInternalSnapshotBeforeUpdate);
            }
          b = c.updateQueue;
          null !== b && Cg(c, b, a);
          return;
        case 3:
          b = c.updateQueue;
          if (null !== b) {
            a = null;
            if (null !== c.child)
              switch (c.child.tag) {
                case 5:
                  a = c.child.stateNode;
                  break;
                case 1:
                  a = c.child.stateNode;
              }
            Cg(c, b, a);
          }
          return;
        case 5:
          a = c.stateNode;
          null === b && c.effectTag & 4 && Fd(c.type, c.memoizedProps) && a.focus();
          return;
        case 6:
          return;
        case 4:
          return;
        case 12:
          return;
        case 13:
          null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && Vc(c))));
          return;
        case 19:
        case 17:
        case 20:
        case 21:
          return;
      }
      throw Error(u(163));
    }
    function Ki(a, b, c) {
      "function" === typeof Li && Li(b);
      switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          a = b.updateQueue;
          if (null !== a && (a = a.lastEffect, null !== a)) {
            var d = a.next;
            cg(97 < c ? 97 : c, function() {
              var a2 = d;
              do {
                var c2 = a2.destroy;
                if (void 0 !== c2) {
                  var g2 = b;
                  try {
                    c2();
                  } catch (h2) {
                    Ei(g2, h2);
                  }
                }
                a2 = a2.next;
              } while (a2 !== d);
            });
          }
          break;
        case 1:
          Fi(b);
          c = b.stateNode;
          "function" === typeof c.componentWillUnmount && Di(b, c);
          break;
        case 5:
          Fi(b);
          break;
        case 4:
          Mi(a, b, c);
      }
    }
    function Ni(a) {
      var b = a.alternate;
      a.return = null;
      a.child = null;
      a.memoizedState = null;
      a.updateQueue = null;
      a.dependencies = null;
      a.alternate = null;
      a.firstEffect = null;
      a.lastEffect = null;
      a.pendingProps = null;
      a.memoizedProps = null;
      a.stateNode = null;
      null !== b && Ni(b);
    }
    function Oi(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    function Pi(a) {
      a: {
        for (var b = a.return; null !== b; ) {
          if (Oi(b)) {
            var c = b;
            break a;
          }
          b = b.return;
        }
        throw Error(u(160));
      }
      b = c.stateNode;
      switch (c.tag) {
        case 5:
          var d = false;
          break;
        case 3:
          b = b.containerInfo;
          d = true;
          break;
        case 4:
          b = b.containerInfo;
          d = true;
          break;
        default:
          throw Error(u(161));
      }
      c.effectTag & 16 && (Rb(b, ""), c.effectTag &= -17);
      a:
        b:
          for (c = a; ; ) {
            for (; null === c.sibling; ) {
              if (null === c.return || Oi(c.return)) {
                c = null;
                break a;
              }
              c = c.return;
            }
            c.sibling.return = c.return;
            for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag; ) {
              if (c.effectTag & 2)
                continue b;
              if (null === c.child || 4 === c.tag)
                continue b;
              else
                c.child.return = c, c = c.child;
            }
            if (!(c.effectTag & 2)) {
              c = c.stateNode;
              break a;
            }
          }
      d ? Qi(a, c, b) : Ri(a, c, b);
    }
    function Qi(a, b, c) {
      var d = a.tag, e = 5 === d || 6 === d;
      if (e)
        a = e ? a.stateNode : a.stateNode.instance, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = sd));
      else if (4 !== d && (a = a.child, null !== a))
        for (Qi(a, b, c), a = a.sibling; null !== a; )
          Qi(a, b, c), a = a.sibling;
    }
    function Ri(a, b, c) {
      var d = a.tag, e = 5 === d || 6 === d;
      if (e)
        a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);
      else if (4 !== d && (a = a.child, null !== a))
        for (Ri(a, b, c), a = a.sibling; null !== a; )
          Ri(a, b, c), a = a.sibling;
    }
    function Mi(a, b, c) {
      for (var d = b, e = false, f2, g2; ; ) {
        if (!e) {
          e = d.return;
          a:
            for (; ; ) {
              if (null === e)
                throw Error(u(160));
              f2 = e.stateNode;
              switch (e.tag) {
                case 5:
                  g2 = false;
                  break a;
                case 3:
                  f2 = f2.containerInfo;
                  g2 = true;
                  break a;
                case 4:
                  f2 = f2.containerInfo;
                  g2 = true;
                  break a;
              }
              e = e.return;
            }
          e = true;
        }
        if (5 === d.tag || 6 === d.tag) {
          a:
            for (var h2 = a, k = d, l2 = c, m2 = k; ; )
              if (Ki(h2, m2, l2), null !== m2.child && 4 !== m2.tag)
                m2.child.return = m2, m2 = m2.child;
              else {
                if (m2 === k)
                  break a;
                for (; null === m2.sibling; ) {
                  if (null === m2.return || m2.return === k)
                    break a;
                  m2 = m2.return;
                }
                m2.sibling.return = m2.return;
                m2 = m2.sibling;
              }
          g2 ? (h2 = f2, k = d.stateNode, 8 === h2.nodeType ? h2.parentNode.removeChild(k) : h2.removeChild(k)) : f2.removeChild(d.stateNode);
        } else if (4 === d.tag) {
          if (null !== d.child) {
            f2 = d.stateNode.containerInfo;
            g2 = true;
            d.child.return = d;
            d = d.child;
            continue;
          }
        } else if (Ki(a, d, c), null !== d.child) {
          d.child.return = d;
          d = d.child;
          continue;
        }
        if (d === b)
          break;
        for (; null === d.sibling; ) {
          if (null === d.return || d.return === b)
            return;
          d = d.return;
          4 === d.tag && (e = false);
        }
        d.sibling.return = d.return;
        d = d.sibling;
      }
    }
    function Si(a, b) {
      switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          Hi(3, b);
          return;
        case 1:
          return;
        case 5:
          var c = b.stateNode;
          if (null != c) {
            var d = b.memoizedProps, e = null !== a ? a.memoizedProps : d;
            a = b.type;
            var f2 = b.updateQueue;
            b.updateQueue = null;
            if (null !== f2) {
              c[Nd] = d;
              "input" === a && "radio" === d.type && null != d.name && Bb(c, d);
              pd(a, e);
              b = pd(a, d);
              for (e = 0; e < f2.length; e += 2) {
                var g2 = f2[e], h2 = f2[e + 1];
                "style" === g2 ? md(c, h2) : "dangerouslySetInnerHTML" === g2 ? Qb(c, h2) : "children" === g2 ? Rb(c, h2) : Xa(c, g2, h2, b);
              }
              switch (a) {
                case "input":
                  Cb(c, d);
                  break;
                case "textarea":
                  Kb(c, d);
                  break;
                case "select":
                  b = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, a = d.value, null != a ? Hb(c, !!d.multiple, a, false) : b !== !!d.multiple && (null != d.defaultValue ? Hb(c, !!d.multiple, d.defaultValue, true) : Hb(c, !!d.multiple, d.multiple ? [] : "", false));
              }
            }
          }
          return;
        case 6:
          if (null === b.stateNode)
            throw Error(u(162));
          b.stateNode.nodeValue = b.memoizedProps;
          return;
        case 3:
          b = b.stateNode;
          b.hydrate && (b.hydrate = false, Vc(b.containerInfo));
          return;
        case 12:
          return;
        case 13:
          c = b;
          null === b.memoizedState ? d = false : (d = true, c = b.child, Ti = $f());
          if (null !== c)
            a:
              for (a = c; ; ) {
                if (5 === a.tag)
                  f2 = a.stateNode, d ? (f2 = f2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (f2 = a.stateNode, e = a.memoizedProps.style, e = void 0 !== e && null !== e && e.hasOwnProperty("display") ? e.display : null, f2.style.display = ld("display", e));
                else if (6 === a.tag)
                  a.stateNode.nodeValue = d ? "" : a.memoizedProps;
                else if (13 === a.tag && null !== a.memoizedState && null === a.memoizedState.dehydrated) {
                  f2 = a.child.sibling;
                  f2.return = a;
                  a = f2;
                  continue;
                } else if (null !== a.child) {
                  a.child.return = a;
                  a = a.child;
                  continue;
                }
                if (a === c)
                  break;
                for (; null === a.sibling; ) {
                  if (null === a.return || a.return === c)
                    break a;
                  a = a.return;
                }
                a.sibling.return = a.return;
                a = a.sibling;
              }
          Ui(b);
          return;
        case 19:
          Ui(b);
          return;
        case 17:
          return;
      }
      throw Error(u(163));
    }
    function Ui(a) {
      var b = a.updateQueue;
      if (null !== b) {
        a.updateQueue = null;
        var c = a.stateNode;
        null === c && (c = a.stateNode = new Bi());
        b.forEach(function(b2) {
          var d = Vi.bind(null, a, b2);
          c.has(b2) || (c.add(b2), b2.then(d, d));
        });
      }
    }
    var Wi = "function" === typeof WeakMap ? WeakMap : Map;
    function Xi(a, b, c) {
      c = wg(c, null);
      c.tag = 3;
      c.payload = { element: null };
      var d = b.value;
      c.callback = function() {
        Yi || (Yi = true, Zi = d);
        Ci(a, b);
      };
      return c;
    }
    function $i(a, b, c) {
      c = wg(c, null);
      c.tag = 3;
      var d = a.type.getDerivedStateFromError;
      if ("function" === typeof d) {
        var e = b.value;
        c.payload = function() {
          Ci(a, b);
          return d(e);
        };
      }
      var f2 = a.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
        "function" !== typeof d && (null === aj ? aj = /* @__PURE__ */ new Set([this]) : aj.add(this), Ci(a, b));
        var c2 = b.stack;
        this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
      });
      return c;
    }
    var bj = Math.ceil, cj = Wa.ReactCurrentDispatcher, dj = Wa.ReactCurrentOwner, V = 0, ej = 8, fj = 16, gj = 32, ti = 0, hj = 1, ij = 2, ui = 3, vi = 4, jj = 5, W = V, T = null, X = null, U = 0, S = ti, kj = null, lj = 1073741823, mj = 1073741823, nj = null, wi = 0, oj = false, Ti = 0, pj = 500, Y = null, Yi = false, Zi = null, aj = null, qj = false, rj = null, sj = 90, tj = null, uj = 0, vj = null, wj = 0;
    function Gg() {
      return (W & (fj | gj)) !== V ? 1073741821 - ($f() / 10 | 0) : 0 !== wj ? wj : wj = 1073741821 - ($f() / 10 | 0);
    }
    function Hg(a, b, c) {
      b = b.mode;
      if (0 === (b & 2))
        return 1073741823;
      var d = ag();
      if (0 === (b & 4))
        return 99 === d ? 1073741823 : 1073741822;
      if ((W & fj) !== V)
        return U;
      if (null !== c)
        a = hg(a, c.timeoutMs | 0 || 5e3, 250);
      else
        switch (d) {
          case 99:
            a = 1073741823;
            break;
          case 98:
            a = hg(a, 150, 100);
            break;
          case 97:
          case 96:
            a = hg(a, 5e3, 250);
            break;
          case 95:
            a = 2;
            break;
          default:
            throw Error(u(326));
        }
      null !== T && a === U && --a;
      return a;
    }
    function Ig(a, b) {
      if (50 < uj)
        throw uj = 0, vj = null, Error(u(185));
      a = xj(a, b);
      if (null !== a) {
        var c = ag();
        1073741823 === b ? (W & ej) !== V && (W & (fj | gj)) === V ? yj(a) : (Z(a), W === V && gg()) : Z(a);
        (W & 4) === V || 98 !== c && 99 !== c || (null === tj ? tj = /* @__PURE__ */ new Map([[a, b]]) : (c = tj.get(a), (void 0 === c || c > b) && tj.set(a, b)));
      }
    }
    function xj(a, b) {
      a.expirationTime < b && (a.expirationTime = b);
      var c = a.alternate;
      null !== c && c.expirationTime < b && (c.expirationTime = b);
      var d = a.return, e = null;
      if (null === d && 3 === a.tag)
        e = a.stateNode;
      else
        for (; null !== d; ) {
          c = d.alternate;
          d.childExpirationTime < b && (d.childExpirationTime = b);
          null !== c && c.childExpirationTime < b && (c.childExpirationTime = b);
          if (null === d.return && 3 === d.tag) {
            e = d.stateNode;
            break;
          }
          d = d.return;
        }
      null !== e && (T === e && (Bg(b), S === vi && xi(e, U)), yi(e, b));
      return e;
    }
    function zj(a) {
      var b = a.lastExpiredTime;
      if (0 !== b)
        return b;
      b = a.firstPendingTime;
      if (!Aj(a, b))
        return b;
      var c = a.lastPingedTime;
      a = a.nextKnownPendingLevel;
      a = c > a ? c : a;
      return 2 >= a && b !== a ? 0 : a;
    }
    function Z(a) {
      if (0 !== a.lastExpiredTime)
        a.callbackExpirationTime = 1073741823, a.callbackPriority = 99, a.callbackNode = eg(yj.bind(null, a));
      else {
        var b = zj(a), c = a.callbackNode;
        if (0 === b)
          null !== c && (a.callbackNode = null, a.callbackExpirationTime = 0, a.callbackPriority = 90);
        else {
          var d = Gg();
          1073741823 === b ? d = 99 : 1 === b || 2 === b ? d = 95 : (d = 10 * (1073741821 - b) - 10 * (1073741821 - d), d = 0 >= d ? 99 : 250 >= d ? 98 : 5250 >= d ? 97 : 95);
          if (null !== c) {
            var e = a.callbackPriority;
            if (a.callbackExpirationTime === b && e >= d)
              return;
            c !== Tf && Kf(c);
          }
          a.callbackExpirationTime = b;
          a.callbackPriority = d;
          b = 1073741823 === b ? eg(yj.bind(null, a)) : dg(d, Bj.bind(null, a), { timeout: 10 * (1073741821 - b) - $f() });
          a.callbackNode = b;
        }
      }
    }
    function Bj(a, b) {
      wj = 0;
      if (b)
        return b = Gg(), Cj(a, b), Z(a), null;
      var c = zj(a);
      if (0 !== c) {
        b = a.callbackNode;
        if ((W & (fj | gj)) !== V)
          throw Error(u(327));
        Dj();
        a === T && c === U || Ej(a, c);
        if (null !== X) {
          var d = W;
          W |= fj;
          var e = Fj();
          do
            try {
              Gj();
              break;
            } catch (h2) {
              Hj(a, h2);
            }
          while (1);
          ng();
          W = d;
          cj.current = e;
          if (S === hj)
            throw b = kj, Ej(a, c), xi(a, c), Z(a), b;
          if (null === X)
            switch (e = a.finishedWork = a.current.alternate, a.finishedExpirationTime = c, d = S, T = null, d) {
              case ti:
              case hj:
                throw Error(u(345));
              case ij:
                Cj(a, 2 < c ? 2 : c);
                break;
              case ui:
                xi(a, c);
                d = a.lastSuspendedTime;
                c === d && (a.nextKnownPendingLevel = Ij(e));
                if (1073741823 === lj && (e = Ti + pj - $f(), 10 < e)) {
                  if (oj) {
                    var f2 = a.lastPingedTime;
                    if (0 === f2 || f2 >= c) {
                      a.lastPingedTime = c;
                      Ej(a, c);
                      break;
                    }
                  }
                  f2 = zj(a);
                  if (0 !== f2 && f2 !== c)
                    break;
                  if (0 !== d && d !== c) {
                    a.lastPingedTime = d;
                    break;
                  }
                  a.timeoutHandle = Hd(Jj.bind(null, a), e);
                  break;
                }
                Jj(a);
                break;
              case vi:
                xi(a, c);
                d = a.lastSuspendedTime;
                c === d && (a.nextKnownPendingLevel = Ij(e));
                if (oj && (e = a.lastPingedTime, 0 === e || e >= c)) {
                  a.lastPingedTime = c;
                  Ej(a, c);
                  break;
                }
                e = zj(a);
                if (0 !== e && e !== c)
                  break;
                if (0 !== d && d !== c) {
                  a.lastPingedTime = d;
                  break;
                }
                1073741823 !== mj ? d = 10 * (1073741821 - mj) - $f() : 1073741823 === lj ? d = 0 : (d = 10 * (1073741821 - lj) - 5e3, e = $f(), c = 10 * (1073741821 - c) - e, d = e - d, 0 > d && (d = 0), d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * bj(d / 1960)) - d, c < d && (d = c));
                if (10 < d) {
                  a.timeoutHandle = Hd(Jj.bind(null, a), d);
                  break;
                }
                Jj(a);
                break;
              case jj:
                if (1073741823 !== lj && null !== nj) {
                  f2 = lj;
                  var g2 = nj;
                  d = g2.busyMinDurationMs | 0;
                  0 >= d ? d = 0 : (e = g2.busyDelayMs | 0, f2 = $f() - (10 * (1073741821 - f2) - (g2.timeoutMs | 0 || 5e3)), d = f2 <= e ? 0 : e + d - f2);
                  if (10 < d) {
                    xi(a, c);
                    a.timeoutHandle = Hd(Jj.bind(null, a), d);
                    break;
                  }
                }
                Jj(a);
                break;
              default:
                throw Error(u(329));
            }
          Z(a);
          if (a.callbackNode === b)
            return Bj.bind(null, a);
        }
      }
      return null;
    }
    function yj(a) {
      var b = a.lastExpiredTime;
      b = 0 !== b ? b : 1073741823;
      if ((W & (fj | gj)) !== V)
        throw Error(u(327));
      Dj();
      a === T && b === U || Ej(a, b);
      if (null !== X) {
        var c = W;
        W |= fj;
        var d = Fj();
        do
          try {
            Kj();
            break;
          } catch (e) {
            Hj(a, e);
          }
        while (1);
        ng();
        W = c;
        cj.current = d;
        if (S === hj)
          throw c = kj, Ej(a, b), xi(a, b), Z(a), c;
        if (null !== X)
          throw Error(u(261));
        a.finishedWork = a.current.alternate;
        a.finishedExpirationTime = b;
        T = null;
        Jj(a);
        Z(a);
      }
      return null;
    }
    function Lj() {
      if (null !== tj) {
        var a = tj;
        tj = null;
        a.forEach(function(a2, c) {
          Cj(c, a2);
          Z(c);
        });
        gg();
      }
    }
    function Mj(a, b) {
      var c = W;
      W |= 1;
      try {
        return a(b);
      } finally {
        W = c, W === V && gg();
      }
    }
    function Nj(a, b) {
      var c = W;
      W &= -2;
      W |= ej;
      try {
        return a(b);
      } finally {
        W = c, W === V && gg();
      }
    }
    function Ej(a, b) {
      a.finishedWork = null;
      a.finishedExpirationTime = 0;
      var c = a.timeoutHandle;
      -1 !== c && (a.timeoutHandle = -1, Id(c));
      if (null !== X)
        for (c = X.return; null !== c; ) {
          var d = c;
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && Df();
              break;
            case 3:
              eh();
              H(K);
              H(J);
              break;
            case 5:
              gh(d);
              break;
            case 4:
              eh();
              break;
            case 13:
              H(M);
              break;
            case 19:
              H(M);
              break;
            case 10:
              og(d);
          }
          c = c.return;
        }
      T = a;
      X = Sg(a.current, null);
      U = b;
      S = ti;
      kj = null;
      mj = lj = 1073741823;
      nj = null;
      wi = 0;
      oj = false;
    }
    function Hj(a, b) {
      do {
        try {
          ng();
          jh.current = sh;
          if (mh)
            for (var c = N.memoizedState; null !== c; ) {
              var d = c.queue;
              null !== d && (d.pending = null);
              c = c.next;
            }
          lh = 0;
          P = O = N = null;
          mh = false;
          if (null === X || null === X.return)
            return S = hj, kj = b, X = null;
          a: {
            var e = a, f2 = X.return, g2 = X, h2 = b;
            b = U;
            g2.effectTag |= 2048;
            g2.firstEffect = g2.lastEffect = null;
            if (null !== h2 && "object" === typeof h2 && "function" === typeof h2.then) {
              var k = h2;
              if (0 === (g2.mode & 2)) {
                var l2 = g2.alternate;
                l2 ? (g2.updateQueue = l2.updateQueue, g2.memoizedState = l2.memoizedState, g2.expirationTime = l2.expirationTime) : (g2.updateQueue = null, g2.memoizedState = null);
              }
              var m2 = 0 !== (M.current & 1), p2 = f2;
              do {
                var x2;
                if (x2 = 13 === p2.tag) {
                  var z2 = p2.memoizedState;
                  if (null !== z2)
                    x2 = null !== z2.dehydrated ? true : false;
                  else {
                    var ca = p2.memoizedProps;
                    x2 = void 0 === ca.fallback ? false : true !== ca.unstable_avoidThisFallback ? true : m2 ? false : true;
                  }
                }
                if (x2) {
                  var D2 = p2.updateQueue;
                  if (null === D2) {
                    var t2 = /* @__PURE__ */ new Set();
                    t2.add(k);
                    p2.updateQueue = t2;
                  } else
                    D2.add(k);
                  if (0 === (p2.mode & 2)) {
                    p2.effectTag |= 64;
                    g2.effectTag &= -2981;
                    if (1 === g2.tag)
                      if (null === g2.alternate)
                        g2.tag = 17;
                      else {
                        var y2 = wg(1073741823, null);
                        y2.tag = 2;
                        xg(g2, y2);
                      }
                    g2.expirationTime = 1073741823;
                    break a;
                  }
                  h2 = void 0;
                  g2 = b;
                  var A2 = e.pingCache;
                  null === A2 ? (A2 = e.pingCache = new Wi(), h2 = /* @__PURE__ */ new Set(), A2.set(k, h2)) : (h2 = A2.get(k), void 0 === h2 && (h2 = /* @__PURE__ */ new Set(), A2.set(k, h2)));
                  if (!h2.has(g2)) {
                    h2.add(g2);
                    var q2 = Oj.bind(null, e, k, g2);
                    k.then(q2, q2);
                  }
                  p2.effectTag |= 4096;
                  p2.expirationTime = b;
                  break a;
                }
                p2 = p2.return;
              } while (null !== p2);
              h2 = Error((pb(g2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + qb(g2));
            }
            S !== jj && (S = ij);
            h2 = Ai(h2, g2);
            p2 = f2;
            do {
              switch (p2.tag) {
                case 3:
                  k = h2;
                  p2.effectTag |= 4096;
                  p2.expirationTime = b;
                  var B2 = Xi(p2, k, b);
                  yg(p2, B2);
                  break a;
                case 1:
                  k = h2;
                  var w2 = p2.type, ub = p2.stateNode;
                  if (0 === (p2.effectTag & 64) && ("function" === typeof w2.getDerivedStateFromError || null !== ub && "function" === typeof ub.componentDidCatch && (null === aj || !aj.has(ub)))) {
                    p2.effectTag |= 4096;
                    p2.expirationTime = b;
                    var vb = $i(p2, k, b);
                    yg(p2, vb);
                    break a;
                  }
              }
              p2 = p2.return;
            } while (null !== p2);
          }
          X = Pj(X);
        } catch (Xc) {
          b = Xc;
          continue;
        }
        break;
      } while (1);
    }
    function Fj() {
      var a = cj.current;
      cj.current = sh;
      return null === a ? sh : a;
    }
    function Ag(a, b) {
      a < lj && 2 < a && (lj = a);
      null !== b && a < mj && 2 < a && (mj = a, nj = b);
    }
    function Bg(a) {
      a > wi && (wi = a);
    }
    function Kj() {
      for (; null !== X; )
        X = Qj(X);
    }
    function Gj() {
      for (; null !== X && !Uf(); )
        X = Qj(X);
    }
    function Qj(a) {
      var b = Rj(a.alternate, a, U);
      a.memoizedProps = a.pendingProps;
      null === b && (b = Pj(a));
      dj.current = null;
      return b;
    }
    function Pj(a) {
      X = a;
      do {
        var b = X.alternate;
        a = X.return;
        if (0 === (X.effectTag & 2048)) {
          b = si(b, X, U);
          if (1 === U || 1 !== X.childExpirationTime) {
            for (var c = 0, d = X.child; null !== d; ) {
              var e = d.expirationTime, f2 = d.childExpirationTime;
              e > c && (c = e);
              f2 > c && (c = f2);
              d = d.sibling;
            }
            X.childExpirationTime = c;
          }
          if (null !== b)
            return b;
          null !== a && 0 === (a.effectTag & 2048) && (null === a.firstEffect && (a.firstEffect = X.firstEffect), null !== X.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = X.firstEffect), a.lastEffect = X.lastEffect), 1 < X.effectTag && (null !== a.lastEffect ? a.lastEffect.nextEffect = X : a.firstEffect = X, a.lastEffect = X));
        } else {
          b = zi(X);
          if (null !== b)
            return b.effectTag &= 2047, b;
          null !== a && (a.firstEffect = a.lastEffect = null, a.effectTag |= 2048);
        }
        b = X.sibling;
        if (null !== b)
          return b;
        X = a;
      } while (null !== X);
      S === ti && (S = jj);
      return null;
    }
    function Ij(a) {
      var b = a.expirationTime;
      a = a.childExpirationTime;
      return b > a ? b : a;
    }
    function Jj(a) {
      var b = ag();
      cg(99, Sj.bind(null, a, b));
      return null;
    }
    function Sj(a, b) {
      do
        Dj();
      while (null !== rj);
      if ((W & (fj | gj)) !== V)
        throw Error(u(327));
      var c = a.finishedWork, d = a.finishedExpirationTime;
      if (null === c)
        return null;
      a.finishedWork = null;
      a.finishedExpirationTime = 0;
      if (c === a.current)
        throw Error(u(177));
      a.callbackNode = null;
      a.callbackExpirationTime = 0;
      a.callbackPriority = 90;
      a.nextKnownPendingLevel = 0;
      var e = Ij(c);
      a.firstPendingTime = e;
      d <= a.lastSuspendedTime ? a.firstSuspendedTime = a.lastSuspendedTime = a.nextKnownPendingLevel = 0 : d <= a.firstSuspendedTime && (a.firstSuspendedTime = d - 1);
      d <= a.lastPingedTime && (a.lastPingedTime = 0);
      d <= a.lastExpiredTime && (a.lastExpiredTime = 0);
      a === T && (X = T = null, U = 0);
      1 < c.effectTag ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, e = c.firstEffect) : e = c : e = c.firstEffect;
      if (null !== e) {
        var f2 = W;
        W |= gj;
        dj.current = null;
        Dd = fd;
        var g2 = xd();
        if (yd(g2)) {
          if ("selectionStart" in g2)
            var h2 = { start: g2.selectionStart, end: g2.selectionEnd };
          else
            a: {
              h2 = (h2 = g2.ownerDocument) && h2.defaultView || window;
              var k = h2.getSelection && h2.getSelection();
              if (k && 0 !== k.rangeCount) {
                h2 = k.anchorNode;
                var l2 = k.anchorOffset, m2 = k.focusNode;
                k = k.focusOffset;
                try {
                  h2.nodeType, m2.nodeType;
                } catch (wb) {
                  h2 = null;
                  break a;
                }
                var p2 = 0, x2 = -1, z2 = -1, ca = 0, D2 = 0, t2 = g2, y2 = null;
                b:
                  for (; ; ) {
                    for (var A2; ; ) {
                      t2 !== h2 || 0 !== l2 && 3 !== t2.nodeType || (x2 = p2 + l2);
                      t2 !== m2 || 0 !== k && 3 !== t2.nodeType || (z2 = p2 + k);
                      3 === t2.nodeType && (p2 += t2.nodeValue.length);
                      if (null === (A2 = t2.firstChild))
                        break;
                      y2 = t2;
                      t2 = A2;
                    }
                    for (; ; ) {
                      if (t2 === g2)
                        break b;
                      y2 === h2 && ++ca === l2 && (x2 = p2);
                      y2 === m2 && ++D2 === k && (z2 = p2);
                      if (null !== (A2 = t2.nextSibling))
                        break;
                      t2 = y2;
                      y2 = t2.parentNode;
                    }
                    t2 = A2;
                  }
                h2 = -1 === x2 || -1 === z2 ? null : { start: x2, end: z2 };
              } else
                h2 = null;
            }
          h2 = h2 || { start: 0, end: 0 };
        } else
          h2 = null;
        Ed = { activeElementDetached: null, focusedElem: g2, selectionRange: h2 };
        fd = false;
        Y = e;
        do
          try {
            Tj();
          } catch (wb) {
            if (null === Y)
              throw Error(u(330));
            Ei(Y, wb);
            Y = Y.nextEffect;
          }
        while (null !== Y);
        Y = e;
        do
          try {
            for (g2 = a, h2 = b; null !== Y; ) {
              var q2 = Y.effectTag;
              q2 & 16 && Rb(Y.stateNode, "");
              if (q2 & 128) {
                var B2 = Y.alternate;
                if (null !== B2) {
                  var w2 = B2.ref;
                  null !== w2 && ("function" === typeof w2 ? w2(null) : w2.current = null);
                }
              }
              switch (q2 & 1038) {
                case 2:
                  Pi(Y);
                  Y.effectTag &= -3;
                  break;
                case 6:
                  Pi(Y);
                  Y.effectTag &= -3;
                  Si(Y.alternate, Y);
                  break;
                case 1024:
                  Y.effectTag &= -1025;
                  break;
                case 1028:
                  Y.effectTag &= -1025;
                  Si(Y.alternate, Y);
                  break;
                case 4:
                  Si(Y.alternate, Y);
                  break;
                case 8:
                  l2 = Y, Mi(g2, l2, h2), Ni(l2);
              }
              Y = Y.nextEffect;
            }
          } catch (wb) {
            if (null === Y)
              throw Error(u(330));
            Ei(Y, wb);
            Y = Y.nextEffect;
          }
        while (null !== Y);
        w2 = Ed;
        B2 = xd();
        q2 = w2.focusedElem;
        h2 = w2.selectionRange;
        if (B2 !== q2 && q2 && q2.ownerDocument && wd(q2.ownerDocument.documentElement, q2)) {
          null !== h2 && yd(q2) && (B2 = h2.start, w2 = h2.end, void 0 === w2 && (w2 = B2), "selectionStart" in q2 ? (q2.selectionStart = B2, q2.selectionEnd = Math.min(w2, q2.value.length)) : (w2 = (B2 = q2.ownerDocument || document) && B2.defaultView || window, w2.getSelection && (w2 = w2.getSelection(), l2 = q2.textContent.length, g2 = Math.min(h2.start, l2), h2 = void 0 === h2.end ? g2 : Math.min(h2.end, l2), !w2.extend && g2 > h2 && (l2 = h2, h2 = g2, g2 = l2), l2 = vd(q2, g2), m2 = vd(q2, h2), l2 && m2 && (1 !== w2.rangeCount || w2.anchorNode !== l2.node || w2.anchorOffset !== l2.offset || w2.focusNode !== m2.node || w2.focusOffset !== m2.offset) && (B2 = B2.createRange(), B2.setStart(l2.node, l2.offset), w2.removeAllRanges(), g2 > h2 ? (w2.addRange(B2), w2.extend(m2.node, m2.offset)) : (B2.setEnd(m2.node, m2.offset), w2.addRange(B2))))));
          B2 = [];
          for (w2 = q2; w2 = w2.parentNode; )
            1 === w2.nodeType && B2.push({
              element: w2,
              left: w2.scrollLeft,
              top: w2.scrollTop
            });
          "function" === typeof q2.focus && q2.focus();
          for (q2 = 0; q2 < B2.length; q2++)
            w2 = B2[q2], w2.element.scrollLeft = w2.left, w2.element.scrollTop = w2.top;
        }
        fd = !!Dd;
        Ed = Dd = null;
        a.current = c;
        Y = e;
        do
          try {
            for (q2 = a; null !== Y; ) {
              var ub = Y.effectTag;
              ub & 36 && Ji(q2, Y.alternate, Y);
              if (ub & 128) {
                B2 = void 0;
                var vb = Y.ref;
                if (null !== vb) {
                  var Xc = Y.stateNode;
                  switch (Y.tag) {
                    case 5:
                      B2 = Xc;
                      break;
                    default:
                      B2 = Xc;
                  }
                  "function" === typeof vb ? vb(B2) : vb.current = B2;
                }
              }
              Y = Y.nextEffect;
            }
          } catch (wb) {
            if (null === Y)
              throw Error(u(330));
            Ei(Y, wb);
            Y = Y.nextEffect;
          }
        while (null !== Y);
        Y = null;
        Vf();
        W = f2;
      } else
        a.current = c;
      if (qj)
        qj = false, rj = a, sj = b;
      else
        for (Y = e; null !== Y; )
          b = Y.nextEffect, Y.nextEffect = null, Y = b;
      b = a.firstPendingTime;
      0 === b && (aj = null);
      1073741823 === b ? a === vj ? uj++ : (uj = 0, vj = a) : uj = 0;
      "function" === typeof Uj && Uj(c.stateNode, d);
      Z(a);
      if (Yi)
        throw Yi = false, a = Zi, Zi = null, a;
      if ((W & ej) !== V)
        return null;
      gg();
      return null;
    }
    function Tj() {
      for (; null !== Y; ) {
        var a = Y.effectTag;
        0 !== (a & 256) && Gi(Y.alternate, Y);
        0 === (a & 512) || qj || (qj = true, dg(97, function() {
          Dj();
          return null;
        }));
        Y = Y.nextEffect;
      }
    }
    function Dj() {
      if (90 !== sj) {
        var a = 97 < sj ? 97 : sj;
        sj = 90;
        return cg(a, Vj);
      }
    }
    function Vj() {
      if (null === rj)
        return false;
      var a = rj;
      rj = null;
      if ((W & (fj | gj)) !== V)
        throw Error(u(331));
      var b = W;
      W |= gj;
      for (a = a.current.firstEffect; null !== a; ) {
        try {
          var c = a;
          if (0 !== (c.effectTag & 512))
            switch (c.tag) {
              case 0:
              case 11:
              case 15:
              case 22:
                Hi(5, c), Ii(5, c);
            }
        } catch (d) {
          if (null === a)
            throw Error(u(330));
          Ei(a, d);
        }
        c = a.nextEffect;
        a.nextEffect = null;
        a = c;
      }
      W = b;
      gg();
      return true;
    }
    function Wj(a, b, c) {
      b = Ai(c, b);
      b = Xi(a, b, 1073741823);
      xg(a, b);
      a = xj(a, 1073741823);
      null !== a && Z(a);
    }
    function Ei(a, b) {
      if (3 === a.tag)
        Wj(a, a, b);
      else
        for (var c = a.return; null !== c; ) {
          if (3 === c.tag) {
            Wj(c, a, b);
            break;
          } else if (1 === c.tag) {
            var d = c.stateNode;
            if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === aj || !aj.has(d))) {
              a = Ai(b, a);
              a = $i(c, a, 1073741823);
              xg(c, a);
              c = xj(c, 1073741823);
              null !== c && Z(c);
              break;
            }
          }
          c = c.return;
        }
    }
    function Oj(a, b, c) {
      var d = a.pingCache;
      null !== d && d.delete(b);
      T === a && U === c ? S === vi || S === ui && 1073741823 === lj && $f() - Ti < pj ? Ej(a, U) : oj = true : Aj(a, c) && (b = a.lastPingedTime, 0 !== b && b < c || (a.lastPingedTime = c, Z(a)));
    }
    function Vi(a, b) {
      var c = a.stateNode;
      null !== c && c.delete(b);
      b = 0;
      0 === b && (b = Gg(), b = Hg(b, a, null));
      a = xj(a, b);
      null !== a && Z(a);
    }
    var Rj;
    Rj = function(a, b, c) {
      var d = b.expirationTime;
      if (null !== a) {
        var e = b.pendingProps;
        if (a.memoizedProps !== e || K.current)
          rg = true;
        else {
          if (d < c) {
            rg = false;
            switch (b.tag) {
              case 3:
                hi(b);
                Xh();
                break;
              case 5:
                fh(b);
                if (b.mode & 4 && 1 !== c && e.hidden)
                  return b.expirationTime = b.childExpirationTime = 1, null;
                break;
              case 1:
                L(b.type) && Gf(b);
                break;
              case 4:
                dh(b, b.stateNode.containerInfo);
                break;
              case 10:
                d = b.memoizedProps.value;
                e = b.type._context;
                I(jg, e._currentValue);
                e._currentValue = d;
                break;
              case 13:
                if (null !== b.memoizedState) {
                  d = b.child.childExpirationTime;
                  if (0 !== d && d >= c)
                    return ji(a, b, c);
                  I(M, M.current & 1);
                  b = $h(a, b, c);
                  return null !== b ? b.sibling : null;
                }
                I(M, M.current & 1);
                break;
              case 19:
                d = b.childExpirationTime >= c;
                if (0 !== (a.effectTag & 64)) {
                  if (d)
                    return mi(a, b, c);
                  b.effectTag |= 64;
                }
                e = b.memoizedState;
                null !== e && (e.rendering = null, e.tail = null);
                I(M, M.current);
                if (!d)
                  return null;
            }
            return $h(a, b, c);
          }
          rg = false;
        }
      } else
        rg = false;
      b.expirationTime = 0;
      switch (b.tag) {
        case 2:
          d = b.type;
          null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2);
          a = b.pendingProps;
          e = Cf(b, J.current);
          qg(b, c);
          e = oh(
            null,
            b,
            d,
            a,
            e,
            c
          );
          b.effectTag |= 1;
          if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
            b.tag = 1;
            b.memoizedState = null;
            b.updateQueue = null;
            if (L(d)) {
              var f2 = true;
              Gf(b);
            } else
              f2 = false;
            b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
            ug(b);
            var g2 = d.getDerivedStateFromProps;
            "function" === typeof g2 && Fg(b, d, g2, a);
            e.updater = Jg;
            b.stateNode = e;
            e._reactInternalFiber = b;
            Ng(b, d, a, c);
            b = gi(null, b, d, true, f2, c);
          } else
            b.tag = 0, R(null, b, e, c), b = b.child;
          return b;
        case 16:
          a: {
            e = b.elementType;
            null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2);
            a = b.pendingProps;
            ob(e);
            if (1 !== e._status)
              throw e._result;
            e = e._result;
            b.type = e;
            f2 = b.tag = Xj(e);
            a = ig(e, a);
            switch (f2) {
              case 0:
                b = di(null, b, e, a, c);
                break a;
              case 1:
                b = fi(null, b, e, a, c);
                break a;
              case 11:
                b = Zh(null, b, e, a, c);
                break a;
              case 14:
                b = ai(null, b, e, ig(e.type, a), d, c);
                break a;
            }
            throw Error(u(306, e, ""));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : ig(d, e), di(a, b, d, e, c);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : ig(d, e), fi(a, b, d, e, c);
        case 3:
          hi(b);
          d = b.updateQueue;
          if (null === a || null === d)
            throw Error(u(282));
          d = b.pendingProps;
          e = b.memoizedState;
          e = null !== e ? e.element : null;
          vg(a, b);
          zg(b, d, null, c);
          d = b.memoizedState.element;
          if (d === e)
            Xh(), b = $h(a, b, c);
          else {
            if (e = b.stateNode.hydrate)
              Ph = Jd(b.stateNode.containerInfo.firstChild), Oh = b, e = Qh = true;
            if (e)
              for (c = Yg(b, null, d, c), b.child = c; c; )
                c.effectTag = c.effectTag & -3 | 1024, c = c.sibling;
            else
              R(a, b, d, c), Xh();
            b = b.child;
          }
          return b;
        case 5:
          return fh(b), null === a && Uh(b), d = b.type, e = b.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e.children, Gd(d, e) ? g2 = null : null !== f2 && Gd(d, f2) && (b.effectTag |= 16), ei(a, b), b.mode & 4 && 1 !== c && e.hidden ? (b.expirationTime = b.childExpirationTime = 1, b = null) : (R(a, b, g2, c), b = b.child), b;
        case 6:
          return null === a && Uh(b), null;
        case 13:
          return ji(a, b, c);
        case 4:
          return dh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Xg(b, null, d, c) : R(a, b, d, c), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : ig(d, e), Zh(a, b, d, e, c);
        case 7:
          return R(a, b, b.pendingProps, c), b.child;
        case 8:
          return R(
            a,
            b,
            b.pendingProps.children,
            c
          ), b.child;
        case 12:
          return R(a, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            d = b.type._context;
            e = b.pendingProps;
            g2 = b.memoizedProps;
            f2 = e.value;
            var h2 = b.type._context;
            I(jg, h2._currentValue);
            h2._currentValue = f2;
            if (null !== g2)
              if (h2 = g2.value, f2 = $e(h2, f2) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h2, f2) : 1073741823) | 0, 0 === f2) {
                if (g2.children === e.children && !K.current) {
                  b = $h(a, b, c);
                  break a;
                }
              } else
                for (h2 = b.child, null !== h2 && (h2.return = b); null !== h2; ) {
                  var k = h2.dependencies;
                  if (null !== k) {
                    g2 = h2.child;
                    for (var l2 = k.firstContext; null !== l2; ) {
                      if (l2.context === d && 0 !== (l2.observedBits & f2)) {
                        1 === h2.tag && (l2 = wg(c, null), l2.tag = 2, xg(h2, l2));
                        h2.expirationTime < c && (h2.expirationTime = c);
                        l2 = h2.alternate;
                        null !== l2 && l2.expirationTime < c && (l2.expirationTime = c);
                        pg(h2.return, c);
                        k.expirationTime < c && (k.expirationTime = c);
                        break;
                      }
                      l2 = l2.next;
                    }
                  } else
                    g2 = 10 === h2.tag ? h2.type === b.type ? null : h2.child : h2.child;
                  if (null !== g2)
                    g2.return = h2;
                  else
                    for (g2 = h2; null !== g2; ) {
                      if (g2 === b) {
                        g2 = null;
                        break;
                      }
                      h2 = g2.sibling;
                      if (null !== h2) {
                        h2.return = g2.return;
                        g2 = h2;
                        break;
                      }
                      g2 = g2.return;
                    }
                  h2 = g2;
                }
            R(a, b, e.children, c);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, f2 = b.pendingProps, d = f2.children, qg(b, c), e = sg(e, f2.unstable_observedBits), d = d(e), b.effectTag |= 1, R(a, b, d, c), b.child;
        case 14:
          return e = b.type, f2 = ig(e, b.pendingProps), f2 = ig(e.type, f2), ai(a, b, e, f2, d, c);
        case 15:
          return ci(a, b, b.type, b.pendingProps, d, c);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : ig(d, e), null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2), b.tag = 1, L(d) ? (a = true, Gf(b)) : a = false, qg(b, c), Lg(b, d, e), Ng(b, d, e, c), gi(
            null,
            b,
            d,
            true,
            a,
            c
          );
        case 19:
          return mi(a, b, c);
      }
      throw Error(u(156, b.tag));
    };
    var Uj = null, Li = null;
    function Yj(a) {
      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)
        return false;
      var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (b.isDisabled || !b.supportsFiber)
        return true;
      try {
        var c = b.inject(a);
        Uj = function(a2) {
          try {
            b.onCommitFiberRoot(c, a2, void 0, 64 === (a2.current.effectTag & 64));
          } catch (e) {
          }
        };
        Li = function(a2) {
          try {
            b.onCommitFiberUnmount(c, a2);
          } catch (e) {
          }
        };
      } catch (d) {
      }
      return true;
    }
    function Zj(a, b, c, d) {
      this.tag = a;
      this.key = c;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d;
      this.effectTag = 0;
      this.lastEffect = this.firstEffect = this.nextEffect = null;
      this.childExpirationTime = this.expirationTime = 0;
      this.alternate = null;
    }
    function Sh(a, b, c, d) {
      return new Zj(a, b, c, d);
    }
    function bi(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function Xj(a) {
      if ("function" === typeof a)
        return bi(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === gb)
          return 11;
        if (a === jb)
          return 14;
      }
      return 2;
    }
    function Sg(a, b) {
      var c = a.alternate;
      null === c ? (c = Sh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.effectTag = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
      c.childExpirationTime = a.childExpirationTime;
      c.expirationTime = a.expirationTime;
      c.child = a.child;
      c.memoizedProps = a.memoizedProps;
      c.memoizedState = a.memoizedState;
      c.updateQueue = a.updateQueue;
      b = a.dependencies;
      c.dependencies = null === b ? null : {
        expirationTime: b.expirationTime,
        firstContext: b.firstContext,
        responders: b.responders
      };
      c.sibling = a.sibling;
      c.index = a.index;
      c.ref = a.ref;
      return c;
    }
    function Ug(a, b, c, d, e, f2) {
      var g2 = 2;
      d = a;
      if ("function" === typeof a)
        bi(a) && (g2 = 1);
      else if ("string" === typeof a)
        g2 = 5;
      else
        a:
          switch (a) {
            case ab:
              return Wg(c.children, e, f2, b);
            case fb:
              g2 = 8;
              e |= 7;
              break;
            case bb:
              g2 = 8;
              e |= 1;
              break;
            case cb$1:
              return a = Sh(12, c, b, e | 8), a.elementType = cb$1, a.type = cb$1, a.expirationTime = f2, a;
            case hb:
              return a = Sh(13, c, b, e), a.type = hb, a.elementType = hb, a.expirationTime = f2, a;
            case ib:
              return a = Sh(19, c, b, e), a.elementType = ib, a.expirationTime = f2, a;
            default:
              if ("object" === typeof a && null !== a)
                switch (a.$$typeof) {
                  case db:
                    g2 = 10;
                    break a;
                  case eb:
                    g2 = 9;
                    break a;
                  case gb:
                    g2 = 11;
                    break a;
                  case jb:
                    g2 = 14;
                    break a;
                  case kb:
                    g2 = 16;
                    d = null;
                    break a;
                  case lb:
                    g2 = 22;
                    break a;
                }
              throw Error(u(130, null == a ? a : typeof a, ""));
          }
      b = Sh(g2, c, b, e);
      b.elementType = a;
      b.type = d;
      b.expirationTime = f2;
      return b;
    }
    function Wg(a, b, c, d) {
      a = Sh(7, a, d, b);
      a.expirationTime = c;
      return a;
    }
    function Tg(a, b, c) {
      a = Sh(6, a, null, b);
      a.expirationTime = c;
      return a;
    }
    function Vg(a, b, c) {
      b = Sh(4, null !== a.children ? a.children : [], a.key, b);
      b.expirationTime = c;
      b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b;
    }
    function ak(a, b, c) {
      this.tag = b;
      this.current = null;
      this.containerInfo = a;
      this.pingCache = this.pendingChildren = null;
      this.finishedExpirationTime = 0;
      this.finishedWork = null;
      this.timeoutHandle = -1;
      this.pendingContext = this.context = null;
      this.hydrate = c;
      this.callbackNode = null;
      this.callbackPriority = 90;
      this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
    }
    function Aj(a, b) {
      var c = a.firstSuspendedTime;
      a = a.lastSuspendedTime;
      return 0 !== c && c >= b && a <= b;
    }
    function xi(a, b) {
      var c = a.firstSuspendedTime, d = a.lastSuspendedTime;
      c < b && (a.firstSuspendedTime = b);
      if (d > b || 0 === c)
        a.lastSuspendedTime = b;
      b <= a.lastPingedTime && (a.lastPingedTime = 0);
      b <= a.lastExpiredTime && (a.lastExpiredTime = 0);
    }
    function yi(a, b) {
      b > a.firstPendingTime && (a.firstPendingTime = b);
      var c = a.firstSuspendedTime;
      0 !== c && (b >= c ? a.firstSuspendedTime = a.lastSuspendedTime = a.nextKnownPendingLevel = 0 : b >= a.lastSuspendedTime && (a.lastSuspendedTime = b + 1), b > a.nextKnownPendingLevel && (a.nextKnownPendingLevel = b));
    }
    function Cj(a, b) {
      var c = a.lastExpiredTime;
      if (0 === c || c > b)
        a.lastExpiredTime = b;
    }
    function bk(a, b, c, d) {
      var e = b.current, f2 = Gg(), g2 = Dg.suspense;
      f2 = Hg(f2, e, g2);
      a:
        if (c) {
          c = c._reactInternalFiber;
          b: {
            if (dc(c) !== c || 1 !== c.tag)
              throw Error(u(170));
            var h2 = c;
            do {
              switch (h2.tag) {
                case 3:
                  h2 = h2.stateNode.context;
                  break b;
                case 1:
                  if (L(h2.type)) {
                    h2 = h2.stateNode.__reactInternalMemoizedMergedChildContext;
                    break b;
                  }
              }
              h2 = h2.return;
            } while (null !== h2);
            throw Error(u(171));
          }
          if (1 === c.tag) {
            var k = c.type;
            if (L(k)) {
              c = Ff(c, k, h2);
              break a;
            }
          }
          c = h2;
        } else
          c = Af;
      null === b.context ? b.context = c : b.pendingContext = c;
      b = wg(f2, g2);
      b.payload = { element: a };
      d = void 0 === d ? null : d;
      null !== d && (b.callback = d);
      xg(e, b);
      Ig(e, f2);
      return f2;
    }
    function ck(a) {
      a = a.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function dk(a, b) {
      a = a.memoizedState;
      null !== a && null !== a.dehydrated && a.retryTime < b && (a.retryTime = b);
    }
    function ek(a, b) {
      dk(a, b);
      (a = a.alternate) && dk(a, b);
    }
    function fk(a, b, c) {
      c = null != c && true === c.hydrate;
      var d = new ak(a, b, c), e = Sh(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
      d.current = e;
      e.stateNode = d;
      ug(e);
      a[Od] = d.current;
      c && 0 !== b && Jc(a, 9 === a.nodeType ? a : a.ownerDocument);
      this._internalRoot = d;
    }
    fk.prototype.render = function(a) {
      bk(a, this._internalRoot, null, null);
    };
    fk.prototype.unmount = function() {
      var a = this._internalRoot, b = a.containerInfo;
      bk(null, a, null, function() {
        b[Od] = null;
      });
    };
    function gk(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    function hk(a, b) {
      b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));
      if (!b)
        for (var c; c = a.lastChild; )
          a.removeChild(c);
      return new fk(a, 0, b ? { hydrate: true } : void 0);
    }
    function ik(a, b, c, d, e) {
      var f2 = c._reactRootContainer;
      if (f2) {
        var g2 = f2._internalRoot;
        if ("function" === typeof e) {
          var h2 = e;
          e = function() {
            var a2 = ck(g2);
            h2.call(a2);
          };
        }
        bk(b, g2, a, e);
      } else {
        f2 = c._reactRootContainer = hk(c, d);
        g2 = f2._internalRoot;
        if ("function" === typeof e) {
          var k = e;
          e = function() {
            var a2 = ck(g2);
            k.call(a2);
          };
        }
        Nj(function() {
          bk(b, g2, a, e);
        });
      }
      return ck(g2);
    }
    function jk(a, b, c) {
      var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: $a, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
    }
    wc = function(a) {
      if (13 === a.tag) {
        var b = hg(Gg(), 150, 100);
        Ig(a, b);
        ek(a, b);
      }
    };
    xc = function(a) {
      13 === a.tag && (Ig(a, 3), ek(a, 3));
    };
    yc = function(a) {
      if (13 === a.tag) {
        var b = Gg();
        b = Hg(b, a, null);
        Ig(a, b);
        ek(a, b);
      }
    };
    za = function(a, b, c) {
      switch (b) {
        case "input":
          Cb(a, c);
          b = c.name;
          if ("radio" === c.type && null != b) {
            for (c = a; c.parentNode; )
              c = c.parentNode;
            c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
            for (b = 0; b < c.length; b++) {
              var d = c[b];
              if (d !== a && d.form === a.form) {
                var e = Qd(d);
                if (!e)
                  throw Error(u(90));
                yb(d);
                Cb(d, e);
              }
            }
          }
          break;
        case "textarea":
          Kb(a, c);
          break;
        case "select":
          b = c.value, null != b && Hb(a, !!c.multiple, b, false);
      }
    };
    Fa = Mj;
    Ga = function(a, b, c, d, e) {
      var f2 = W;
      W |= 4;
      try {
        return cg(98, a.bind(null, b, c, d, e));
      } finally {
        W = f2, W === V && gg();
      }
    };
    Ha = function() {
      (W & (1 | fj | gj)) === V && (Lj(), Dj());
    };
    Ia = function(a, b) {
      var c = W;
      W |= 2;
      try {
        return a(b);
      } finally {
        W = c, W === V && gg();
      }
    };
    function kk(a, b) {
      var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!gk(b))
        throw Error(u(200));
      return jk(a, b, null, c);
    }
    var lk = { Events: [Nc, Pd, Qd, xa, ta, Xd, function(a) {
      jc(a, Wd);
    }, Da, Ea, id, mc, Dj, { current: false }] };
    (function(a) {
      var b = a.findFiberByHostInstance;
      return Yj(n({}, a, { overrideHookState: null, overrideProps: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Wa.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
        a2 = hc(a2);
        return null === a2 ? null : a2.stateNode;
      }, findFiberByHostInstance: function(a2) {
        return b ? b(a2) : null;
      }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null }));
    })({
      findFiberByHostInstance: tc,
      bundleType: 0,
      version: "16.14.0",
      rendererPackageName: "react-dom"
    });
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = lk;
    reactDom_production_min.createPortal = kk;
    reactDom_production_min.findDOMNode = function(a) {
      if (null == a)
        return null;
      if (1 === a.nodeType)
        return a;
      var b = a._reactInternalFiber;
      if (void 0 === b) {
        if ("function" === typeof a.render)
          throw Error(u(188));
        throw Error(u(268, Object.keys(a)));
      }
      a = hc(b);
      a = null === a ? null : a.stateNode;
      return a;
    };
    reactDom_production_min.flushSync = function(a, b) {
      if ((W & (fj | gj)) !== V)
        throw Error(u(187));
      var c = W;
      W |= 1;
      try {
        return cg(99, a.bind(null, b));
      } finally {
        W = c, gg();
      }
    };
    reactDom_production_min.hydrate = function(a, b, c) {
      if (!gk(b))
        throw Error(u(200));
      return ik(null, a, b, true, c);
    };
    reactDom_production_min.render = function(a, b, c) {
      if (!gk(b))
        throw Error(u(200));
      return ik(null, a, b, false, c);
    };
    reactDom_production_min.unmountComponentAtNode = function(a) {
      if (!gk(a))
        throw Error(u(40));
      return a._reactRootContainer ? (Nj(function() {
        ik(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[Od] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Mj;
    reactDom_production_min.unstable_createPortal = function(a, b) {
      return kk(a, b, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
    };
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
      if (!gk(c))
        throw Error(u(200));
      if (null == a || void 0 === a._reactInternalFiber)
        throw Error(u(38));
      return ik(a, b, c, false, d);
    };
    reactDom_production_min.version = "16.14.0";
    (function(module2) {
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        module2.exports = reactDom_production_min;
      }
    })(reactDom);
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDom.exports);
    class AngleDelta {
      constructor(x1, y1, x2, y2) {
        __publicField(this, "x");
        __publicField(this, "y");
        __publicField(this, "distance");
        __publicField(this, "angle");
        __publicField(this, "getVector", (magnitude, angle) => {
          let angleRadians = angle * Math.PI / 180;
          this.x = magnitude * Math.cos(angleRadians);
          this.y = magnitude * Math.sin(angleRadians);
          return this;
        });
        let x3 = x2 - x1;
        let y3 = y2 - y1;
        this.distance = Math.sqrt(x3 * x3 + y3 * y3);
        this.angle = Math.atan2(y3, x3) * 180 / Math.PI;
      }
    }
    var identicon = { exports: {} };
    var pnglib = { exports: {} };
    /**
    * A handy class to calculate color values.
    *
    * @version 1.0
    * @author Robert Eisele <robert@xarg.org>
    * @copyright Copyright (c) 2010, Robert Eisele
    * @link http://www.xarg.org/2010/03/generate-client-side-png-files-using-javascript/
    * @license http://www.opensource.org/licenses/bsd-license.php BSD License
    *
    */
    var hasRequiredPnglib;
    function requirePnglib() {
      if (hasRequiredPnglib)
        return pnglib.exports;
      hasRequiredPnglib = 1;
      (function(module2) {
        (function() {
          function write(buffer, offs) {
            for (var i = 2; i < arguments.length; i++) {
              for (var j = 0; j < arguments[i].length; j++) {
                buffer[offs++] = arguments[i].charAt(j);
              }
            }
          }
          function byte2(w2) {
            return String.fromCharCode(w2 >> 8 & 255, w2 & 255);
          }
          function byte4(w2) {
            return String.fromCharCode(w2 >> 24 & 255, w2 >> 16 & 255, w2 >> 8 & 255, w2 & 255);
          }
          function byte2lsb(w2) {
            return String.fromCharCode(w2 & 255, w2 >> 8 & 255);
          }
          var PNGlib = function(width2, height2, depth) {
            this.width = width2;
            this.height = height2;
            this.depth = depth;
            this.pix_size = height2 * (width2 + 1);
            this.data_size = 2 + this.pix_size + 5 * Math.floor((65534 + this.pix_size) / 65535) + 4;
            this.ihdr_offs = 0;
            this.ihdr_size = 4 + 4 + 13 + 4;
            this.plte_offs = this.ihdr_offs + this.ihdr_size;
            this.plte_size = 4 + 4 + 3 * depth + 4;
            this.trns_offs = this.plte_offs + this.plte_size;
            this.trns_size = 4 + 4 + depth + 4;
            this.idat_offs = this.trns_offs + this.trns_size;
            this.idat_size = 4 + 4 + this.data_size + 4;
            this.iend_offs = this.idat_offs + this.idat_size;
            this.iend_size = 4 + 4 + 4;
            this.buffer_size = this.iend_offs + this.iend_size;
            this.buffer = new Array();
            this.palette = new Object();
            this.pindex = 0;
            var _crc32 = new Array();
            for (var i = 0; i < this.buffer_size; i++) {
              this.buffer[i] = "\0";
            }
            write(this.buffer, this.ihdr_offs, byte4(this.ihdr_size - 12), "IHDR", byte4(width2), byte4(height2), "\b");
            write(this.buffer, this.plte_offs, byte4(this.plte_size - 12), "PLTE");
            write(this.buffer, this.trns_offs, byte4(this.trns_size - 12), "tRNS");
            write(this.buffer, this.idat_offs, byte4(this.idat_size - 12), "IDAT");
            write(this.buffer, this.iend_offs, byte4(this.iend_size - 12), "IEND");
            var header = 8 + (7 << 4) << 8 | 3 << 6;
            header += 31 - header % 31;
            write(this.buffer, this.idat_offs + 8, byte2(header));
            for (var i = 0; (i << 16) - 1 < this.pix_size; i++) {
              var size2, bits;
              if (i + 65535 < this.pix_size) {
                size2 = 65535;
                bits = "\0";
              } else {
                size2 = this.pix_size - (i << 16) - i;
                bits = "";
              }
              write(this.buffer, this.idat_offs + 8 + 2 + (i << 16) + (i << 2), bits, byte2lsb(size2), byte2lsb(~size2));
            }
            for (var i = 0; i < 256; i++) {
              var c = i;
              for (var j = 0; j < 8; j++) {
                if (c & 1) {
                  c = -306674912 ^ c >> 1 & 2147483647;
                } else {
                  c = c >> 1 & 2147483647;
                }
              }
              _crc32[i] = c;
            }
            this.index = function(x2, y2) {
              var i2 = y2 * (this.width + 1) + x2 + 1;
              var j2 = this.idat_offs + 8 + 2 + 5 * Math.floor(i2 / 65535 + 1) + i2;
              return j2;
            };
            this.color = function(red, green, blue, alpha) {
              alpha = alpha >= 0 ? alpha : 255;
              var color = ((alpha << 8 | red) << 8 | green) << 8 | blue;
              if (typeof this.palette[color] == "undefined") {
                if (this.pindex == this.depth)
                  return "\0";
                var ndx = this.plte_offs + 8 + 3 * this.pindex;
                this.buffer[ndx + 0] = String.fromCharCode(red);
                this.buffer[ndx + 1] = String.fromCharCode(green);
                this.buffer[ndx + 2] = String.fromCharCode(blue);
                this.buffer[this.trns_offs + 8 + this.pindex] = String.fromCharCode(alpha);
                this.palette[color] = String.fromCharCode(this.pindex++);
              }
              return this.palette[color];
            };
            this.getBase64 = function() {
              var s = this.getDump();
              var ch2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              var c1, c2, c3, e1, e2, e3, e4;
              var l2 = s.length;
              var i2 = 0;
              var r2 = "";
              do {
                c1 = s.charCodeAt(i2);
                e1 = c1 >> 2;
                c2 = s.charCodeAt(i2 + 1);
                e2 = (c1 & 3) << 4 | c2 >> 4;
                c3 = s.charCodeAt(i2 + 2);
                if (l2 < i2 + 2) {
                  e3 = 64;
                } else {
                  e3 = (c2 & 15) << 2 | c3 >> 6;
                }
                if (l2 < i2 + 3) {
                  e4 = 64;
                } else {
                  e4 = c3 & 63;
                }
                r2 += ch2.charAt(e1) + ch2.charAt(e2) + ch2.charAt(e3) + ch2.charAt(e4);
              } while ((i2 += 3) < l2);
              return r2;
            };
            this.getDump = function() {
              var BASE = 65521;
              var NMAX = 5552;
              var s1 = 1;
              var s2 = 0;
              var n2 = NMAX;
              for (var y2 = 0; y2 < this.height; y2++) {
                for (var x2 = -1; x2 < this.width; x2++) {
                  s1 += this.buffer[this.index(x2, y2)].charCodeAt(0);
                  s2 += s1;
                  if ((n2 -= 1) == 0) {
                    s1 %= BASE;
                    s2 %= BASE;
                    n2 = NMAX;
                  }
                }
              }
              s1 %= BASE;
              s2 %= BASE;
              write(this.buffer, this.idat_offs + this.idat_size - 8, byte4(s2 << 16 | s1));
              function crc32(png, offs, size3) {
                var crc = -1;
                for (var i2 = 4; i2 < size3 - 4; i2 += 1) {
                  crc = _crc32[(crc ^ png[offs + i2].charCodeAt(0)) & 255] ^ crc >> 8 & 16777215;
                }
                write(png, offs + size3 - 4, byte4(crc ^ -1));
              }
              crc32(this.buffer, this.ihdr_offs, this.ihdr_size);
              crc32(this.buffer, this.plte_offs, this.plte_size);
              crc32(this.buffer, this.trns_offs, this.trns_size);
              crc32(this.buffer, this.idat_offs, this.idat_size);
              crc32(this.buffer, this.iend_offs, this.iend_size);
              return "PNG\r\n\n" + this.buffer.join("");
            };
          };
          {
            module2.exports = PNGlib;
          }
        })();
      })(pnglib);
      return pnglib.exports;
    }
    (function(module2) {
      (function() {
        var PNGlib;
        {
          PNGlib = requirePnglib();
        }
        var Identicon2 = function(hash, options) {
          if (typeof hash !== "string" || hash.length < 15) {
            throw "A hash of at least 15 characters is required.";
          }
          this.defaults = {
            background: [240, 240, 240, 255],
            margin: 0.08,
            size: 64,
            saturation: 0.7,
            brightness: 0.5,
            format: "png"
          };
          this.options = typeof options === "object" ? options : this.defaults;
          if (typeof arguments[1] === "number") {
            this.options.size = arguments[1];
          }
          if (arguments[2]) {
            this.options.margin = arguments[2];
          }
          this.hash = hash;
          this.background = this.options.background || this.defaults.background;
          this.size = this.options.size || this.defaults.size;
          this.format = this.options.format || this.defaults.format;
          this.margin = this.options.margin !== void 0 ? this.options.margin : this.defaults.margin;
          var hue = parseInt(this.hash.substr(-7), 16) / 268435455;
          var saturation = this.options.saturation || this.defaults.saturation;
          var brightness = this.options.brightness || this.defaults.brightness;
          this.foreground = this.options.foreground || this.hsl2rgb(hue, saturation, brightness);
        };
        Identicon2.prototype = {
          background: null,
          foreground: null,
          hash: null,
          margin: null,
          size: null,
          format: null,
          image: function() {
            return this.isSvg() ? new Svg(this.size, this.foreground, this.background) : new PNGlib(this.size, this.size, 256);
          },
          render: function() {
            var image = this.image(), size2 = this.size, baseMargin = Math.floor(size2 * this.margin), cell = Math.floor((size2 - baseMargin * 2) / 5), margin = Math.floor((size2 - cell * 5) / 2), bg2 = image.color.apply(image, this.background), fg2 = image.color.apply(image, this.foreground);
            var i, color;
            for (i = 0; i < 15; i++) {
              color = parseInt(this.hash.charAt(i), 16) % 2 ? bg2 : fg2;
              if (i < 5) {
                this.rectangle(2 * cell + margin, i * cell + margin, cell, cell, color, image);
              } else if (i < 10) {
                this.rectangle(1 * cell + margin, (i - 5) * cell + margin, cell, cell, color, image);
                this.rectangle(3 * cell + margin, (i - 5) * cell + margin, cell, cell, color, image);
              } else if (i < 15) {
                this.rectangle(0 * cell + margin, (i - 10) * cell + margin, cell, cell, color, image);
                this.rectangle(4 * cell + margin, (i - 10) * cell + margin, cell, cell, color, image);
              }
            }
            return image;
          },
          rectangle: function(x2, y2, w2, h2, color, image) {
            if (this.isSvg()) {
              image.rectangles.push({ x: x2, y: y2, w: w2, h: h2, color });
            } else {
              var i, j;
              for (i = x2; i < x2 + w2; i++) {
                for (j = y2; j < y2 + h2; j++) {
                  image.buffer[image.index(i, j)] = color;
                }
              }
            }
          },
          hsl2rgb: function(h2, s, b) {
            h2 *= 6;
            s = [
              b += s *= b < 0.5 ? b : 1 - b,
              b - h2 % 1 * s * 2,
              b -= s *= 2,
              b,
              b + h2 % 1 * s,
              b + s
            ];
            return [
              s[~~h2 % 6] * 255,
              s[(h2 | 16) % 6] * 255,
              s[(h2 | 8) % 6] * 255
            ];
          },
          toString: function(raw) {
            if (raw) {
              return this.render().getDump();
            } else {
              return this.render().getBase64();
            }
          },
          isSvg: function() {
            return this.format.match(/svg/i);
          }
        };
        var Svg = function(size2, foreground, background) {
          this.size = size2;
          this.foreground = this.color.apply(this, foreground);
          this.background = this.color.apply(this, background);
          this.rectangles = [];
        };
        Svg.prototype = {
          size: null,
          foreground: null,
          background: null,
          rectangles: null,
          color: function(r2, g2, b, a) {
            var values2 = [r2, g2, b].map(Math.round);
            values2.push(a >= 0 && a <= 255 ? a / 255 : 1);
            return "rgba(" + values2.join(",") + ")";
          },
          getDump: function() {
            var i, xml, rect, fg2 = this.foreground, bg2 = this.background, stroke = this.size * 5e-3;
            xml = "<svg xmlns='http://www.w3.org/2000/svg' width='" + this.size + "' height='" + this.size + "' style='background-color:" + bg2 + ";'><g style='fill:" + fg2 + "; stroke:" + fg2 + "; stroke-width:" + stroke + ";'>";
            for (i = 0; i < this.rectangles.length; i++) {
              rect = this.rectangles[i];
              if (rect.color == bg2)
                continue;
              xml += "<rect  x='" + rect.x + "' y='" + rect.y + "' width='" + rect.w + "' height='" + rect.h + "'/>";
            }
            xml += "</g></svg>";
            return xml;
          },
          getBase64: function() {
            if ("function" === typeof btoa) {
              return btoa(this.getDump());
            } else if (Buffer) {
              return new Buffer(this.getDump(), "binary").toString("base64");
            } else {
              throw "Cannot generate base64 output";
            }
          }
        };
        {
          module2.exports = Identicon2;
        }
      })();
    })(identicon);
    const Identicon = identicon.exports;
    const hashFnv32a = (str, seed) => {
      let i, l2, hval = seed === void 0 ? 2166136261 : seed;
      for (i = 0, l2 = str.length; i < l2; i++) {
        hval ^= str.charCodeAt(i);
        hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
      }
      return ("00000000" + (hval >>> 0).toString(16)).substr(-8);
    };
    const createIdenticon = (seed, options) => {
      options = options ?? {};
      let hash = hashFnv32a(seed, 12345) + hashFnv32a(seed, 54321);
      let src = "data:image/svg+xml;base64," + new Identicon(hash, {
        background: options.background ?? [24, 27, 33, 1],
        margin: options.margin ?? 0,
        size: options.size ?? 60,
        format: options.format ?? "svg"
      });
      return src.toString();
    };
    var promise = {};
    (function(exports2) {
      (function(global2) {
        var NativePromise = global2["Promise"];
        var nativePromiseSupported = NativePromise && "resolve" in NativePromise && "reject" in NativePromise && "all" in NativePromise && "race" in NativePromise && function() {
          var resolve2;
          new NativePromise(function(r2) {
            resolve2 = r2;
          });
          return typeof resolve2 === "function";
        }();
        if (exports2) {
          exports2.Promise = nativePromiseSupported ? NativePromise : Promise2;
          exports2.Polyfill = Promise2;
        } else {
          {
            if (!nativePromiseSupported)
              global2["Promise"] = Promise2;
          }
        }
        var PENDING = "pending";
        var SEALED = "sealed";
        var FULFILLED = "fulfilled";
        var REJECTED = "rejected";
        var NOOP = function() {
        };
        function isArray2(value2) {
          return Object.prototype.toString.call(value2) === "[object Array]";
        }
        var asyncSetTimer = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
        var asyncQueue = [];
        var asyncTimer;
        function asyncFlush() {
          for (var i = 0; i < asyncQueue.length; i++)
            asyncQueue[i][0](asyncQueue[i][1]);
          asyncQueue = [];
          asyncTimer = false;
        }
        function asyncCall(callback, arg) {
          asyncQueue.push([callback, arg]);
          if (!asyncTimer) {
            asyncTimer = true;
            asyncSetTimer(asyncFlush, 0);
          }
        }
        function invokeResolver(resolver, promise2) {
          function resolvePromise(value2) {
            resolve(promise2, value2);
          }
          function rejectPromise(reason) {
            reject2(promise2, reason);
          }
          try {
            resolver(resolvePromise, rejectPromise);
          } catch (e) {
            rejectPromise(e);
          }
        }
        function invokeCallback(subscriber) {
          var owner = subscriber.owner;
          var settled = owner.state_;
          var value2 = owner.data_;
          var callback = subscriber[settled];
          var promise2 = subscriber.then;
          if (typeof callback === "function") {
            settled = FULFILLED;
            try {
              value2 = callback(value2);
            } catch (e) {
              reject2(promise2, e);
            }
          }
          if (!handleThenable(promise2, value2)) {
            if (settled === FULFILLED)
              resolve(promise2, value2);
            if (settled === REJECTED)
              reject2(promise2, value2);
          }
        }
        function handleThenable(promise2, value2) {
          var resolved;
          try {
            if (promise2 === value2)
              throw new TypeError("A promises callback cannot return that same promise.");
            if (value2 && (typeof value2 === "function" || typeof value2 === "object")) {
              var then = value2.then;
              if (typeof then === "function") {
                then.call(value2, function(val) {
                  if (!resolved) {
                    resolved = true;
                    if (value2 !== val)
                      resolve(promise2, val);
                    else
                      fulfill(promise2, val);
                  }
                }, function(reason) {
                  if (!resolved) {
                    resolved = true;
                    reject2(promise2, reason);
                  }
                });
                return true;
              }
            }
          } catch (e) {
            if (!resolved)
              reject2(promise2, e);
            return true;
          }
          return false;
        }
        function resolve(promise2, value2) {
          if (promise2 === value2 || !handleThenable(promise2, value2))
            fulfill(promise2, value2);
        }
        function fulfill(promise2, value2) {
          if (promise2.state_ === PENDING) {
            promise2.state_ = SEALED;
            promise2.data_ = value2;
            asyncCall(publishFulfillment, promise2);
          }
        }
        function reject2(promise2, reason) {
          if (promise2.state_ === PENDING) {
            promise2.state_ = SEALED;
            promise2.data_ = reason;
            asyncCall(publishRejection, promise2);
          }
        }
        function publish(promise2) {
          var callbacks = promise2.then_;
          promise2.then_ = void 0;
          for (var i = 0; i < callbacks.length; i++) {
            invokeCallback(callbacks[i]);
          }
        }
        function publishFulfillment(promise2) {
          promise2.state_ = FULFILLED;
          publish(promise2);
        }
        function publishRejection(promise2) {
          promise2.state_ = REJECTED;
          publish(promise2);
        }
        function Promise2(resolver) {
          if (typeof resolver !== "function")
            throw new TypeError("Promise constructor takes a function argument");
          if (this instanceof Promise2 === false)
            throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
          this.then_ = [];
          invokeResolver(resolver, this);
        }
        Promise2.prototype = {
          constructor: Promise2,
          state_: PENDING,
          then_: null,
          data_: void 0,
          then: function(onFulfillment, onRejection) {
            var subscriber = {
              owner: this,
              then: new this.constructor(NOOP),
              fulfilled: onFulfillment,
              rejected: onRejection
            };
            if (this.state_ === FULFILLED || this.state_ === REJECTED) {
              asyncCall(invokeCallback, subscriber);
            } else {
              this.then_.push(subscriber);
            }
            return subscriber.then;
          },
          "catch": function(onRejection) {
            return this.then(null, onRejection);
          }
        };
        Promise2.all = function(promises) {
          var Class = this;
          if (!isArray2(promises))
            throw new TypeError("You must pass an array to Promise.all().");
          return new Class(function(resolve2, reject3) {
            var results = [];
            var remaining = 0;
            function resolver(index2) {
              remaining++;
              return function(value2) {
                results[index2] = value2;
                if (!--remaining)
                  resolve2(results);
              };
            }
            for (var i = 0, promise2; i < promises.length; i++) {
              promise2 = promises[i];
              if (promise2 && typeof promise2.then === "function")
                promise2.then(resolver(i), reject3);
              else
                results[i] = promise2;
            }
            if (!remaining)
              resolve2(results);
          });
        };
        Promise2.race = function(promises) {
          var Class = this;
          if (!isArray2(promises))
            throw new TypeError("You must pass an array to Promise.race().");
          return new Class(function(resolve2, reject3) {
            for (var i = 0, promise2; i < promises.length; i++) {
              promise2 = promises[i];
              if (promise2 && typeof promise2.then === "function")
                promise2.then(resolve2, reject3);
              else
                resolve2(promise2);
            }
          });
        };
        Promise2.resolve = function(value2) {
          var Class = this;
          if (value2 && typeof value2 === "object" && value2.constructor === Class)
            return value2;
          return new Class(function(resolve2) {
            resolve2(value2);
          });
        };
        Promise2.reject = function(reason) {
          var Class = this;
          return new Class(function(resolve2, reject3) {
            reject3(reason);
          });
        };
      })(typeof window != "undefined" ? window : typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : commonjsGlobal);
    })(promise);
    /*!
     * @pixi/polyfill - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/polyfill is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    if (!window.Promise) {
      window.Promise = promise.Polyfill;
    }
    if (!Object.assign) {
      Object.assign = objectAssign;
    }
    var ONE_FRAME_TIME = 16;
    if (!(Date.now && Date.prototype.getTime)) {
      Date.now = function now2() {
        return new Date().getTime();
      };
    }
    if (!(window.performance && window.performance.now)) {
      var startTime_1 = Date.now();
      if (!window.performance) {
        window.performance = {};
      }
      window.performance.now = function() {
        return Date.now() - startTime_1;
      };
    }
    var lastTime = Date.now();
    var vendors = ["ms", "moz", "webkit", "o"];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
      var p = vendors[x];
      window.requestAnimationFrame = window[p + "RequestAnimationFrame"];
      window.cancelAnimationFrame = window[p + "CancelAnimationFrame"] || window[p + "CancelRequestAnimationFrame"];
    }
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(callback) {
        if (typeof callback !== "function") {
          throw new TypeError(callback + "is not a function");
        }
        var currentTime = Date.now();
        var delay2 = ONE_FRAME_TIME + lastTime - currentTime;
        if (delay2 < 0) {
          delay2 = 0;
        }
        lastTime = currentTime;
        return window.setTimeout(function() {
          lastTime = Date.now();
          callback(performance.now());
        }, delay2);
      };
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = function(id2) {
        return clearTimeout(id2);
      };
    }
    if (!Math.sign) {
      Math.sign = function mathSign(x2) {
        x2 = Number(x2);
        if (x2 === 0 || isNaN(x2)) {
          return x2;
        }
        return x2 > 0 ? 1 : -1;
      };
    }
    if (!Number.isInteger) {
      Number.isInteger = function numberIsInteger(value2) {
        return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
      };
    }
    if (!window.ArrayBuffer) {
      window.ArrayBuffer = Array;
    }
    if (!window.Float32Array) {
      window.Float32Array = Array;
    }
    if (!window.Uint32Array) {
      window.Uint32Array = Array;
    }
    if (!window.Uint16Array) {
      window.Uint16Array = Array;
    }
    if (!window.Uint8Array) {
      window.Uint8Array = Array;
    }
    if (!window.Int32Array) {
      window.Int32Array = Array;
    }
    var appleIphone = /iPhone/i;
    var appleIpod = /iPod/i;
    var appleTablet = /iPad/i;
    var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
    var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
    var androidTablet = /Android/i;
    var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
    var amazonTablet = /Silk/i;
    var windowsPhone = /Windows Phone/i;
    var windowsTablet = /\bWindows(?:.+)ARM\b/i;
    var otherBlackBerry = /BlackBerry/i;
    var otherBlackBerry10 = /BB10/i;
    var otherOpera = /Opera Mini/i;
    var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
    var otherFirefox = /Mobile(?:.+)Firefox\b/i;
    var isAppleTabletOnIos13 = function(navigator2) {
      return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
    };
    function createMatch(userAgent) {
      return function(regex) {
        return regex.test(userAgent);
      };
    }
    function isMobile$1(param) {
      var nav = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
      };
      if (!param && typeof navigator !== "undefined") {
        nav = {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          maxTouchPoints: navigator.maxTouchPoints || 0
        };
      } else if (typeof param === "string") {
        nav.userAgent = param;
      } else if (param && param.userAgent) {
        nav = {
          userAgent: param.userAgent,
          platform: param.platform,
          maxTouchPoints: param.maxTouchPoints || 0
        };
      }
      var userAgent = nav.userAgent;
      var tmp = userAgent.split("[FBAN");
      if (typeof tmp[1] !== "undefined") {
        userAgent = tmp[0];
      }
      tmp = userAgent.split("Twitter");
      if (typeof tmp[1] !== "undefined") {
        userAgent = tmp[0];
      }
      var match = createMatch(userAgent);
      var result2 = {
        apple: {
          phone: match(appleIphone) && !match(windowsPhone),
          ipod: match(appleIpod),
          tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
          universal: match(appleUniversal),
          device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
        },
        amazon: {
          phone: match(amazonPhone),
          tablet: !match(amazonPhone) && match(amazonTablet),
          device: match(amazonPhone) || match(amazonTablet)
        },
        android: {
          phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
          tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
          device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
        },
        windows: {
          phone: match(windowsPhone),
          tablet: match(windowsTablet),
          device: match(windowsPhone) || match(windowsTablet)
        },
        other: {
          blackberry: match(otherBlackBerry),
          blackberry10: match(otherBlackBerry10),
          opera: match(otherOpera),
          firefox: match(otherFirefox),
          chrome: match(otherChrome),
          device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
        },
        any: false,
        phone: false,
        tablet: false
      };
      result2.any = result2.apple.device || result2.android.device || result2.windows.device || result2.other.device;
      result2.phone = result2.apple.phone || result2.android.phone || result2.windows.phone;
      result2.tablet = result2.apple.tablet || result2.android.tablet || result2.windows.tablet;
      return result2;
    }
    /*!
     * @pixi/settings - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/settings is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var isMobile = isMobile$1(window.navigator);
    function maxRecommendedTextures(max2) {
      var allowMax = true;
      if (isMobile.tablet || isMobile.phone) {
        if (isMobile.apple.device) {
          var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
          if (match) {
            var majorVersion = parseInt(match[1], 10);
            if (majorVersion < 11) {
              allowMax = false;
            }
          }
        }
        if (isMobile.android.device) {
          var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
          if (match) {
            var majorVersion = parseInt(match[1], 10);
            if (majorVersion < 7) {
              allowMax = false;
            }
          }
        }
      }
      return allowMax ? max2 : 4;
    }
    function canUploadSameBuffer() {
      return !isMobile.apple.device;
    }
    var settings = {
      MIPMAP_TEXTURES: 1,
      ANISOTROPIC_LEVEL: 0,
      RESOLUTION: 1,
      FILTER_RESOLUTION: 1,
      SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
      SPRITE_BATCH_SIZE: 4096,
      RENDER_OPTIONS: {
        view: null,
        antialias: false,
        autoDensity: false,
        transparent: false,
        backgroundColor: 0,
        clearBeforeRender: true,
        preserveDrawingBuffer: false,
        width: 800,
        height: 600,
        legacy: false
      },
      GC_MODE: 0,
      GC_MAX_IDLE: 60 * 60,
      GC_MAX_CHECK_COUNT: 60 * 10,
      WRAP_MODE: 33071,
      SCALE_MODE: 1,
      PRECISION_VERTEX: "highp",
      PRECISION_FRAGMENT: isMobile.apple.device ? "highp" : "mediump",
      CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
      CREATE_IMAGE_BITMAP: false,
      ROUND_PIXELS: false
    };
    var eventemitter3 = { exports: {} };
    (function(module2) {
      var has2 = Object.prototype.hasOwnProperty, prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context2, once2) {
        this.fn = fn;
        this.context = context2;
        this.once = once2 || false;
      }
      function addListener(emitter, event, fn, context2, once2) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context2 || emitter, once2), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events2, name2;
        if (this._eventsCount === 0)
          return names;
        for (name2 in events2 = this._events) {
          if (has2.call(events2, name2))
            names.push(prefix ? name2.slice(1) : name2);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events2));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i = 0, l2 = handlers.length, ee2 = new Array(l2); i < l2; i++) {
          ee2[i] = handlers[i].fn;
        }
        return ee2;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once)
              this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context2) {
        return addListener(this, event, fn, context2, false);
      };
      EventEmitter2.prototype.once = function once2(event, fn, context2) {
        return addListener(this, event, fn, context2, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once2) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once2 || listeners.once) && (!context2 || listeners.context === context2)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once2 && !listeners[i].once || context2 && listeners[i].context !== context2) {
              events2.push(listeners[i]);
            }
          }
          if (events2.length)
            this._events[evt] = events2.length === 1 ? events2[0] : events2;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      {
        module2.exports = EventEmitter2;
      }
    })(eventemitter3);
    const EventEmitter = eventemitter3.exports;
    var earcut$1 = { exports: {} };
    earcut$1.exports = earcut;
    earcut$1.exports.default = earcut;
    function earcut(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x2, y2, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x2 = data[i];
          y2 = data[i + 1];
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last2;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i = start; i < end; i += dim)
          last2 = insertNode(i, data[i], data[i + 1], last2);
      } else {
        for (i = end - dim; i >= start; i -= dim)
          last2 = insertNode(i, data[i], data[i + 1], last2);
      }
      if (last2 && equals(last2, last2.next)) {
        removeNode(last2);
        last2 = last2.next;
      }
      return last2;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p2 = start, again;
      do {
        again = false;
        if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
          removeNode(p2);
          p2 = end = p2.prev;
          if (p2 === p2.next)
            break;
          again = true;
        } else {
          p2 = p2.next;
        }
      } while (again || p2 !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim);
          triangles.push(ear.i / dim);
          triangles.push(next.i / dim);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var p2 = ear.next.next;
      while (p2 !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
      var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
      var p2 = ear.prevZ, n2 = ear.nextZ;
      while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
        if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
        if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      while (p2 && p2.z >= minZ) {
        if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
      }
      while (n2 && n2.z <= maxZ) {
        if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p2 = start;
      do {
        var a = p2.prev, b = p2.next.next;
        if (!equals(a, b) && intersects(a, p2, p2.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim);
          triangles.push(p2.i / dim);
          triangles.push(b.i / dim);
          removeNode(p2);
          removeNode(p2.next);
          p2 = start = b;
        }
        p2 = p2.next;
      } while (p2 !== start);
      return filterPoints(p2);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize);
            earcutLinked(c, triangles, dim, minX, minY, invSize);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue2 = [], i, len, start, end, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue2.push(getLeftmost(list));
      }
      queue2.sort(compareX);
      for (i = 0; i < queue2.length; i++) {
        eliminateHole(queue2[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      outerNode = findHoleBridge(hole, outerNode);
      if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(outerNode, outerNode.next);
        filterPoints(b, b.next);
      }
    }
    function findHoleBridge(hole, outerNode) {
      var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
      do {
        if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
          var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
          if (x2 <= hx && x2 > qx) {
            qx = x2;
            if (x2 === hx) {
              if (hy === p2.y)
                return p2;
              if (hy === p2.next.y)
                return p2.next;
            }
            m2 = p2.x < p2.next.x ? p2 : p2.next;
          }
        }
        p2 = p2.next;
      } while (p2 !== outerNode);
      if (!m2)
        return null;
      if (hx === qx)
        return m2;
      var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
      p2 = m2;
      do {
        if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
          tan = Math.abs(hy - p2.y) / (hx - p2.x);
          if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
            m2 = p2;
            tanMin = tan;
          }
        }
        p2 = p2.next;
      } while (p2 !== stop);
      return m2;
    }
    function sectorContainsSector(m2, p2) {
      return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p2 = start;
      do {
        if (p2.z === null)
          p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
        p2.prevZ = p2.prev;
        p2.nextZ = p2.next;
        p2 = p2.next;
      } while (p2 !== start);
      p2.prevZ.nextZ = null;
      p2.prevZ = null;
      sortLinked(p2);
    }
    function sortLinked(list) {
      var i, p2, q2, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p2 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p2) {
          numMerges++;
          q2 = p2;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q2 = q2.nextZ;
            if (!q2)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q2) {
            if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
              e = p2;
              p2 = p2.nextZ;
              pSize--;
            } else {
              e = q2;
              q2 = q2.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p2 = q2;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x2, y2, minX, minY, invSize) {
      x2 = 32767 * (x2 - minX) * invSize;
      y2 = 32767 * (y2 - minY) * invSize;
      x2 = (x2 | x2 << 8) & 16711935;
      x2 = (x2 | x2 << 4) & 252645135;
      x2 = (x2 | x2 << 2) & 858993459;
      x2 = (x2 | x2 << 1) & 1431655765;
      y2 = (y2 | y2 << 8) & 16711935;
      y2 = (y2 | y2 << 4) & 252645135;
      y2 = (y2 | y2 << 2) & 858993459;
      y2 = (y2 | y2 << 1) & 1431655765;
      return x2 | y2 << 1;
    }
    function getLeftmost(start) {
      var p2 = start, leftmost = start;
      do {
        if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
          leftmost = p2;
        p2 = p2.next;
      } while (p2 !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
    }
    function area(p2, q2, r2) {
      return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign$2(area(p1, q1, p2));
      var o2 = sign$2(area(p1, q1, q2));
      var o3 = sign$2(area(p2, q2, p1));
      var o4 = sign$2(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p2, q2, r2) {
      return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
    }
    function sign$2(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b) {
      var p2 = a;
      do {
        if (p2.i !== a.i && p2.next.i !== a.i && p2.i !== b.i && p2.next.i !== b.i && intersects(p2, p2.next, a, b))
          return true;
        p2 = p2.next;
      } while (p2 !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p2 = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
          inside = !inside;
        p2 = p2.next;
      } while (p2 !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x2, y2, last2) {
      var p2 = new Node(i, x2, y2);
      if (!last2) {
        p2.prev = p2;
        p2.next = p2;
      } else {
        p2.next = last2.next;
        p2.prev = last2;
        last2.next.prev = p2;
        last2.next = p2;
      }
      return p2;
    }
    function removeNode(p2) {
      p2.next.prev = p2.prev;
      p2.prev.next = p2.next;
      if (p2.prevZ)
        p2.prevZ.nextZ = p2.nextZ;
      if (p2.nextZ)
        p2.nextZ.prevZ = p2.prevZ;
    }
    function Node(i, x2, y2) {
      this.i = i;
      this.x = x2;
      this.y = y2;
      this.prev = null;
      this.next = null;
      this.z = null;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
          var start = holeIndices[i] * dim;
          var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum;
    }
    earcut.flatten = function(data) {
      var dim = data[0][0].length, result2 = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d = 0; d < dim; d++)
            result2.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result2.holes.push(holeIndex);
        }
      }
      return result2;
    };
    var url = {};
    var punycode$1 = { exports: {} };
    /*! https://mths.be/punycode v1.3.2 by @mathias */
    (function(module2, exports2) {
      (function(root2) {
        var freeExports = exports2 && !exports2.nodeType && exports2;
        var freeModule = module2 && !module2.nodeType && module2;
        var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
          root2 = freeGlobal;
        }
        var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
        function error(type) {
          throw RangeError(errors[type]);
        }
        function map2(array, fn) {
          var length = array.length;
          var result2 = [];
          while (length--) {
            result2[length] = fn(array[length]);
          }
          return result2;
        }
        function mapDomain(string, fn) {
          var parts = string.split("@");
          var result2 = "";
          if (parts.length > 1) {
            result2 = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators, ".");
          var labels = string.split(".");
          var encoded = map2(labels, fn).join(".");
          return result2 + encoded;
        }
        function ucs2decode(string) {
          var output = [], counter = 0, length = string.length, value2, extra;
          while (counter < length) {
            value2 = string.charCodeAt(counter++);
            if (value2 >= 55296 && value2 <= 56319 && counter < length) {
              extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value2);
                counter--;
              }
            } else {
              output.push(value2);
            }
          }
          return output;
        }
        function ucs2encode(array) {
          return map2(array, function(value2) {
            var output = "";
            if (value2 > 65535) {
              value2 -= 65536;
              output += stringFromCharCode(value2 >>> 10 & 1023 | 55296);
              value2 = 56320 | value2 & 1023;
            }
            output += stringFromCharCode(value2);
            return output;
          }).join("");
        }
        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        }
        function digitToBasic(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }
        function adapt(delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }
        function decode2(input) {
          var output = [], inputLength = input.length, out, i = 0, n2 = initialN, bias = initialBias, basic, j, index2, oldi, w2, k, digit, t2, baseMinusT;
          basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (j = 0; j < basic; ++j) {
            if (input.charCodeAt(j) >= 128) {
              error("not-basic");
            }
            output.push(input.charCodeAt(j));
          }
          for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
            for (oldi = i, w2 = 1, k = base; ; k += base) {
              if (index2 >= inputLength) {
                error("invalid-input");
              }
              digit = basicToDigit(input.charCodeAt(index2++));
              if (digit >= base || digit > floor((maxInt - i) / w2)) {
                error("overflow");
              }
              i += digit * w2;
              t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (digit < t2) {
                break;
              }
              baseMinusT = base - t2;
              if (w2 > floor(maxInt / baseMinusT)) {
                error("overflow");
              }
              w2 *= baseMinusT;
            }
            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            if (floor(i / out) > maxInt - n2) {
              error("overflow");
            }
            n2 += floor(i / out);
            i %= out;
            output.splice(i++, 0, n2);
          }
          return ucs2encode(output);
        }
        function encode2(input) {
          var n2, delta, handledCPCount, basicLength, bias, j, m2, q2, k, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
          input = ucs2decode(input);
          inputLength = input.length;
          n2 = initialN;
          delta = 0;
          bias = initialBias;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 128) {
              output.push(stringFromCharCode(currentValue));
            }
          }
          handledCPCount = basicLength = output.length;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            for (m2 = maxInt, j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue >= n2 && currentValue < m2) {
                m2 = currentValue;
              }
            }
            handledCPCountPlusOne = handledCPCount + 1;
            if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error("overflow");
            }
            delta += (m2 - n2) * handledCPCountPlusOne;
            n2 = m2;
            for (j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue < n2 && ++delta > maxInt) {
                error("overflow");
              }
              if (currentValue == n2) {
                for (q2 = delta, k = base; ; k += base) {
                  t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q2 < t2) {
                    break;
                  }
                  qMinusT = q2 - t2;
                  baseMinusT = base - t2;
                  output.push(
                    stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
                  );
                  q2 = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q2, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
            ++delta;
            ++n2;
          }
          return output.join("");
        }
        function toUnicode(input) {
          return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
          });
        }
        function toASCII(input) {
          return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
          });
        }
        punycode2 = {
          "version": "1.3.2",
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode2,
          "encode": encode2,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        if (freeExports && freeModule) {
          if (module2.exports == freeExports) {
            freeModule.exports = punycode2;
          } else {
            for (key in punycode2) {
              punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
            }
          }
        } else {
          root2.punycode = punycode2;
        }
      })(commonjsGlobal);
    })(punycode$1, punycode$1.exports);
    var util$1 = {
      isString: function(arg) {
        return typeof arg === "string";
      },
      isObject: function(arg) {
        return typeof arg === "object" && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };
    var querystring$1 = {};
    function hasOwnProperty$1(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var decode = function(qs, sep, eq2, options) {
      sep = sep || "&";
      eq2 = eq2 || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i = 0; i < len; ++i) {
        var x2 = qs[i].replace(regexp, "%20"), idx = x2.indexOf(eq2), kstr, vstr, k, v2;
        if (idx >= 0) {
          kstr = x2.substr(0, idx);
          vstr = x2.substr(idx + 1);
        } else {
          kstr = x2;
          vstr = "";
        }
        k = decodeURIComponent(kstr);
        v2 = decodeURIComponent(vstr);
        if (!hasOwnProperty$1(obj, k)) {
          obj[k] = v2;
        } else if (Array.isArray(obj[k])) {
          obj[k].push(v2);
        } else {
          obj[k] = [obj[k], v2];
        }
      }
      return obj;
    };
    var stringifyPrimitive = function(v2) {
      switch (typeof v2) {
        case "string":
          return v2;
        case "boolean":
          return v2 ? "true" : "false";
        case "number":
          return isFinite(v2) ? v2 : "";
        default:
          return "";
      }
    };
    var encode$1 = function(obj, sep, eq2, name2) {
      sep = sep || "&";
      eq2 = eq2 || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return Object.keys(obj).map(function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq2;
          if (Array.isArray(obj[k])) {
            return obj[k].map(function(v2) {
              return ks + encodeURIComponent(stringifyPrimitive(v2));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
      }
      if (!name2)
        return "";
      return encodeURIComponent(stringifyPrimitive(name2)) + eq2 + encodeURIComponent(stringifyPrimitive(obj));
    };
    querystring$1.decode = querystring$1.parse = decode;
    querystring$1.encode = querystring$1.stringify = encode$1;
    var punycode = punycode$1.exports;
    var util = util$1;
    var parse = url.parse = urlParse;
    url.resolve = urlResolve;
    url.resolveObject = urlResolveObject;
    url.format = urlFormat;
    url.Url = Url$1;
    function Url$1() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
      "javascript": true,
      "javascript:": true
    }, hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    }, slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    }, querystring = querystring$1;
    function urlParse(url2, parseQueryString, slashesDenoteHost) {
      if (url2 && util.isObject(url2) && url2 instanceof Url$1)
        return url2;
      var u2 = new Url$1();
      u2.parse(url2, parseQueryString, slashesDenoteHost);
      return u2;
    }
    Url$1.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url2)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
      }
      var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url2 = uSplit.join(splitter);
      var rest2 = url2;
      rest2 = rest2.trim();
      if (!slashesDenoteHost && url2.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest2);
        if (simplePath) {
          this.path = rest2;
          this.href = rest2;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto2 = protocolPattern.exec(rest2);
      if (proto2) {
        proto2 = proto2[0];
        var lowerProto = proto2.toLowerCase();
        this.protocol = lowerProto;
        rest2 = rest2.substr(proto2.length);
      }
      if (slashesDenoteHost || proto2 || rest2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest2.substr(0, 2) === "//";
        if (slashes && !(proto2 && hostlessProtocol[proto2])) {
          rest2 = rest2.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto2] && (slashes || proto2 && !slashedProtocol[proto2])) {
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest2.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest2.lastIndexOf("@");
        } else {
          atSign = rest2.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest2.slice(0, atSign);
          rest2 = rest2.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest2.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        if (hostEnd === -1)
          hostEnd = rest2.length;
        this.host = rest2.slice(0, hostEnd);
        rest2 = rest2.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l2 = hostparts.length; i < l2; i++) {
            var part = hostparts[i];
            if (!part)
              continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest2 = "/" + notHost.join(".") + rest2;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p2 = this.port ? ":" + this.port : "";
        var h2 = this.hostname || "";
        this.host = h2 + p2;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest2[0] !== "/") {
            rest2 = "/" + rest2;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i = 0, l2 = autoEscape.length; i < l2; i++) {
          var ae2 = autoEscape[i];
          if (rest2.indexOf(ae2) === -1)
            continue;
          var esc = encodeURIComponent(ae2);
          if (esc === ae2) {
            esc = escape(ae2);
          }
          rest2 = rest2.split(ae2).join(esc);
        }
      }
      var hash = rest2.indexOf("#");
      if (hash !== -1) {
        this.hash = rest2.substr(hash);
        rest2 = rest2.slice(0, hash);
      }
      var qm = rest2.indexOf("?");
      if (qm !== -1) {
        this.search = rest2.substr(qm);
        this.query = rest2.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest2 = rest2.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest2)
        this.pathname = rest2;
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p2 = this.pathname || "";
        var s = this.search || "";
        this.path = p2 + s;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (util.isString(obj))
        obj = urlParse(obj);
      if (!(obj instanceof Url$1))
        return Url$1.prototype.format.call(obj);
      return obj.format();
    }
    Url$1.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":")
        protocol += ":";
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/")
          pathname = "/" + pathname;
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#")
        hash = "#" + hash;
      if (search && search.charAt(0) !== "?")
        search = "?" + search;
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    Url$1.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    function urlResolveObject(source, relative) {
      if (!source)
        return relative;
      return urlParse(source, false, true).resolveObject(relative);
    }
    Url$1.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel = new Url$1();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result2 = new Url$1();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result2[tkey] = this[tkey];
      }
      result2.hash = relative.hash;
      if (relative.href === "") {
        result2.href = result2.format();
        return result2;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol")
            result2[rkey] = relative[rkey];
        }
        if (slashedProtocol[result2.protocol] && result2.hostname && !result2.pathname) {
          result2.path = result2.pathname = "/";
        }
        result2.href = result2.format();
        return result2;
      }
      if (relative.protocol && relative.protocol !== result2.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys2 = Object.keys(relative);
          for (var v2 = 0; v2 < keys2.length; v2++) {
            var k = keys2[v2];
            result2[k] = relative[k];
          }
          result2.href = result2.format();
          return result2;
        }
        result2.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result2.pathname = relPath.join("/");
        } else {
          result2.pathname = relative.pathname;
        }
        result2.search = relative.search;
        result2.query = relative.query;
        result2.host = relative.host || "";
        result2.auth = relative.auth;
        result2.hostname = relative.hostname || relative.host;
        result2.port = relative.port;
        if (result2.pathname || result2.search) {
          var p2 = result2.pathname || "";
          var s = result2.search || "";
          result2.path = p2 + s;
        }
        result2.slashes = result2.slashes || relative.slashes;
        result2.href = result2.format();
        return result2;
      }
      var isSourceAbs = result2.pathname && result2.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result2.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result2.pathname && result2.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result2.protocol && !slashedProtocol[result2.protocol];
      if (psychotic) {
        result2.hostname = "";
        result2.port = null;
        if (result2.host) {
          if (srcPath[0] === "")
            srcPath[0] = result2.host;
          else
            srcPath.unshift(result2.host);
        }
        result2.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result2.host = relative.host || relative.host === "" ? relative.host : result2.host;
        result2.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result2.hostname;
        result2.search = relative.search;
        result2.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result2.search = relative.search;
        result2.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result2.hostname = result2.host = srcPath.shift();
          var authInHost = result2.host && result2.host.indexOf("@") > 0 ? result2.host.split("@") : false;
          if (authInHost) {
            result2.auth = authInHost.shift();
            result2.host = result2.hostname = authInHost.shift();
          }
        }
        result2.search = relative.search;
        result2.query = relative.query;
        if (!util.isNull(result2.pathname) || !util.isNull(result2.search)) {
          result2.path = (result2.pathname ? result2.pathname : "") + (result2.search ? result2.search : "");
        }
        result2.href = result2.format();
        return result2;
      }
      if (!srcPath.length) {
        result2.pathname = null;
        if (result2.search) {
          result2.path = "/" + result2.search;
        } else {
          result2.path = null;
        }
        result2.href = result2.format();
        return result2;
      }
      var last2 = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result2.host || relative.host || srcPath.length > 1) && (last2 === "." || last2 === "..") || last2 === "";
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last2 = srcPath[i];
        if (last2 === ".") {
          srcPath.splice(i, 1);
        } else if (last2 === "..") {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result2.hostname = result2.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        var authInHost = result2.host && result2.host.indexOf("@") > 0 ? result2.host.split("@") : false;
        if (authInHost) {
          result2.auth = authInHost.shift();
          result2.host = result2.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result2.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result2.pathname = null;
        result2.path = null;
      } else {
        result2.pathname = srcPath.join("/");
      }
      if (!util.isNull(result2.pathname) || !util.isNull(result2.search)) {
        result2.path = (result2.pathname ? result2.pathname : "") + (result2.search ? result2.search : "");
      }
      result2.auth = relative.auth || result2.auth;
      result2.slashes = result2.slashes || relative.slashes;
      result2.href = result2.format();
      return result2;
    };
    Url$1.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host)
        this.hostname = host;
    };
    /*!
     * @pixi/constants - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/constants is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var ENV$1;
    (function(ENV2) {
      ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
      ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
      ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
    })(ENV$1 || (ENV$1 = {}));
    var RENDERER_TYPE$1;
    (function(RENDERER_TYPE2) {
      RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
      RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
      RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
    })(RENDERER_TYPE$1 || (RENDERER_TYPE$1 = {}));
    var BUFFER_BITS$1;
    (function(BUFFER_BITS2) {
      BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
      BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
      BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
    })(BUFFER_BITS$1 || (BUFFER_BITS$1 = {}));
    var BLEND_MODES$1;
    (function(BLEND_MODES2) {
      BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
      BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
      BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
      BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
      BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
      BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
      BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
      BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
      BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
      BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
      BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
      BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
      BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
      BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
      BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
      BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
      BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
      BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
      BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
      BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
      BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
      BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
      BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
      BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
      BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
      BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
      BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
      BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
      BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
      BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
      BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
      BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
    })(BLEND_MODES$1 || (BLEND_MODES$1 = {}));
    var DRAW_MODES$1;
    (function(DRAW_MODES2) {
      DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
      DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
      DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
      DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
      DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
      DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
      DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    })(DRAW_MODES$1 || (DRAW_MODES$1 = {}));
    var FORMATS$1;
    (function(FORMATS2) {
      FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
      FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
      FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
      FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
      FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    })(FORMATS$1 || (FORMATS$1 = {}));
    var TARGETS$1;
    (function(TARGETS2) {
      TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    })(TARGETS$1 || (TARGETS$1 = {}));
    var TYPES$1;
    (function(TYPES2) {
      TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
      TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
    })(TYPES$1 || (TYPES$1 = {}));
    var SCALE_MODES$1;
    (function(SCALE_MODES2) {
      SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
      SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
    })(SCALE_MODES$1 || (SCALE_MODES$1 = {}));
    var WRAP_MODES$1;
    (function(WRAP_MODES2) {
      WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
      WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
      WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    })(WRAP_MODES$1 || (WRAP_MODES$1 = {}));
    var MIPMAP_MODES$1;
    (function(MIPMAP_MODES2) {
      MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
      MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
      MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
    })(MIPMAP_MODES$1 || (MIPMAP_MODES$1 = {}));
    var ALPHA_MODES$1;
    (function(ALPHA_MODES2) {
      ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
      ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
      ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
      ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
      ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
      ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
    })(ALPHA_MODES$1 || (ALPHA_MODES$1 = {}));
    var CLEAR_MODES$1;
    (function(CLEAR_MODES2) {
      CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
      CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
      CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
      CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
      CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
      CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
    })(CLEAR_MODES$1 || (CLEAR_MODES$1 = {}));
    var GC_MODES$1;
    (function(GC_MODES2) {
      GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
      GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
    })(GC_MODES$1 || (GC_MODES$1 = {}));
    var PRECISION$1;
    (function(PRECISION2) {
      PRECISION2["LOW"] = "lowp";
      PRECISION2["MEDIUM"] = "mediump";
      PRECISION2["HIGH"] = "highp";
    })(PRECISION$1 || (PRECISION$1 = {}));
    var MASK_TYPES$1;
    (function(MASK_TYPES2) {
      MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
      MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
      MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
      MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
    })(MASK_TYPES$1 || (MASK_TYPES$1 = {}));
    var MSAA_QUALITY$1;
    (function(MSAA_QUALITY2) {
      MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
      MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
      MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
      MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
    })(MSAA_QUALITY$1 || (MSAA_QUALITY$1 = {}));
    /*!
     * @pixi/utils - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/utils is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    settings.RETINA_PREFIX = /@([0-9\.]+)x/;
    settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = true;
    var saidHello = false;
    var VERSION$1 = "5.3.3";
    function sayHello(type) {
      var _a2;
      if (saidHello) {
        return;
      }
      if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
        var args = [
          "\n %c %c %c PixiJS " + VERSION$1 + " -  " + type + "   %c  %c  http://www.pixijs.com/  %c %c %c%c \n\n",
          "background: #ff66a5; padding:5px 0;",
          "background: #ff66a5; padding:5px 0;",
          "color: #ff66a5; background: #030307; padding:5px 0;",
          "background: #ff66a5; padding:5px 0;",
          "background: #ffc3dc; padding:5px 0;",
          "background: #ff66a5; padding:5px 0;",
          "color: #ff2424; background: #fff; padding:5px 0;",
          "color: #ff2424; background: #fff; padding:5px 0;",
          "color: #ff2424; background: #fff; padding:5px 0;"
        ];
        (_a2 = window.console).log.apply(_a2, args);
      } else if (window.console) {
        window.console.log("PixiJS " + VERSION$1 + " - " + type + " - http://www.pixijs.com/");
      }
      saidHello = true;
    }
    var supported;
    function isWebGLSupported() {
      if (typeof supported === "undefined") {
        supported = function supported2() {
          var contextOptions = {
            stencil: true,
            failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
          };
          try {
            if (!window.WebGLRenderingContext) {
              return false;
            }
            var canvas2 = document.createElement("canvas");
            var gl = canvas2.getContext("webgl", contextOptions) || canvas2.getContext("experimental-webgl", contextOptions);
            var success = !!(gl && gl.getContextAttributes().stencil);
            if (gl) {
              var loseContext = gl.getExtension("WEBGL_lose_context");
              if (loseContext) {
                loseContext.loseContext();
              }
            }
            gl = null;
            return success;
          } catch (e) {
            return false;
          }
        }();
      }
      return supported;
    }
    function hex2rgb(hex, out) {
      if (out === void 0) {
        out = [];
      }
      out[0] = (hex >> 16 & 255) / 255;
      out[1] = (hex >> 8 & 255) / 255;
      out[2] = (hex & 255) / 255;
      return out;
    }
    function hex2string(hex) {
      var hexString = hex.toString(16);
      hexString = "000000".substr(0, 6 - hexString.length) + hexString;
      return "#" + hexString;
    }
    function string2hex(string) {
      if (typeof string === "string" && string[0] === "#") {
        string = string.substr(1);
      }
      return parseInt(string, 16);
    }
    function mapPremultipliedBlendModes() {
      var pm = [];
      var npm = [];
      for (var i = 0; i < 32; i++) {
        pm[i] = i;
        npm[i] = i;
      }
      pm[BLEND_MODES$1.NORMAL_NPM] = BLEND_MODES$1.NORMAL;
      pm[BLEND_MODES$1.ADD_NPM] = BLEND_MODES$1.ADD;
      pm[BLEND_MODES$1.SCREEN_NPM] = BLEND_MODES$1.SCREEN;
      npm[BLEND_MODES$1.NORMAL] = BLEND_MODES$1.NORMAL_NPM;
      npm[BLEND_MODES$1.ADD] = BLEND_MODES$1.ADD_NPM;
      npm[BLEND_MODES$1.SCREEN] = BLEND_MODES$1.SCREEN_NPM;
      var array = [];
      array.push(npm);
      array.push(pm);
      return array;
    }
    var premultiplyBlendMode = mapPremultipliedBlendModes();
    function correctBlendMode(blendMode, premultiplied) {
      return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
    }
    function premultiplyRgba(rgb, alpha, out, premultiply) {
      out = out || new Float32Array(4);
      if (premultiply || premultiply === void 0) {
        out[0] = rgb[0] * alpha;
        out[1] = rgb[1] * alpha;
        out[2] = rgb[2] * alpha;
      } else {
        out[0] = rgb[0];
        out[1] = rgb[1];
        out[2] = rgb[2];
      }
      out[3] = alpha;
      return out;
    }
    function premultiplyTint(tint, alpha) {
      if (alpha === 1) {
        return (alpha * 255 << 24) + tint;
      }
      if (alpha === 0) {
        return 0;
      }
      var R2 = tint >> 16 & 255;
      var G2 = tint >> 8 & 255;
      var B2 = tint & 255;
      R2 = R2 * alpha + 0.5 | 0;
      G2 = G2 * alpha + 0.5 | 0;
      B2 = B2 * alpha + 0.5 | 0;
      return (alpha * 255 << 24) + (R2 << 16) + (G2 << 8) + B2;
    }
    function premultiplyTintToRgba(tint, alpha, out, premultiply) {
      out = out || new Float32Array(4);
      out[0] = (tint >> 16 & 255) / 255;
      out[1] = (tint >> 8 & 255) / 255;
      out[2] = (tint & 255) / 255;
      if (premultiply || premultiply === void 0) {
        out[0] *= alpha;
        out[1] *= alpha;
        out[2] *= alpha;
      }
      out[3] = alpha;
      return out;
    }
    function createIndicesForQuads(size2, outBuffer) {
      if (outBuffer === void 0) {
        outBuffer = null;
      }
      var totalIndices = size2 * 6;
      outBuffer = outBuffer || new Uint16Array(totalIndices);
      if (outBuffer.length !== totalIndices) {
        throw new Error("Out buffer length is incorrect, got " + outBuffer.length + " and expected " + totalIndices);
      }
      for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
        outBuffer[i + 0] = j + 0;
        outBuffer[i + 1] = j + 1;
        outBuffer[i + 2] = j + 2;
        outBuffer[i + 3] = j + 0;
        outBuffer[i + 4] = j + 2;
        outBuffer[i + 5] = j + 3;
      }
      return outBuffer;
    }
    function nextPow2(v2) {
      v2 += v2 === 0 ? 1 : 0;
      --v2;
      v2 |= v2 >>> 1;
      v2 |= v2 >>> 2;
      v2 |= v2 >>> 4;
      v2 |= v2 >>> 8;
      v2 |= v2 >>> 16;
      return v2 + 1;
    }
    function isPow2(v2) {
      return !(v2 & v2 - 1) && !!v2;
    }
    function log2(v2) {
      var r2 = (v2 > 65535 ? 1 : 0) << 4;
      v2 >>>= r2;
      var shift = (v2 > 255 ? 1 : 0) << 3;
      v2 >>>= shift;
      r2 |= shift;
      shift = (v2 > 15 ? 1 : 0) << 2;
      v2 >>>= shift;
      r2 |= shift;
      shift = (v2 > 3 ? 1 : 0) << 1;
      v2 >>>= shift;
      r2 |= shift;
      return r2 | v2 >> 1;
    }
    function removeItems(arr, startIdx, removeCount) {
      var length = arr.length;
      var i;
      if (startIdx >= length || removeCount === 0) {
        return;
      }
      removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
      var len = length - removeCount;
      for (i = startIdx; i < len; ++i) {
        arr[i] = arr[i + removeCount];
      }
      arr.length = len;
    }
    function sign$1(n2) {
      if (n2 === 0) {
        return 0;
      }
      return n2 < 0 ? -1 : 1;
    }
    var nextUid = 0;
    function uid() {
      return ++nextUid;
    }
    var warnings = {};
    function deprecation(version2, message, ignoreDepth) {
      if (ignoreDepth === void 0) {
        ignoreDepth = 3;
      }
      if (warnings[message]) {
        return;
      }
      var stack = new Error().stack;
      if (typeof stack === "undefined") {
        console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version2);
      } else {
        stack = stack.split("\n").splice(ignoreDepth).join("\n");
        if (console.groupCollapsed) {
          console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", message + "\nDeprecated since v" + version2);
          console.warn(stack);
          console.groupEnd();
        } else {
          console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version2);
          console.warn(stack);
        }
      }
      warnings[message] = true;
    }
    var ProgramCache = {};
    var TextureCache = /* @__PURE__ */ Object.create(null);
    var BaseTextureCache = /* @__PURE__ */ Object.create(null);
    var CanvasRenderTarget = function() {
      function CanvasRenderTarget2(width2, height2, resolution) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        this.resolution = resolution || settings.RESOLUTION;
        this.resize(width2, height2);
      }
      CanvasRenderTarget2.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      };
      CanvasRenderTarget2.prototype.resize = function(width2, height2) {
        this.canvas.width = width2 * this.resolution;
        this.canvas.height = height2 * this.resolution;
      };
      CanvasRenderTarget2.prototype.destroy = function() {
        this.context = null;
        this.canvas = null;
      };
      Object.defineProperty(CanvasRenderTarget2.prototype, "width", {
        get: function() {
          return this.canvas.width;
        },
        set: function(val) {
          this.canvas.width = val;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CanvasRenderTarget2.prototype, "height", {
        get: function() {
          return this.canvas.height;
        },
        set: function(val) {
          this.canvas.height = val;
        },
        enumerable: false,
        configurable: true
      });
      return CanvasRenderTarget2;
    }();
    function trimCanvas(canvas2) {
      var width2 = canvas2.width;
      var height2 = canvas2.height;
      var context2 = canvas2.getContext("2d");
      var imageData = context2.getImageData(0, 0, width2, height2);
      var pixels = imageData.data;
      var len = pixels.length;
      var bound = {
        top: null,
        left: null,
        right: null,
        bottom: null
      };
      var data = null;
      var i;
      var x2;
      var y2;
      for (i = 0; i < len; i += 4) {
        if (pixels[i + 3] !== 0) {
          x2 = i / 4 % width2;
          y2 = ~~(i / 4 / width2);
          if (bound.top === null) {
            bound.top = y2;
          }
          if (bound.left === null) {
            bound.left = x2;
          } else if (x2 < bound.left) {
            bound.left = x2;
          }
          if (bound.right === null) {
            bound.right = x2 + 1;
          } else if (bound.right < x2) {
            bound.right = x2 + 1;
          }
          if (bound.bottom === null) {
            bound.bottom = y2;
          } else if (bound.bottom < y2) {
            bound.bottom = y2;
          }
        }
      }
      if (bound.top !== null) {
        width2 = bound.right - bound.left;
        height2 = bound.bottom - bound.top + 1;
        data = context2.getImageData(bound.left, bound.top, width2, height2);
      }
      return {
        height: height2,
        width: width2,
        data
      };
    }
    var tempAnchor$1;
    function determineCrossOrigin(url2, loc) {
      if (loc === void 0) {
        loc = window.location;
      }
      if (url2.indexOf("data:") === 0) {
        return "";
      }
      loc = loc || window.location;
      if (!tempAnchor$1) {
        tempAnchor$1 = document.createElement("a");
      }
      tempAnchor$1.href = url2;
      var parsedUrl = parse(tempAnchor$1.href);
      var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
      if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
        return "anonymous";
      }
      return "";
    }
    function getResolutionOfUrl(url2, defaultValue2) {
      var resolution = settings.RETINA_PREFIX.exec(url2);
      if (resolution) {
        return parseFloat(resolution[1]);
      }
      return defaultValue2 !== void 0 ? defaultValue2 : 1;
    }
    /*!
     * @pixi/math - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/math is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var PI_2 = Math.PI * 2;
    var RAD_TO_DEG = 180 / Math.PI;
    var DEG_TO_RAD = Math.PI / 180;
    var SHAPES;
    (function(SHAPES2) {
      SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
      SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
      SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
      SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
      SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
    })(SHAPES || (SHAPES = {}));
    var Rectangle = function() {
      function Rectangle2(x2, y2, width2, height2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (width2 === void 0) {
          width2 = 0;
        }
        if (height2 === void 0) {
          height2 = 0;
        }
        this.x = Number(x2);
        this.y = Number(y2);
        this.width = Number(width2);
        this.height = Number(height2);
        this.type = SHAPES.RECT;
      }
      Object.defineProperty(Rectangle2.prototype, "left", {
        get: function() {
          return this.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle2.prototype, "right", {
        get: function() {
          return this.x + this.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle2.prototype, "top", {
        get: function() {
          return this.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle2.prototype, "bottom", {
        get: function() {
          return this.y + this.height;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle2, "EMPTY", {
        get: function() {
          return new Rectangle2(0, 0, 0, 0);
        },
        enumerable: false,
        configurable: true
      });
      Rectangle2.prototype.clone = function() {
        return new Rectangle2(this.x, this.y, this.width, this.height);
      };
      Rectangle2.prototype.copyFrom = function(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      };
      Rectangle2.prototype.copyTo = function(rectangle) {
        rectangle.x = this.x;
        rectangle.y = this.y;
        rectangle.width = this.width;
        rectangle.height = this.height;
        return rectangle;
      };
      Rectangle2.prototype.contains = function(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x2 >= this.x && x2 < this.x + this.width) {
          if (y2 >= this.y && y2 < this.y + this.height) {
            return true;
          }
        }
        return false;
      };
      Rectangle2.prototype.pad = function(paddingX, paddingY) {
        if (paddingX === void 0) {
          paddingX = 0;
        }
        if (paddingY === void 0) {
          paddingY = paddingX;
        }
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
      };
      Rectangle2.prototype.fit = function(rectangle) {
        var x1 = Math.max(this.x, rectangle.x);
        var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.max(this.y, rectangle.y);
        var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x2 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
        return this;
      };
      Rectangle2.prototype.ceil = function(resolution, eps) {
        if (resolution === void 0) {
          resolution = 1;
        }
        if (eps === void 0) {
          eps = 1e-3;
        }
        var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x2 - this.x;
        this.height = y2 - this.y;
        return this;
      };
      Rectangle2.prototype.enlarge = function(rectangle) {
        var x1 = Math.min(this.x, rectangle.x);
        var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.min(this.y, rectangle.y);
        var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
        return this;
      };
      return Rectangle2;
    }();
    var Circle = function() {
      function Circle2(x2, y2, radius) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (radius === void 0) {
          radius = 0;
        }
        this.x = x2;
        this.y = y2;
        this.radius = radius;
        this.type = SHAPES.CIRC;
      }
      Circle2.prototype.clone = function() {
        return new Circle2(this.x, this.y, this.radius);
      };
      Circle2.prototype.contains = function(x2, y2) {
        if (this.radius <= 0) {
          return false;
        }
        var r2 = this.radius * this.radius;
        var dx = this.x - x2;
        var dy = this.y - y2;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
      };
      Circle2.prototype.getBounds = function() {
        return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
      };
      return Circle2;
    }();
    var Ellipse = function() {
      function Ellipse2(x2, y2, halfWidth, halfHeight) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (halfWidth === void 0) {
          halfWidth = 0;
        }
        if (halfHeight === void 0) {
          halfHeight = 0;
        }
        this.x = x2;
        this.y = y2;
        this.width = halfWidth;
        this.height = halfHeight;
        this.type = SHAPES.ELIP;
      }
      Ellipse2.prototype.clone = function() {
        return new Ellipse2(this.x, this.y, this.width, this.height);
      };
      Ellipse2.prototype.contains = function(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        var normx = (x2 - this.x) / this.width;
        var normy = (y2 - this.y) / this.height;
        normx *= normx;
        normy *= normy;
        return normx + normy <= 1;
      };
      Ellipse2.prototype.getBounds = function() {
        return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
      };
      return Ellipse2;
    }();
    var Polygon = function() {
      function Polygon2() {
        var arguments$1 = arguments;
        var points = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          points[_i] = arguments$1[_i];
        }
        var flat = Array.isArray(points[0]) ? points[0] : points;
        if (typeof flat[0] !== "number") {
          var p2 = [];
          for (var i = 0, il = flat.length; i < il; i++) {
            p2.push(flat[i].x, flat[i].y);
          }
          flat = p2;
        }
        this.points = flat;
        this.type = SHAPES.POLY;
        this.closeStroke = true;
      }
      Polygon2.prototype.clone = function() {
        var points = this.points.slice();
        var polygon = new Polygon2(points);
        polygon.closeStroke = this.closeStroke;
        return polygon;
      };
      Polygon2.prototype.contains = function(x2, y2) {
        var inside = false;
        var length = this.points.length / 2;
        for (var i = 0, j = length - 1; i < length; j = i++) {
          var xi2 = this.points[i * 2];
          var yi2 = this.points[i * 2 + 1];
          var xj2 = this.points[j * 2];
          var yj2 = this.points[j * 2 + 1];
          var intersect = yi2 > y2 !== yj2 > y2 && x2 < (xj2 - xi2) * ((y2 - yi2) / (yj2 - yi2)) + xi2;
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      };
      return Polygon2;
    }();
    var RoundedRectangle = function() {
      function RoundedRectangle2(x2, y2, width2, height2, radius) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (width2 === void 0) {
          width2 = 0;
        }
        if (height2 === void 0) {
          height2 = 0;
        }
        if (radius === void 0) {
          radius = 20;
        }
        this.x = x2;
        this.y = y2;
        this.width = width2;
        this.height = height2;
        this.radius = radius;
        this.type = SHAPES.RREC;
      }
      RoundedRectangle2.prototype.clone = function() {
        return new RoundedRectangle2(this.x, this.y, this.width, this.height, this.radius);
      };
      RoundedRectangle2.prototype.contains = function(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x2 >= this.x && x2 <= this.x + this.width) {
          if (y2 >= this.y && y2 <= this.y + this.height) {
            if (y2 >= this.y + this.radius && y2 <= this.y + this.height - this.radius || x2 >= this.x + this.radius && x2 <= this.x + this.width - this.radius) {
              return true;
            }
            var dx = x2 - (this.x + this.radius);
            var dy = y2 - (this.y + this.radius);
            var radius2 = this.radius * this.radius;
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x2 - (this.x + this.width - this.radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dy = y2 - (this.y + this.height - this.radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x2 - (this.x + this.radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
          }
        }
        return false;
      };
      return RoundedRectangle2;
    }();
    var Point = function() {
      function Point2(x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        this.x = x2;
        this.y = y2;
      }
      Point2.prototype.clone = function() {
        return new Point2(this.x, this.y);
      };
      Point2.prototype.copyFrom = function(p2) {
        this.set(p2.x, p2.y);
        return this;
      };
      Point2.prototype.copyTo = function(p2) {
        p2.set(this.x, this.y);
        return p2;
      };
      Point2.prototype.equals = function(p2) {
        return p2.x === this.x && p2.y === this.y;
      };
      Point2.prototype.set = function(x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = x2;
        }
        this.x = x2;
        this.y = y2;
        return this;
      };
      return Point2;
    }();
    var ObservablePoint = function() {
      function ObservablePoint2(cb2, scope, x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        this._x = x2;
        this._y = y2;
        this.cb = cb2;
        this.scope = scope;
      }
      ObservablePoint2.prototype.clone = function(cb2, scope) {
        if (cb2 === void 0) {
          cb2 = this.cb;
        }
        if (scope === void 0) {
          scope = this.scope;
        }
        return new ObservablePoint2(cb2, scope, this._x, this._y);
      };
      ObservablePoint2.prototype.set = function(x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = x2;
        }
        if (this._x !== x2 || this._y !== y2) {
          this._x = x2;
          this._y = y2;
          this.cb.call(this.scope);
        }
        return this;
      };
      ObservablePoint2.prototype.copyFrom = function(p2) {
        if (this._x !== p2.x || this._y !== p2.y) {
          this._x = p2.x;
          this._y = p2.y;
          this.cb.call(this.scope);
        }
        return this;
      };
      ObservablePoint2.prototype.copyTo = function(p2) {
        p2.set(this._x, this._y);
        return p2;
      };
      ObservablePoint2.prototype.equals = function(p2) {
        return p2.x === this._x && p2.y === this._y;
      };
      Object.defineProperty(ObservablePoint2.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(value2) {
          if (this._x !== value2) {
            this._x = value2;
            this.cb.call(this.scope);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ObservablePoint2.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(value2) {
          if (this._y !== value2) {
            this._y = value2;
            this.cb.call(this.scope);
          }
        },
        enumerable: false,
        configurable: true
      });
      return ObservablePoint2;
    }();
    var Matrix = function() {
      function Matrix2(a, b, c, d, tx, ty) {
        if (a === void 0) {
          a = 1;
        }
        if (b === void 0) {
          b = 0;
        }
        if (c === void 0) {
          c = 0;
        }
        if (d === void 0) {
          d = 1;
        }
        if (tx === void 0) {
          tx = 0;
        }
        if (ty === void 0) {
          ty = 0;
        }
        this.array = null;
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
      }
      Matrix2.prototype.fromArray = function(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
      };
      Matrix2.prototype.set = function(a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        return this;
      };
      Matrix2.prototype.toArray = function(transpose, out) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        var array = out || this.array;
        if (transpose) {
          array[0] = this.a;
          array[1] = this.b;
          array[2] = 0;
          array[3] = this.c;
          array[4] = this.d;
          array[5] = 0;
          array[6] = this.tx;
          array[7] = this.ty;
          array[8] = 1;
        } else {
          array[0] = this.a;
          array[1] = this.c;
          array[2] = this.tx;
          array[3] = this.b;
          array[4] = this.d;
          array[5] = this.ty;
          array[6] = 0;
          array[7] = 0;
          array[8] = 1;
        }
        return array;
      };
      Matrix2.prototype.apply = function(pos, newPos) {
        newPos = newPos || new Point();
        var x2 = pos.x;
        var y2 = pos.y;
        newPos.x = this.a * x2 + this.c * y2 + this.tx;
        newPos.y = this.b * x2 + this.d * y2 + this.ty;
        return newPos;
      };
      Matrix2.prototype.applyInverse = function(pos, newPos) {
        newPos = newPos || new Point();
        var id2 = 1 / (this.a * this.d + this.c * -this.b);
        var x2 = pos.x;
        var y2 = pos.y;
        newPos.x = this.d * id2 * x2 + -this.c * id2 * y2 + (this.ty * this.c - this.tx * this.d) * id2;
        newPos.y = this.a * id2 * y2 + -this.b * id2 * x2 + (-this.ty * this.a + this.tx * this.b) * id2;
        return newPos;
      };
      Matrix2.prototype.translate = function(x2, y2) {
        this.tx += x2;
        this.ty += y2;
        return this;
      };
      Matrix2.prototype.scale = function(x2, y2) {
        this.a *= x2;
        this.d *= y2;
        this.c *= x2;
        this.b *= y2;
        this.tx *= x2;
        this.ty *= y2;
        return this;
      };
      Matrix2.prototype.rotate = function(angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      };
      Matrix2.prototype.append = function(matrix) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      };
      Matrix2.prototype.setTransform = function(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x2 - (pivotX * this.a + pivotY * this.c);
        this.ty = y2 - (pivotX * this.b + pivotY * this.d);
        return this;
      };
      Matrix2.prototype.prepend = function(matrix) {
        var tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          var a1 = this.a;
          var c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      };
      Matrix2.prototype.decompose = function(transform) {
        var a = this.a;
        var b = this.b;
        var c = this.c;
        var d = this.d;
        var skewX = -Math.atan2(-c, d);
        var skewY = Math.atan2(b, a);
        var delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
          transform.rotation = skewY;
          transform.skew.x = transform.skew.y = 0;
        } else {
          transform.rotation = 0;
          transform.skew.x = skewX;
          transform.skew.y = skewY;
        }
        transform.scale.x = Math.sqrt(a * a + b * b);
        transform.scale.y = Math.sqrt(c * c + d * d);
        transform.position.x = this.tx;
        transform.position.y = this.ty;
        return transform;
      };
      Matrix2.prototype.invert = function() {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n2 = a1 * d1 - b1 * c1;
        this.a = d1 / n2;
        this.b = -b1 / n2;
        this.c = -c1 / n2;
        this.d = a1 / n2;
        this.tx = (c1 * this.ty - d1 * tx1) / n2;
        this.ty = -(a1 * this.ty - b1 * tx1) / n2;
        return this;
      };
      Matrix2.prototype.identity = function() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      };
      Matrix2.prototype.clone = function() {
        var matrix = new Matrix2();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      };
      Matrix2.prototype.copyTo = function(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      };
      Matrix2.prototype.copyFrom = function(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
      };
      Object.defineProperty(Matrix2, "IDENTITY", {
        get: function() {
          return new Matrix2();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Matrix2, "TEMP_MATRIX", {
        get: function() {
          return new Matrix2();
        },
        enumerable: false,
        configurable: true
      });
      return Matrix2;
    }();
    var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
    var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
    var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
    var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
    var rotationCayley = [];
    var rotationMatrices = [];
    var signum = Math.sign;
    function init() {
      for (var i = 0; i < 16; i++) {
        var row = [];
        rotationCayley.push(row);
        for (var j = 0; j < 16; j++) {
          var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
          var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
          var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
          var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
          for (var k = 0; k < 16; k++) {
            if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
              row.push(k);
              break;
            }
          }
        }
      }
      for (var i = 0; i < 16; i++) {
        var mat = new Matrix();
        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
        rotationMatrices.push(mat);
      }
    }
    init();
    var groupD8 = {
      E: 0,
      SE: 1,
      S: 2,
      SW: 3,
      W: 4,
      NW: 5,
      N: 6,
      NE: 7,
      MIRROR_VERTICAL: 8,
      MAIN_DIAGONAL: 10,
      MIRROR_HORIZONTAL: 12,
      REVERSE_DIAGONAL: 14,
      uX: function(ind) {
        return ux[ind];
      },
      uY: function(ind) {
        return uy[ind];
      },
      vX: function(ind) {
        return vx[ind];
      },
      vY: function(ind) {
        return vy[ind];
      },
      inv: function(rotation) {
        if (rotation & 8) {
          return rotation & 15;
        }
        return -rotation & 7;
      },
      add: function(rotationSecond, rotationFirst) {
        return rotationCayley[rotationSecond][rotationFirst];
      },
      sub: function(rotationSecond, rotationFirst) {
        return rotationCayley[rotationSecond][groupD8.inv(rotationFirst)];
      },
      rotate180: function(rotation) {
        return rotation ^ 4;
      },
      isVertical: function(rotation) {
        return (rotation & 3) === 2;
      },
      byDirection: function(dx, dy) {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
          if (dy >= 0) {
            return groupD8.S;
          }
          return groupD8.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
          if (dx > 0) {
            return groupD8.E;
          }
          return groupD8.W;
        } else if (dy > 0) {
          if (dx > 0) {
            return groupD8.SE;
          }
          return groupD8.SW;
        } else if (dx > 0) {
          return groupD8.NE;
        }
        return groupD8.NW;
      },
      matrixAppendRotationInv: function(matrix, rotation, tx, ty) {
        if (tx === void 0) {
          tx = 0;
        }
        if (ty === void 0) {
          ty = 0;
        }
        var mat = rotationMatrices[groupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
      }
    };
    var Transform = function() {
      function Transform2() {
        this.worldTransform = new Matrix();
        this.localTransform = new Matrix();
        this.position = new ObservablePoint(this.onChange, this, 0, 0);
        this.scale = new ObservablePoint(this.onChange, this, 1, 1);
        this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
        this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
        this._rotation = 0;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
        this._localID = 0;
        this._currentLocalID = 0;
        this._worldID = 0;
        this._parentID = 0;
      }
      Transform2.prototype.onChange = function() {
        this._localID++;
      };
      Transform2.prototype.updateSkew = function() {
        this._cx = Math.cos(this._rotation + this.skew.y);
        this._sx = Math.sin(this._rotation + this.skew.y);
        this._cy = -Math.sin(this._rotation - this.skew.x);
        this._sy = Math.cos(this._rotation - this.skew.x);
        this._localID++;
      };
      Transform2.prototype.updateLocalTransform = function() {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
          lt.a = this._cx * this.scale.x;
          lt.b = this._sx * this.scale.x;
          lt.c = this._cy * this.scale.y;
          lt.d = this._sy * this.scale.y;
          lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
          lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
          this._currentLocalID = this._localID;
          this._parentID = -1;
        }
      };
      Transform2.prototype.updateTransform = function(parentTransform) {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
          lt.a = this._cx * this.scale.x;
          lt.b = this._sx * this.scale.x;
          lt.c = this._cy * this.scale.y;
          lt.d = this._sy * this.scale.y;
          lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
          lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
          this._currentLocalID = this._localID;
          this._parentID = -1;
        }
        if (this._parentID !== parentTransform._worldID) {
          var pt = parentTransform.worldTransform;
          var wt = this.worldTransform;
          wt.a = lt.a * pt.a + lt.b * pt.c;
          wt.b = lt.a * pt.b + lt.b * pt.d;
          wt.c = lt.c * pt.a + lt.d * pt.c;
          wt.d = lt.c * pt.b + lt.d * pt.d;
          wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
          wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
          this._parentID = parentTransform._worldID;
          this._worldID++;
        }
      };
      Transform2.prototype.setFromMatrix = function(matrix) {
        matrix.decompose(this);
        this._localID++;
      };
      Object.defineProperty(Transform2.prototype, "rotation", {
        get: function() {
          return this._rotation;
        },
        set: function(value2) {
          if (this._rotation !== value2) {
            this._rotation = value2;
            this.updateSkew();
          }
        },
        enumerable: false,
        configurable: true
      });
      Transform2.IDENTITY = new Transform2();
      return Transform2;
    }();
    /*!
     * @pixi/display - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/display is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    settings.SORTABLE_CHILDREN = false;
    var Bounds = function() {
      function Bounds2() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.rect = null;
        this.updateID = -1;
      }
      Bounds2.prototype.isEmpty = function() {
        return this.minX > this.maxX || this.minY > this.maxY;
      };
      Bounds2.prototype.clear = function() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
      };
      Bounds2.prototype.getRectangle = function(rect) {
        if (this.minX > this.maxX || this.minY > this.maxY) {
          return Rectangle.EMPTY;
        }
        rect = rect || new Rectangle(0, 0, 1, 1);
        rect.x = this.minX;
        rect.y = this.minY;
        rect.width = this.maxX - this.minX;
        rect.height = this.maxY - this.minY;
        return rect;
      };
      Bounds2.prototype.addPoint = function(point) {
        this.minX = Math.min(this.minX, point.x);
        this.maxX = Math.max(this.maxX, point.x);
        this.minY = Math.min(this.minY, point.y);
        this.maxY = Math.max(this.maxY, point.y);
      };
      Bounds2.prototype.addQuad = function(vertices) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x2 = vertices[0];
        var y2 = vertices[1];
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = vertices[2];
        y2 = vertices[3];
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = vertices[4];
        y2 = vertices[5];
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = vertices[6];
        y2 = vertices[7];
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds2.prototype.addFrame = function(transform, x0, y0, x1, y1) {
        this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
      };
      Bounds2.prototype.addFrameMatrix = function(matrix, x0, y0, x1, y1) {
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x2 = a * x0 + c * y0 + tx;
        var y2 = b * x0 + d * y0 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = a * x1 + c * y0 + tx;
        y2 = b * x1 + d * y0 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = a * x0 + c * y1 + tx;
        y2 = b * x0 + d * y1 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = a * x1 + c * y1 + tx;
        y2 = b * x1 + d * y1 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds2.prototype.addVertexData = function(vertexData, beginOffset, endOffset) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
          var x2 = vertexData[i];
          var y2 = vertexData[i + 1];
          minX = x2 < minX ? x2 : minX;
          minY = y2 < minY ? y2 : minY;
          maxX = x2 > maxX ? x2 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds2.prototype.addVertices = function(transform, vertices, beginOffset, endOffset) {
        this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
      };
      Bounds2.prototype.addVerticesMatrix = function(matrix, vertices, beginOffset, endOffset, padX, padY) {
        if (padX === void 0) {
          padX = 0;
        }
        if (padY === void 0) {
          padY = padX;
        }
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
          var rawX = vertices[i];
          var rawY = vertices[i + 1];
          var x2 = a * rawX + c * rawY + tx;
          var y2 = d * rawY + b * rawX + ty;
          minX = Math.min(minX, x2 - padX);
          maxX = Math.max(maxX, x2 + padX);
          minY = Math.min(minY, y2 - padY);
          maxY = Math.max(maxY, y2 + padY);
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds2.prototype.addBounds = function(bounds) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = bounds.minX < minX ? bounds.minX : minX;
        this.minY = bounds.minY < minY ? bounds.minY : minY;
        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
      };
      Bounds2.prototype.addBoundsMask = function(bounds, mask) {
        var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
        var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
        var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
        var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
        if (_minX <= _maxX && _minY <= _maxY) {
          var minX = this.minX;
          var minY = this.minY;
          var maxX = this.maxX;
          var maxY = this.maxY;
          this.minX = _minX < minX ? _minX : minX;
          this.minY = _minY < minY ? _minY : minY;
          this.maxX = _maxX > maxX ? _maxX : maxX;
          this.maxY = _maxY > maxY ? _maxY : maxY;
        }
      };
      Bounds2.prototype.addBoundsMatrix = function(bounds, matrix) {
        this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
      };
      Bounds2.prototype.addBoundsArea = function(bounds, area2) {
        var _minX = bounds.minX > area2.x ? bounds.minX : area2.x;
        var _minY = bounds.minY > area2.y ? bounds.minY : area2.y;
        var _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width;
        var _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;
        if (_minX <= _maxX && _minY <= _maxY) {
          var minX = this.minX;
          var minY = this.minY;
          var maxX = this.maxX;
          var maxY = this.maxY;
          this.minX = _minX < minX ? _minX : minX;
          this.minY = _minY < minY ? _minY : minY;
          this.maxX = _maxX > maxX ? _maxX : maxX;
          this.maxY = _maxY > maxY ? _maxY : maxY;
        }
      };
      Bounds2.prototype.pad = function(paddingX, paddingY) {
        if (paddingX === void 0) {
          paddingX = 0;
        }
        if (paddingY === void 0) {
          paddingY = paddingX;
        }
        if (!this.isEmpty()) {
          this.minX -= paddingX;
          this.maxX += paddingX;
          this.minY -= paddingY;
          this.maxY += paddingY;
        }
      };
      Bounds2.prototype.addFramePad = function(x0, y0, x1, y1, padX, padY) {
        x0 -= padX;
        y0 -= padY;
        x1 += padX;
        y1 += padY;
        this.minX = this.minX < x0 ? this.minX : x0;
        this.maxX = this.maxX > x1 ? this.maxX : x1;
        this.minY = this.minY < y0 ? this.minY : y0;
        this.maxY = this.maxY > y1 ? this.maxY : y1;
      };
      return Bounds2;
    }();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$j = function(d, b) {
      extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$j(d, b);
    };
    function __extends$j(d, b) {
      extendStatics$j(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var DisplayObject = function(_super) {
      __extends$j(DisplayObject2, _super);
      function DisplayObject2() {
        var _this = _super.call(this) || this;
        _this.tempDisplayObjectParent = null;
        _this.transform = new Transform();
        _this.alpha = 1;
        _this.visible = true;
        _this.renderable = true;
        _this.parent = null;
        _this.worldAlpha = 1;
        _this._lastSortedIndex = 0;
        _this._zIndex = 0;
        _this.filterArea = null;
        _this.filters = null;
        _this._enabledFilters = null;
        _this._bounds = new Bounds();
        _this._localBounds = null;
        _this._boundsID = 0;
        _this._boundsRect = null;
        _this._localBoundsRect = null;
        _this._mask = null;
        _this._destroyed = false;
        _this.isSprite = false;
        _this.isMask = false;
        return _this;
      }
      DisplayObject2.mixin = function(source) {
        var keys2 = Object.keys(source);
        for (var i = 0; i < keys2.length; ++i) {
          var propertyName = keys2[i];
          Object.defineProperty(DisplayObject2.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
      };
      DisplayObject2.prototype._recursivePostUpdateTransform = function() {
        if (this.parent) {
          this.parent._recursivePostUpdateTransform();
          this.transform.updateTransform(this.parent.transform);
        } else {
          this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
      };
      DisplayObject2.prototype.updateTransform = function() {
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
      };
      DisplayObject2.prototype.getBounds = function(skipUpdate, rect) {
        if (!skipUpdate) {
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
          } else {
            this._recursivePostUpdateTransform();
            this.updateTransform();
          }
        }
        if (this._bounds.updateID !== this._boundsID) {
          this.calculateBounds();
          this._bounds.updateID = this._boundsID;
        }
        if (!rect) {
          if (!this._boundsRect) {
            this._boundsRect = new Rectangle();
          }
          rect = this._boundsRect;
        }
        return this._bounds.getRectangle(rect);
      };
      DisplayObject2.prototype.getLocalBounds = function(rect) {
        if (!rect) {
          if (!this._localBoundsRect) {
            this._localBoundsRect = new Rectangle();
          }
          rect = this._localBoundsRect;
        }
        if (!this._localBounds) {
          this._localBounds = new Bounds();
        }
        var transformRef = this.transform;
        var parentRef = this.parent;
        this.parent = null;
        this.transform = this._tempDisplayObjectParent.transform;
        var worldBounds = this._bounds;
        var worldBoundsID = this._boundsID;
        this._bounds = this._localBounds;
        var bounds = this.getBounds(false, rect);
        this.parent = parentRef;
        this.transform = transformRef;
        this._bounds = worldBounds;
        this._bounds.updateID += this._boundsID - worldBoundsID;
        return bounds;
      };
      DisplayObject2.prototype.toGlobal = function(position, point, skipUpdate) {
        if (skipUpdate === void 0) {
          skipUpdate = false;
        }
        if (!skipUpdate) {
          this._recursivePostUpdateTransform();
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.displayObjectUpdateTransform();
            this.parent = null;
          } else {
            this.displayObjectUpdateTransform();
          }
        }
        return this.worldTransform.apply(position, point);
      };
      DisplayObject2.prototype.toLocal = function(position, from2, point, skipUpdate) {
        if (from2) {
          position = from2.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
          this._recursivePostUpdateTransform();
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.displayObjectUpdateTransform();
            this.parent = null;
          } else {
            this.displayObjectUpdateTransform();
          }
        }
        return this.worldTransform.applyInverse(position, point);
      };
      DisplayObject2.prototype.setParent = function(container) {
        if (!container || !container.addChild) {
          throw new Error("setParent: Argument must be a Container");
        }
        container.addChild(this);
        return container;
      };
      DisplayObject2.prototype.setTransform = function(x2, y2, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (scaleX === void 0) {
          scaleX = 1;
        }
        if (scaleY === void 0) {
          scaleY = 1;
        }
        if (rotation === void 0) {
          rotation = 0;
        }
        if (skewX === void 0) {
          skewX = 0;
        }
        if (skewY === void 0) {
          skewY = 0;
        }
        if (pivotX === void 0) {
          pivotX = 0;
        }
        if (pivotY === void 0) {
          pivotY = 0;
        }
        this.position.x = x2;
        this.position.y = y2;
        this.scale.x = !scaleX ? 1 : scaleX;
        this.scale.y = !scaleY ? 1 : scaleY;
        this.rotation = rotation;
        this.skew.x = skewX;
        this.skew.y = skewY;
        this.pivot.x = pivotX;
        this.pivot.y = pivotY;
        return this;
      };
      DisplayObject2.prototype.destroy = function(_options) {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.removeAllListeners();
        this.transform = null;
        this.parent = null;
        this._bounds = null;
        this._mask = null;
        this.filters = null;
        this.filterArea = null;
        this.hitArea = null;
        this.interactive = false;
        this.interactiveChildren = false;
        this._destroyed = true;
      };
      Object.defineProperty(DisplayObject2.prototype, "_tempDisplayObjectParent", {
        get: function() {
          if (this.tempDisplayObjectParent === null) {
            this.tempDisplayObjectParent = new TemporaryDisplayObject();
          }
          return this.tempDisplayObjectParent;
        },
        enumerable: false,
        configurable: true
      });
      DisplayObject2.prototype.enableTempParent = function() {
        var myParent = this.parent;
        this.parent = this._tempDisplayObjectParent;
        return myParent;
      };
      DisplayObject2.prototype.disableTempParent = function(cacheParent) {
        this.parent = cacheParent;
      };
      Object.defineProperty(DisplayObject2.prototype, "x", {
        get: function() {
          return this.position.x;
        },
        set: function(value2) {
          this.transform.position.x = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "y", {
        get: function() {
          return this.position.y;
        },
        set: function(value2) {
          this.transform.position.y = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "worldTransform", {
        get: function() {
          return this.transform.worldTransform;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "localTransform", {
        get: function() {
          return this.transform.localTransform;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "position", {
        get: function() {
          return this.transform.position;
        },
        set: function(value2) {
          this.transform.position.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "scale", {
        get: function() {
          return this.transform.scale;
        },
        set: function(value2) {
          this.transform.scale.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "pivot", {
        get: function() {
          return this.transform.pivot;
        },
        set: function(value2) {
          this.transform.pivot.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "skew", {
        get: function() {
          return this.transform.skew;
        },
        set: function(value2) {
          this.transform.skew.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "rotation", {
        get: function() {
          return this.transform.rotation;
        },
        set: function(value2) {
          this.transform.rotation = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "angle", {
        get: function() {
          return this.transform.rotation * RAD_TO_DEG;
        },
        set: function(value2) {
          this.transform.rotation = value2 * DEG_TO_RAD;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "zIndex", {
        get: function() {
          return this._zIndex;
        },
        set: function(value2) {
          this._zIndex = value2;
          if (this.parent) {
            this.parent.sortDirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "worldVisible", {
        get: function() {
          var item = this;
          do {
            if (!item.visible) {
              return false;
            }
            item = item.parent;
          } while (item);
          return true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "mask", {
        get: function() {
          return this._mask;
        },
        set: function(value2) {
          if (this._mask) {
            var maskObject = this._mask.maskObject || this._mask;
            maskObject.renderable = true;
            maskObject.isMask = false;
          }
          this._mask = value2;
          if (this._mask) {
            var maskObject = this._mask.maskObject || this._mask;
            maskObject.renderable = false;
            maskObject.isMask = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      return DisplayObject2;
    }(EventEmitter);
    var TemporaryDisplayObject = function(_super) {
      __extends$j(TemporaryDisplayObject2, _super);
      function TemporaryDisplayObject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.sortDirty = null;
        return _this;
      }
      return TemporaryDisplayObject2;
    }(DisplayObject);
    DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
    function sortChildren(a, b) {
      if (a.zIndex === b.zIndex) {
        return a._lastSortedIndex - b._lastSortedIndex;
      }
      return a.zIndex - b.zIndex;
    }
    var Container = function(_super) {
      __extends$j(Container2, _super);
      function Container2() {
        var _this = _super.call(this) || this;
        _this.children = [];
        _this.sortableChildren = settings.SORTABLE_CHILDREN;
        _this.sortDirty = false;
        return _this;
      }
      Container2.prototype.onChildrenChange = function(_length) {
      };
      Container2.prototype.addChild = function() {
        var arguments$1 = arguments;
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          children[_i] = arguments$1[_i];
        }
        if (children.length > 1) {
          for (var i = 0; i < children.length; i++) {
            this.addChild(children[i]);
          }
        } else {
          var child = children[0];
          if (child.parent) {
            child.parent.removeChild(child);
          }
          child.parent = this;
          this.sortDirty = true;
          child.transform._parentID = -1;
          this.children.push(child);
          this._boundsID++;
          this.onChildrenChange(this.children.length - 1);
          this.emit("childAdded", child, this, this.children.length - 1);
          child.emit("added", this);
        }
        return children[0];
      };
      Container2.prototype.addChildAt = function(child, index2) {
        if (index2 < 0 || index2 > this.children.length) {
          throw new Error(child + "addChildAt: The index " + index2 + " supplied is out of bounds " + this.children.length);
        }
        if (child.parent) {
          child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        child.transform._parentID = -1;
        this.children.splice(index2, 0, child);
        this._boundsID++;
        this.onChildrenChange(index2);
        child.emit("added", this);
        this.emit("childAdded", child, this, index2);
        return child;
      };
      Container2.prototype.swapChildren = function(child, child2) {
        if (child === child2) {
          return;
        }
        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
      };
      Container2.prototype.getChildIndex = function(child) {
        var index2 = this.children.indexOf(child);
        if (index2 === -1) {
          throw new Error("The supplied DisplayObject must be a child of the caller");
        }
        return index2;
      };
      Container2.prototype.setChildIndex = function(child, index2) {
        if (index2 < 0 || index2 >= this.children.length) {
          throw new Error("The index " + index2 + " supplied is out of bounds " + this.children.length);
        }
        var currentIndex = this.getChildIndex(child);
        removeItems(this.children, currentIndex, 1);
        this.children.splice(index2, 0, child);
        this.onChildrenChange(index2);
      };
      Container2.prototype.getChildAt = function(index2) {
        if (index2 < 0 || index2 >= this.children.length) {
          throw new Error("getChildAt: Index (" + index2 + ") does not exist.");
        }
        return this.children[index2];
      };
      Container2.prototype.removeChild = function() {
        var arguments$1 = arguments;
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          children[_i] = arguments$1[_i];
        }
        if (children.length > 1) {
          for (var i = 0; i < children.length; i++) {
            this.removeChild(children[i]);
          }
        } else {
          var child = children[0];
          var index2 = this.children.indexOf(child);
          if (index2 === -1) {
            return null;
          }
          child.parent = null;
          child.transform._parentID = -1;
          removeItems(this.children, index2, 1);
          this._boundsID++;
          this.onChildrenChange(index2);
          child.emit("removed", this);
          this.emit("childRemoved", child, this, index2);
        }
        return children[0];
      };
      Container2.prototype.removeChildAt = function(index2) {
        var child = this.getChildAt(index2);
        child.parent = null;
        child.transform._parentID = -1;
        removeItems(this.children, index2, 1);
        this._boundsID++;
        this.onChildrenChange(index2);
        child.emit("removed", this);
        this.emit("childRemoved", child, this, index2);
        return child;
      };
      Container2.prototype.removeChildren = function(beginIndex, endIndex) {
        if (beginIndex === void 0) {
          beginIndex = 0;
        }
        if (endIndex === void 0) {
          endIndex = this.children.length;
        }
        var begin = beginIndex;
        var end = endIndex;
        var range2 = end - begin;
        var removed;
        if (range2 > 0 && range2 <= end) {
          removed = this.children.splice(begin, range2);
          for (var i = 0; i < removed.length; ++i) {
            removed[i].parent = null;
            if (removed[i].transform) {
              removed[i].transform._parentID = -1;
            }
          }
          this._boundsID++;
          this.onChildrenChange(beginIndex);
          for (var i = 0; i < removed.length; ++i) {
            removed[i].emit("removed", this);
            this.emit("childRemoved", removed[i], this, i);
          }
          return removed;
        } else if (range2 === 0 && this.children.length === 0) {
          return [];
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
      };
      Container2.prototype.sortChildren = function() {
        var sortRequired = false;
        for (var i = 0, j = this.children.length; i < j; ++i) {
          var child = this.children[i];
          child._lastSortedIndex = i;
          if (!sortRequired && child.zIndex !== 0) {
            sortRequired = true;
          }
        }
        if (sortRequired && this.children.length > 1) {
          this.children.sort(sortChildren);
        }
        this.sortDirty = false;
      };
      Container2.prototype.updateTransform = function() {
        if (this.sortableChildren && this.sortDirty) {
          this.sortChildren();
        }
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (var i = 0, j = this.children.length; i < j; ++i) {
          var child = this.children[i];
          if (child.visible) {
            child.updateTransform();
          }
        }
      };
      Container2.prototype.calculateBounds = function() {
        this._bounds.clear();
        this._calculateBounds();
        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          if (!child.visible || !child.renderable) {
            continue;
          }
          child.calculateBounds();
          if (child._mask) {
            var maskObject = child._mask.maskObject || child._mask;
            maskObject.calculateBounds();
            this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
          } else if (child.filterArea) {
            this._bounds.addBoundsArea(child._bounds, child.filterArea);
          } else {
            this._bounds.addBounds(child._bounds);
          }
        }
        this._bounds.updateID = this._boundsID;
      };
      Container2.prototype.getLocalBounds = function(rect, skipChildrenUpdate) {
        if (skipChildrenUpdate === void 0) {
          skipChildrenUpdate = false;
        }
        var result2 = _super.prototype.getLocalBounds.call(this, rect);
        if (!skipChildrenUpdate) {
          for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];
            if (child.visible) {
              child.updateTransform();
            }
          }
        }
        return result2;
      };
      Container2.prototype._calculateBounds = function() {
      };
      Container2.prototype.render = function(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
          return;
        }
        if (this._mask || this.filters && this.filters.length) {
          this.renderAdvanced(renderer);
        } else {
          this._render(renderer);
          for (var i = 0, j = this.children.length; i < j; ++i) {
            this.children[i].render(renderer);
          }
        }
      };
      Container2.prototype.renderAdvanced = function(renderer) {
        renderer.batch.flush();
        var filters = this.filters;
        var mask = this._mask;
        if (filters) {
          if (!this._enabledFilters) {
            this._enabledFilters = [];
          }
          this._enabledFilters.length = 0;
          for (var i = 0; i < filters.length; i++) {
            if (filters[i].enabled) {
              this._enabledFilters.push(filters[i]);
            }
          }
          if (this._enabledFilters.length) {
            renderer.filter.push(this, this._enabledFilters);
          }
        }
        if (mask) {
          renderer.mask.push(this, this._mask);
        }
        this._render(renderer);
        for (var i = 0, j = this.children.length; i < j; i++) {
          this.children[i].render(renderer);
        }
        renderer.batch.flush();
        if (mask) {
          renderer.mask.pop(this);
        }
        if (filters && this._enabledFilters && this._enabledFilters.length) {
          renderer.filter.pop();
        }
      };
      Container2.prototype._render = function(_renderer) {
      };
      Container2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this);
        this.sortDirty = false;
        var destroyChildren = typeof options === "boolean" ? options : options && options.children;
        var oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
          for (var i = 0; i < oldChildren.length; ++i) {
            oldChildren[i].destroy(options);
          }
        }
      };
      Object.defineProperty(Container2.prototype, "width", {
        get: function() {
          return this.scale.x * this.getLocalBounds().width;
        },
        set: function(value2) {
          var width2 = this.getLocalBounds().width;
          if (width2 !== 0) {
            this.scale.x = value2 / width2;
          } else {
            this.scale.x = 1;
          }
          this._width = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Container2.prototype, "height", {
        get: function() {
          return this.scale.y * this.getLocalBounds().height;
        },
        set: function(value2) {
          var height2 = this.getLocalBounds().height;
          if (height2 !== 0) {
            this.scale.y = value2 / height2;
          } else {
            this.scale.y = 1;
          }
          this._height = value2;
        },
        enumerable: false,
        configurable: true
      });
      return Container2;
    }(DisplayObject);
    Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
    /*!
     * @pixi/accessibility - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/accessibility is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var accessibleTarget = {
      accessible: false,
      accessibleTitle: null,
      accessibleHint: null,
      tabIndex: 0,
      _accessibleActive: false,
      _accessibleDiv: null,
      accessibleType: "button",
      accessiblePointerEvents: "auto",
      accessibleChildren: true,
      renderId: -1
    };
    DisplayObject.mixin(accessibleTarget);
    var KEY_CODE_TAB = 9;
    var DIV_TOUCH_SIZE = 100;
    var DIV_TOUCH_POS_X = 0;
    var DIV_TOUCH_POS_Y = 0;
    var DIV_TOUCH_ZINDEX = 2;
    var DIV_HOOK_SIZE = 1;
    var DIV_HOOK_POS_X = -1e3;
    var DIV_HOOK_POS_Y = -1e3;
    var DIV_HOOK_ZINDEX = 2;
    var AccessibilityManager = function() {
      function AccessibilityManager2(renderer) {
        this._hookDiv = null;
        if (isMobile.tablet || isMobile.phone) {
          this.createTouchHook();
        }
        var div = document.createElement("div");
        div.style.width = DIV_TOUCH_SIZE + "px";
        div.style.height = DIV_TOUCH_SIZE + "px";
        div.style.position = "absolute";
        div.style.top = DIV_TOUCH_POS_X + "px";
        div.style.left = DIV_TOUCH_POS_Y + "px";
        div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
        this.div = div;
        this.pool = [];
        this.renderId = 0;
        this.debug = false;
        this.renderer = renderer;
        this.children = [];
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        this._isActive = false;
        this._isMobileAccessibility = false;
        this.androidUpdateCount = 0;
        this.androidUpdateFrequency = 500;
        window.addEventListener("keydown", this._onKeyDown, false);
      }
      Object.defineProperty(AccessibilityManager2.prototype, "isActive", {
        get: function() {
          return this._isActive;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AccessibilityManager2.prototype, "isMobileAccessibility", {
        get: function() {
          return this._isMobileAccessibility;
        },
        enumerable: false,
        configurable: true
      });
      AccessibilityManager2.prototype.createTouchHook = function() {
        var _this = this;
        var hookDiv = document.createElement("button");
        hookDiv.style.width = DIV_HOOK_SIZE + "px";
        hookDiv.style.height = DIV_HOOK_SIZE + "px";
        hookDiv.style.position = "absolute";
        hookDiv.style.top = DIV_HOOK_POS_X + "px";
        hookDiv.style.left = DIV_HOOK_POS_Y + "px";
        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = "#FF0000";
        hookDiv.title = "select to enable accessability for this content";
        hookDiv.addEventListener("focus", function() {
          _this._isMobileAccessibility = true;
          _this.activate();
          _this.destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
      };
      AccessibilityManager2.prototype.destroyTouchHook = function() {
        if (!this._hookDiv) {
          return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
      };
      AccessibilityManager2.prototype.activate = function() {
        if (this._isActive) {
          return;
        }
        this._isActive = true;
        window.document.addEventListener("mousemove", this._onMouseMove, true);
        window.removeEventListener("keydown", this._onKeyDown, false);
        this.renderer.on("postrender", this.update, this);
        if (this.renderer.view.parentNode) {
          this.renderer.view.parentNode.appendChild(this.div);
        }
      };
      AccessibilityManager2.prototype.deactivate = function() {
        if (!this._isActive || this._isMobileAccessibility) {
          return;
        }
        this._isActive = false;
        window.document.removeEventListener("mousemove", this._onMouseMove, true);
        window.addEventListener("keydown", this._onKeyDown, false);
        this.renderer.off("postrender", this.update);
        if (this.div.parentNode) {
          this.div.parentNode.removeChild(this.div);
        }
      };
      AccessibilityManager2.prototype.updateAccessibleObjects = function(displayObject) {
        if (!displayObject.visible || !displayObject.accessibleChildren) {
          return;
        }
        if (displayObject.accessible && displayObject.interactive) {
          if (!displayObject._accessibleActive) {
            this.addChild(displayObject);
          }
          displayObject.renderId = this.renderId;
        }
        var children = displayObject.children;
        for (var i = 0; i < children.length; i++) {
          this.updateAccessibleObjects(children[i]);
        }
      };
      AccessibilityManager2.prototype.update = function() {
        var now2 = performance.now();
        if (isMobile.android.device && now2 < this.androidUpdateCount) {
          return;
        }
        this.androidUpdateCount = now2 + this.androidUpdateFrequency;
        if (!this.renderer.renderingToScreen) {
          return;
        }
        if (this.renderer._lastObjectRendered) {
          this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        }
        var rect = this.renderer.view.getBoundingClientRect();
        var resolution = this.renderer.resolution;
        var sx = rect.width / this.renderer.width * resolution;
        var sy = rect.height / this.renderer.height * resolution;
        var div = this.div;
        div.style.left = rect.left + "px";
        div.style.top = rect.top + "px";
        div.style.width = this.renderer.width + "px";
        div.style.height = this.renderer.height + "px";
        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          if (child.renderId !== this.renderId) {
            child._accessibleActive = false;
            removeItems(this.children, i, 1);
            this.div.removeChild(child._accessibleDiv);
            this.pool.push(child._accessibleDiv);
            child._accessibleDiv = null;
            i--;
          } else {
            div = child._accessibleDiv;
            var hitArea = child.hitArea;
            var wt = child.worldTransform;
            if (child.hitArea) {
              div.style.left = (wt.tx + hitArea.x * wt.a) * sx + "px";
              div.style.top = (wt.ty + hitArea.y * wt.d) * sy + "px";
              div.style.width = hitArea.width * wt.a * sx + "px";
              div.style.height = hitArea.height * wt.d * sy + "px";
            } else {
              hitArea = child.getBounds();
              this.capHitArea(hitArea);
              div.style.left = hitArea.x * sx + "px";
              div.style.top = hitArea.y * sy + "px";
              div.style.width = hitArea.width * sx + "px";
              div.style.height = hitArea.height * sy + "px";
              if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                div.title = child.accessibleTitle;
              }
              if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                div.setAttribute("aria-label", child.accessibleHint);
              }
            }
            if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
              div.title = child.accessibleTitle;
              div.tabIndex = child.tabIndex;
              if (this.debug) {
                this.updateDebugHTML(div);
              }
            }
          }
        }
        this.renderId++;
      };
      AccessibilityManager2.prototype.updateDebugHTML = function(div) {
        div.innerHTML = "type: " + div.type + "</br> title : " + div.title + "</br> tabIndex: " + div.tabIndex;
      };
      AccessibilityManager2.prototype.capHitArea = function(hitArea) {
        if (hitArea.x < 0) {
          hitArea.width += hitArea.x;
          hitArea.x = 0;
        }
        if (hitArea.y < 0) {
          hitArea.height += hitArea.y;
          hitArea.y = 0;
        }
        if (hitArea.x + hitArea.width > this.renderer.width) {
          hitArea.width = this.renderer.width - hitArea.x;
        }
        if (hitArea.y + hitArea.height > this.renderer.height) {
          hitArea.height = this.renderer.height - hitArea.y;
        }
      };
      AccessibilityManager2.prototype.addChild = function(displayObject) {
        var div = this.pool.pop();
        if (!div) {
          div = document.createElement("button");
          div.style.width = DIV_TOUCH_SIZE + "px";
          div.style.height = DIV_TOUCH_SIZE + "px";
          div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
          div.style.position = "absolute";
          div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          div.style.borderStyle = "none";
          if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
            div.setAttribute("aria-live", "off");
          } else {
            div.setAttribute("aria-live", "polite");
          }
          if (navigator.userAgent.match(/rv:.*Gecko\//)) {
            div.setAttribute("aria-relevant", "additions");
          } else {
            div.setAttribute("aria-relevant", "text");
          }
          div.addEventListener("click", this._onClick.bind(this));
          div.addEventListener("focus", this._onFocus.bind(this));
          div.addEventListener("focusout", this._onFocusOut.bind(this));
        }
        div.style.pointerEvents = displayObject.accessiblePointerEvents;
        div.type = displayObject.accessibleType;
        if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
          div.title = displayObject.accessibleTitle;
        } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
          div.title = "displayObject " + displayObject.tabIndex;
        }
        if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
          div.setAttribute("aria-label", displayObject.accessibleHint);
        }
        if (this.debug) {
          this.updateDebugHTML(div);
        }
        displayObject._accessibleActive = true;
        displayObject._accessibleDiv = div;
        div.displayObject = displayObject;
        this.children.push(displayObject);
        this.div.appendChild(displayObject._accessibleDiv);
        displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
      };
      AccessibilityManager2.prototype._onClick = function(e) {
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, "click", interactionManager.eventData);
        interactionManager.dispatchEvent(e.target.displayObject, "pointertap", interactionManager.eventData);
        interactionManager.dispatchEvent(e.target.displayObject, "tap", interactionManager.eventData);
      };
      AccessibilityManager2.prototype._onFocus = function(e) {
        if (!e.target.getAttribute("aria-live")) {
          e.target.setAttribute("aria-live", "assertive");
        }
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, "mouseover", interactionManager.eventData);
      };
      AccessibilityManager2.prototype._onFocusOut = function(e) {
        if (!e.target.getAttribute("aria-live")) {
          e.target.setAttribute("aria-live", "polite");
        }
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, "mouseout", interactionManager.eventData);
      };
      AccessibilityManager2.prototype._onKeyDown = function(e) {
        if (e.keyCode !== KEY_CODE_TAB) {
          return;
        }
        this.activate();
      };
      AccessibilityManager2.prototype._onMouseMove = function(e) {
        if (e.movementX === 0 && e.movementY === 0) {
          return;
        }
        this.deactivate();
      };
      AccessibilityManager2.prototype.destroy = function() {
        this.destroyTouchHook();
        this.div = null;
        window.document.removeEventListener("mousemove", this._onMouseMove, true);
        window.removeEventListener("keydown", this._onKeyDown);
        this.pool = null;
        this.children = null;
        this.renderer = null;
      };
      return AccessibilityManager2;
    }();
    /*!
     * @pixi/ticker - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/ticker is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    settings.TARGET_FPMS = 0.06;
    var UPDATE_PRIORITY;
    (function(UPDATE_PRIORITY2) {
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
    })(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
    var TickerListener = function() {
      function TickerListener2(fn, context2, priority, once2) {
        if (context2 === void 0) {
          context2 = null;
        }
        if (priority === void 0) {
          priority = 0;
        }
        if (once2 === void 0) {
          once2 = false;
        }
        this.fn = fn;
        this.context = context2;
        this.priority = priority;
        this.once = once2;
        this.next = null;
        this.previous = null;
        this._destroyed = false;
      }
      TickerListener2.prototype.match = function(fn, context2) {
        if (context2 === void 0) {
          context2 = null;
        }
        return this.fn === fn && this.context === context2;
      };
      TickerListener2.prototype.emit = function(deltaTime) {
        if (this.fn) {
          if (this.context) {
            this.fn.call(this.context, deltaTime);
          } else {
            this.fn(deltaTime);
          }
        }
        var redirect = this.next;
        if (this.once) {
          this.destroy(true);
        }
        if (this._destroyed) {
          this.next = null;
        }
        return redirect;
      };
      TickerListener2.prototype.connect = function(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      };
      TickerListener2.prototype.destroy = function(hard) {
        if (hard === void 0) {
          hard = false;
        }
        this._destroyed = true;
        this.fn = null;
        this.context = null;
        if (this.previous) {
          this.previous.next = this.next;
        }
        if (this.next) {
          this.next.previous = this.previous;
        }
        var redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
      };
      return TickerListener2;
    }();
    var Ticker = function() {
      function Ticker2() {
        var _this = this;
        this._head = new TickerListener(null, null, Infinity);
        this._requestId = null;
        this._maxElapsedMS = 100;
        this._minElapsedMS = 0;
        this.autoStart = false;
        this.deltaTime = 1;
        this.deltaMS = 1 / settings.TARGET_FPMS;
        this.elapsedMS = 1 / settings.TARGET_FPMS;
        this.lastTime = -1;
        this.speed = 1;
        this.started = false;
        this._protected = false;
        this._lastFrame = -1;
        this._tick = function(time) {
          _this._requestId = null;
          if (_this.started) {
            _this.update(time);
            if (_this.started && _this._requestId === null && _this._head.next) {
              _this._requestId = requestAnimationFrame(_this._tick);
            }
          }
        };
      }
      Ticker2.prototype._requestIfNeeded = function() {
        if (this._requestId === null && this._head.next) {
          this.lastTime = performance.now();
          this._lastFrame = this.lastTime;
          this._requestId = requestAnimationFrame(this._tick);
        }
      };
      Ticker2.prototype._cancelIfNeeded = function() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      };
      Ticker2.prototype._startIfPossible = function() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      };
      Ticker2.prototype.add = function(fn, context2, priority) {
        if (priority === void 0) {
          priority = UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener(fn, context2, priority));
      };
      Ticker2.prototype.addOnce = function(fn, context2, priority) {
        if (priority === void 0) {
          priority = UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener(fn, context2, priority, true));
      };
      Ticker2.prototype._addListener = function(listener) {
        var current = this._head.next;
        var previous = this._head;
        if (!current) {
          listener.connect(previous);
        } else {
          while (current) {
            if (listener.priority > current.priority) {
              listener.connect(previous);
              break;
            }
            previous = current;
            current = current.next;
          }
          if (!listener.previous) {
            listener.connect(previous);
          }
        }
        this._startIfPossible();
        return this;
      };
      Ticker2.prototype.remove = function(fn, context2) {
        var listener = this._head.next;
        while (listener) {
          if (listener.match(fn, context2)) {
            listener = listener.destroy();
          } else {
            listener = listener.next;
          }
        }
        if (!this._head.next) {
          this._cancelIfNeeded();
        }
        return this;
      };
      Object.defineProperty(Ticker2.prototype, "count", {
        get: function() {
          if (!this._head) {
            return 0;
          }
          var count = 0;
          var current = this._head;
          while (current = current.next) {
            count++;
          }
          return count;
        },
        enumerable: false,
        configurable: true
      });
      Ticker2.prototype.start = function() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      };
      Ticker2.prototype.stop = function() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      };
      Ticker2.prototype.destroy = function() {
        if (!this._protected) {
          this.stop();
          var listener = this._head.next;
          while (listener) {
            listener = listener.destroy(true);
          }
          this._head.destroy();
          this._head = null;
        }
      };
      Ticker2.prototype.update = function(currentTime) {
        if (currentTime === void 0) {
          currentTime = performance.now();
        }
        var elapsedMS;
        if (currentTime > this.lastTime) {
          elapsedMS = this.elapsedMS = currentTime - this.lastTime;
          if (elapsedMS > this._maxElapsedMS) {
            elapsedMS = this._maxElapsedMS;
          }
          elapsedMS *= this.speed;
          if (this._minElapsedMS) {
            var delta = currentTime - this._lastFrame | 0;
            if (delta < this._minElapsedMS) {
              return;
            }
            this._lastFrame = currentTime - delta % this._minElapsedMS;
          }
          this.deltaMS = elapsedMS;
          this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
          var head = this._head;
          var listener = head.next;
          while (listener) {
            listener = listener.emit(this.deltaTime);
          }
          if (!head.next) {
            this._cancelIfNeeded();
          }
        } else {
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
      };
      Object.defineProperty(Ticker2.prototype, "FPS", {
        get: function() {
          return 1e3 / this.elapsedMS;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker2.prototype, "minFPS", {
        get: function() {
          return 1e3 / this._maxElapsedMS;
        },
        set: function(fps) {
          var minFPS = Math.min(this.maxFPS, fps);
          var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS);
          this._maxElapsedMS = 1 / minFPMS;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker2.prototype, "maxFPS", {
        get: function() {
          if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
          }
          return 0;
        },
        set: function(fps) {
          if (fps === 0) {
            this._minElapsedMS = 0;
          } else {
            var maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker2, "shared", {
        get: function() {
          if (!Ticker2._shared) {
            var shared = Ticker2._shared = new Ticker2();
            shared.autoStart = true;
            shared._protected = true;
          }
          return Ticker2._shared;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker2, "system", {
        get: function() {
          if (!Ticker2._system) {
            var system = Ticker2._system = new Ticker2();
            system.autoStart = true;
            system._protected = true;
          }
          return Ticker2._system;
        },
        enumerable: false,
        configurable: true
      });
      return Ticker2;
    }();
    var TickerPlugin = function() {
      function TickerPlugin2() {
      }
      TickerPlugin2.init = function(options) {
        var _this = this;
        options = Object.assign({
          autoStart: true,
          sharedTicker: false
        }, options);
        Object.defineProperty(this, "ticker", {
          set: function(ticker) {
            if (this._ticker) {
              this._ticker.remove(this.render, this);
            }
            this._ticker = ticker;
            if (ticker) {
              ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
            }
          },
          get: function() {
            return this._ticker;
          }
        });
        this.stop = function() {
          _this._ticker.stop();
        };
        this.start = function() {
          _this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
        if (options.autoStart) {
          this.start();
        }
      };
      TickerPlugin2.destroy = function() {
        if (this._ticker) {
          var oldTicker = this._ticker;
          this.ticker = null;
          oldTicker.destroy();
        }
      };
      return TickerPlugin2;
    }();
    /*!
     * @pixi/interaction - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/interaction is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var InteractionData = function() {
      function InteractionData2() {
        this.pressure = 0;
        this.rotationAngle = 0;
        this.twist = 0;
        this.tangentialPressure = 0;
        this.global = new Point();
        this.target = null;
        this.originalEvent = null;
        this.identifier = null;
        this.isPrimary = false;
        this.button = 0;
        this.buttons = 0;
        this.width = 0;
        this.height = 0;
        this.tiltX = 0;
        this.tiltY = 0;
        this.pointerType = null;
        this.pressure = 0;
        this.rotationAngle = 0;
        this.twist = 0;
        this.tangentialPressure = 0;
      }
      Object.defineProperty(InteractionData2.prototype, "pointerId", {
        get: function() {
          return this.identifier;
        },
        enumerable: false,
        configurable: true
      });
      InteractionData2.prototype.getLocalPosition = function(displayObject, point, globalPos) {
        return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
      };
      InteractionData2.prototype.copyEvent = function(event) {
        if ("isPrimary" in event && event.isPrimary) {
          this.isPrimary = true;
        }
        this.button = "button" in event && event.button;
        var buttons = "buttons" in event && event.buttons;
        this.buttons = Number.isInteger(buttons) ? buttons : "which" in event && event.which;
        this.width = "width" in event && event.width;
        this.height = "height" in event && event.height;
        this.tiltX = "tiltX" in event && event.tiltX;
        this.tiltY = "tiltY" in event && event.tiltY;
        this.pointerType = "pointerType" in event && event.pointerType;
        this.pressure = "pressure" in event && event.pressure;
        this.rotationAngle = "rotationAngle" in event && event.rotationAngle;
        this.twist = "twist" in event && event.twist || 0;
        this.tangentialPressure = "tangentialPressure" in event && event.tangentialPressure || 0;
      };
      InteractionData2.prototype.reset = function() {
        this.isPrimary = false;
      };
      return InteractionData2;
    }();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$i = function(d, b) {
      extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$i(d, b);
    };
    function __extends$i(d, b) {
      extendStatics$i(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var InteractionEvent = function() {
      function InteractionEvent2() {
        this.stopped = false;
        this.stopsPropagatingAt = null;
        this.stopPropagationHint = false;
        this.target = null;
        this.currentTarget = null;
        this.type = null;
        this.data = null;
      }
      InteractionEvent2.prototype.stopPropagation = function() {
        this.stopped = true;
        this.stopPropagationHint = true;
        this.stopsPropagatingAt = this.currentTarget;
      };
      InteractionEvent2.prototype.reset = function() {
        this.stopped = false;
        this.stopsPropagatingAt = null;
        this.stopPropagationHint = false;
        this.currentTarget = null;
        this.target = null;
      };
      return InteractionEvent2;
    }();
    var InteractionTrackingData = function() {
      function InteractionTrackingData2(pointerId) {
        this._pointerId = pointerId;
        this._flags = InteractionTrackingData2.FLAGS.NONE;
      }
      InteractionTrackingData2.prototype._doSet = function(flag, yn) {
        if (yn) {
          this._flags = this._flags | flag;
        } else {
          this._flags = this._flags & ~flag;
        }
      };
      Object.defineProperty(InteractionTrackingData2.prototype, "pointerId", {
        get: function() {
          return this._pointerId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "flags", {
        get: function() {
          return this._flags;
        },
        set: function(flags) {
          this._flags = flags;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "none", {
        get: function() {
          return this._flags === InteractionTrackingData2.FLAGS.NONE;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "over", {
        get: function() {
          return (this._flags & InteractionTrackingData2.FLAGS.OVER) !== 0;
        },
        set: function(yn) {
          this._doSet(InteractionTrackingData2.FLAGS.OVER, yn);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "rightDown", {
        get: function() {
          return (this._flags & InteractionTrackingData2.FLAGS.RIGHT_DOWN) !== 0;
        },
        set: function(yn) {
          this._doSet(InteractionTrackingData2.FLAGS.RIGHT_DOWN, yn);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "leftDown", {
        get: function() {
          return (this._flags & InteractionTrackingData2.FLAGS.LEFT_DOWN) !== 0;
        },
        set: function(yn) {
          this._doSet(InteractionTrackingData2.FLAGS.LEFT_DOWN, yn);
        },
        enumerable: false,
        configurable: true
      });
      InteractionTrackingData2.FLAGS = Object.freeze({
        NONE: 0,
        OVER: 1 << 0,
        LEFT_DOWN: 1 << 1,
        RIGHT_DOWN: 1 << 2
      });
      return InteractionTrackingData2;
    }();
    var TreeSearch = function() {
      function TreeSearch2() {
        this._tempPoint = new Point();
      }
      TreeSearch2.prototype.recursiveFindHit = function(interactionEvent, displayObject, func, hitTest, interactive) {
        if (!displayObject || !displayObject.visible) {
          return false;
        }
        var point = interactionEvent.data.global;
        interactive = displayObject.interactive || interactive;
        var hit = false;
        var interactiveParent = interactive;
        var hitTestChildren = true;
        if (displayObject.hitArea) {
          if (hitTest) {
            displayObject.worldTransform.applyInverse(point, this._tempPoint);
            if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
              hitTest = false;
              hitTestChildren = false;
            } else {
              hit = true;
            }
          }
          interactiveParent = false;
        } else if (displayObject._mask) {
          if (hitTest) {
            if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {
              hitTest = false;
            }
          }
        }
        if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
          var children = displayObject.children;
          for (var i = children.length - 1; i >= 0; i--) {
            var child = children[i];
            var childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);
            if (childHit) {
              if (!child.parent) {
                continue;
              }
              interactiveParent = false;
              if (childHit) {
                if (interactionEvent.target) {
                  hitTest = false;
                }
                hit = true;
              }
            }
          }
        }
        if (interactive) {
          if (hitTest && !interactionEvent.target) {
            if (!displayObject.hitArea && displayObject.containsPoint) {
              if (displayObject.containsPoint(point)) {
                hit = true;
              }
            }
          }
          if (displayObject.interactive) {
            if (hit && !interactionEvent.target) {
              interactionEvent.target = displayObject;
            }
            if (func) {
              func(interactionEvent, displayObject, !!hit);
            }
          }
        }
        return hit;
      };
      TreeSearch2.prototype.findHit = function(interactionEvent, displayObject, func, hitTest) {
        this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);
      };
      return TreeSearch2;
    }();
    var interactiveTarget = {
      interactive: false,
      interactiveChildren: true,
      hitArea: null,
      get buttonMode() {
        return this.cursor === "pointer";
      },
      set buttonMode(value2) {
        if (value2) {
          this.cursor = "pointer";
        } else if (this.cursor === "pointer") {
          this.cursor = null;
        }
      },
      cursor: null,
      get trackedPointers() {
        if (this._trackedPointers === void 0) {
          this._trackedPointers = {};
        }
        return this._trackedPointers;
      },
      _trackedPointers: void 0
    };
    DisplayObject.mixin(interactiveTarget);
    var MOUSE_POINTER_ID = 1;
    var hitTestEvent = {
      target: null,
      data: {
        global: null
      }
    };
    var InteractionManager = function(_super) {
      __extends$i(InteractionManager2, _super);
      function InteractionManager2(renderer, options) {
        var _this = _super.call(this) || this;
        options = options || {};
        _this.renderer = renderer;
        _this.autoPreventDefault = options.autoPreventDefault !== void 0 ? options.autoPreventDefault : true;
        _this.interactionFrequency = options.interactionFrequency || 10;
        _this.mouse = new InteractionData();
        _this.mouse.identifier = MOUSE_POINTER_ID;
        _this.mouse.global.set(-999999);
        _this.activeInteractionData = {};
        _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
        _this.interactionDataPool = [];
        _this.eventData = new InteractionEvent();
        _this.interactionDOMElement = null;
        _this.moveWhenInside = false;
        _this.eventsAdded = false;
        _this.tickerAdded = false;
        _this.mouseOverRenderer = false;
        _this.supportsTouchEvents = "ontouchstart" in window;
        _this.supportsPointerEvents = !!window.PointerEvent;
        _this.onPointerUp = _this.onPointerUp.bind(_this);
        _this.processPointerUp = _this.processPointerUp.bind(_this);
        _this.onPointerCancel = _this.onPointerCancel.bind(_this);
        _this.processPointerCancel = _this.processPointerCancel.bind(_this);
        _this.onPointerDown = _this.onPointerDown.bind(_this);
        _this.processPointerDown = _this.processPointerDown.bind(_this);
        _this.onPointerMove = _this.onPointerMove.bind(_this);
        _this.processPointerMove = _this.processPointerMove.bind(_this);
        _this.onPointerOut = _this.onPointerOut.bind(_this);
        _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
        _this.onPointerOver = _this.onPointerOver.bind(_this);
        _this.cursorStyles = {
          default: "inherit",
          pointer: "pointer"
        };
        _this.currentCursorMode = null;
        _this.cursor = null;
        _this.resolution = 1;
        _this.delayedEvents = [];
        _this.search = new TreeSearch();
        _this._tempDisplayObject = new TemporaryDisplayObject();
        _this._useSystemTicker = options.useSystemTicker !== void 0 ? options.useSystemTicker : true;
        _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);
        return _this;
      }
      Object.defineProperty(InteractionManager2.prototype, "useSystemTicker", {
        get: function() {
          return this._useSystemTicker;
        },
        set: function(useSystemTicker) {
          this._useSystemTicker = useSystemTicker;
          if (useSystemTicker) {
            this.addTickerListener();
          } else {
            this.removeTickerListener();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionManager2.prototype, "lastObjectRendered", {
        get: function() {
          return this.renderer._lastObjectRendered || this._tempDisplayObject;
        },
        enumerable: false,
        configurable: true
      });
      InteractionManager2.prototype.hitTest = function(globalPoint, root2) {
        hitTestEvent.target = null;
        hitTestEvent.data.global = globalPoint;
        if (!root2) {
          root2 = this.lastObjectRendered;
        }
        this.processInteractive(hitTestEvent, root2, null, true);
        return hitTestEvent.target;
      };
      InteractionManager2.prototype.setTargetElement = function(element, resolution) {
        if (resolution === void 0) {
          resolution = 1;
        }
        this.removeTickerListener();
        this.removeEvents();
        this.interactionDOMElement = element;
        this.resolution = resolution;
        this.addEvents();
        this.addTickerListener();
      };
      InteractionManager2.prototype.addTickerListener = function() {
        if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {
          return;
        }
        Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
        this.tickerAdded = true;
      };
      InteractionManager2.prototype.removeTickerListener = function() {
        if (!this.tickerAdded) {
          return;
        }
        Ticker.system.remove(this.tickerUpdate, this);
        this.tickerAdded = false;
      };
      InteractionManager2.prototype.addEvents = function() {
        if (this.eventsAdded || !this.interactionDOMElement) {
          return;
        }
        var style = this.interactionDOMElement.style;
        if (window.navigator.msPointerEnabled) {
          style.msContentZooming = "none";
          style.msTouchAction = "none";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "none";
        }
        if (this.supportsPointerEvents) {
          window.document.addEventListener("pointermove", this.onPointerMove, true);
          this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, true);
          this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, true);
          this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, true);
          window.addEventListener("pointercancel", this.onPointerCancel, true);
          window.addEventListener("pointerup", this.onPointerUp, true);
        } else {
          window.document.addEventListener("mousemove", this.onPointerMove, true);
          this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, true);
          this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, true);
          this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, true);
          window.addEventListener("mouseup", this.onPointerUp, true);
        }
        if (this.supportsTouchEvents) {
          this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, true);
          this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, true);
          this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, true);
          this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, true);
        }
        this.eventsAdded = true;
      };
      InteractionManager2.prototype.removeEvents = function() {
        if (!this.eventsAdded || !this.interactionDOMElement) {
          return;
        }
        var style = this.interactionDOMElement.style;
        if (window.navigator.msPointerEnabled) {
          style.msContentZooming = "";
          style.msTouchAction = "";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "";
        }
        if (this.supportsPointerEvents) {
          window.document.removeEventListener("pointermove", this.onPointerMove, true);
          this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, true);
          this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, true);
          this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, true);
          window.removeEventListener("pointercancel", this.onPointerCancel, true);
          window.removeEventListener("pointerup", this.onPointerUp, true);
        } else {
          window.document.removeEventListener("mousemove", this.onPointerMove, true);
          this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, true);
          this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, true);
          this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, true);
          window.removeEventListener("mouseup", this.onPointerUp, true);
        }
        if (this.supportsTouchEvents) {
          this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, true);
          this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, true);
          this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, true);
          this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, true);
        }
        this.interactionDOMElement = null;
        this.eventsAdded = false;
      };
      InteractionManager2.prototype.tickerUpdate = function(deltaTime) {
        this._deltaTime += deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
          return;
        }
        this._deltaTime = 0;
        this.update();
      };
      InteractionManager2.prototype.update = function() {
        if (!this.interactionDOMElement) {
          return;
        }
        if (this._didMove) {
          this._didMove = false;
          return;
        }
        this.cursor = null;
        for (var k in this.activeInteractionData) {
          if (this.activeInteractionData.hasOwnProperty(k)) {
            var interactionData = this.activeInteractionData[k];
            if (interactionData.originalEvent && interactionData.pointerType !== "touch") {
              var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
              this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, true);
            }
          }
        }
        this.setCursorMode(this.cursor);
      };
      InteractionManager2.prototype.setCursorMode = function(mode) {
        mode = mode || "default";
        if (this.currentCursorMode === mode) {
          return;
        }
        this.currentCursorMode = mode;
        var style = this.cursorStyles[mode];
        if (style) {
          switch (typeof style) {
            case "string":
              this.interactionDOMElement.style.cursor = style;
              break;
            case "function":
              style(mode);
              break;
            case "object":
              Object.assign(this.interactionDOMElement.style, style);
              break;
          }
        } else if (typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
          this.interactionDOMElement.style.cursor = mode;
        }
      };
      InteractionManager2.prototype.dispatchEvent = function(displayObject, eventString, eventData) {
        if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {
          eventData.currentTarget = displayObject;
          eventData.type = eventString;
          displayObject.emit(eventString, eventData);
          if (displayObject[eventString]) {
            displayObject[eventString](eventData);
          }
        }
      };
      InteractionManager2.prototype.delayDispatchEvent = function(displayObject, eventString, eventData) {
        this.delayedEvents.push({ displayObject, eventString, eventData });
      };
      InteractionManager2.prototype.mapPositionToPoint = function(point, x2, y2) {
        var rect;
        if (!this.interactionDOMElement.parentElement) {
          rect = { x: 0, y: 0, width: 0, height: 0 };
        } else {
          rect = this.interactionDOMElement.getBoundingClientRect();
        }
        var resolutionMultiplier = 1 / this.resolution;
        point.x = (x2 - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
        point.y = (y2 - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
      };
      InteractionManager2.prototype.processInteractive = function(interactionEvent, displayObject, func, hitTest) {
        var hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);
        var delayedEvents = this.delayedEvents;
        if (!delayedEvents.length) {
          return hit;
        }
        interactionEvent.stopPropagationHint = false;
        var delayedLen = delayedEvents.length;
        this.delayedEvents = [];
        for (var i = 0; i < delayedLen; i++) {
          var _a2 = delayedEvents[i], displayObject_1 = _a2.displayObject, eventString = _a2.eventString, eventData = _a2.eventData;
          if (eventData.stopsPropagatingAt === displayObject_1) {
            eventData.stopPropagationHint = true;
          }
          this.dispatchEvent(displayObject_1, eventString, eventData);
        }
        return hit;
      };
      InteractionManager2.prototype.onPointerDown = function(originalEvent) {
        if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
          return;
        }
        var events2 = this.normalizeToPointerData(originalEvent);
        if (this.autoPreventDefault && events2[0].isNormalized) {
          var cancelable = originalEvent.cancelable || !("cancelable" in originalEvent);
          if (cancelable) {
            originalEvent.preventDefault();
          }
        }
        var eventLen = events2.length;
        for (var i = 0; i < eventLen; i++) {
          var event = events2[i];
          var interactionData = this.getInteractionDataForPointerId(event);
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
          interactionEvent.data.originalEvent = originalEvent;
          this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerDown, true);
          this.emit("pointerdown", interactionEvent);
          if (event.pointerType === "touch") {
            this.emit("touchstart", interactionEvent);
          } else if (event.pointerType === "mouse" || event.pointerType === "pen") {
            var isRightButton = event.button === 2;
            this.emit(isRightButton ? "rightdown" : "mousedown", this.eventData);
          }
        }
      };
      InteractionManager2.prototype.processPointerDown = function(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var id2 = interactionEvent.data.identifier;
        if (hit) {
          if (!displayObject.trackedPointers[id2]) {
            displayObject.trackedPointers[id2] = new InteractionTrackingData(id2);
          }
          this.dispatchEvent(displayObject, "pointerdown", interactionEvent);
          if (data.pointerType === "touch") {
            this.dispatchEvent(displayObject, "touchstart", interactionEvent);
          } else if (data.pointerType === "mouse" || data.pointerType === "pen") {
            var isRightButton = data.button === 2;
            if (isRightButton) {
              displayObject.trackedPointers[id2].rightDown = true;
            } else {
              displayObject.trackedPointers[id2].leftDown = true;
            }
            this.dispatchEvent(displayObject, isRightButton ? "rightdown" : "mousedown", interactionEvent);
          }
        }
      };
      InteractionManager2.prototype.onPointerComplete = function(originalEvent, cancelled, func) {
        var events2 = this.normalizeToPointerData(originalEvent);
        var eventLen = events2.length;
        var eventAppend = originalEvent.target !== this.interactionDOMElement ? "outside" : "";
        for (var i = 0; i < eventLen; i++) {
          var event = events2[i];
          var interactionData = this.getInteractionDataForPointerId(event);
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
          interactionEvent.data.originalEvent = originalEvent;
          this.processInteractive(interactionEvent, this.lastObjectRendered, func, cancelled || !eventAppend);
          this.emit(cancelled ? "pointercancel" : "pointerup" + eventAppend, interactionEvent);
          if (event.pointerType === "mouse" || event.pointerType === "pen") {
            var isRightButton = event.button === 2;
            this.emit(isRightButton ? "rightup" + eventAppend : "mouseup" + eventAppend, interactionEvent);
          } else if (event.pointerType === "touch") {
            this.emit(cancelled ? "touchcancel" : "touchend" + eventAppend, interactionEvent);
            this.releaseInteractionDataForPointerId(event.pointerId);
          }
        }
      };
      InteractionManager2.prototype.onPointerCancel = function(event) {
        if (this.supportsTouchEvents && event.pointerType === "touch") {
          return;
        }
        this.onPointerComplete(event, true, this.processPointerCancel);
      };
      InteractionManager2.prototype.processPointerCancel = function(interactionEvent, displayObject) {
        var data = interactionEvent.data;
        var id2 = interactionEvent.data.identifier;
        if (displayObject.trackedPointers[id2] !== void 0) {
          delete displayObject.trackedPointers[id2];
          this.dispatchEvent(displayObject, "pointercancel", interactionEvent);
          if (data.pointerType === "touch") {
            this.dispatchEvent(displayObject, "touchcancel", interactionEvent);
          }
        }
      };
      InteractionManager2.prototype.onPointerUp = function(event) {
        if (this.supportsTouchEvents && event.pointerType === "touch") {
          return;
        }
        this.onPointerComplete(event, false, this.processPointerUp);
      };
      InteractionManager2.prototype.processPointerUp = function(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var id2 = interactionEvent.data.identifier;
        var trackingData = displayObject.trackedPointers[id2];
        var isTouch = data.pointerType === "touch";
        var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
        var isMouseTap = false;
        if (isMouse) {
          var isRightButton = data.button === 2;
          var flags = InteractionTrackingData.FLAGS;
          var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
          var isDown = trackingData !== void 0 && trackingData.flags & test;
          if (hit) {
            this.dispatchEvent(displayObject, isRightButton ? "rightup" : "mouseup", interactionEvent);
            if (isDown) {
              this.dispatchEvent(displayObject, isRightButton ? "rightclick" : "click", interactionEvent);
              isMouseTap = true;
            }
          } else if (isDown) {
            this.dispatchEvent(displayObject, isRightButton ? "rightupoutside" : "mouseupoutside", interactionEvent);
          }
          if (trackingData) {
            if (isRightButton) {
              trackingData.rightDown = false;
            } else {
              trackingData.leftDown = false;
            }
          }
        }
        if (hit) {
          this.dispatchEvent(displayObject, "pointerup", interactionEvent);
          if (isTouch) {
            this.dispatchEvent(displayObject, "touchend", interactionEvent);
          }
          if (trackingData) {
            if (!isMouse || isMouseTap) {
              this.dispatchEvent(displayObject, "pointertap", interactionEvent);
            }
            if (isTouch) {
              this.dispatchEvent(displayObject, "tap", interactionEvent);
              trackingData.over = false;
            }
          }
        } else if (trackingData) {
          this.dispatchEvent(displayObject, "pointerupoutside", interactionEvent);
          if (isTouch) {
            this.dispatchEvent(displayObject, "touchendoutside", interactionEvent);
          }
        }
        if (trackingData && trackingData.none) {
          delete displayObject.trackedPointers[id2];
        }
      };
      InteractionManager2.prototype.onPointerMove = function(originalEvent) {
        if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
          return;
        }
        var events2 = this.normalizeToPointerData(originalEvent);
        if (events2[0].pointerType === "mouse" || events2[0].pointerType === "pen") {
          this._didMove = true;
          this.cursor = null;
        }
        var eventLen = events2.length;
        for (var i = 0; i < eventLen; i++) {
          var event = events2[i];
          var interactionData = this.getInteractionDataForPointerId(event);
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
          interactionEvent.data.originalEvent = originalEvent;
          this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerMove, true);
          this.emit("pointermove", interactionEvent);
          if (event.pointerType === "touch") {
            this.emit("touchmove", interactionEvent);
          }
          if (event.pointerType === "mouse" || event.pointerType === "pen") {
            this.emit("mousemove", interactionEvent);
          }
        }
        if (events2[0].pointerType === "mouse") {
          this.setCursorMode(this.cursor);
        }
      };
      InteractionManager2.prototype.processPointerMove = function(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var isTouch = data.pointerType === "touch";
        var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
        if (isMouse) {
          this.processPointerOverOut(interactionEvent, displayObject, hit);
        }
        if (!this.moveWhenInside || hit) {
          this.dispatchEvent(displayObject, "pointermove", interactionEvent);
          if (isTouch) {
            this.dispatchEvent(displayObject, "touchmove", interactionEvent);
          }
          if (isMouse) {
            this.dispatchEvent(displayObject, "mousemove", interactionEvent);
          }
        }
      };
      InteractionManager2.prototype.onPointerOut = function(originalEvent) {
        if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
          return;
        }
        var events2 = this.normalizeToPointerData(originalEvent);
        var event = events2[0];
        if (event.pointerType === "mouse") {
          this.mouseOverRenderer = false;
          this.setCursorMode(null);
        }
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = event;
        this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, false);
        this.emit("pointerout", interactionEvent);
        if (event.pointerType === "mouse" || event.pointerType === "pen") {
          this.emit("mouseout", interactionEvent);
        } else {
          this.releaseInteractionDataForPointerId(interactionData.identifier);
        }
      };
      InteractionManager2.prototype.processPointerOverOut = function(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var id2 = interactionEvent.data.identifier;
        var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
        var trackingData = displayObject.trackedPointers[id2];
        if (hit && !trackingData) {
          trackingData = displayObject.trackedPointers[id2] = new InteractionTrackingData(id2);
        }
        if (trackingData === void 0) {
          return;
        }
        if (hit && this.mouseOverRenderer) {
          if (!trackingData.over) {
            trackingData.over = true;
            this.delayDispatchEvent(displayObject, "pointerover", interactionEvent);
            if (isMouse) {
              this.delayDispatchEvent(displayObject, "mouseover", interactionEvent);
            }
          }
          if (isMouse && this.cursor === null) {
            this.cursor = displayObject.cursor;
          }
        } else if (trackingData.over) {
          trackingData.over = false;
          this.dispatchEvent(displayObject, "pointerout", this.eventData);
          if (isMouse) {
            this.dispatchEvent(displayObject, "mouseout", interactionEvent);
          }
          if (trackingData.none) {
            delete displayObject.trackedPointers[id2];
          }
        }
      };
      InteractionManager2.prototype.onPointerOver = function(originalEvent) {
        var events2 = this.normalizeToPointerData(originalEvent);
        var event = events2[0];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = event;
        if (event.pointerType === "mouse") {
          this.mouseOverRenderer = true;
        }
        this.emit("pointerover", interactionEvent);
        if (event.pointerType === "mouse" || event.pointerType === "pen") {
          this.emit("mouseover", interactionEvent);
        }
      };
      InteractionManager2.prototype.getInteractionDataForPointerId = function(event) {
        var pointerId = event.pointerId;
        var interactionData;
        if (pointerId === MOUSE_POINTER_ID || event.pointerType === "mouse") {
          interactionData = this.mouse;
        } else if (this.activeInteractionData[pointerId]) {
          interactionData = this.activeInteractionData[pointerId];
        } else {
          interactionData = this.interactionDataPool.pop() || new InteractionData();
          interactionData.identifier = pointerId;
          this.activeInteractionData[pointerId] = interactionData;
        }
        interactionData.copyEvent(event);
        return interactionData;
      };
      InteractionManager2.prototype.releaseInteractionDataForPointerId = function(pointerId) {
        var interactionData = this.activeInteractionData[pointerId];
        if (interactionData) {
          delete this.activeInteractionData[pointerId];
          interactionData.reset();
          this.interactionDataPool.push(interactionData);
        }
      };
      InteractionManager2.prototype.configureInteractionEventForDOMEvent = function(interactionEvent, pointerEvent, interactionData) {
        interactionEvent.data = interactionData;
        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
        if (pointerEvent.pointerType === "touch") {
          pointerEvent.globalX = interactionData.global.x;
          pointerEvent.globalY = interactionData.global.y;
        }
        interactionData.originalEvent = pointerEvent;
        interactionEvent.reset();
        return interactionEvent;
      };
      InteractionManager2.prototype.normalizeToPointerData = function(event) {
        var normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
          for (var i = 0, li2 = event.changedTouches.length; i < li2; i++) {
            var touch = event.changedTouches[i];
            if (typeof touch.button === "undefined") {
              touch.button = event.touches.length ? 1 : 0;
            }
            if (typeof touch.buttons === "undefined") {
              touch.buttons = event.touches.length ? 1 : 0;
            }
            if (typeof touch.isPrimary === "undefined") {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if (typeof touch.width === "undefined") {
              touch.width = touch.radiusX || 1;
            }
            if (typeof touch.height === "undefined") {
              touch.height = touch.radiusY || 1;
            }
            if (typeof touch.tiltX === "undefined") {
              touch.tiltX = 0;
            }
            if (typeof touch.tiltY === "undefined") {
              touch.tiltY = 0;
            }
            if (typeof touch.pointerType === "undefined") {
              touch.pointerType = "touch";
            }
            if (typeof touch.pointerId === "undefined") {
              touch.pointerId = touch.identifier || 0;
            }
            if (typeof touch.pressure === "undefined") {
              touch.pressure = touch.force || 0.5;
            }
            if (typeof touch.twist === "undefined") {
              touch.twist = 0;
            }
            if (typeof touch.tangentialPressure === "undefined") {
              touch.tangentialPressure = 0;
            }
            if (typeof touch.layerX === "undefined") {
              touch.layerX = touch.offsetX = touch.clientX;
            }
            if (typeof touch.layerY === "undefined") {
              touch.layerY = touch.offsetY = touch.clientY;
            }
            touch.isNormalized = true;
            normalizedEvents.push(touch);
          }
        } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {
          var tempEvent = event;
          if (typeof tempEvent.isPrimary === "undefined") {
            tempEvent.isPrimary = true;
          }
          if (typeof tempEvent.width === "undefined") {
            tempEvent.width = 1;
          }
          if (typeof tempEvent.height === "undefined") {
            tempEvent.height = 1;
          }
          if (typeof tempEvent.tiltX === "undefined") {
            tempEvent.tiltX = 0;
          }
          if (typeof tempEvent.tiltY === "undefined") {
            tempEvent.tiltY = 0;
          }
          if (typeof tempEvent.pointerType === "undefined") {
            tempEvent.pointerType = "mouse";
          }
          if (typeof tempEvent.pointerId === "undefined") {
            tempEvent.pointerId = MOUSE_POINTER_ID;
          }
          if (typeof tempEvent.pressure === "undefined") {
            tempEvent.pressure = 0.5;
          }
          if (typeof tempEvent.twist === "undefined") {
            tempEvent.twist = 0;
          }
          if (typeof tempEvent.tangentialPressure === "undefined") {
            tempEvent.tangentialPressure = 0;
          }
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      };
      InteractionManager2.prototype.destroy = function() {
        this.removeEvents();
        this.removeTickerListener();
        this.removeAllListeners();
        this.renderer = null;
        this.mouse = null;
        this.eventData = null;
        this.interactionDOMElement = null;
        this.onPointerDown = null;
        this.processPointerDown = null;
        this.onPointerUp = null;
        this.processPointerUp = null;
        this.onPointerCancel = null;
        this.processPointerCancel = null;
        this.onPointerMove = null;
        this.processPointerMove = null;
        this.onPointerOut = null;
        this.processPointerOverOut = null;
        this.onPointerOver = null;
        this.search = null;
      };
      return InteractionManager2;
    }(EventEmitter);
    /*!
     * @pixi/runner - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/runner is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var Runner = function() {
      function Runner2(name2) {
        this.items = [];
        this._name = name2;
        this._aliasCount = 0;
      }
      Runner2.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {
        if (arguments.length > 8) {
          throw new Error("max arguments reached");
        }
        var _a2 = this, name2 = _a2.name, items2 = _a2.items;
        this._aliasCount++;
        for (var i = 0, len = items2.length; i < len; i++) {
          items2[i][name2](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        if (items2 === this.items) {
          this._aliasCount--;
        }
        return this;
      };
      Runner2.prototype.ensureNonAliasedItems = function() {
        if (this._aliasCount > 0 && this.items.length > 1) {
          this._aliasCount = 0;
          this.items = this.items.slice(0);
        }
      };
      Runner2.prototype.add = function(item) {
        if (item[this._name]) {
          this.ensureNonAliasedItems();
          this.remove(item);
          this.items.push(item);
        }
        return this;
      };
      Runner2.prototype.remove = function(item) {
        var index2 = this.items.indexOf(item);
        if (index2 !== -1) {
          this.ensureNonAliasedItems();
          this.items.splice(index2, 1);
        }
        return this;
      };
      Runner2.prototype.contains = function(item) {
        return this.items.indexOf(item) !== -1;
      };
      Runner2.prototype.removeAll = function() {
        this.ensureNonAliasedItems();
        this.items.length = 0;
        return this;
      };
      Runner2.prototype.destroy = function() {
        this.removeAll();
        this.items = null;
        this._name = null;
      };
      Object.defineProperty(Runner2.prototype, "empty", {
        get: function() {
          return this.items.length === 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Runner2.prototype, "name", {
        get: function() {
          return this._name;
        },
        enumerable: false,
        configurable: true
      });
      return Runner2;
    }();
    Object.defineProperties(Runner.prototype, {
      dispatch: { value: Runner.prototype.emit },
      run: { value: Runner.prototype.emit }
    });
    /*!
     * @pixi/core - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/core is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    settings.PREFER_ENV = isMobile.any ? ENV$1.WEBGL : ENV$1.WEBGL2;
    settings.STRICT_TEXTURE_CACHE = false;
    var INSTALLED = [];
    function autoDetectResource(source, options) {
      if (!source) {
        return null;
      }
      var extension = "";
      if (typeof source === "string") {
        var result2 = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
        if (result2) {
          extension = result2[1].toLowerCase();
        }
      }
      for (var i = INSTALLED.length - 1; i >= 0; --i) {
        var ResourcePlugin = INSTALLED[i];
        if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
          return new ResourcePlugin(source, options);
        }
      }
      throw new Error("Unrecognized source type to auto-detect Resource");
    }
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$h = function(d, b) {
      extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$h(d, b);
    };
    function __extends$h(d, b) {
      extendStatics$h(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var Resource$1 = function() {
      function Resource2(width2, height2) {
        if (width2 === void 0) {
          width2 = 0;
        }
        if (height2 === void 0) {
          height2 = 0;
        }
        this._width = width2;
        this._height = height2;
        this.destroyed = false;
        this.internal = false;
        this.onResize = new Runner("setRealSize");
        this.onUpdate = new Runner("update");
        this.onError = new Runner("onError");
      }
      Resource2.prototype.bind = function(baseTexture) {
        this.onResize.add(baseTexture);
        this.onUpdate.add(baseTexture);
        this.onError.add(baseTexture);
        if (this._width || this._height) {
          this.onResize.emit(this._width, this._height);
        }
      };
      Resource2.prototype.unbind = function(baseTexture) {
        this.onResize.remove(baseTexture);
        this.onUpdate.remove(baseTexture);
        this.onError.remove(baseTexture);
      };
      Resource2.prototype.resize = function(width2, height2) {
        if (width2 !== this._width || height2 !== this._height) {
          this._width = width2;
          this._height = height2;
          this.onResize.emit(width2, height2);
        }
      };
      Object.defineProperty(Resource2.prototype, "valid", {
        get: function() {
          return !!this._width && !!this._height;
        },
        enumerable: false,
        configurable: true
      });
      Resource2.prototype.update = function() {
        if (!this.destroyed) {
          this.onUpdate.emit();
        }
      };
      Resource2.prototype.load = function() {
        return Promise.resolve(this);
      };
      Object.defineProperty(Resource2.prototype, "width", {
        get: function() {
          return this._width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Resource2.prototype, "height", {
        get: function() {
          return this._height;
        },
        enumerable: false,
        configurable: true
      });
      Resource2.prototype.style = function(_renderer, _baseTexture, _glTexture) {
        return false;
      };
      Resource2.prototype.dispose = function() {
      };
      Resource2.prototype.destroy = function() {
        if (!this.destroyed) {
          this.destroyed = true;
          this.dispose();
          this.onError.removeAll();
          this.onError = null;
          this.onResize.removeAll();
          this.onResize = null;
          this.onUpdate.removeAll();
          this.onUpdate = null;
        }
      };
      Resource2.test = function(_source, _extension) {
        return false;
      };
      return Resource2;
    }();
    var BufferResource = function(_super) {
      __extends$h(BufferResource2, _super);
      function BufferResource2(source, options) {
        var _this = this;
        var _a2 = options || {}, width2 = _a2.width, height2 = _a2.height;
        if (!width2 || !height2) {
          throw new Error("BufferResource width or height invalid");
        }
        _this = _super.call(this, width2, height2) || this;
        _this.data = source;
        return _this;
      }
      BufferResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$1.UNPACK);
        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
          gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
        } else {
          glTexture.width = baseTexture.width;
          glTexture.height = baseTexture.height;
          gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.width, baseTexture.height, 0, baseTexture.format, glTexture.type, this.data);
        }
        return true;
      };
      BufferResource2.prototype.dispose = function() {
        this.data = null;
      };
      BufferResource2.test = function(source) {
        return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
      };
      return BufferResource2;
    }(Resource$1);
    var defaultBufferOptions = {
      scaleMode: SCALE_MODES$1.NEAREST,
      format: FORMATS$1.RGBA,
      alphaMode: ALPHA_MODES$1.NPM
    };
    var BaseTexture = function(_super) {
      __extends$h(BaseTexture2, _super);
      function BaseTexture2(resource, options) {
        if (resource === void 0) {
          resource = null;
        }
        if (options === void 0) {
          options = null;
        }
        var _this = _super.call(this) || this;
        options = options || {};
        var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width2 = options.width, height2 = options.height, wrapMode = options.wrapMode, format2 = options.format, type = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
        if (resource && !(resource instanceof Resource$1)) {
          resource = autoDetectResource(resource, resourceOptions);
          resource.internal = true;
        }
        _this.width = width2 || 0;
        _this.height = height2 || 0;
        _this.resolution = resolution || settings.RESOLUTION;
        _this.mipmap = mipmap !== void 0 ? mipmap : settings.MIPMAP_TEXTURES;
        _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings.ANISOTROPIC_LEVEL;
        _this.wrapMode = wrapMode || settings.WRAP_MODE;
        _this.scaleMode = scaleMode !== void 0 ? scaleMode : settings.SCALE_MODE;
        _this.format = format2 || FORMATS$1.RGBA;
        _this.type = type || TYPES$1.UNSIGNED_BYTE;
        _this.target = target || TARGETS$1.TEXTURE_2D;
        _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES$1.UNPACK;
        if (options.premultiplyAlpha !== void 0) {
          _this.premultiplyAlpha = options.premultiplyAlpha;
        }
        _this.uid = uid();
        _this.touched = 0;
        _this.isPowerOfTwo = false;
        _this._refreshPOT();
        _this._glTextures = {};
        _this.dirtyId = 0;
        _this.dirtyStyleId = 0;
        _this.cacheId = null;
        _this.valid = width2 > 0 && height2 > 0;
        _this.textureCacheIds = [];
        _this.destroyed = false;
        _this.resource = null;
        _this._batchEnabled = 0;
        _this._batchLocation = 0;
        _this.parentTextureArray = null;
        _this.setResource(resource);
        return _this;
      }
      Object.defineProperty(BaseTexture2.prototype, "realWidth", {
        get: function() {
          return Math.ceil(this.width * this.resolution - 1e-4);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "realHeight", {
        get: function() {
          return Math.ceil(this.height * this.resolution - 1e-4);
        },
        enumerable: false,
        configurable: true
      });
      BaseTexture2.prototype.setStyle = function(scaleMode, mipmap) {
        var dirty;
        if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
          this.scaleMode = scaleMode;
          dirty = true;
        }
        if (mipmap !== void 0 && mipmap !== this.mipmap) {
          this.mipmap = mipmap;
          dirty = true;
        }
        if (dirty) {
          this.dirtyStyleId++;
        }
        return this;
      };
      BaseTexture2.prototype.setSize = function(width2, height2, resolution) {
        this.resolution = resolution || this.resolution;
        this.width = width2;
        this.height = height2;
        this._refreshPOT();
        this.update();
        return this;
      };
      BaseTexture2.prototype.setRealSize = function(realWidth, realHeight, resolution) {
        this.resolution = resolution || this.resolution;
        this.width = realWidth / this.resolution;
        this.height = realHeight / this.resolution;
        this._refreshPOT();
        this.update();
        return this;
      };
      BaseTexture2.prototype._refreshPOT = function() {
        this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
      };
      BaseTexture2.prototype.setResolution = function(resolution) {
        var oldResolution = this.resolution;
        if (oldResolution === resolution) {
          return this;
        }
        this.resolution = resolution;
        if (this.valid) {
          this.width = this.width * oldResolution / resolution;
          this.height = this.height * oldResolution / resolution;
          this.emit("update", this);
        }
        this._refreshPOT();
        return this;
      };
      BaseTexture2.prototype.setResource = function(resource) {
        if (this.resource === resource) {
          return this;
        }
        if (this.resource) {
          throw new Error("Resource can be set only once");
        }
        resource.bind(this);
        this.resource = resource;
        return this;
      };
      BaseTexture2.prototype.update = function() {
        if (!this.valid) {
          if (this.width > 0 && this.height > 0) {
            this.valid = true;
            this.emit("loaded", this);
            this.emit("update", this);
          }
        } else {
          this.dirtyId++;
          this.dirtyStyleId++;
          this.emit("update", this);
        }
      };
      BaseTexture2.prototype.onError = function(event) {
        this.emit("error", this, event);
      };
      BaseTexture2.prototype.destroy = function() {
        if (this.resource) {
          this.resource.unbind(this);
          if (this.resource.internal) {
            this.resource.destroy();
          }
          this.resource = null;
        }
        if (this.cacheId) {
          delete BaseTextureCache[this.cacheId];
          delete TextureCache[this.cacheId];
          this.cacheId = null;
        }
        this.dispose();
        BaseTexture2.removeFromCache(this);
        this.textureCacheIds = null;
        this.destroyed = true;
      };
      BaseTexture2.prototype.dispose = function() {
        this.emit("dispose", this);
      };
      BaseTexture2.prototype.castToBaseTexture = function() {
        return this;
      };
      BaseTexture2.from = function(source, options, strict) {
        if (strict === void 0) {
          strict = settings.STRICT_TEXTURE_CACHE;
        }
        var isFrame = typeof source === "string";
        var cacheId = null;
        if (isFrame) {
          cacheId = source;
        } else {
          if (!source._pixiId) {
            source._pixiId = "pixiid_" + uid();
          }
          cacheId = source._pixiId;
        }
        var baseTexture = BaseTextureCache[cacheId];
        if (isFrame && strict && !baseTexture) {
          throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
        }
        if (!baseTexture) {
          baseTexture = new BaseTexture2(source, options);
          baseTexture.cacheId = cacheId;
          BaseTexture2.addToCache(baseTexture, cacheId);
        }
        return baseTexture;
      };
      BaseTexture2.fromBuffer = function(buffer, width2, height2, options) {
        buffer = buffer || new Float32Array(width2 * height2 * 4);
        var resource = new BufferResource(buffer, { width: width2, height: height2 });
        var type = buffer instanceof Float32Array ? TYPES$1.FLOAT : TYPES$1.UNSIGNED_BYTE;
        return new BaseTexture2(resource, Object.assign(defaultBufferOptions, options || { width: width2, height: height2, type }));
      };
      BaseTexture2.addToCache = function(baseTexture, id2) {
        if (id2) {
          if (baseTexture.textureCacheIds.indexOf(id2) === -1) {
            baseTexture.textureCacheIds.push(id2);
          }
          if (BaseTextureCache[id2]) {
            console.warn("BaseTexture added to the cache with an id [" + id2 + "] that already had an entry");
          }
          BaseTextureCache[id2] = baseTexture;
        }
      };
      BaseTexture2.removeFromCache = function(baseTexture) {
        if (typeof baseTexture === "string") {
          var baseTextureFromCache = BaseTextureCache[baseTexture];
          if (baseTextureFromCache) {
            var index2 = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
            if (index2 > -1) {
              baseTextureFromCache.textureCacheIds.splice(index2, 1);
            }
            delete BaseTextureCache[baseTexture];
            return baseTextureFromCache;
          }
        } else if (baseTexture && baseTexture.textureCacheIds) {
          for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
            delete BaseTextureCache[baseTexture.textureCacheIds[i]];
          }
          baseTexture.textureCacheIds.length = 0;
          return baseTexture;
        }
        return null;
      };
      BaseTexture2._globalBatch = 0;
      return BaseTexture2;
    }(EventEmitter);
    var AbstractMultiResource = function(_super) {
      __extends$h(AbstractMultiResource2, _super);
      function AbstractMultiResource2(length, options) {
        var _this = this;
        var _a2 = options || {}, width2 = _a2.width, height2 = _a2.height;
        _this = _super.call(this, width2, height2) || this;
        _this.items = [];
        _this.itemDirtyIds = [];
        for (var i = 0; i < length; i++) {
          var partTexture = new BaseTexture();
          _this.items.push(partTexture);
          _this.itemDirtyIds.push(-2);
        }
        _this.length = length;
        _this._load = null;
        _this.baseTexture = null;
        return _this;
      }
      AbstractMultiResource2.prototype.initFromArray = function(resources, options) {
        for (var i = 0; i < this.length; i++) {
          if (!resources[i]) {
            continue;
          }
          if (resources[i].castToBaseTexture) {
            this.addBaseTextureAt(resources[i].castToBaseTexture(), i);
          } else if (resources[i] instanceof Resource$1) {
            this.addResourceAt(resources[i], i);
          } else {
            this.addResourceAt(autoDetectResource(resources[i], options), i);
          }
        }
      };
      AbstractMultiResource2.prototype.dispose = function() {
        for (var i = 0, len = this.length; i < len; i++) {
          this.items[i].destroy();
        }
        this.items = null;
        this.itemDirtyIds = null;
        this._load = null;
      };
      AbstractMultiResource2.prototype.addResourceAt = function(resource, index2) {
        if (!this.items[index2]) {
          throw new Error("Index " + index2 + " is out of bounds");
        }
        if (resource.valid && !this.valid) {
          this.resize(resource.width, resource.height);
        }
        this.items[index2].setResource(resource);
        return this;
      };
      AbstractMultiResource2.prototype.bind = function(baseTexture) {
        if (this.baseTexture !== null) {
          throw new Error("Only one base texture per TextureArray is allowed");
        }
        _super.prototype.bind.call(this, baseTexture);
        for (var i = 0; i < this.length; i++) {
          this.items[i].parentTextureArray = baseTexture;
          this.items[i].on("update", baseTexture.update, baseTexture);
        }
      };
      AbstractMultiResource2.prototype.unbind = function(baseTexture) {
        _super.prototype.unbind.call(this, baseTexture);
        for (var i = 0; i < this.length; i++) {
          this.items[i].parentTextureArray = null;
          this.items[i].off("update", baseTexture.update, baseTexture);
        }
      };
      AbstractMultiResource2.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        var resources = this.items.map(function(item) {
          return item.resource;
        }).filter(function(item) {
          return item;
        });
        var promises = resources.map(function(item) {
          return item.load();
        });
        this._load = Promise.all(promises).then(function() {
          var _a2 = _this.items[0], realWidth = _a2.realWidth, realHeight = _a2.realHeight;
          _this.resize(realWidth, realHeight);
          return Promise.resolve(_this);
        });
        return this._load;
      };
      return AbstractMultiResource2;
    }(Resource$1);
    var ArrayResource = function(_super) {
      __extends$h(ArrayResource2, _super);
      function ArrayResource2(source, options) {
        var _this = this;
        var _a2 = options || {}, width2 = _a2.width, height2 = _a2.height;
        var urls;
        var length;
        if (Array.isArray(source)) {
          urls = source;
          length = source.length;
        } else {
          length = source;
        }
        _this = _super.call(this, length, { width: width2, height: height2 }) || this;
        if (urls) {
          _this.initFromArray(urls, options);
        }
        return _this;
      }
      ArrayResource2.prototype.addBaseTextureAt = function(baseTexture, index2) {
        if (baseTexture.resource) {
          this.addResourceAt(baseTexture.resource, index2);
        } else {
          throw new Error("ArrayResource does not support RenderTexture");
        }
        return this;
      };
      ArrayResource2.prototype.bind = function(baseTexture) {
        _super.prototype.bind.call(this, baseTexture);
        baseTexture.target = TARGETS$1.TEXTURE_2D_ARRAY;
      };
      ArrayResource2.prototype.upload = function(renderer, texture, glTexture) {
        var _a2 = this, length = _a2.length, itemDirtyIds = _a2.itemDirtyIds, items2 = _a2.items;
        var gl = renderer.gl;
        if (glTexture.dirtyId < 0) {
          gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, texture.format, this._width, this._height, length, 0, texture.format, texture.type, null);
        }
        for (var i = 0; i < length; i++) {
          var item = items2[i];
          if (itemDirtyIds[i] < item.dirtyId) {
            itemDirtyIds[i] = item.dirtyId;
            if (item.valid) {
              gl.texSubImage3D(
                gl.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                i,
                item.resource.width,
                item.resource.height,
                1,
                texture.format,
                texture.type,
                item.resource.source
              );
            }
          }
        }
        return true;
      };
      return ArrayResource2;
    }(AbstractMultiResource);
    var BaseImageResource = function(_super) {
      __extends$h(BaseImageResource2, _super);
      function BaseImageResource2(source) {
        var _this = this;
        var sourceAny = source;
        var width2 = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
        var height2 = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
        _this = _super.call(this, width2, height2) || this;
        _this.source = source;
        _this.noSubImage = false;
        return _this;
      }
      BaseImageResource2.crossOrigin = function(element, url2, crossorigin) {
        if (crossorigin === void 0 && url2.indexOf("data:") !== 0) {
          element.crossOrigin = determineCrossOrigin(url2);
        } else if (crossorigin !== false) {
          element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
        }
      };
      BaseImageResource2.prototype.upload = function(renderer, baseTexture, glTexture, source) {
        var gl = renderer.gl;
        var width2 = baseTexture.realWidth;
        var height2 = baseTexture.realHeight;
        source = source || this.source;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$1.UNPACK);
        if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width2 && glTexture.height === height2) {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
        } else {
          glTexture.width = width2;
          glTexture.height = height2;
          gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
        }
        return true;
      };
      BaseImageResource2.prototype.update = function() {
        if (this.destroyed) {
          return;
        }
        var source = this.source;
        var width2 = source.naturalWidth || source.videoWidth || source.width;
        var height2 = source.naturalHeight || source.videoHeight || source.height;
        this.resize(width2, height2);
        _super.prototype.update.call(this);
      };
      BaseImageResource2.prototype.dispose = function() {
        this.source = null;
      };
      return BaseImageResource2;
    }(Resource$1);
    var CanvasResource = function(_super) {
      __extends$h(CanvasResource2, _super);
      function CanvasResource2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CanvasResource2.test = function(source) {
        var OffscreenCanvas2 = window.OffscreenCanvas;
        if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
          return true;
        }
        return source instanceof HTMLCanvasElement;
      };
      return CanvasResource2;
    }(BaseImageResource);
    var CubeResource = function(_super) {
      __extends$h(CubeResource2, _super);
      function CubeResource2(source, options) {
        var _this = this;
        var _a2 = options || {}, width2 = _a2.width, height2 = _a2.height, autoLoad = _a2.autoLoad, linkBaseTexture = _a2.linkBaseTexture;
        if (source && source.length !== CubeResource2.SIDES) {
          throw new Error("Invalid length. Got " + source.length + ", expected 6");
        }
        _this = _super.call(this, 6, { width: width2, height: height2 }) || this;
        for (var i = 0; i < CubeResource2.SIDES; i++) {
          _this.items[i].target = TARGETS$1.TEXTURE_CUBE_MAP_POSITIVE_X + i;
        }
        _this.linkBaseTexture = linkBaseTexture !== false;
        if (source) {
          _this.initFromArray(source, options);
        }
        if (autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      CubeResource2.prototype.bind = function(baseTexture) {
        _super.prototype.bind.call(this, baseTexture);
        baseTexture.target = TARGETS$1.TEXTURE_CUBE_MAP;
      };
      CubeResource2.prototype.addBaseTextureAt = function(baseTexture, index2, linkBaseTexture) {
        if (linkBaseTexture === void 0) {
          linkBaseTexture = this.linkBaseTexture;
        }
        if (!this.items[index2]) {
          throw new Error("Index " + index2 + " is out of bounds");
        }
        if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
          if (baseTexture.resource) {
            this.addResourceAt(baseTexture.resource, index2);
          } else {
            throw new Error("CubeResource does not support copying of renderTexture.");
          }
        } else {
          baseTexture.target = TARGETS$1.TEXTURE_CUBE_MAP_POSITIVE_X + index2;
          baseTexture.parentTextureArray = this.baseTexture;
          this.items[index2] = baseTexture;
        }
        if (baseTexture.valid && !this.valid) {
          this.resize(baseTexture.realWidth, baseTexture.realHeight);
        }
        this.items[index2] = baseTexture;
        return this;
      };
      CubeResource2.prototype.upload = function(renderer, _baseTexture, glTexture) {
        var dirty = this.itemDirtyIds;
        for (var i = 0; i < CubeResource2.SIDES; i++) {
          var side = this.items[i];
          if (dirty[i] < side.dirtyId) {
            if (side.valid && side.resource) {
              side.resource.upload(renderer, side, glTexture);
              dirty[i] = side.dirtyId;
            } else if (dirty[i] < -1) {
              renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
              dirty[i] = -1;
            }
          }
        }
        return true;
      };
      CubeResource2.test = function(source) {
        return Array.isArray(source) && source.length === CubeResource2.SIDES;
      };
      CubeResource2.SIDES = 6;
      return CubeResource2;
    }(AbstractMultiResource);
    var ImageResource = function(_super) {
      __extends$h(ImageResource2, _super);
      function ImageResource2(source, options) {
        var _this = this;
        options = options || {};
        if (!(source instanceof HTMLImageElement)) {
          var imageElement = new Image();
          BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
          imageElement.src = source;
          source = imageElement;
        }
        _this = _super.call(this, source) || this;
        if (!source.complete && !!_this._width && !!_this._height) {
          _this._width = 0;
          _this._height = 0;
        }
        _this.url = source.src;
        _this._process = null;
        _this.preserveBitmap = false;
        _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!window.createImageBitmap;
        _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
        if (options.premultiplyAlpha !== void 0) {
          _this.premultiplyAlpha = options.premultiplyAlpha;
        }
        _this.bitmap = null;
        _this._load = null;
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      ImageResource2.prototype.load = function(createBitmap) {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        if (createBitmap !== void 0) {
          this.createBitmap = createBitmap;
        }
        this._load = new Promise(function(resolve, reject2) {
          var source = _this.source;
          _this.url = source.src;
          var completed = function() {
            if (_this.destroyed) {
              return;
            }
            source.onload = null;
            source.onerror = null;
            _this.resize(source.width, source.height);
            _this._load = null;
            if (_this.createBitmap) {
              resolve(_this.process());
            } else {
              resolve(_this);
            }
          };
          if (source.complete && source.src) {
            completed();
          } else {
            source.onload = completed;
            source.onerror = function(event) {
              reject2(event);
              _this.onError.emit(event);
            };
          }
        });
        return this._load;
      };
      ImageResource2.prototype.process = function() {
        var _this = this;
        var source = this.source;
        if (this._process !== null) {
          return this._process;
        }
        if (this.bitmap !== null || !window.createImageBitmap) {
          return Promise.resolve(this);
        }
        this._process = window.createImageBitmap(source, 0, 0, source.width, source.height, {
          premultiplyAlpha: this.alphaMode === ALPHA_MODES$1.UNPACK ? "premultiply" : "none"
        }).then(function(bitmap) {
          if (_this.destroyed) {
            return Promise.reject();
          }
          _this.bitmap = bitmap;
          _this.update();
          _this._process = null;
          return Promise.resolve(_this);
        });
        return this._process;
      };
      ImageResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
        if (typeof this.alphaMode === "number") {
          baseTexture.alphaMode = this.alphaMode;
        }
        if (!this.createBitmap) {
          return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);
        }
        if (!this.bitmap) {
          this.process();
          if (!this.bitmap) {
            return false;
          }
        }
        _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);
        if (!this.preserveBitmap) {
          var flag = true;
          var glTextures = baseTexture._glTextures;
          for (var key in glTextures) {
            var otherTex = glTextures[key];
            if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
              flag = false;
              break;
            }
          }
          if (flag) {
            if (this.bitmap.close) {
              this.bitmap.close();
            }
            this.bitmap = null;
          }
        }
        return true;
      };
      ImageResource2.prototype.dispose = function() {
        this.source.onload = null;
        this.source.onerror = null;
        _super.prototype.dispose.call(this);
        if (this.bitmap) {
          this.bitmap.close();
          this.bitmap = null;
        }
        this._process = null;
        this._load = null;
      };
      ImageResource2.test = function(source) {
        return typeof source === "string" || source instanceof HTMLImageElement;
      };
      return ImageResource2;
    }(BaseImageResource);
    var SVGResource = function(_super) {
      __extends$h(SVGResource2, _super);
      function SVGResource2(sourceBase64, options) {
        var _this = this;
        options = options || {};
        _this = _super.call(this, document.createElement("canvas")) || this;
        _this._width = 0;
        _this._height = 0;
        _this.svg = sourceBase64;
        _this.scale = options.scale || 1;
        _this._overrideWidth = options.width;
        _this._overrideHeight = options.height;
        _this._resolve = null;
        _this._crossorigin = options.crossorigin;
        _this._load = null;
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      SVGResource2.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        this._load = new Promise(function(resolve) {
          _this._resolve = function() {
            _this.resize(_this.source.width, _this.source.height);
            resolve(_this);
          };
          if (/^\<svg/.test(_this.svg.trim())) {
            if (!btoa) {
              throw new Error("Your browser doesn't support base64 conversions.");
            }
            _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
          }
          _this._loadSvg();
        });
        return this._load;
      };
      SVGResource2.prototype._loadSvg = function() {
        var _this = this;
        var tempImage = new Image();
        BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
        tempImage.src = this.svg;
        tempImage.onerror = function(event) {
          if (!_this._resolve) {
            return;
          }
          tempImage.onerror = null;
          _this.onError.emit(event);
        };
        tempImage.onload = function() {
          if (!_this._resolve) {
            return;
          }
          var svgWidth = tempImage.width;
          var svgHeight = tempImage.height;
          if (!svgWidth || !svgHeight) {
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          }
          var width2 = svgWidth * _this.scale;
          var height2 = svgHeight * _this.scale;
          if (_this._overrideWidth || _this._overrideHeight) {
            width2 = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
            height2 = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
          }
          width2 = Math.round(width2);
          height2 = Math.round(height2);
          var canvas2 = _this.source;
          canvas2.width = width2;
          canvas2.height = height2;
          canvas2._pixiId = "canvas_" + uid();
          canvas2.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width2, height2);
          _this._resolve();
          _this._resolve = null;
        };
      };
      SVGResource2.getSize = function(svgString) {
        var sizeMatch = SVGResource2.SVG_SIZE.exec(svgString);
        var size2 = {};
        if (sizeMatch) {
          size2[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
          size2[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
        }
        return size2;
      };
      SVGResource2.prototype.dispose = function() {
        _super.prototype.dispose.call(this);
        this._resolve = null;
        this._crossorigin = null;
      };
      SVGResource2.test = function(source, extension) {
        return extension === "svg" || typeof source === "string" && source.indexOf("data:image/svg+xml;base64") === 0 || typeof source === "string" && source.indexOf("<svg") === 0;
      };
      SVGResource2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
      return SVGResource2;
    }(BaseImageResource);
    var VideoResource = function(_super) {
      __extends$h(VideoResource2, _super);
      function VideoResource2(source, options) {
        var _this = this;
        options = options || {};
        if (!(source instanceof HTMLVideoElement)) {
          var videoElement = document.createElement("video");
          videoElement.setAttribute("preload", "auto");
          videoElement.setAttribute("webkit-playsinline", "");
          videoElement.setAttribute("playsinline", "");
          if (typeof source === "string") {
            source = [source];
          }
          var firstSrc = source[0].src || source[0];
          BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
          for (var i = 0; i < source.length; ++i) {
            var sourceElement = document.createElement("source");
            var _a2 = source[i], src = _a2.src, mime = _a2.mime;
            src = src || source[i];
            var baseSrc = src.split("?").shift().toLowerCase();
            var ext = baseSrc.substr(baseSrc.lastIndexOf(".") + 1);
            mime = mime || VideoResource2.MIME_TYPES[ext] || "video/" + ext;
            sourceElement.src = src;
            sourceElement.type = mime;
            videoElement.appendChild(sourceElement);
          }
          source = videoElement;
        }
        _this = _super.call(this, source) || this;
        _this.noSubImage = true;
        _this._autoUpdate = true;
        _this._isConnectedToTicker = false;
        _this._updateFPS = options.updateFPS || 0;
        _this._msToNextUpdate = 0;
        _this.autoPlay = options.autoPlay !== false;
        _this._load = null;
        _this._resolve = null;
        _this._onCanPlay = _this._onCanPlay.bind(_this);
        _this._onError = _this._onError.bind(_this);
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      VideoResource2.prototype.update = function(_deltaTime) {
        if (!this.destroyed) {
          var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
          if (!this._updateFPS || this._msToNextUpdate <= 0) {
            _super.prototype.update.call(this);
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
          }
        }
      };
      VideoResource2.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        var source = this.source;
        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
          source.complete = true;
        }
        source.addEventListener("play", this._onPlayStart.bind(this));
        source.addEventListener("pause", this._onPlayStop.bind(this));
        if (!this._isSourceReady()) {
          source.addEventListener("canplay", this._onCanPlay);
          source.addEventListener("canplaythrough", this._onCanPlay);
          source.addEventListener("error", this._onError, true);
        } else {
          this._onCanPlay();
        }
        this._load = new Promise(function(resolve) {
          if (_this.valid) {
            resolve(_this);
          } else {
            _this._resolve = resolve;
            source.load();
          }
        });
        return this._load;
      };
      VideoResource2.prototype._onError = function(event) {
        this.source.removeEventListener("error", this._onError, true);
        this.onError.emit(event);
      };
      VideoResource2.prototype._isSourcePlaying = function() {
        var source = this.source;
        return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
      };
      VideoResource2.prototype._isSourceReady = function() {
        var source = this.source;
        return source.readyState === 3 || source.readyState === 4;
      };
      VideoResource2.prototype._onPlayStart = function() {
        if (!this.valid) {
          this._onCanPlay();
        }
        if (this.autoUpdate && !this._isConnectedToTicker) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      };
      VideoResource2.prototype._onPlayStop = function() {
        if (this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        }
      };
      VideoResource2.prototype._onCanPlay = function() {
        var source = this.source;
        source.removeEventListener("canplay", this._onCanPlay);
        source.removeEventListener("canplaythrough", this._onCanPlay);
        var valid = this.valid;
        this.resize(source.videoWidth, source.videoHeight);
        if (!valid && this._resolve) {
          this._resolve(this);
          this._resolve = null;
        }
        if (this._isSourcePlaying()) {
          this._onPlayStart();
        } else if (this.autoPlay) {
          source.play();
        }
      };
      VideoResource2.prototype.dispose = function() {
        if (this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
        }
        var source = this.source;
        if (source) {
          source.removeEventListener("error", this._onError, true);
          source.pause();
          source.src = "";
          source.load();
        }
        _super.prototype.dispose.call(this);
      };
      Object.defineProperty(VideoResource2.prototype, "autoUpdate", {
        get: function() {
          return this._autoUpdate;
        },
        set: function(value2) {
          if (value2 !== this._autoUpdate) {
            this._autoUpdate = value2;
            if (!this._autoUpdate && this._isConnectedToTicker) {
              Ticker.shared.remove(this.update, this);
              this._isConnectedToTicker = false;
            } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
              Ticker.shared.add(this.update, this);
              this._isConnectedToTicker = true;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(VideoResource2.prototype, "updateFPS", {
        get: function() {
          return this._updateFPS;
        },
        set: function(value2) {
          if (value2 !== this._updateFPS) {
            this._updateFPS = value2;
          }
        },
        enumerable: false,
        configurable: true
      });
      VideoResource2.test = function(source, extension) {
        return source instanceof HTMLVideoElement || VideoResource2.TYPES.indexOf(extension) > -1;
      };
      VideoResource2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
      VideoResource2.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
      };
      return VideoResource2;
    }(BaseImageResource);
    var ImageBitmapResource = function(_super) {
      __extends$h(ImageBitmapResource2, _super);
      function ImageBitmapResource2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ImageBitmapResource2.test = function(source) {
        return !!window.createImageBitmap && source instanceof ImageBitmap;
      };
      return ImageBitmapResource2;
    }(BaseImageResource);
    INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
    var System = function() {
      function System2(renderer) {
        this.renderer = renderer;
      }
      System2.prototype.destroy = function() {
        this.renderer = null;
      };
      return System2;
    }();
    var DepthResource = function(_super) {
      __extends$h(DepthResource2, _super);
      function DepthResource2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DepthResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$1.UNPACK);
        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
          gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
        } else {
          glTexture.width = baseTexture.width;
          glTexture.height = baseTexture.height;
          gl.texImage2D(
            baseTexture.target,
            0,
            renderer.context.webGLVersion === 1 ? gl.DEPTH_COMPONENT : gl.DEPTH_COMPONENT16,
            baseTexture.width,
            baseTexture.height,
            0,
            baseTexture.format,
            baseTexture.type,
            this.data
          );
        }
        return true;
      };
      return DepthResource2;
    }(BufferResource);
    var Framebuffer = function() {
      function Framebuffer2(width2, height2) {
        this.width = Math.ceil(width2 || 100);
        this.height = Math.ceil(height2 || 100);
        this.stencil = false;
        this.depth = false;
        this.dirtyId = 0;
        this.dirtyFormat = 0;
        this.dirtySize = 0;
        this.depthTexture = null;
        this.colorTextures = [];
        this.glFramebuffers = {};
        this.disposeRunner = new Runner("disposeFramebuffer");
        this.multisample = MSAA_QUALITY$1.NONE;
      }
      Object.defineProperty(Framebuffer2.prototype, "colorTexture", {
        get: function() {
          return this.colorTextures[0];
        },
        enumerable: false,
        configurable: true
      });
      Framebuffer2.prototype.addColorTexture = function(index2, texture) {
        if (index2 === void 0) {
          index2 = 0;
        }
        this.colorTextures[index2] = texture || new BaseTexture(null, {
          scaleMode: SCALE_MODES$1.NEAREST,
          resolution: 1,
          mipmap: MIPMAP_MODES$1.OFF,
          width: this.width,
          height: this.height
        });
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer2.prototype.addDepthTexture = function(texture) {
        this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
          scaleMode: SCALE_MODES$1.NEAREST,
          resolution: 1,
          width: this.width,
          height: this.height,
          mipmap: MIPMAP_MODES$1.OFF,
          format: FORMATS$1.DEPTH_COMPONENT,
          type: TYPES$1.UNSIGNED_SHORT
        });
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer2.prototype.enableDepth = function() {
        this.depth = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer2.prototype.enableStencil = function() {
        this.stencil = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer2.prototype.resize = function(width2, height2) {
        width2 = Math.ceil(width2);
        height2 = Math.ceil(height2);
        if (width2 === this.width && height2 === this.height) {
          return;
        }
        this.width = width2;
        this.height = height2;
        this.dirtyId++;
        this.dirtySize++;
        for (var i = 0; i < this.colorTextures.length; i++) {
          var texture = this.colorTextures[i];
          var resolution = texture.resolution;
          texture.setSize(width2 / resolution, height2 / resolution);
        }
        if (this.depthTexture) {
          var resolution = this.depthTexture.resolution;
          this.depthTexture.setSize(width2 / resolution, height2 / resolution);
        }
      };
      Framebuffer2.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Framebuffer2.prototype.destroyDepthTexture = function() {
        if (this.depthTexture) {
          this.depthTexture.destroy();
          this.depthTexture = null;
          ++this.dirtyId;
          ++this.dirtyFormat;
        }
      };
      return Framebuffer2;
    }();
    var BaseRenderTexture = function(_super) {
      __extends$h(BaseRenderTexture2, _super);
      function BaseRenderTexture2(options) {
        var _this = this;
        if (typeof options === "number") {
          var width_1 = arguments[0];
          var height_1 = arguments[1];
          var scaleMode = arguments[2];
          var resolution = arguments[3];
          options = { width: width_1, height: height_1, scaleMode, resolution };
        }
        _this = _super.call(this, null, options) || this;
        var _a2 = options || {}, width2 = _a2.width, height2 = _a2.height;
        _this.mipmap = 0;
        _this.width = Math.ceil(width2) || 100;
        _this.height = Math.ceil(height2) || 100;
        _this.valid = true;
        _this.clearColor = [0, 0, 0, 0];
        _this.framebuffer = new Framebuffer(_this.width * _this.resolution, _this.height * _this.resolution).addColorTexture(0, _this);
        _this.maskStack = [];
        _this.filterStack = [{}];
        return _this;
      }
      BaseRenderTexture2.prototype.resize = function(width2, height2) {
        width2 = Math.ceil(width2);
        height2 = Math.ceil(height2);
        this.framebuffer.resize(width2 * this.resolution, height2 * this.resolution);
      };
      BaseRenderTexture2.prototype.dispose = function() {
        this.framebuffer.dispose();
        _super.prototype.dispose.call(this);
      };
      BaseRenderTexture2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        this.framebuffer.destroyDepthTexture();
        this.framebuffer = null;
      };
      return BaseRenderTexture2;
    }(BaseTexture);
    var TextureUvs = function() {
      function TextureUvs2() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 1;
        this.y1 = 0;
        this.x2 = 1;
        this.y2 = 1;
        this.x3 = 0;
        this.y3 = 1;
        this.uvsFloat32 = new Float32Array(8);
      }
      TextureUvs2.prototype.set = function(frame, baseFrame, rotate) {
        var tw = baseFrame.width;
        var th2 = baseFrame.height;
        if (rotate) {
          var w2 = frame.width / 2 / tw;
          var h2 = frame.height / 2 / th2;
          var cX = frame.x / tw + w2;
          var cY = frame.y / th2 + h2;
          rotate = groupD8.add(rotate, groupD8.NW);
          this.x0 = cX + w2 * groupD8.uX(rotate);
          this.y0 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          this.x1 = cX + w2 * groupD8.uX(rotate);
          this.y1 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          this.x2 = cX + w2 * groupD8.uX(rotate);
          this.y2 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          this.x3 = cX + w2 * groupD8.uX(rotate);
          this.y3 = cY + h2 * groupD8.uY(rotate);
        } else {
          this.x0 = frame.x / tw;
          this.y0 = frame.y / th2;
          this.x1 = (frame.x + frame.width) / tw;
          this.y1 = frame.y / th2;
          this.x2 = (frame.x + frame.width) / tw;
          this.y2 = (frame.y + frame.height) / th2;
          this.x3 = frame.x / tw;
          this.y3 = (frame.y + frame.height) / th2;
        }
        this.uvsFloat32[0] = this.x0;
        this.uvsFloat32[1] = this.y0;
        this.uvsFloat32[2] = this.x1;
        this.uvsFloat32[3] = this.y1;
        this.uvsFloat32[4] = this.x2;
        this.uvsFloat32[5] = this.y2;
        this.uvsFloat32[6] = this.x3;
        this.uvsFloat32[7] = this.y3;
      };
      return TextureUvs2;
    }();
    var DEFAULT_UVS = new TextureUvs();
    var Texture = function(_super) {
      __extends$h(Texture2, _super);
      function Texture2(baseTexture, frame, orig, trim2, rotate, anchor) {
        var _this = _super.call(this) || this;
        _this.noFrame = false;
        if (!frame) {
          _this.noFrame = true;
          frame = new Rectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof Texture2) {
          baseTexture = baseTexture.baseTexture;
        }
        _this.baseTexture = baseTexture;
        _this._frame = frame;
        _this.trim = trim2;
        _this.valid = false;
        _this._uvs = DEFAULT_UVS;
        _this.uvMatrix = null;
        _this.orig = orig || frame;
        _this._rotate = Number(rotate || 0);
        if (rotate === true) {
          _this._rotate = 2;
        } else if (_this._rotate % 2 !== 0) {
          throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        }
        _this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
        _this._updateID = 0;
        _this.textureCacheIds = [];
        if (!baseTexture.valid) {
          baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
        } else if (_this.noFrame) {
          if (baseTexture.valid) {
            _this.onBaseTextureUpdated(baseTexture);
          }
        } else {
          _this.frame = frame;
        }
        if (_this.noFrame) {
          baseTexture.on("update", _this.onBaseTextureUpdated, _this);
        }
        return _this;
      }
      Texture2.prototype.update = function() {
        if (this.baseTexture.resource) {
          this.baseTexture.resource.update();
        }
      };
      Texture2.prototype.onBaseTextureUpdated = function(baseTexture) {
        if (this.noFrame) {
          if (!this.baseTexture.valid) {
            return;
          }
          this._frame.width = baseTexture.width;
          this._frame.height = baseTexture.height;
          this.valid = true;
          this.updateUvs();
        } else {
          this.frame = this._frame;
        }
        this.emit("update", this);
      };
      Texture2.prototype.destroy = function(destroyBase) {
        if (this.baseTexture) {
          if (destroyBase) {
            var resource = this.baseTexture;
            if (resource && resource.url && TextureCache[resource.url]) {
              Texture2.removeFromCache(resource.url);
            }
            this.baseTexture.destroy();
          }
          this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
          this.baseTexture.off("update", this.onBaseTextureUpdated, this);
          this.baseTexture = null;
        }
        this._frame = null;
        this._uvs = null;
        this.trim = null;
        this.orig = null;
        this.valid = false;
        Texture2.removeFromCache(this);
        this.textureCacheIds = null;
      };
      Texture2.prototype.clone = function() {
        return new Texture2(this.baseTexture, this.frame.clone(), this.orig.clone(), this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
      };
      Texture2.prototype.updateUvs = function() {
        if (this._uvs === DEFAULT_UVS) {
          this._uvs = new TextureUvs();
        }
        this._uvs.set(this._frame, this.baseTexture, this.rotate);
        this._updateID++;
      };
      Texture2.from = function(source, options, strict) {
        if (options === void 0) {
          options = {};
        }
        if (strict === void 0) {
          strict = settings.STRICT_TEXTURE_CACHE;
        }
        var isFrame = typeof source === "string";
        var cacheId = null;
        if (isFrame) {
          cacheId = source;
        } else {
          if (!source._pixiId) {
            source._pixiId = "pixiid_" + uid();
          }
          cacheId = source._pixiId;
        }
        var texture = TextureCache[cacheId];
        if (isFrame && strict && !texture) {
          throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
        }
        if (!texture) {
          if (!options.resolution) {
            options.resolution = getResolutionOfUrl(source);
          }
          texture = new Texture2(new BaseTexture(source, options));
          texture.baseTexture.cacheId = cacheId;
          BaseTexture.addToCache(texture.baseTexture, cacheId);
          Texture2.addToCache(texture, cacheId);
        }
        return texture;
      };
      Texture2.fromURL = function(url2, options) {
        var resourceOptions = Object.assign({ autoLoad: false }, options === null || options === void 0 ? void 0 : options.resourceOptions);
        var texture = Texture2.from(url2, Object.assign({ resourceOptions }, options), false);
        var resource = texture.baseTexture.resource;
        if (texture.baseTexture.valid) {
          return Promise.resolve(texture);
        }
        return resource.load().then(function() {
          return Promise.resolve(texture);
        });
      };
      Texture2.fromBuffer = function(buffer, width2, height2, options) {
        return new Texture2(BaseTexture.fromBuffer(buffer, width2, height2, options));
      };
      Texture2.fromLoader = function(source, imageUrl, name2) {
        var resource = new ImageResource(source);
        resource.url = imageUrl;
        var baseTexture = new BaseTexture(resource, {
          scaleMode: settings.SCALE_MODE,
          resolution: getResolutionOfUrl(imageUrl)
        });
        var texture = new Texture2(baseTexture);
        if (!name2) {
          name2 = imageUrl;
        }
        BaseTexture.addToCache(texture.baseTexture, name2);
        Texture2.addToCache(texture, name2);
        if (name2 !== imageUrl) {
          BaseTexture.addToCache(texture.baseTexture, imageUrl);
          Texture2.addToCache(texture, imageUrl);
        }
        return texture;
      };
      Texture2.addToCache = function(texture, id2) {
        if (id2) {
          if (texture.textureCacheIds.indexOf(id2) === -1) {
            texture.textureCacheIds.push(id2);
          }
          if (TextureCache[id2]) {
            console.warn("Texture added to the cache with an id [" + id2 + "] that already had an entry");
          }
          TextureCache[id2] = texture;
        }
      };
      Texture2.removeFromCache = function(texture) {
        if (typeof texture === "string") {
          var textureFromCache = TextureCache[texture];
          if (textureFromCache) {
            var index2 = textureFromCache.textureCacheIds.indexOf(texture);
            if (index2 > -1) {
              textureFromCache.textureCacheIds.splice(index2, 1);
            }
            delete TextureCache[texture];
            return textureFromCache;
          }
        } else if (texture && texture.textureCacheIds) {
          for (var i = 0; i < texture.textureCacheIds.length; ++i) {
            if (TextureCache[texture.textureCacheIds[i]] === texture) {
              delete TextureCache[texture.textureCacheIds[i]];
            }
          }
          texture.textureCacheIds.length = 0;
          return texture;
        }
        return null;
      };
      Object.defineProperty(Texture2.prototype, "resolution", {
        get: function() {
          return this.baseTexture.resolution;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture2.prototype, "frame", {
        get: function() {
          return this._frame;
        },
        set: function(frame) {
          this._frame = frame;
          this.noFrame = false;
          var x2 = frame.x, y2 = frame.y, width2 = frame.width, height2 = frame.height;
          var xNotFit = x2 + width2 > this.baseTexture.width;
          var yNotFit = y2 + height2 > this.baseTexture.height;
          if (xNotFit || yNotFit) {
            var relationship = xNotFit && yNotFit ? "and" : "or";
            var errorX = "X: " + x2 + " + " + width2 + " = " + (x2 + width2) + " > " + this.baseTexture.width;
            var errorY = "Y: " + y2 + " + " + height2 + " = " + (y2 + height2) + " > " + this.baseTexture.height;
            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
          }
          this.valid = width2 && height2 && this.baseTexture.valid;
          if (!this.trim && !this.rotate) {
            this.orig = frame;
          }
          if (this.valid) {
            this.updateUvs();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture2.prototype, "rotate", {
        get: function() {
          return this._rotate;
        },
        set: function(rotate) {
          this._rotate = rotate;
          if (this.valid) {
            this.updateUvs();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture2.prototype, "width", {
        get: function() {
          return this.orig.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture2.prototype, "height", {
        get: function() {
          return this.orig.height;
        },
        enumerable: false,
        configurable: true
      });
      Texture2.prototype.castToBaseTexture = function() {
        return this.baseTexture;
      };
      return Texture2;
    }(EventEmitter);
    function createWhiteTexture() {
      var canvas2 = document.createElement("canvas");
      canvas2.width = 16;
      canvas2.height = 16;
      var context2 = canvas2.getContext("2d");
      context2.fillStyle = "white";
      context2.fillRect(0, 0, 16, 16);
      return new Texture(new BaseTexture(new CanvasResource(canvas2)));
    }
    function removeAllHandlers(tex) {
      tex.destroy = function _emptyDestroy() {
      };
      tex.on = function _emptyOn() {
      };
      tex.once = function _emptyOnce() {
      };
      tex.emit = function _emptyEmit() {
      };
    }
    Texture.EMPTY = new Texture(new BaseTexture());
    removeAllHandlers(Texture.EMPTY);
    removeAllHandlers(Texture.EMPTY.baseTexture);
    Texture.WHITE = createWhiteTexture();
    removeAllHandlers(Texture.WHITE);
    removeAllHandlers(Texture.WHITE.baseTexture);
    var RenderTexture = function(_super) {
      __extends$h(RenderTexture2, _super);
      function RenderTexture2(baseRenderTexture, frame) {
        var _this = this;
        var _legacyRenderer = null;
        if (!(baseRenderTexture instanceof BaseRenderTexture)) {
          var width2 = arguments[1];
          var height2 = arguments[2];
          var scaleMode = arguments[3];
          var resolution = arguments[4];
          console.warn("Please use RenderTexture.create(" + width2 + ", " + height2 + ") instead of the ctor directly.");
          _legacyRenderer = arguments[0];
          frame = null;
          baseRenderTexture = new BaseRenderTexture({
            width: width2,
            height: height2,
            scaleMode,
            resolution
          });
        }
        _this = _super.call(this, baseRenderTexture, frame) || this;
        _this.legacyRenderer = _legacyRenderer;
        _this.valid = true;
        _this.filterFrame = null;
        _this.filterPoolKey = null;
        _this.updateUvs();
        return _this;
      }
      Object.defineProperty(RenderTexture2.prototype, "framebuffer", {
        get: function() {
          return this.baseTexture.framebuffer;
        },
        enumerable: false,
        configurable: true
      });
      RenderTexture2.prototype.resize = function(width2, height2, resizeBaseTexture) {
        if (resizeBaseTexture === void 0) {
          resizeBaseTexture = true;
        }
        width2 = Math.ceil(width2);
        height2 = Math.ceil(height2);
        this.valid = width2 > 0 && height2 > 0;
        this._frame.width = this.orig.width = width2;
        this._frame.height = this.orig.height = height2;
        if (resizeBaseTexture) {
          this.baseTexture.resize(width2, height2);
        }
        this.updateUvs();
      };
      RenderTexture2.prototype.setResolution = function(resolution) {
        var baseTexture = this.baseTexture;
        if (baseTexture.resolution === resolution) {
          return;
        }
        baseTexture.setResolution(resolution);
        this.resize(baseTexture.width, baseTexture.height, false);
      };
      RenderTexture2.create = function(options) {
        if (typeof options === "number") {
          options = {
            width: options,
            height: arguments[1],
            scaleMode: arguments[2],
            resolution: arguments[3]
          };
        }
        return new RenderTexture2(new BaseRenderTexture(options));
      };
      return RenderTexture2;
    }(Texture);
    var RenderTexturePool = function() {
      function RenderTexturePool2(textureOptions) {
        this.texturePool = {};
        this.textureOptions = textureOptions || {};
        this.enableFullScreen = false;
        this._pixelsWidth = 0;
        this._pixelsHeight = 0;
      }
      RenderTexturePool2.prototype.createTexture = function(realWidth, realHeight) {
        var baseRenderTexture = new BaseRenderTexture(Object.assign({
          width: realWidth,
          height: realHeight,
          resolution: 1
        }, this.textureOptions));
        return new RenderTexture(baseRenderTexture);
      };
      RenderTexturePool2.prototype.getOptimalTexture = function(minWidth, minHeight, resolution) {
        if (resolution === void 0) {
          resolution = 1;
        }
        var key = RenderTexturePool2.SCREEN_KEY;
        minWidth *= resolution;
        minHeight *= resolution;
        if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
          minWidth = nextPow2(minWidth);
          minHeight = nextPow2(minHeight);
          key = (minWidth & 65535) << 16 | minHeight & 65535;
        }
        if (!this.texturePool[key]) {
          this.texturePool[key] = [];
        }
        var renderTexture = this.texturePool[key].pop();
        if (!renderTexture) {
          renderTexture = this.createTexture(minWidth, minHeight);
        }
        renderTexture.filterPoolKey = key;
        renderTexture.setResolution(resolution);
        return renderTexture;
      };
      RenderTexturePool2.prototype.getFilterTexture = function(input, resolution) {
        var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution);
        filterTexture.filterFrame = input.filterFrame;
        return filterTexture;
      };
      RenderTexturePool2.prototype.returnTexture = function(renderTexture) {
        var key = renderTexture.filterPoolKey;
        renderTexture.filterFrame = null;
        this.texturePool[key].push(renderTexture);
      };
      RenderTexturePool2.prototype.returnFilterTexture = function(renderTexture) {
        this.returnTexture(renderTexture);
      };
      RenderTexturePool2.prototype.clear = function(destroyTextures) {
        destroyTextures = destroyTextures !== false;
        if (destroyTextures) {
          for (var i in this.texturePool) {
            var textures = this.texturePool[i];
            if (textures) {
              for (var j = 0; j < textures.length; j++) {
                textures[j].destroy(true);
              }
            }
          }
        }
        this.texturePool = {};
      };
      RenderTexturePool2.prototype.setScreenSize = function(size2) {
        if (size2.width === this._pixelsWidth && size2.height === this._pixelsHeight) {
          return;
        }
        var screenKey = RenderTexturePool2.SCREEN_KEY;
        var textures = this.texturePool[screenKey];
        this.enableFullScreen = size2.width > 0 && size2.height > 0;
        if (textures) {
          for (var j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
        this.texturePool[screenKey] = [];
        this._pixelsWidth = size2.width;
        this._pixelsHeight = size2.height;
      };
      RenderTexturePool2.SCREEN_KEY = "screen";
      return RenderTexturePool2;
    }();
    var Attribute = function() {
      function Attribute2(buffer, size2, normalized, type, stride, start, instance) {
        if (size2 === void 0) {
          size2 = 0;
        }
        if (normalized === void 0) {
          normalized = false;
        }
        if (type === void 0) {
          type = 5126;
        }
        this.buffer = buffer;
        this.size = size2;
        this.normalized = normalized;
        this.type = type;
        this.stride = stride;
        this.start = start;
        this.instance = instance;
      }
      Attribute2.prototype.destroy = function() {
        this.buffer = null;
      };
      Attribute2.from = function(buffer, size2, normalized, type, stride) {
        return new Attribute2(buffer, size2, normalized, type, stride);
      };
      return Attribute2;
    }();
    var UID = 0;
    var Buffer$1 = function() {
      function Buffer2(data, _static, index2) {
        if (_static === void 0) {
          _static = true;
        }
        if (index2 === void 0) {
          index2 = false;
        }
        this.data = data || new Float32Array(1);
        this._glBuffers = {};
        this._updateID = 0;
        this.index = index2;
        this.static = _static;
        this.id = UID++;
        this.disposeRunner = new Runner("disposeBuffer");
      }
      Buffer2.prototype.update = function(data) {
        this.data = data || this.data;
        this._updateID++;
      };
      Buffer2.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Buffer2.prototype.destroy = function() {
        this.dispose();
        this.data = null;
      };
      Buffer2.from = function(data) {
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        return new Buffer2(data);
      };
      return Buffer2;
    }();
    function getBufferType(array) {
      if (array.BYTES_PER_ELEMENT === 4) {
        if (array instanceof Float32Array) {
          return "Float32Array";
        } else if (array instanceof Uint32Array) {
          return "Uint32Array";
        }
        return "Int32Array";
      } else if (array.BYTES_PER_ELEMENT === 2) {
        if (array instanceof Uint16Array) {
          return "Uint16Array";
        }
      } else if (array.BYTES_PER_ELEMENT === 1) {
        if (array instanceof Uint8Array) {
          return "Uint8Array";
        }
      }
      return null;
    }
    var map$2 = {
      Float32Array,
      Uint32Array,
      Int32Array,
      Uint8Array
    };
    function interleaveTypedArrays(arrays, sizes) {
      var outSize = 0;
      var stride = 0;
      var views = {};
      for (var i = 0; i < arrays.length; i++) {
        stride += sizes[i];
        outSize += arrays[i].length;
      }
      var buffer = new ArrayBuffer(outSize * 4);
      var out = null;
      var littleOffset = 0;
      for (var i = 0; i < arrays.length; i++) {
        var size2 = sizes[i];
        var array = arrays[i];
        var type = getBufferType(array);
        if (!views[type]) {
          views[type] = new map$2[type](buffer);
        }
        out = views[type];
        for (var j = 0; j < array.length; j++) {
          var indexStart = (j / size2 | 0) * stride + littleOffset;
          var index2 = j % size2;
          out[indexStart + index2] = array[j];
        }
        littleOffset += size2;
      }
      return new Float32Array(buffer);
    }
    var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
    var UID$1 = 0;
    var map$1$1 = {
      Float32Array,
      Uint32Array,
      Int32Array,
      Uint8Array,
      Uint16Array
    };
    var Geometry = function() {
      function Geometry2(buffers, attributes) {
        if (buffers === void 0) {
          buffers = [];
        }
        if (attributes === void 0) {
          attributes = {};
        }
        this.buffers = buffers;
        this.indexBuffer = null;
        this.attributes = attributes;
        this.glVertexArrayObjects = {};
        this.id = UID$1++;
        this.instanced = false;
        this.instanceCount = 1;
        this.disposeRunner = new Runner("disposeGeometry");
        this.refCount = 0;
      }
      Geometry2.prototype.addAttribute = function(id2, buffer, size2, normalized, type, stride, start, instance) {
        if (size2 === void 0) {
          size2 = 0;
        }
        if (normalized === void 0) {
          normalized = false;
        }
        if (instance === void 0) {
          instance = false;
        }
        if (!buffer) {
          throw new Error("You must pass a buffer when creating an attribute");
        }
        if (!(buffer instanceof Buffer$1)) {
          if (buffer instanceof Array) {
            buffer = new Float32Array(buffer);
          }
          buffer = new Buffer$1(buffer);
        }
        var ids = id2.split("|");
        if (ids.length > 1) {
          for (var i = 0; i < ids.length; i++) {
            this.addAttribute(ids[i], buffer, size2, normalized, type);
          }
          return this;
        }
        var bufferIndex = this.buffers.indexOf(buffer);
        if (bufferIndex === -1) {
          this.buffers.push(buffer);
          bufferIndex = this.buffers.length - 1;
        }
        this.attributes[id2] = new Attribute(bufferIndex, size2, normalized, type, stride, start, instance);
        this.instanced = this.instanced || instance;
        return this;
      };
      Geometry2.prototype.getAttribute = function(id2) {
        return this.attributes[id2];
      };
      Geometry2.prototype.getBuffer = function(id2) {
        return this.buffers[this.getAttribute(id2).buffer];
      };
      Geometry2.prototype.addIndex = function(buffer) {
        if (!(buffer instanceof Buffer$1)) {
          if (buffer instanceof Array) {
            buffer = new Uint16Array(buffer);
          }
          buffer = new Buffer$1(buffer);
        }
        buffer.index = true;
        this.indexBuffer = buffer;
        if (this.buffers.indexOf(buffer) === -1) {
          this.buffers.push(buffer);
        }
        return this;
      };
      Geometry2.prototype.getIndex = function() {
        return this.indexBuffer;
      };
      Geometry2.prototype.interleave = function() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
          return this;
        }
        var arrays = [];
        var sizes = [];
        var interleavedBuffer = new Buffer$1();
        var i;
        for (i in this.attributes) {
          var attribute = this.attributes[i];
          var buffer = this.buffers[attribute.buffer];
          arrays.push(buffer.data);
          sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
          attribute.buffer = 0;
        }
        interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
        for (i = 0; i < this.buffers.length; i++) {
          if (this.buffers[i] !== this.indexBuffer) {
            this.buffers[i].destroy();
          }
        }
        this.buffers = [interleavedBuffer];
        if (this.indexBuffer) {
          this.buffers.push(this.indexBuffer);
        }
        return this;
      };
      Geometry2.prototype.getSize = function() {
        for (var i in this.attributes) {
          var attribute = this.attributes[i];
          var buffer = this.buffers[attribute.buffer];
          return buffer.data.length / (attribute.stride / 4 || attribute.size);
        }
        return 0;
      };
      Geometry2.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Geometry2.prototype.destroy = function() {
        this.dispose();
        this.buffers = null;
        this.indexBuffer = null;
        this.attributes = null;
      };
      Geometry2.prototype.clone = function() {
        var geometry = new Geometry2();
        for (var i = 0; i < this.buffers.length; i++) {
          geometry.buffers[i] = new Buffer$1(this.buffers[i].data.slice(0));
        }
        for (var i in this.attributes) {
          var attrib = this.attributes[i];
          geometry.attributes[i] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
        }
        if (this.indexBuffer) {
          geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
          geometry.indexBuffer.index = true;
        }
        return geometry;
      };
      Geometry2.merge = function(geometries) {
        var geometryOut = new Geometry2();
        var arrays = [];
        var sizes = [];
        var offsets = [];
        var geometry;
        for (var i = 0; i < geometries.length; i++) {
          geometry = geometries[i];
          for (var j = 0; j < geometry.buffers.length; j++) {
            sizes[j] = sizes[j] || 0;
            sizes[j] += geometry.buffers[j].data.length;
            offsets[j] = 0;
          }
        }
        for (var i = 0; i < geometry.buffers.length; i++) {
          arrays[i] = new map$1$1[getBufferType(geometry.buffers[i].data)](sizes[i]);
          geometryOut.buffers[i] = new Buffer$1(arrays[i]);
        }
        for (var i = 0; i < geometries.length; i++) {
          geometry = geometries[i];
          for (var j = 0; j < geometry.buffers.length; j++) {
            arrays[j].set(geometry.buffers[j].data, offsets[j]);
            offsets[j] += geometry.buffers[j].data.length;
          }
        }
        geometryOut.attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
          geometryOut.indexBuffer.index = true;
          var offset2 = 0;
          var stride = 0;
          var offset22 = 0;
          var bufferIndexToCount = 0;
          for (var i = 0; i < geometry.buffers.length; i++) {
            if (geometry.buffers[i] !== geometry.indexBuffer) {
              bufferIndexToCount = i;
              break;
            }
          }
          for (var i in geometry.attributes) {
            var attribute = geometry.attributes[i];
            if ((attribute.buffer | 0) === bufferIndexToCount) {
              stride += attribute.size * byteSizeMap[attribute.type] / 4;
            }
          }
          for (var i = 0; i < geometries.length; i++) {
            var indexBufferData = geometries[i].indexBuffer.data;
            for (var j = 0; j < indexBufferData.length; j++) {
              geometryOut.indexBuffer.data[j + offset22] += offset2;
            }
            offset2 += geometry.buffers[bufferIndexToCount].data.length / stride;
            offset22 += indexBufferData.length;
          }
        }
        return geometryOut;
      };
      return Geometry2;
    }();
    var Quad = function(_super) {
      __extends$h(Quad2, _super);
      function Quad2() {
        var _this = _super.call(this) || this;
        _this.addAttribute("aVertexPosition", new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ])).addIndex([0, 1, 3, 2]);
        return _this;
      }
      return Quad2;
    }(Geometry);
    var QuadUv = function(_super) {
      __extends$h(QuadUv2, _super);
      function QuadUv2() {
        var _this = _super.call(this) || this;
        _this.vertices = new Float32Array([
          -1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          1
        ]);
        _this.uvs = new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ]);
        _this.vertexBuffer = new Buffer$1(_this.vertices);
        _this.uvBuffer = new Buffer$1(_this.uvs);
        _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
        return _this;
      }
      QuadUv2.prototype.map = function(targetTextureFrame, destinationFrame) {
        var x2 = 0;
        var y2 = 0;
        this.uvs[0] = x2;
        this.uvs[1] = y2;
        this.uvs[2] = x2 + destinationFrame.width / targetTextureFrame.width;
        this.uvs[3] = y2;
        this.uvs[4] = x2 + destinationFrame.width / targetTextureFrame.width;
        this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height;
        this.uvs[6] = x2;
        this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height;
        x2 = destinationFrame.x;
        y2 = destinationFrame.y;
        this.vertices[0] = x2;
        this.vertices[1] = y2;
        this.vertices[2] = x2 + destinationFrame.width;
        this.vertices[3] = y2;
        this.vertices[4] = x2 + destinationFrame.width;
        this.vertices[5] = y2 + destinationFrame.height;
        this.vertices[6] = x2;
        this.vertices[7] = y2 + destinationFrame.height;
        this.invalidate();
        return this;
      };
      QuadUv2.prototype.invalidate = function() {
        this.vertexBuffer._updateID++;
        this.uvBuffer._updateID++;
        return this;
      };
      return QuadUv2;
    }(Geometry);
    var UID$2 = 0;
    var UniformGroup = function() {
      function UniformGroup2(uniforms, _static) {
        this.uniforms = uniforms;
        this.group = true;
        this.syncUniforms = {};
        this.dirtyId = 0;
        this.id = UID$2++;
        this.static = !!_static;
      }
      UniformGroup2.prototype.update = function() {
        this.dirtyId++;
      };
      UniformGroup2.prototype.add = function(name2, uniforms, _static) {
        this.uniforms[name2] = new UniformGroup2(uniforms, _static);
      };
      UniformGroup2.from = function(uniforms, _static) {
        return new UniformGroup2(uniforms, _static);
      };
      return UniformGroup2;
    }();
    var FilterState = function() {
      function FilterState2() {
        this.renderTexture = null;
        this.target = null;
        this.legacy = false;
        this.resolution = 1;
        this.sourceFrame = new Rectangle();
        this.destinationFrame = new Rectangle();
        this.filters = [];
      }
      FilterState2.prototype.clear = function() {
        this.target = null;
        this.filters = null;
        this.renderTexture = null;
      };
      return FilterState2;
    }();
    var FilterSystem = function(_super) {
      __extends$h(FilterSystem2, _super);
      function FilterSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.defaultFilterStack = [{}];
        _this.texturePool = new RenderTexturePool();
        _this.texturePool.setScreenSize(renderer.view);
        _this.statePool = [];
        _this.quad = new Quad();
        _this.quadUv = new QuadUv();
        _this.tempRect = new Rectangle();
        _this.activeState = {};
        _this.globalUniforms = new UniformGroup({
          outputFrame: _this.tempRect,
          inputSize: new Float32Array(4),
          inputPixel: new Float32Array(4),
          inputClamp: new Float32Array(4),
          resolution: 1,
          filterArea: new Float32Array(4),
          filterClamp: new Float32Array(4)
        }, true);
        _this.forceClear = false;
        _this.useMaxPadding = false;
        return _this;
      }
      FilterSystem2.prototype.push = function(target, filters) {
        var renderer = this.renderer;
        var filterStack = this.defaultFilterStack;
        var state = this.statePool.pop() || new FilterState();
        var resolution = filters[0].resolution;
        var padding = filters[0].padding;
        var autoFit = filters[0].autoFit;
        var legacy = filters[0].legacy;
        for (var i = 1; i < filters.length; i++) {
          var filter2 = filters[i];
          resolution = Math.min(resolution, filter2.resolution);
          padding = this.useMaxPadding ? Math.max(padding, filter2.padding) : padding + filter2.padding;
          autoFit = autoFit || filter2.autoFit;
          legacy = legacy || filter2.legacy;
        }
        if (filterStack.length === 1) {
          this.defaultFilterStack[0].renderTexture = renderer.renderTexture.current;
        }
        filterStack.push(state);
        state.resolution = resolution;
        state.legacy = legacy;
        state.target = target;
        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
        state.sourceFrame.pad(padding);
        if (autoFit) {
          state.sourceFrame.fit(this.renderer.renderTexture.sourceFrame);
        }
        state.sourceFrame.ceil(resolution);
        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);
        state.filters = filters;
        state.destinationFrame.width = state.renderTexture.width;
        state.destinationFrame.height = state.renderTexture.height;
        var destinationFrame = this.tempRect;
        destinationFrame.width = state.sourceFrame.width;
        destinationFrame.height = state.sourceFrame.height;
        state.renderTexture.filterFrame = state.sourceFrame;
        renderer.renderTexture.bind(state.renderTexture, state.sourceFrame, destinationFrame);
        renderer.renderTexture.clear();
      };
      FilterSystem2.prototype.pop = function() {
        var filterStack = this.defaultFilterStack;
        var state = filterStack.pop();
        var filters = state.filters;
        this.activeState = state;
        var globalUniforms = this.globalUniforms.uniforms;
        globalUniforms.outputFrame = state.sourceFrame;
        globalUniforms.resolution = state.resolution;
        var inputSize = globalUniforms.inputSize;
        var inputPixel = globalUniforms.inputPixel;
        var inputClamp = globalUniforms.inputClamp;
        inputSize[0] = state.destinationFrame.width;
        inputSize[1] = state.destinationFrame.height;
        inputSize[2] = 1 / inputSize[0];
        inputSize[3] = 1 / inputSize[1];
        inputPixel[0] = inputSize[0] * state.resolution;
        inputPixel[1] = inputSize[1] * state.resolution;
        inputPixel[2] = 1 / inputPixel[0];
        inputPixel[3] = 1 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
        inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
        if (state.legacy) {
          var filterArea = globalUniforms.filterArea;
          filterArea[0] = state.destinationFrame.width;
          filterArea[1] = state.destinationFrame.height;
          filterArea[2] = state.sourceFrame.x;
          filterArea[3] = state.sourceFrame.y;
          globalUniforms.filterClamp = globalUniforms.inputClamp;
        }
        this.globalUniforms.update();
        var lastState = filterStack[filterStack.length - 1];
        if (state.renderTexture.framebuffer.multisample > 1) {
          this.renderer.framebuffer.blit();
        }
        if (filters.length === 1) {
          filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES$1.BLEND, state);
          this.returnFilterTexture(state.renderTexture);
        } else {
          var flip = state.renderTexture;
          var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
          var i = 0;
          for (i = 0; i < filters.length - 1; ++i) {
            filters[i].apply(this, flip, flop, CLEAR_MODES$1.CLEAR, state);
            var t2 = flip;
            flip = flop;
            flop = t2;
          }
          filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES$1.BLEND, state);
          this.returnFilterTexture(flip);
          this.returnFilterTexture(flop);
        }
        state.clear();
        this.statePool.push(state);
      };
      FilterSystem2.prototype.bindAndClear = function(filterTexture, clearMode) {
        if (clearMode === void 0) {
          clearMode = CLEAR_MODES$1.CLEAR;
        }
        if (filterTexture && filterTexture.filterFrame) {
          var destinationFrame = this.tempRect;
          destinationFrame.width = filterTexture.filterFrame.width;
          destinationFrame.height = filterTexture.filterFrame.height;
          this.renderer.renderTexture.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
        } else {
          this.renderer.renderTexture.bind(filterTexture);
        }
        if (typeof clearMode === "boolean") {
          clearMode = clearMode ? CLEAR_MODES$1.CLEAR : CLEAR_MODES$1.BLEND;
          deprecation("5.2.1", "Use CLEAR_MODES when using clear applyFilter option");
        }
        if (clearMode === CLEAR_MODES$1.CLEAR || clearMode === CLEAR_MODES$1.BLIT && this.forceClear) {
          this.renderer.renderTexture.clear();
        }
      };
      FilterSystem2.prototype.applyFilter = function(filter2, input, output, clearMode) {
        var renderer = this.renderer;
        this.bindAndClear(output, clearMode);
        filter2.uniforms.uSampler = input;
        filter2.uniforms.filterGlobals = this.globalUniforms;
        renderer.state.set(filter2.state);
        renderer.shader.bind(filter2);
        if (filter2.legacy) {
          this.quadUv.map(input._frame, input.filterFrame);
          renderer.geometry.bind(this.quadUv);
          renderer.geometry.draw(DRAW_MODES$1.TRIANGLES);
        } else {
          renderer.geometry.bind(this.quad);
          renderer.geometry.draw(DRAW_MODES$1.TRIANGLE_STRIP);
        }
      };
      FilterSystem2.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
        var _a2 = this.activeState, sourceFrame = _a2.sourceFrame, destinationFrame = _a2.destinationFrame;
        var orig = sprite._texture.orig;
        var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
        var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1 / orig.width, 1 / orig.height);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
      };
      FilterSystem2.prototype.destroy = function() {
        this.texturePool.clear(false);
      };
      FilterSystem2.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution) {
        if (resolution === void 0) {
          resolution = 1;
        }
        return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution);
      };
      FilterSystem2.prototype.getFilterTexture = function(input, resolution) {
        if (typeof input === "number") {
          var swap = input;
          input = resolution;
          resolution = swap;
        }
        input = input || this.activeState.renderTexture;
        var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution);
        filterTexture.filterFrame = input.filterFrame;
        return filterTexture;
      };
      FilterSystem2.prototype.returnFilterTexture = function(renderTexture) {
        this.texturePool.returnTexture(renderTexture);
      };
      FilterSystem2.prototype.emptyPool = function() {
        this.texturePool.clear(true);
      };
      FilterSystem2.prototype.resize = function() {
        this.texturePool.setScreenSize(this.renderer.view);
      };
      return FilterSystem2;
    }(System);
    var ObjectRenderer = function() {
      function ObjectRenderer2(renderer) {
        this.renderer = renderer;
      }
      ObjectRenderer2.prototype.flush = function() {
      };
      ObjectRenderer2.prototype.destroy = function() {
        this.renderer = null;
      };
      ObjectRenderer2.prototype.start = function() {
      };
      ObjectRenderer2.prototype.stop = function() {
        this.flush();
      };
      ObjectRenderer2.prototype.render = function(_object) {
      };
      return ObjectRenderer2;
    }();
    var BatchSystem = function(_super) {
      __extends$h(BatchSystem2, _super);
      function BatchSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.emptyRenderer = new ObjectRenderer(renderer);
        _this.currentRenderer = _this.emptyRenderer;
        return _this;
      }
      BatchSystem2.prototype.setObjectRenderer = function(objectRenderer) {
        if (this.currentRenderer === objectRenderer) {
          return;
        }
        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;
        this.currentRenderer.start();
      };
      BatchSystem2.prototype.flush = function() {
        this.setObjectRenderer(this.emptyRenderer);
      };
      BatchSystem2.prototype.reset = function() {
        this.setObjectRenderer(this.emptyRenderer);
      };
      BatchSystem2.prototype.copyBoundTextures = function(arr, maxTextures) {
        var boundTextures = this.renderer.texture.boundTextures;
        for (var i = maxTextures - 1; i >= 0; --i) {
          arr[i] = boundTextures[i] || null;
          if (arr[i]) {
            arr[i]._batchLocation = i;
          }
        }
      };
      BatchSystem2.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
        var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
        var j = 0;
        for (var i = 0; i < count; i++) {
          var tex = elements[i];
          var loc = tex._batchLocation;
          if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
            ids[i] = loc;
            continue;
          }
          while (j < maxTextures) {
            var bound = boundTextures[j];
            if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
              j++;
              continue;
            }
            ids[i] = j;
            tex._batchLocation = j;
            boundTextures[j] = tex;
            break;
          }
        }
      };
      return BatchSystem2;
    }(System);
    var CONTEXT_UID_COUNTER = 0;
    var ContextSystem = function(_super) {
      __extends$h(ContextSystem2, _super);
      function ContextSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.webGLVersion = 1;
        _this.extensions = {};
        _this.supports = {
          uint32Indices: false
        };
        _this.handleContextLost = _this.handleContextLost.bind(_this);
        _this.handleContextRestored = _this.handleContextRestored.bind(_this);
        renderer.view.addEventListener("webglcontextlost", _this.handleContextLost, false);
        renderer.view.addEventListener("webglcontextrestored", _this.handleContextRestored, false);
        return _this;
      }
      Object.defineProperty(ContextSystem2.prototype, "isLost", {
        get: function() {
          return !this.gl || this.gl.isContextLost();
        },
        enumerable: false,
        configurable: true
      });
      ContextSystem2.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
        if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
          gl.getExtension("WEBGL_lose_context").restoreContext();
        }
      };
      ContextSystem2.prototype.initFromContext = function(gl) {
        this.gl = gl;
        this.validateContext(gl);
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
        this.renderer.runners.contextChange.emit(gl);
      };
      ContextSystem2.prototype.initFromOptions = function(options) {
        var gl = this.createContext(this.renderer.view, options);
        this.initFromContext(gl);
      };
      ContextSystem2.prototype.createContext = function(canvas2, options) {
        var gl;
        if (settings.PREFER_ENV >= ENV$1.WEBGL2) {
          gl = canvas2.getContext("webgl2", options);
        }
        if (gl) {
          this.webGLVersion = 2;
        } else {
          this.webGLVersion = 1;
          gl = canvas2.getContext("webgl", options) || canvas2.getContext("experimental-webgl", options);
          if (!gl) {
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
          }
        }
        this.gl = gl;
        this.getExtensions();
        return this.gl;
      };
      ContextSystem2.prototype.getExtensions = function() {
        var gl = this.gl;
        if (this.webGLVersion === 1) {
          Object.assign(this.extensions, {
            drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
            depthTexture: gl.getExtension("WEBGL_depth_texture"),
            loseContext: gl.getExtension("WEBGL_lose_context"),
            vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
            anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
            uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
            floatTexture: gl.getExtension("OES_texture_float"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            textureHalfFloat: gl.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
          });
        } else if (this.webGLVersion === 2) {
          Object.assign(this.extensions, {
            anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
            colorBufferFloat: gl.getExtension("EXT_color_buffer_float"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear")
          });
        }
      };
      ContextSystem2.prototype.handleContextLost = function(event) {
        event.preventDefault();
      };
      ContextSystem2.prototype.handleContextRestored = function() {
        this.renderer.runners.contextChange.emit(this.gl);
      };
      ContextSystem2.prototype.destroy = function() {
        var view = this.renderer.view;
        view.removeEventListener("webglcontextlost", this.handleContextLost);
        view.removeEventListener("webglcontextrestored", this.handleContextRestored);
        this.gl.useProgram(null);
        if (this.extensions.loseContext) {
          this.extensions.loseContext.loseContext();
        }
      };
      ContextSystem2.prototype.postrender = function() {
        if (this.renderer.renderingToScreen) {
          this.gl.flush();
        }
      };
      ContextSystem2.prototype.validateContext = function(gl) {
        var attributes = gl.getContextAttributes();
        if (!attributes.stencil) {
          console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        }
        var hasuint32 = "WebGL2RenderingContext" in window && gl instanceof window.WebGL2RenderingContext || !!gl.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = hasuint32;
        if (!hasuint32) {
          console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
        }
      };
      return ContextSystem2;
    }(System);
    var GLFramebuffer = function() {
      function GLFramebuffer2(framebuffer) {
        this.framebuffer = framebuffer;
        this.stencil = null;
        this.dirtyId = 0;
        this.dirtyFormat = 0;
        this.dirtySize = 0;
        this.multisample = MSAA_QUALITY$1.NONE;
        this.msaaBuffer = null;
        this.blitFramebuffer = null;
      }
      return GLFramebuffer2;
    }();
    var tempRectangle = new Rectangle();
    var FramebufferSystem = function(_super) {
      __extends$h(FramebufferSystem2, _super);
      function FramebufferSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.managedFramebuffers = [];
        _this.unknownFramebuffer = new Framebuffer(10, 10);
        _this.msaaSamples = null;
        return _this;
      }
      FramebufferSystem2.prototype.contextChange = function() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle();
        this.hasMRT = true;
        this.writeDepthTexture = true;
        this.disposeAll(true);
        if (this.renderer.context.webGLVersion === 1) {
          var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
          var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
          if (settings.PREFER_ENV === ENV$1.WEBGL_LEGACY) {
            nativeDrawBuffersExtension_1 = null;
            nativeDepthTextureExtension = null;
          }
          if (nativeDrawBuffersExtension_1) {
            gl.drawBuffers = function(activeTextures) {
              return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
            };
          } else {
            this.hasMRT = false;
            gl.drawBuffers = function() {
            };
          }
          if (!nativeDepthTextureExtension) {
            this.writeDepthTexture = false;
          }
        } else {
          this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
        }
      };
      FramebufferSystem2.prototype.bind = function(framebuffer, frame) {
        var gl = this.gl;
        if (framebuffer) {
          var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
          if (this.current !== framebuffer) {
            this.current = framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
          }
          if (fbo.dirtyId !== framebuffer.dirtyId) {
            fbo.dirtyId = framebuffer.dirtyId;
            if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
              fbo.dirtyFormat = framebuffer.dirtyFormat;
              this.updateFramebuffer(framebuffer);
            } else if (fbo.dirtySize !== framebuffer.dirtySize) {
              fbo.dirtySize = framebuffer.dirtySize;
              this.resizeFramebuffer(framebuffer);
            }
          }
          for (var i = 0; i < framebuffer.colorTextures.length; i++) {
            var tex = framebuffer.colorTextures[i];
            this.renderer.texture.unbind(tex.parentTextureArray || tex);
          }
          if (framebuffer.depthTexture) {
            this.renderer.texture.unbind(framebuffer.depthTexture);
          }
          if (frame) {
            this.setViewport(frame.x, frame.y, frame.width, frame.height);
          } else {
            this.setViewport(0, 0, framebuffer.width, framebuffer.height);
          }
        } else {
          if (this.current) {
            this.current = null;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          }
          if (frame) {
            this.setViewport(frame.x, frame.y, frame.width, frame.height);
          } else {
            this.setViewport(0, 0, this.renderer.width, this.renderer.height);
          }
        }
      };
      FramebufferSystem2.prototype.setViewport = function(x2, y2, width2, height2) {
        var v2 = this.viewport;
        if (v2.width !== width2 || v2.height !== height2 || v2.x !== x2 || v2.y !== y2) {
          v2.x = x2;
          v2.y = y2;
          v2.width = width2;
          v2.height = height2;
          this.gl.viewport(x2, y2, width2, height2);
        }
      };
      Object.defineProperty(FramebufferSystem2.prototype, "size", {
        get: function() {
          if (this.current) {
            return { x: 0, y: 0, width: this.current.width, height: this.current.height };
          }
          return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
        },
        enumerable: false,
        configurable: true
      });
      FramebufferSystem2.prototype.clear = function(r2, g2, b, a, mask) {
        if (mask === void 0) {
          mask = BUFFER_BITS$1.COLOR | BUFFER_BITS$1.DEPTH;
        }
        var gl = this.gl;
        gl.clearColor(r2, g2, b, a);
        gl.clear(mask);
      };
      FramebufferSystem2.prototype.initFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = new GLFramebuffer(gl.createFramebuffer());
        fbo.multisample = this.detectSamples(framebuffer.multisample);
        framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
        this.managedFramebuffers.push(framebuffer);
        framebuffer.disposeRunner.add(this);
        return fbo;
      };
      FramebufferSystem2.prototype.resizeFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (fbo.stencil) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
        var colorTextures = framebuffer.colorTextures;
        for (var i = 0; i < colorTextures.length; i++) {
          this.renderer.texture.bind(colorTextures[i], 0);
        }
        if (framebuffer.depthTexture) {
          this.renderer.texture.bind(framebuffer.depthTexture, 0);
        }
      };
      FramebufferSystem2.prototype.updateFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var colorTextures = framebuffer.colorTextures;
        var count = colorTextures.length;
        if (!gl.drawBuffers) {
          count = Math.min(count, 1);
        }
        if (fbo.multisample > 1) {
          fbo.msaaBuffer = gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
        }
        var activeTextures = [];
        for (var i = 0; i < count; i++) {
          if (i === 0 && fbo.multisample > 1) {
            continue;
          }
          var texture = framebuffer.colorTextures[i];
          var parentTexture = texture.parentTextureArray || texture;
          this.renderer.texture.bind(parentTexture, 0);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, 0);
          activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
        }
        if (activeTextures.length > 1) {
          gl.drawBuffers(activeTextures);
        }
        if (framebuffer.depthTexture) {
          var writeDepthTexture = this.writeDepthTexture;
          if (writeDepthTexture) {
            var depthTexture = framebuffer.depthTexture;
            this.renderer.texture.bind(depthTexture, 0);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, 0);
          }
        }
        if (!fbo.stencil && (framebuffer.stencil || framebuffer.depth)) {
          fbo.stencil = gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
          if (!framebuffer.depthTexture) {
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
          }
        }
      };
      FramebufferSystem2.prototype.detectSamples = function(samples) {
        var msaaSamples = this.msaaSamples;
        var res = MSAA_QUALITY$1.NONE;
        if (samples <= 1 || msaaSamples === null) {
          return res;
        }
        for (var i = 0; i < msaaSamples.length; i++) {
          if (msaaSamples[i] <= samples) {
            res = msaaSamples[i];
            break;
          }
        }
        if (res === 1) {
          res = MSAA_QUALITY$1.NONE;
        }
        return res;
      };
      FramebufferSystem2.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
        var _a2 = this, current = _a2.current, renderer = _a2.renderer, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
        if (renderer.context.webGLVersion !== 2) {
          return;
        }
        if (!current) {
          return;
        }
        var fbo = current.glFramebuffers[CONTEXT_UID];
        if (!fbo) {
          return;
        }
        if (!framebuffer) {
          if (fbo.multisample <= 1) {
            return;
          }
          if (!fbo.blitFramebuffer) {
            fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
            fbo.blitFramebuffer.addColorTexture(0, current.colorTextures[0]);
          }
          framebuffer = fbo.blitFramebuffer;
          framebuffer.width = current.width;
          framebuffer.height = current.height;
        }
        if (!sourcePixels) {
          sourcePixels = tempRectangle;
          sourcePixels.width = current.width;
          sourcePixels.height = current.height;
        }
        if (!destPixels) {
          destPixels = sourcePixels;
        }
        var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
        this.bind(framebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
        gl.blitFramebuffer(sourcePixels.x, sourcePixels.y, sourcePixels.width, sourcePixels.height, destPixels.x, destPixels.y, destPixels.width, destPixels.height, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
      };
      FramebufferSystem2.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var gl = this.gl;
        if (!fbo) {
          return;
        }
        delete framebuffer.glFramebuffers[this.CONTEXT_UID];
        var index2 = this.managedFramebuffers.indexOf(framebuffer);
        if (index2 >= 0) {
          this.managedFramebuffers.splice(index2, 1);
        }
        framebuffer.disposeRunner.remove(this);
        if (!contextLost) {
          gl.deleteFramebuffer(fbo.framebuffer);
          if (fbo.stencil) {
            gl.deleteRenderbuffer(fbo.stencil);
          }
        }
      };
      FramebufferSystem2.prototype.disposeAll = function(contextLost) {
        var list = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (var i = 0; i < list.length; i++) {
          this.disposeFramebuffer(list[i], contextLost);
        }
      };
      FramebufferSystem2.prototype.forceStencil = function() {
        var framebuffer = this.current;
        if (!framebuffer) {
          return;
        }
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (!fbo || fbo.stencil) {
          return;
        }
        framebuffer.enableStencil();
        var w2 = framebuffer.width;
        var h2 = framebuffer.height;
        var gl = this.gl;
        var stencil = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w2, h2);
        fbo.stencil = stencil;
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
      };
      FramebufferSystem2.prototype.reset = function() {
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle();
      };
      return FramebufferSystem2;
    }(System);
    var GLBuffer = function() {
      function GLBuffer2(buffer) {
        this.buffer = buffer || null;
        this.updateID = -1;
        this.byteLength = -1;
        this.refCount = 0;
      }
      return GLBuffer2;
    }();
    var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
    var GeometrySystem = function(_super) {
      __extends$h(GeometrySystem2, _super);
      function GeometrySystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this._activeGeometry = null;
        _this._activeVao = null;
        _this.hasVao = true;
        _this.hasInstance = true;
        _this.canUseUInt32ElementIndex = false;
        _this.managedGeometries = {};
        _this.managedBuffers = {};
        return _this;
      }
      GeometrySystem2.prototype.contextChange = function() {
        this.disposeAll(true);
        var gl = this.gl = this.renderer.gl;
        var context2 = this.renderer.context;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        if (!gl.createVertexArray) {
          var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
          if (settings.PREFER_ENV === ENV$1.WEBGL_LEGACY) {
            nativeVaoExtension_1 = null;
          }
          if (nativeVaoExtension_1) {
            gl.createVertexArray = function() {
              return nativeVaoExtension_1.createVertexArrayOES();
            };
            gl.bindVertexArray = function(vao) {
              return nativeVaoExtension_1.bindVertexArrayOES(vao);
            };
            gl.deleteVertexArray = function(vao) {
              return nativeVaoExtension_1.deleteVertexArrayOES(vao);
            };
          } else {
            this.hasVao = false;
            gl.createVertexArray = function() {
              return null;
            };
            gl.bindVertexArray = function() {
              return null;
            };
            gl.deleteVertexArray = function() {
              return null;
            };
          }
        }
        if (!gl.vertexAttribDivisor) {
          var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
          if (instanceExt_1) {
            gl.vertexAttribDivisor = function(a, b) {
              return instanceExt_1.vertexAttribDivisorANGLE(a, b);
            };
            gl.drawElementsInstanced = function(a, b, c, d, e) {
              return instanceExt_1.drawElementsInstancedANGLE(a, b, c, d, e);
            };
            gl.drawArraysInstanced = function(a, b, c, d) {
              return instanceExt_1.drawArraysInstancedANGLE(a, b, c, d);
            };
          } else {
            this.hasInstance = false;
          }
        }
        this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
      };
      GeometrySystem2.prototype.bind = function(geometry, shader) {
        shader = shader || this.renderer.shader.shader;
        var gl = this.gl;
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        if (!vaos) {
          this.managedGeometries[geometry.id] = geometry;
          geometry.disposeRunner.add(this);
          geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
        }
        var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader.program);
        this._activeGeometry = geometry;
        if (this._activeVao !== vao) {
          this._activeVao = vao;
          if (this.hasVao) {
            gl.bindVertexArray(vao);
          } else {
            this.activateVao(geometry, shader.program);
          }
        }
        this.updateBuffers();
      };
      GeometrySystem2.prototype.reset = function() {
        this.unbind();
      };
      GeometrySystem2.prototype.updateBuffers = function() {
        var geometry = this._activeGeometry;
        var gl = this.gl;
        for (var i = 0; i < geometry.buffers.length; i++) {
          var buffer = geometry.buffers[i];
          var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
          if (buffer._updateID !== glBuffer.updateID) {
            glBuffer.updateID = buffer._updateID;
            var type = buffer.index ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
            gl.bindBuffer(type, glBuffer.buffer);
            this._boundBuffer = glBuffer;
            if (glBuffer.byteLength >= buffer.data.byteLength) {
              gl.bufferSubData(type, 0, buffer.data);
            } else {
              var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
              glBuffer.byteLength = buffer.data.byteLength;
              gl.bufferData(type, buffer.data, drawType);
            }
          }
        }
      };
      GeometrySystem2.prototype.checkCompatibility = function(geometry, program) {
        var geometryAttributes = geometry.attributes;
        var shaderAttributes = program.attributeData;
        for (var j in shaderAttributes) {
          if (!geometryAttributes[j]) {
            throw new Error('shader and geometry incompatible, geometry missing the "' + j + '" attribute');
          }
        }
      };
      GeometrySystem2.prototype.getSignature = function(geometry, program) {
        var attribs = geometry.attributes;
        var shaderAttributes = program.attributeData;
        var strings = ["g", geometry.id];
        for (var i in attribs) {
          if (shaderAttributes[i]) {
            strings.push(i);
          }
        }
        return strings.join("-");
      };
      GeometrySystem2.prototype.initGeometryVao = function(geometry, program) {
        this.checkCompatibility(geometry, program);
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var signature = this.getSignature(geometry, program);
        var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var vao = vaoObjectHash[signature];
        if (vao) {
          vaoObjectHash[program.id] = vao;
          return vao;
        }
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        var tempStride = {};
        var tempStart = {};
        for (var j in buffers) {
          tempStride[j] = 0;
          tempStart[j] = 0;
        }
        for (var j in attributes) {
          if (!attributes[j].size && program.attributeData[j]) {
            attributes[j].size = program.attributeData[j].size;
          } else if (!attributes[j].size) {
            console.warn("PIXI Geometry attribute '" + j + "' size cannot be determined (likely the bound shader does not have the attribute)");
          }
          tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap$1[attributes[j].type];
        }
        for (var j in attributes) {
          var attribute = attributes[j];
          var attribSize = attribute.size;
          if (attribute.stride === void 0) {
            if (tempStride[attribute.buffer] === attribSize * byteSizeMap$1[attribute.type]) {
              attribute.stride = 0;
            } else {
              attribute.stride = tempStride[attribute.buffer];
            }
          }
          if (attribute.start === void 0) {
            attribute.start = tempStart[attribute.buffer];
            tempStart[attribute.buffer] += attribSize * byteSizeMap$1[attribute.type];
          }
        }
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        for (var i = 0; i < buffers.length; i++) {
          var buffer = buffers[i];
          if (!buffer._glBuffers[CONTEXT_UID]) {
            buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
            this.managedBuffers[buffer.id] = buffer;
            buffer.disposeRunner.add(this);
          }
          buffer._glBuffers[CONTEXT_UID].refCount++;
        }
        this.activateVao(geometry, program);
        this._activeVao = vao;
        vaoObjectHash[program.id] = vao;
        vaoObjectHash[signature] = vao;
        return vao;
      };
      GeometrySystem2.prototype.disposeBuffer = function(buffer, contextLost) {
        if (!this.managedBuffers[buffer.id]) {
          return;
        }
        delete this.managedBuffers[buffer.id];
        var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
        var gl = this.gl;
        buffer.disposeRunner.remove(this);
        if (!glBuffer) {
          return;
        }
        if (!contextLost) {
          gl.deleteBuffer(glBuffer.buffer);
        }
        delete buffer._glBuffers[this.CONTEXT_UID];
      };
      GeometrySystem2.prototype.disposeGeometry = function(geometry, contextLost) {
        if (!this.managedGeometries[geometry.id]) {
          return;
        }
        delete this.managedGeometries[geometry.id];
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var gl = this.gl;
        var buffers = geometry.buffers;
        geometry.disposeRunner.remove(this);
        if (!vaos) {
          return;
        }
        for (var i = 0; i < buffers.length; i++) {
          var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            this.disposeBuffer(buffers[i], contextLost);
          }
        }
        if (!contextLost) {
          for (var vaoId in vaos) {
            if (vaoId[0] === "g") {
              var vao = vaos[vaoId];
              if (this._activeVao === vao) {
                this.unbind();
              }
              gl.deleteVertexArray(vao);
            }
          }
        }
        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
      };
      GeometrySystem2.prototype.disposeAll = function(contextLost) {
        var all = Object.keys(this.managedGeometries);
        for (var i = 0; i < all.length; i++) {
          this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
        }
        all = Object.keys(this.managedBuffers);
        for (var i = 0; i < all.length; i++) {
          this.disposeBuffer(this.managedBuffers[all[i]], contextLost);
        }
      };
      GeometrySystem2.prototype.activateVao = function(geometry, program) {
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.indexBuffer._glBuffers[CONTEXT_UID].buffer);
        }
        var lastBuffer = null;
        for (var j in attributes) {
          var attribute = attributes[j];
          var buffer = buffers[attribute.buffer];
          var glBuffer = buffer._glBuffers[CONTEXT_UID];
          if (program.attributeData[j]) {
            if (lastBuffer !== glBuffer) {
              gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer.buffer);
              lastBuffer = glBuffer;
            }
            var location = program.attributeData[j].location;
            gl.enableVertexAttribArray(location);
            gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
            if (attribute.instance) {
              if (this.hasInstance) {
                gl.vertexAttribDivisor(location, 1);
              } else {
                throw new Error("geometry error, GPU Instancing is not supported on this device");
              }
            }
          }
        }
      };
      GeometrySystem2.prototype.draw = function(type, size2, start, instanceCount) {
        var gl = this.gl;
        var geometry = this._activeGeometry;
        if (geometry.indexBuffer) {
          var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
            if (geometry.instanced) {
              gl.drawElementsInstanced(type, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
            } else {
              gl.drawElements(type, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
            }
          } else {
            console.warn("unsupported index buffer type: uint32");
          }
        } else if (geometry.instanced) {
          gl.drawArraysInstanced(type, start, size2 || geometry.getSize(), instanceCount || 1);
        } else {
          gl.drawArrays(type, start, size2 || geometry.getSize());
        }
        return this;
      };
      GeometrySystem2.prototype.unbind = function() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
      };
      return GeometrySystem2;
    }(System);
    var MaskData = function() {
      function MaskData2(maskObject) {
        if (maskObject === void 0) {
          maskObject = null;
        }
        this.type = MASK_TYPES$1.NONE;
        this.autoDetect = true;
        this.maskObject = maskObject || null;
        this.pooled = false;
        this.isMaskData = true;
        this._stencilCounter = 0;
        this._scissorCounter = 0;
        this._scissorRect = null;
        this._target = null;
      }
      MaskData2.prototype.reset = function() {
        if (this.pooled) {
          this.maskObject = null;
          this.type = MASK_TYPES$1.NONE;
          this.autoDetect = true;
        }
        this._target = null;
      };
      MaskData2.prototype.copyCountersOrReset = function(maskAbove) {
        if (maskAbove) {
          this._stencilCounter = maskAbove._stencilCounter;
          this._scissorCounter = maskAbove._scissorCounter;
          this._scissorRect = maskAbove._scissorRect;
        } else {
          this._stencilCounter = 0;
          this._scissorCounter = 0;
          this._scissorRect = null;
        }
      };
      return MaskData2;
    }();
    function compileShader(gl, type, src) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      return shader;
    }
    function compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations) {
      var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
      var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
      var program = gl.createProgram();
      gl.attachShader(program, glVertShader);
      gl.attachShader(program, glFragShader);
      if (attributeLocations) {
        for (var i in attributeLocations) {
          gl.bindAttribLocation(program, attributeLocations[i], i);
        }
      }
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        if (!gl.getShaderParameter(glVertShader, gl.COMPILE_STATUS)) {
          console.warn(vertexSrc);
          console.error(gl.getShaderInfoLog(glVertShader));
        }
        if (!gl.getShaderParameter(glFragShader, gl.COMPILE_STATUS)) {
          console.warn(fragmentSrc);
          console.error(gl.getShaderInfoLog(glFragShader));
        }
        console.error("Pixi.js Error: Could not initialize shader.");
        console.error("gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS));
        console.error("gl.getError()", gl.getError());
        if (gl.getProgramInfoLog(program) !== "") {
          console.warn("Pixi.js Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
        }
        gl.deleteProgram(program);
        program = null;
      }
      gl.deleteShader(glVertShader);
      gl.deleteShader(glFragShader);
      return program;
    }
    function booleanArray(size2) {
      var array = new Array(size2);
      for (var i = 0; i < array.length; i++) {
        array[i] = false;
      }
      return array;
    }
    function defaultValue(type, size2) {
      switch (type) {
        case "float":
          return 0;
        case "vec2":
          return new Float32Array(2 * size2);
        case "vec3":
          return new Float32Array(3 * size2);
        case "vec4":
          return new Float32Array(4 * size2);
        case "int":
        case "sampler2D":
        case "sampler2DArray":
          return 0;
        case "ivec2":
          return new Int32Array(2 * size2);
        case "ivec3":
          return new Int32Array(3 * size2);
        case "ivec4":
          return new Int32Array(4 * size2);
        case "bool":
          return false;
        case "bvec2":
          return booleanArray(2 * size2);
        case "bvec3":
          return booleanArray(3 * size2);
        case "bvec4":
          return booleanArray(4 * size2);
        case "mat2":
          return new Float32Array([
            1,
            0,
            0,
            1
          ]);
        case "mat3":
          return new Float32Array([
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ]);
        case "mat4":
          return new Float32Array([
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ]);
      }
      return null;
    }
    var unknownContext = {};
    var context = unknownContext;
    function getTestContext() {
      if (context === unknownContext || context && context.isContextLost()) {
        var canvas2 = document.createElement("canvas");
        var gl = void 0;
        if (settings.PREFER_ENV >= ENV$1.WEBGL2) {
          gl = canvas2.getContext("webgl2", {});
        }
        if (!gl) {
          gl = canvas2.getContext("webgl", {}) || canvas2.getContext("experimental-webgl", {});
          if (!gl) {
            gl = null;
          } else {
            gl.getExtension("WEBGL_draw_buffers");
          }
        }
        context = gl;
      }
      return context;
    }
    var maxFragmentPrecision;
    function getMaxFragmentPrecision() {
      if (!maxFragmentPrecision) {
        maxFragmentPrecision = PRECISION$1.MEDIUM;
        var gl = getTestContext();
        if (gl) {
          if (gl.getShaderPrecisionFormat) {
            var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
            maxFragmentPrecision = shaderFragment.precision ? PRECISION$1.HIGH : PRECISION$1.MEDIUM;
          }
        }
      }
      return maxFragmentPrecision;
    }
    function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
      if (src.substring(0, 9) !== "precision") {
        var precision = requestedPrecision;
        if (requestedPrecision === PRECISION$1.HIGH && maxSupportedPrecision !== PRECISION$1.HIGH) {
          precision = PRECISION$1.MEDIUM;
        }
        return "precision " + precision + " float;\n" + src;
      } else if (maxSupportedPrecision !== PRECISION$1.HIGH && src.substring(0, 15) === "precision highp") {
        return src.replace("precision highp", "precision mediump");
      }
      return src;
    }
    var GLSL_TO_SIZE = {
      float: 1,
      vec2: 2,
      vec3: 3,
      vec4: 4,
      int: 1,
      ivec2: 2,
      ivec3: 3,
      ivec4: 4,
      bool: 1,
      bvec2: 2,
      bvec3: 3,
      bvec4: 4,
      mat2: 4,
      mat3: 9,
      mat4: 16,
      sampler2D: 1
    };
    function mapSize(type) {
      return GLSL_TO_SIZE[type];
    }
    var GL_TABLE = null;
    var GL_TO_GLSL_TYPES = {
      FLOAT: "float",
      FLOAT_VEC2: "vec2",
      FLOAT_VEC3: "vec3",
      FLOAT_VEC4: "vec4",
      INT: "int",
      INT_VEC2: "ivec2",
      INT_VEC3: "ivec3",
      INT_VEC4: "ivec4",
      BOOL: "bool",
      BOOL_VEC2: "bvec2",
      BOOL_VEC3: "bvec3",
      BOOL_VEC4: "bvec4",
      FLOAT_MAT2: "mat2",
      FLOAT_MAT3: "mat3",
      FLOAT_MAT4: "mat4",
      SAMPLER_2D: "sampler2D",
      INT_SAMPLER_2D: "sampler2D",
      UNSIGNED_INT_SAMPLER_2D: "sampler2D",
      SAMPLER_CUBE: "samplerCube",
      INT_SAMPLER_CUBE: "samplerCube",
      UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
      SAMPLER_2D_ARRAY: "sampler2DArray",
      INT_SAMPLER_2D_ARRAY: "sampler2DArray",
      UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    };
    function mapType(gl, type) {
      if (!GL_TABLE) {
        var typeNames = Object.keys(GL_TO_GLSL_TYPES);
        GL_TABLE = {};
        for (var i = 0; i < typeNames.length; ++i) {
          var tn = typeNames[i];
          GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
        }
      }
      return GL_TABLE[type];
    }
    var uniformParsers = [
      {
        test: function(data) {
          return data.type === "float" && data.size === 1;
        },
        code: function(name2) {
          return '\n            if(uv["' + name2 + '"] !== ud["' + name2 + '"].value)\n            {\n                ud["' + name2 + '"].value = uv["' + name2 + '"]\n                gl.uniform1f(ud["' + name2 + '"].location, uv["' + name2 + '"])\n            }\n            ';
        }
      },
      {
        test: function(data) {
          return (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray;
        },
        code: function(name2) {
          return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name2 + '"], t);\n\n            if(ud["' + name2 + '"].value !== t)\n            {\n                ud["' + name2 + '"].value = t;\n                gl.uniform1i(ud["' + name2 + '"].location, t);\n; // eslint-disable-line max-len\n            }';
        }
      },
      {
        test: function(data, uniform) {
          return data.type === "mat3" && data.size === 1 && uniform.a !== void 0;
        },
        code: function(name2) {
          return '\n            gl.uniformMatrix3fv(ud["' + name2 + '"].location, false, uv["' + name2 + '"].toArray(true));\n            ';
        }
      },
      {
        test: function(data, uniform) {
          return data.type === "vec2" && data.size === 1 && uniform.x !== void 0;
        },
        code: function(name2) {
          return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name2 + '"].location, v.x, v.y);\n                }';
        }
      },
      {
        test: function(data) {
          return data.type === "vec2" && data.size === 1;
        },
        code: function(name2) {
          return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name2 + '"].location, v[0], v[1]);\n                }\n            ';
        }
      },
      {
        test: function(data, uniform) {
          return data.type === "vec4" && data.size === 1 && uniform.width !== void 0;
        },
        code: function(name2) {
          return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name2 + '"].location, v.x, v.y, v.width, v.height)\n                }';
        }
      },
      {
        test: function(data) {
          return data.type === "vec4" && data.size === 1;
        },
        code: function(name2) {
          return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name2 + '"].location, v[0], v[1], v[2], v[3])\n                }';
        }
      }
    ];
    var GLSL_TO_SINGLE_SETTERS_CACHED = {
      float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",
      vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",
      vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
      vec4: "gl.uniform4f(location, v[0], v[1], v[2], v[3])",
      int: "gl.uniform1i(location, v)",
      ivec2: "gl.uniform2i(location, v[0], v[1])",
      ivec3: "gl.uniform3i(location, v[0], v[1], v[2])",
      ivec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
      bool: "gl.uniform1i(location, v)",
      bvec2: "gl.uniform2i(location, v[0], v[1])",
      bvec3: "gl.uniform3i(location, v[0], v[1], v[2])",
      bvec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      sampler2D: "gl.uniform1i(location, v)",
      samplerCube: "gl.uniform1i(location, v)",
      sampler2DArray: "gl.uniform1i(location, v)"
    };
    var GLSL_TO_ARRAY_SETTERS = {
      float: "gl.uniform1fv(location, v)",
      vec2: "gl.uniform2fv(location, v)",
      vec3: "gl.uniform3fv(location, v)",
      vec4: "gl.uniform4fv(location, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      int: "gl.uniform1iv(location, v)",
      ivec2: "gl.uniform2iv(location, v)",
      ivec3: "gl.uniform3iv(location, v)",
      ivec4: "gl.uniform4iv(location, v)",
      bool: "gl.uniform1iv(location, v)",
      bvec2: "gl.uniform2iv(location, v)",
      bvec3: "gl.uniform3iv(location, v)",
      bvec4: "gl.uniform4iv(location, v)",
      sampler2D: "gl.uniform1iv(location, v)",
      samplerCube: "gl.uniform1iv(location, v)",
      sampler2DArray: "gl.uniform1iv(location, v)"
    };
    function generateUniformsSync(group2, uniformData) {
      var funcFragments = ["\n        var v = null;\n        var cv = null\n        var t = 0;\n        var gl = renderer.gl\n    "];
      for (var i in group2.uniforms) {
        var data = uniformData[i];
        if (!data) {
          if (group2.uniforms[i].group) {
            funcFragments.push('\n                    renderer.shader.syncUniformGroup(uv["' + i + '"], syncData);\n                ');
          }
          continue;
        }
        var uniform = group2.uniforms[i];
        var parsed = false;
        for (var j = 0; j < uniformParsers.length; j++) {
          if (uniformParsers[j].test(data, uniform)) {
            funcFragments.push(uniformParsers[j].code(i, uniform));
            parsed = true;
            break;
          }
        }
        if (!parsed) {
          var templateType = data.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
          var template2 = templateType[data.type].replace("location", 'ud["' + i + '"].location');
          funcFragments.push('\n            cv = ud["' + i + '"].value;\n            v = uv["' + i + '"];\n            ' + template2 + ";");
        }
      }
      return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
    }
    var fragTemplate$1 = [
      "precision mediump float;",
      "void main(void){",
      "float test = 0.1;",
      "%forloop%",
      "gl_FragColor = vec4(0.0);",
      "}"
    ].join("\n");
    function generateIfTestSrc(maxIfs) {
      var src = "";
      for (var i = 0; i < maxIfs; ++i) {
        if (i > 0) {
          src += "\nelse ";
        }
        if (i < maxIfs - 1) {
          src += "if(test == " + i + ".0){}";
        }
      }
      return src;
    }
    function checkMaxIfStatementsInShader(maxIfs, gl) {
      if (maxIfs === 0) {
        throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
      }
      var shader = gl.createShader(gl.FRAGMENT_SHADER);
      while (true) {
        var fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          maxIfs = maxIfs / 2 | 0;
        } else {
          break;
        }
      }
      return maxIfs;
    }
    var unsafeEval;
    function unsafeEvalSupported() {
      if (typeof unsafeEval === "boolean") {
        return unsafeEval;
      }
      try {
        var func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
        unsafeEval = func({ a: "b" }, "a", "b") === true;
      } catch (e) {
        unsafeEval = false;
      }
      return unsafeEval;
    }
    var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
    var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
    var UID$3 = 0;
    var nameCache = {};
    var Program = function() {
      function Program2(vertexSrc, fragmentSrc, name2) {
        if (name2 === void 0) {
          name2 = "pixi-shader";
        }
        this.id = UID$3++;
        this.vertexSrc = vertexSrc || Program2.defaultVertexSrc;
        this.fragmentSrc = fragmentSrc || Program2.defaultFragmentSrc;
        this.vertexSrc = this.vertexSrc.trim();
        this.fragmentSrc = this.fragmentSrc.trim();
        if (this.vertexSrc.substring(0, 8) !== "#version") {
          name2 = name2.replace(/\s+/g, "-");
          if (nameCache[name2]) {
            nameCache[name2]++;
            name2 += "-" + nameCache[name2];
          } else {
            nameCache[name2] = 1;
          }
          this.vertexSrc = "#define SHADER_NAME " + name2 + "\n" + this.vertexSrc;
          this.fragmentSrc = "#define SHADER_NAME " + name2 + "\n" + this.fragmentSrc;
          this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION$1.HIGH);
          this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());
        }
        this.extractData(this.vertexSrc, this.fragmentSrc);
        this.glPrograms = {};
        this.syncUniforms = null;
      }
      Program2.prototype.extractData = function(vertexSrc, fragmentSrc) {
        var gl = getTestContext();
        if (gl) {
          var program = compileProgram(gl, vertexSrc, fragmentSrc);
          this.attributeData = this.getAttributeData(program, gl);
          this.uniformData = this.getUniformData(program, gl);
          gl.deleteProgram(program);
        } else {
          this.uniformData = {};
          this.attributeData = {};
        }
      };
      Program2.prototype.getAttributeData = function(program, gl) {
        var attributes = {};
        var attributesArray = [];
        var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < totalAttributes; i++) {
          var attribData = gl.getActiveAttrib(program, i);
          var type = mapType(gl, attribData.type);
          var data = {
            type,
            name: attribData.name,
            size: mapSize(type),
            location: 0
          };
          attributes[attribData.name] = data;
          attributesArray.push(data);
        }
        attributesArray.sort(function(a, b) {
          return a.name > b.name ? 1 : -1;
        });
        for (var i = 0; i < attributesArray.length; i++) {
          attributesArray[i].location = i;
        }
        return attributes;
      };
      Program2.prototype.getUniformData = function(program, gl) {
        var uniforms = {};
        var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i < totalUniforms; i++) {
          var uniformData = gl.getActiveUniform(program, i);
          var name2 = uniformData.name.replace(/\[.*?\]$/, "");
          var isArray2 = uniformData.name.match(/\[.*?\]$/);
          var type = mapType(gl, uniformData.type);
          uniforms[name2] = {
            type,
            size: uniformData.size,
            isArray: isArray2,
            value: defaultValue(type, uniformData.size)
          };
        }
        return uniforms;
      };
      Object.defineProperty(Program2, "defaultVertexSrc", {
        get: function() {
          return defaultVertex;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Program2, "defaultFragmentSrc", {
        get: function() {
          return defaultFragment;
        },
        enumerable: false,
        configurable: true
      });
      Program2.from = function(vertexSrc, fragmentSrc, name2) {
        var key = vertexSrc + fragmentSrc;
        var program = ProgramCache[key];
        if (!program) {
          ProgramCache[key] = program = new Program2(vertexSrc, fragmentSrc, name2);
        }
        return program;
      };
      return Program2;
    }();
    var Shader = function() {
      function Shader2(program, uniforms) {
        this.program = program;
        if (uniforms) {
          if (uniforms instanceof UniformGroup) {
            this.uniformGroup = uniforms;
          } else {
            this.uniformGroup = new UniformGroup(uniforms);
          }
        } else {
          this.uniformGroup = new UniformGroup({});
        }
        for (var i in program.uniformData) {
          if (this.uniformGroup.uniforms[i] instanceof Array) {
            this.uniformGroup.uniforms[i] = new Float32Array(this.uniformGroup.uniforms[i]);
          }
        }
      }
      Shader2.prototype.checkUniformExists = function(name2, group2) {
        if (group2.uniforms[name2]) {
          return true;
        }
        for (var i in group2.uniforms) {
          var uniform = group2.uniforms[i];
          if (uniform.group) {
            if (this.checkUniformExists(name2, uniform)) {
              return true;
            }
          }
        }
        return false;
      };
      Shader2.prototype.destroy = function() {
        this.uniformGroup = null;
      };
      Object.defineProperty(Shader2.prototype, "uniforms", {
        get: function() {
          return this.uniformGroup.uniforms;
        },
        enumerable: false,
        configurable: true
      });
      Shader2.from = function(vertexSrc, fragmentSrc, uniforms) {
        var program = Program.from(vertexSrc, fragmentSrc);
        return new Shader2(program, uniforms);
      };
      return Shader2;
    }();
    var BLEND = 0;
    var OFFSET = 1;
    var CULLING = 2;
    var DEPTH_TEST = 3;
    var WINDING = 4;
    var State = function() {
      function State2() {
        this.data = 0;
        this.blendMode = BLEND_MODES$1.NORMAL;
        this.polygonOffset = 0;
        this.blend = true;
      }
      Object.defineProperty(State2.prototype, "blend", {
        get: function() {
          return !!(this.data & 1 << BLEND);
        },
        set: function(value2) {
          if (!!(this.data & 1 << BLEND) !== value2) {
            this.data ^= 1 << BLEND;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State2.prototype, "offsets", {
        get: function() {
          return !!(this.data & 1 << OFFSET);
        },
        set: function(value2) {
          if (!!(this.data & 1 << OFFSET) !== value2) {
            this.data ^= 1 << OFFSET;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State2.prototype, "culling", {
        get: function() {
          return !!(this.data & 1 << CULLING);
        },
        set: function(value2) {
          if (!!(this.data & 1 << CULLING) !== value2) {
            this.data ^= 1 << CULLING;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State2.prototype, "depthTest", {
        get: function() {
          return !!(this.data & 1 << DEPTH_TEST);
        },
        set: function(value2) {
          if (!!(this.data & 1 << DEPTH_TEST) !== value2) {
            this.data ^= 1 << DEPTH_TEST;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State2.prototype, "clockwiseFrontFace", {
        get: function() {
          return !!(this.data & 1 << WINDING);
        },
        set: function(value2) {
          if (!!(this.data & 1 << WINDING) !== value2) {
            this.data ^= 1 << WINDING;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State2.prototype, "blendMode", {
        get: function() {
          return this._blendMode;
        },
        set: function(value2) {
          this.blend = value2 !== BLEND_MODES$1.NONE;
          this._blendMode = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State2.prototype, "polygonOffset", {
        get: function() {
          return this._polygonOffset;
        },
        set: function(value2) {
          this.offsets = !!value2;
          this._polygonOffset = value2;
        },
        enumerable: false,
        configurable: true
      });
      State2.for2d = function() {
        var state = new State2();
        state.depthTest = false;
        state.blend = true;
        return state;
      };
      return State2;
    }();
    var defaultVertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
    var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
    var Filter = function(_super) {
      __extends$h(Filter2, _super);
      function Filter2(vertexSrc, fragmentSrc, uniforms) {
        var _this = this;
        var program = Program.from(vertexSrc || Filter2.defaultVertexSrc, fragmentSrc || Filter2.defaultFragmentSrc);
        _this = _super.call(this, program, uniforms) || this;
        _this.padding = 0;
        _this.resolution = settings.FILTER_RESOLUTION;
        _this.enabled = true;
        _this.autoFit = true;
        _this.legacy = !!_this.program.attributeData.aTextureCoord;
        _this.state = new State();
        return _this;
      }
      Filter2.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {
        filterManager.applyFilter(this, input, output, clearMode);
      };
      Object.defineProperty(Filter2.prototype, "blendMode", {
        get: function() {
          return this.state.blendMode;
        },
        set: function(value2) {
          this.state.blendMode = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Filter2, "defaultVertexSrc", {
        get: function() {
          return defaultVertex$1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Filter2, "defaultFragmentSrc", {
        get: function() {
          return defaultFragment$1;
        },
        enumerable: false,
        configurable: true
      });
      return Filter2;
    }(Shader);
    var vertex$5 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
    var fragment$8 = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
    var tempMat$1 = new Matrix();
    var TextureMatrix = function() {
      function TextureMatrix2(texture, clampMargin) {
        this._texture = texture;
        this.mapCoord = new Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        this._textureID = -1;
        this._updateID = 0;
        this.clampOffset = 0;
        this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
        this.isSimple = false;
      }
      Object.defineProperty(TextureMatrix2.prototype, "texture", {
        get: function() {
          return this._texture;
        },
        set: function(value2) {
          this._texture = value2;
          this._textureID = -1;
        },
        enumerable: false,
        configurable: true
      });
      TextureMatrix2.prototype.multiplyUvs = function(uvs, out) {
        if (out === void 0) {
          out = uvs;
        }
        var mat = this.mapCoord;
        for (var i = 0; i < uvs.length; i += 2) {
          var x2 = uvs[i];
          var y2 = uvs[i + 1];
          out[i] = x2 * mat.a + y2 * mat.c + mat.tx;
          out[i + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
        }
        return out;
      };
      TextureMatrix2.prototype.update = function(forceUpdate) {
        var tex = this._texture;
        if (!tex || !tex.valid) {
          return false;
        }
        if (!forceUpdate && this._textureID === tex._updateID) {
          return false;
        }
        this._textureID = tex._updateID;
        this._updateID++;
        var uvs = tex._uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        var orig = tex.orig;
        var trim2 = tex.trim;
        if (trim2) {
          tempMat$1.set(orig.width / trim2.width, 0, 0, orig.height / trim2.height, -trim2.x / trim2.width, -trim2.y / trim2.height);
          this.mapCoord.append(tempMat$1);
        }
        var texBase = tex.baseTexture;
        var frame = this.uClampFrame;
        var margin = this.clampMargin / texBase.resolution;
        var offset2 = this.clampOffset;
        frame[0] = (tex._frame.x + margin + offset2) / texBase.width;
        frame[1] = (tex._frame.y + margin + offset2) / texBase.height;
        frame[2] = (tex._frame.x + tex._frame.width - margin + offset2) / texBase.width;
        frame[3] = (tex._frame.y + tex._frame.height - margin + offset2) / texBase.height;
        this.uClampOffset[0] = offset2 / texBase.realWidth;
        this.uClampOffset[1] = offset2 / texBase.realHeight;
        this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
        return true;
      };
      return TextureMatrix2;
    }();
    var SpriteMaskFilter = function(_super) {
      __extends$h(SpriteMaskFilter2, _super);
      function SpriteMaskFilter2(sprite) {
        var _this = this;
        var maskMatrix = new Matrix();
        _this = _super.call(this, vertex$5, fragment$8) || this;
        sprite.renderable = false;
        _this.maskSprite = sprite;
        _this.maskMatrix = maskMatrix;
        return _this;
      }
      SpriteMaskFilter2.prototype.apply = function(filterManager, input, output, clearMode) {
        var maskSprite = this.maskSprite;
        var tex = maskSprite._texture;
        if (!tex.valid) {
          return;
        }
        if (!tex.uvMatrix) {
          tex.uvMatrix = new TextureMatrix(tex, 0);
        }
        tex.uvMatrix.update();
        this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
        this.uniforms.mask = tex;
        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
        this.uniforms.alpha = maskSprite.worldAlpha;
        this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
        filterManager.applyFilter(this, input, output, clearMode);
      };
      return SpriteMaskFilter2;
    }(Filter);
    var MaskSystem = function(_super) {
      __extends$h(MaskSystem2, _super);
      function MaskSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.enableScissor = false;
        _this.alphaMaskPool = [];
        _this.maskDataPool = [];
        _this.maskStack = [];
        _this.alphaMaskIndex = 0;
        return _this;
      }
      MaskSystem2.prototype.setMaskStack = function(maskStack) {
        this.maskStack = maskStack;
        this.renderer.scissor.setMaskStack(maskStack);
        this.renderer.stencil.setMaskStack(maskStack);
      };
      MaskSystem2.prototype.push = function(target, maskDataOrTarget) {
        var maskData = maskDataOrTarget;
        if (!maskData.isMaskData) {
          var d = this.maskDataPool.pop() || new MaskData();
          d.pooled = true;
          d.maskObject = maskDataOrTarget;
          maskData = d;
        }
        if (maskData.autoDetect) {
          this.detect(maskData);
        }
        maskData.copyCountersOrReset(this.maskStack[this.maskStack.length - 1]);
        maskData._target = target;
        switch (maskData.type) {
          case MASK_TYPES$1.SCISSOR:
            this.maskStack.push(maskData);
            this.renderer.scissor.push(maskData);
            break;
          case MASK_TYPES$1.STENCIL:
            this.maskStack.push(maskData);
            this.renderer.stencil.push(maskData);
            break;
          case MASK_TYPES$1.SPRITE:
            maskData.copyCountersOrReset(null);
            this.pushSpriteMask(maskData);
            this.maskStack.push(maskData);
            break;
        }
      };
      MaskSystem2.prototype.pop = function(target) {
        var maskData = this.maskStack.pop();
        if (!maskData || maskData._target !== target) {
          return;
        }
        switch (maskData.type) {
          case MASK_TYPES$1.SCISSOR:
            this.renderer.scissor.pop();
            break;
          case MASK_TYPES$1.STENCIL:
            this.renderer.stencil.pop(maskData.maskObject);
            break;
          case MASK_TYPES$1.SPRITE:
            this.popSpriteMask();
            break;
        }
        maskData.reset();
        if (maskData.pooled) {
          this.maskDataPool.push(maskData);
        }
      };
      MaskSystem2.prototype.detect = function(maskData) {
        var maskObject = maskData.maskObject;
        if (maskObject.isSprite) {
          maskData.type = MASK_TYPES$1.SPRITE;
          return;
        }
        maskData.type = MASK_TYPES$1.STENCIL;
        if (this.enableScissor && maskObject.isFastRect && maskObject.isFastRect()) {
          var matrix = maskObject.worldTransform;
          var rotX = Math.atan2(matrix.b, matrix.a);
          var rotXY = Math.atan2(matrix.d, matrix.c);
          rotX = Math.round(rotX * (180 / Math.PI) * 100);
          rotXY = Math.round(rotXY * (180 / Math.PI) * 100) - rotX;
          rotX = (rotX % 9e3 + 9e3) % 9e3;
          rotXY = (rotXY % 18e3 + 18e3) % 18e3;
          if (rotX === 0 && rotXY === 9e3) {
            maskData.type = MASK_TYPES$1.SCISSOR;
          }
        }
      };
      MaskSystem2.prototype.pushSpriteMask = function(maskData) {
        var maskObject = maskData.maskObject;
        var target = maskData._target;
        var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
        if (!alphaMaskFilter) {
          alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter(maskObject)];
        }
        alphaMaskFilter[0].resolution = this.renderer.resolution;
        alphaMaskFilter[0].maskSprite = maskObject;
        var stashFilterArea = target.filterArea;
        target.filterArea = maskObject.getBounds(true);
        this.renderer.filter.push(target, alphaMaskFilter);
        target.filterArea = stashFilterArea;
        this.alphaMaskIndex++;
      };
      MaskSystem2.prototype.popSpriteMask = function() {
        this.renderer.filter.pop();
        this.alphaMaskIndex--;
      };
      return MaskSystem2;
    }(System);
    var AbstractMaskSystem = function(_super) {
      __extends$h(AbstractMaskSystem2, _super);
      function AbstractMaskSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.maskStack = [];
        _this.glConst = 0;
        return _this;
      }
      AbstractMaskSystem2.prototype.getStackLength = function() {
        return this.maskStack.length;
      };
      AbstractMaskSystem2.prototype.setMaskStack = function(maskStack) {
        var gl = this.renderer.gl;
        var curStackLen = this.getStackLength();
        this.maskStack = maskStack;
        var newStackLen = this.getStackLength();
        if (newStackLen !== curStackLen) {
          if (newStackLen === 0) {
            gl.disable(this.glConst);
          } else {
            gl.enable(this.glConst);
            this._useCurrent();
          }
        }
      };
      AbstractMaskSystem2.prototype._useCurrent = function() {
      };
      AbstractMaskSystem2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        this.maskStack = null;
      };
      return AbstractMaskSystem2;
    }(System);
    var ScissorSystem = function(_super) {
      __extends$h(ScissorSystem2, _super);
      function ScissorSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.glConst = WebGLRenderingContext.SCISSOR_TEST;
        return _this;
      }
      ScissorSystem2.prototype.getStackLength = function() {
        var maskData = this.maskStack[this.maskStack.length - 1];
        if (maskData) {
          return maskData._scissorCounter;
        }
        return 0;
      };
      ScissorSystem2.prototype.push = function(maskData) {
        var maskObject = maskData.maskObject;
        maskObject.renderable = true;
        var prevData = maskData._scissorRect;
        var bounds = maskObject.getBounds(true);
        var gl = this.renderer.gl;
        maskObject.renderable = false;
        if (prevData) {
          bounds.fit(prevData);
        } else {
          gl.enable(gl.SCISSOR_TEST);
        }
        maskData._scissorCounter++;
        maskData._scissorRect = bounds;
        this._useCurrent();
      };
      ScissorSystem2.prototype.pop = function() {
        var gl = this.renderer.gl;
        if (this.getStackLength() > 0) {
          this._useCurrent();
        } else {
          gl.disable(gl.SCISSOR_TEST);
        }
      };
      ScissorSystem2.prototype._useCurrent = function() {
        var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
        var rt = this.renderer.renderTexture.current;
        var _a2 = this.renderer.projection, transform = _a2.transform, sourceFrame = _a2.sourceFrame, destinationFrame = _a2.destinationFrame;
        var resolution = rt ? rt.resolution : this.renderer.resolution;
        var x2 = (rect.x - sourceFrame.x) * resolution + destinationFrame.x;
        var y2 = (rect.y - sourceFrame.y) * resolution + destinationFrame.y;
        var width2 = rect.width * resolution;
        var height2 = rect.height * resolution;
        if (transform) {
          x2 += transform.tx * resolution;
          y2 += transform.ty * resolution;
        }
        if (!rt) {
          y2 = this.renderer.height - height2 - y2;
        }
        this.renderer.gl.scissor(x2, y2, width2, height2);
      };
      return ScissorSystem2;
    }(AbstractMaskSystem);
    var StencilSystem = function(_super) {
      __extends$h(StencilSystem2, _super);
      function StencilSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.glConst = WebGLRenderingContext.STENCIL_TEST;
        return _this;
      }
      StencilSystem2.prototype.getStackLength = function() {
        var maskData = this.maskStack[this.maskStack.length - 1];
        if (maskData) {
          return maskData._stencilCounter;
        }
        return 0;
      };
      StencilSystem2.prototype.push = function(maskData) {
        var maskObject = maskData.maskObject;
        var gl = this.renderer.gl;
        var prevMaskCount = maskData._stencilCounter;
        if (prevMaskCount === 0) {
          this.renderer.framebuffer.forceStencil();
          gl.enable(gl.STENCIL_TEST);
        }
        maskData._stencilCounter++;
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
        maskObject.renderable = true;
        maskObject.render(this.renderer);
        this.renderer.batch.flush();
        maskObject.renderable = false;
        this._useCurrent();
      };
      StencilSystem2.prototype.pop = function(maskObject) {
        var gl = this.renderer.gl;
        if (this.getStackLength() === 0) {
          gl.disable(gl.STENCIL_TEST);
          gl.clear(gl.STENCIL_BUFFER_BIT);
          gl.clearStencil(0);
        } else {
          gl.colorMask(false, false, false, false);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
          maskObject.renderable = true;
          maskObject.render(this.renderer);
          this.renderer.batch.flush();
          maskObject.renderable = false;
          this._useCurrent();
        }
      };
      StencilSystem2.prototype._useCurrent = function() {
        var gl = this.renderer.gl;
        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.EQUAL, this.getStackLength(), this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      };
      StencilSystem2.prototype._getBitwiseMask = function() {
        return (1 << this.getStackLength()) - 1;
      };
      return StencilSystem2;
    }(AbstractMaskSystem);
    var ProjectionSystem = function(_super) {
      __extends$h(ProjectionSystem2, _super);
      function ProjectionSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.destinationFrame = null;
        _this.sourceFrame = null;
        _this.defaultFrame = null;
        _this.projectionMatrix = new Matrix();
        _this.transform = null;
        return _this;
      }
      ProjectionSystem2.prototype.update = function(destinationFrame, sourceFrame, resolution, root2) {
        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
        this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
        this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root2);
        if (this.transform) {
          this.projectionMatrix.append(this.transform);
        }
        var renderer = this.renderer;
        renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
        renderer.globalUniforms.update();
        if (renderer.shader.shader) {
          renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
        }
      };
      ProjectionSystem2.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root2) {
        var pm = this.projectionMatrix;
        var sign2 = !root2 ? 1 : -1;
        pm.identity();
        pm.a = 1 / sourceFrame.width * 2;
        pm.d = sign2 * (1 / sourceFrame.height * 2);
        pm.tx = -1 - sourceFrame.x * pm.a;
        pm.ty = -sign2 - sourceFrame.y * pm.d;
      };
      ProjectionSystem2.prototype.setTransform = function(_matrix) {
      };
      return ProjectionSystem2;
    }(System);
    var tempRect = new Rectangle();
    var tempRect2 = new Rectangle();
    var viewportFrame = new Rectangle();
    var RenderTextureSystem = function(_super) {
      __extends$h(RenderTextureSystem2, _super);
      function RenderTextureSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.clearColor = renderer._backgroundColorRgba;
        _this.defaultMaskStack = [];
        _this.current = null;
        _this.sourceFrame = new Rectangle();
        _this.destinationFrame = new Rectangle();
        return _this;
      }
      RenderTextureSystem2.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
        if (renderTexture === void 0) {
          renderTexture = null;
        }
        var renderer = this.renderer;
        this.current = renderTexture;
        var baseTexture;
        var framebuffer;
        var resolution;
        if (renderTexture) {
          baseTexture = renderTexture.baseTexture;
          resolution = baseTexture.resolution;
          if (!sourceFrame) {
            tempRect.width = renderTexture.frame.width;
            tempRect.height = renderTexture.frame.height;
            sourceFrame = tempRect;
          }
          if (!destinationFrame) {
            tempRect2.x = renderTexture.frame.x;
            tempRect2.y = renderTexture.frame.y;
            tempRect2.width = sourceFrame.width;
            tempRect2.height = sourceFrame.height;
            destinationFrame = tempRect2;
          }
          framebuffer = baseTexture.framebuffer;
        } else {
          resolution = renderer.resolution;
          if (!sourceFrame) {
            tempRect.width = renderer.screen.width;
            tempRect.height = renderer.screen.height;
            sourceFrame = tempRect;
          }
          if (!destinationFrame) {
            destinationFrame = tempRect;
            destinationFrame.width = sourceFrame.width;
            destinationFrame.height = sourceFrame.height;
          }
        }
        viewportFrame.x = destinationFrame.x * resolution;
        viewportFrame.y = destinationFrame.y * resolution;
        viewportFrame.width = destinationFrame.width * resolution;
        viewportFrame.height = destinationFrame.height * resolution;
        this.renderer.framebuffer.bind(framebuffer, viewportFrame);
        this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
        if (renderTexture) {
          this.renderer.mask.setMaskStack(baseTexture.maskStack);
        } else {
          this.renderer.mask.setMaskStack(this.defaultMaskStack);
        }
        this.sourceFrame.copyFrom(sourceFrame);
        this.destinationFrame.copyFrom(destinationFrame);
      };
      RenderTextureSystem2.prototype.clear = function(clearColor, mask) {
        if (this.current) {
          clearColor = clearColor || this.current.baseTexture.clearColor;
        } else {
          clearColor = clearColor || this.clearColor;
        }
        this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
      };
      RenderTextureSystem2.prototype.resize = function() {
        this.bind(null);
      };
      RenderTextureSystem2.prototype.reset = function() {
        this.bind(null);
      };
      return RenderTextureSystem2;
    }(System);
    var GLProgram = function() {
      function GLProgram2(program, uniformData) {
        this.program = program;
        this.uniformData = uniformData;
        this.uniformGroups = {};
      }
      GLProgram2.prototype.destroy = function() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.program = null;
      };
      return GLProgram2;
    }();
    var UID$4 = 0;
    var defaultSyncData = { textureCount: 0 };
    var ShaderSystem = function(_super) {
      __extends$h(ShaderSystem2, _super);
      function ShaderSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.destroyed = false;
        _this.systemCheck();
        _this.gl = null;
        _this.shader = null;
        _this.program = null;
        _this.cache = {};
        _this.id = UID$4++;
        return _this;
      }
      ShaderSystem2.prototype.systemCheck = function() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
        }
      };
      ShaderSystem2.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.reset();
      };
      ShaderSystem2.prototype.bind = function(shader, dontSync) {
        shader.uniforms.globals = this.renderer.globalUniforms;
        var program = shader.program;
        var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(shader);
        this.shader = shader;
        if (this.program !== program) {
          this.program = program;
          this.gl.useProgram(glProgram.program);
        }
        if (!dontSync) {
          defaultSyncData.textureCount = 0;
          this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
        }
        return glProgram;
      };
      ShaderSystem2.prototype.setUniforms = function(uniforms) {
        var shader = this.shader.program;
        var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
        shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
      };
      ShaderSystem2.prototype.syncUniformGroup = function(group2, syncData) {
        var glProgram = this.getglProgram();
        if (!group2.static || group2.dirtyId !== glProgram.uniformGroups[group2.id]) {
          glProgram.uniformGroups[group2.id] = group2.dirtyId;
          this.syncUniforms(group2, glProgram, syncData);
        }
      };
      ShaderSystem2.prototype.syncUniforms = function(group2, glProgram, syncData) {
        var syncFunc = group2.syncUniforms[this.shader.program.id] || this.createSyncGroups(group2);
        syncFunc(glProgram.uniformData, group2.uniforms, this.renderer, syncData);
      };
      ShaderSystem2.prototype.createSyncGroups = function(group2) {
        var id2 = this.getSignature(group2, this.shader.program.uniformData);
        if (!this.cache[id2]) {
          this.cache[id2] = generateUniformsSync(group2, this.shader.program.uniformData);
        }
        group2.syncUniforms[this.shader.program.id] = this.cache[id2];
        return group2.syncUniforms[this.shader.program.id];
      };
      ShaderSystem2.prototype.getSignature = function(group2, uniformData) {
        var uniforms = group2.uniforms;
        var strings = [];
        for (var i in uniforms) {
          strings.push(i);
          if (uniformData[i]) {
            strings.push(uniformData[i].type);
          }
        }
        return strings.join("-");
      };
      ShaderSystem2.prototype.getglProgram = function() {
        if (this.shader) {
          return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
        }
        return null;
      };
      ShaderSystem2.prototype.generateShader = function(shader) {
        var gl = this.gl;
        var program = shader.program;
        var attribMap = {};
        for (var i in program.attributeData) {
          attribMap[i] = program.attributeData[i].location;
        }
        var shaderProgram = compileProgram(gl, program.vertexSrc, program.fragmentSrc, attribMap);
        var uniformData = {};
        for (var i in program.uniformData) {
          var data = program.uniformData[i];
          uniformData[i] = {
            location: gl.getUniformLocation(shaderProgram, i),
            value: defaultValue(data.type, data.size)
          };
        }
        var glProgram = new GLProgram(shaderProgram, uniformData);
        program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
        return glProgram;
      };
      ShaderSystem2.prototype.reset = function() {
        this.program = null;
        this.shader = null;
      };
      ShaderSystem2.prototype.destroy = function() {
        this.destroyed = true;
      };
      return ShaderSystem2;
    }(System);
    function mapWebGLBlendModesToPixi(gl, array) {
      if (array === void 0) {
        array = [];
      }
      array[BLEND_MODES$1.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.ADD] = [gl.ONE, gl.ONE];
      array[BLEND_MODES$1.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.NONE] = [0, 0];
      array[BLEND_MODES$1.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
      array[BLEND_MODES$1.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
      array[BLEND_MODES$1.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
      array[BLEND_MODES$1.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
      array[BLEND_MODES$1.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
      array[BLEND_MODES$1.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
      array[BLEND_MODES$1.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
      return array;
    }
    var BLEND$1 = 0;
    var OFFSET$1 = 1;
    var CULLING$1 = 2;
    var DEPTH_TEST$1 = 3;
    var WINDING$1 = 4;
    var StateSystem = function(_super) {
      __extends$h(StateSystem2, _super);
      function StateSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.gl = null;
        _this.stateId = 0;
        _this.polygonOffset = 0;
        _this.blendMode = BLEND_MODES$1.NONE;
        _this._blendEq = false;
        _this.map = [];
        _this.map[BLEND$1] = _this.setBlend;
        _this.map[OFFSET$1] = _this.setOffset;
        _this.map[CULLING$1] = _this.setCullFace;
        _this.map[DEPTH_TEST$1] = _this.setDepthTest;
        _this.map[WINDING$1] = _this.setFrontFace;
        _this.checks = [];
        _this.defaultState = new State();
        _this.defaultState.blend = true;
        return _this;
      }
      StateSystem2.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.blendModes = mapWebGLBlendModesToPixi(gl);
        this.set(this.defaultState);
        this.reset();
      };
      StateSystem2.prototype.set = function(state) {
        state = state || this.defaultState;
        if (this.stateId !== state.data) {
          var diff2 = this.stateId ^ state.data;
          var i = 0;
          while (diff2) {
            if (diff2 & 1) {
              this.map[i].call(this, !!(state.data & 1 << i));
            }
            diff2 = diff2 >> 1;
            i++;
          }
          this.stateId = state.data;
        }
        for (var i = 0; i < this.checks.length; i++) {
          this.checks[i](this, state);
        }
      };
      StateSystem2.prototype.forceState = function(state) {
        state = state || this.defaultState;
        for (var i = 0; i < this.map.length; i++) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        for (var i = 0; i < this.checks.length; i++) {
          this.checks[i](this, state);
        }
        this.stateId = state.data;
      };
      StateSystem2.prototype.setBlend = function(value2) {
        this.updateCheck(StateSystem2.checkBlendMode, value2);
        this.gl[value2 ? "enable" : "disable"](this.gl.BLEND);
      };
      StateSystem2.prototype.setOffset = function(value2) {
        this.updateCheck(StateSystem2.checkPolygonOffset, value2);
        this.gl[value2 ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      };
      StateSystem2.prototype.setDepthTest = function(value2) {
        this.gl[value2 ? "enable" : "disable"](this.gl.DEPTH_TEST);
      };
      StateSystem2.prototype.setCullFace = function(value2) {
        this.gl[value2 ? "enable" : "disable"](this.gl.CULL_FACE);
      };
      StateSystem2.prototype.setFrontFace = function(value2) {
        this.gl.frontFace(this.gl[value2 ? "CW" : "CCW"]);
      };
      StateSystem2.prototype.setBlendMode = function(value2) {
        if (value2 === this.blendMode) {
          return;
        }
        this.blendMode = value2;
        var mode = this.blendModes[value2];
        var gl = this.gl;
        if (mode.length === 2) {
          gl.blendFunc(mode[0], mode[1]);
        } else {
          gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
          this._blendEq = true;
          gl.blendEquationSeparate(mode[4], mode[5]);
        } else if (this._blendEq) {
          this._blendEq = false;
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
      };
      StateSystem2.prototype.setPolygonOffset = function(value2, scale) {
        this.gl.polygonOffset(value2, scale);
      };
      StateSystem2.prototype.reset = function() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(this.defaultState);
        this._blendEq = true;
        this.blendMode = -1;
        this.setBlendMode(0);
      };
      StateSystem2.prototype.updateCheck = function(func, value2) {
        var index2 = this.checks.indexOf(func);
        if (value2 && index2 === -1) {
          this.checks.push(func);
        } else if (!value2 && index2 !== -1) {
          this.checks.splice(index2, 1);
        }
      };
      StateSystem2.checkBlendMode = function(system, state) {
        system.setBlendMode(state.blendMode);
      };
      StateSystem2.checkPolygonOffset = function(system, state) {
        system.setPolygonOffset(1, state.polygonOffset);
      };
      return StateSystem2;
    }(System);
    var TextureGCSystem = function(_super) {
      __extends$h(TextureGCSystem2, _super);
      function TextureGCSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.count = 0;
        _this.checkCount = 0;
        _this.maxIdle = settings.GC_MAX_IDLE;
        _this.checkCountMax = settings.GC_MAX_CHECK_COUNT;
        _this.mode = settings.GC_MODE;
        return _this;
      }
      TextureGCSystem2.prototype.postrender = function() {
        if (!this.renderer.renderingToScreen) {
          return;
        }
        this.count++;
        if (this.mode === GC_MODES$1.MANUAL) {
          return;
        }
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
          this.checkCount = 0;
          this.run();
        }
      };
      TextureGCSystem2.prototype.run = function() {
        var tm = this.renderer.texture;
        var managedTextures = tm.managedTextures;
        var wasRemoved = false;
        for (var i = 0; i < managedTextures.length; i++) {
          var texture = managedTextures[i];
          if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
            tm.destroyTexture(texture, true);
            managedTextures[i] = null;
            wasRemoved = true;
          }
        }
        if (wasRemoved) {
          var j = 0;
          for (var i = 0; i < managedTextures.length; i++) {
            if (managedTextures[i] !== null) {
              managedTextures[j++] = managedTextures[i];
            }
          }
          managedTextures.length = j;
        }
      };
      TextureGCSystem2.prototype.unload = function(displayObject) {
        var _a2;
        var tm = this.renderer.texture;
        if ((_a2 = displayObject._texture) === null || _a2 === void 0 ? void 0 : _a2.framebuffer) {
          tm.destroyTexture(displayObject._texture);
        }
        for (var i = displayObject.children.length - 1; i >= 0; i--) {
          this.unload(displayObject.children[i]);
        }
      };
      return TextureGCSystem2;
    }(System);
    var GLTexture = function() {
      function GLTexture2(texture) {
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        this.dirtyId = -1;
        this.dirtyStyleId = -1;
        this.mipmap = false;
        this.wrapMode = 33071;
        this.type = 6408;
        this.internalFormat = 5121;
      }
      return GLTexture2;
    }();
    var TextureSystem = function(_super) {
      __extends$h(TextureSystem2, _super);
      function TextureSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.boundTextures = [];
        _this.currentLocation = -1;
        _this.managedTextures = [];
        _this._unknownBoundTextures = false;
        _this.unknownTexture = new BaseTexture();
        return _this;
      }
      TextureSystem2.prototype.contextChange = function() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.webGLVersion = this.renderer.context.webGLVersion;
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = maxTextures;
        for (var i = 0; i < maxTextures; i++) {
          this.boundTextures[i] = null;
        }
        this.emptyTextures = {};
        var emptyTexture2D = new GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
        for (var i = 0; i < 6; i++) {
          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        for (var i = 0; i < this.boundTextures.length; i++) {
          this.bind(null, i);
        }
      };
      TextureSystem2.prototype.bind = function(texture, location) {
        if (location === void 0) {
          location = 0;
        }
        var gl = this.gl;
        if (texture) {
          texture = texture.castToBaseTexture();
          if (texture.parentTextureArray) {
            return;
          }
          if (texture.valid) {
            texture.touched = this.renderer.textureGC.count;
            var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
            if (this.boundTextures[location] !== texture) {
              if (this.currentLocation !== location) {
                this.currentLocation = location;
                gl.activeTexture(gl.TEXTURE0 + location);
              }
              gl.bindTexture(texture.target, glTexture.texture);
            }
            if (glTexture.dirtyId !== texture.dirtyId) {
              if (this.currentLocation !== location) {
                this.currentLocation = location;
                gl.activeTexture(gl.TEXTURE0 + location);
              }
              this.updateTexture(texture);
            }
            this.boundTextures[location] = texture;
          }
        } else {
          if (this.currentLocation !== location) {
            this.currentLocation = location;
            gl.activeTexture(gl.TEXTURE0 + location);
          }
          gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
          this.boundTextures[location] = null;
        }
      };
      TextureSystem2.prototype.reset = function() {
        this._unknownBoundTextures = true;
        this.currentLocation = -1;
        for (var i = 0; i < this.boundTextures.length; i++) {
          this.boundTextures[i] = this.unknownTexture;
        }
      };
      TextureSystem2.prototype.unbind = function(texture) {
        var _a2 = this, gl = _a2.gl, boundTextures = _a2.boundTextures;
        if (this._unknownBoundTextures) {
          this._unknownBoundTextures = false;
          for (var i = 0; i < boundTextures.length; i++) {
            if (boundTextures[i] === this.unknownTexture) {
              this.bind(null, i);
            }
          }
        }
        for (var i = 0; i < boundTextures.length; i++) {
          if (boundTextures[i] === texture) {
            if (this.currentLocation !== i) {
              gl.activeTexture(gl.TEXTURE0 + i);
              this.currentLocation = i;
            }
            gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[texture.target].texture);
            boundTextures[i] = null;
          }
        }
      };
      TextureSystem2.prototype.initTexture = function(texture) {
        var glTexture = new GLTexture(this.gl.createTexture());
        glTexture.dirtyId = -1;
        texture._glTextures[this.CONTEXT_UID] = glTexture;
        this.managedTextures.push(texture);
        texture.on("dispose", this.destroyTexture, this);
        return glTexture;
      };
      TextureSystem2.prototype.initTextureType = function(texture, glTexture) {
        glTexture.internalFormat = texture.format;
        glTexture.type = texture.type;
        if (this.webGLVersion !== 2) {
          return;
        }
        var gl = this.renderer.gl;
        if (texture.type === gl.FLOAT && texture.format === gl.RGBA) {
          glTexture.internalFormat = gl.RGBA32F;
        }
        if (texture.type === TYPES$1.HALF_FLOAT) {
          glTexture.type = gl.HALF_FLOAT;
        }
        if (glTexture.type === gl.HALF_FLOAT && texture.format === gl.RGBA) {
          glTexture.internalFormat = gl.RGBA16F;
        }
      };
      TextureSystem2.prototype.updateTexture = function(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
          return;
        }
        var renderer = this.renderer;
        this.initTextureType(texture, glTexture);
        if (texture.resource && texture.resource.upload(renderer, texture, glTexture))
          ;
        else {
          var width2 = texture.realWidth;
          var height2 = texture.realHeight;
          var gl = renderer.gl;
          if (glTexture.width !== width2 || glTexture.height !== height2 || glTexture.dirtyId < 0) {
            glTexture.width = width2;
            glTexture.height = height2;
            gl.texImage2D(texture.target, 0, glTexture.internalFormat, width2, height2, 0, texture.format, glTexture.type, null);
          }
        }
        if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
          this.updateTextureStyle(texture);
        }
        glTexture.dirtyId = texture.dirtyId;
      };
      TextureSystem2.prototype.destroyTexture = function(texture, skipRemove) {
        var gl = this.gl;
        texture = texture.castToBaseTexture();
        if (texture._glTextures[this.CONTEXT_UID]) {
          this.unbind(texture);
          gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
          texture.off("dispose", this.destroyTexture, this);
          delete texture._glTextures[this.CONTEXT_UID];
          if (!skipRemove) {
            var i = this.managedTextures.indexOf(texture);
            if (i !== -1) {
              removeItems(this.managedTextures, i, 1);
            }
          }
        }
      };
      TextureSystem2.prototype.updateTextureStyle = function(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
          return;
        }
        if ((texture.mipmap === MIPMAP_MODES$1.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
          glTexture.mipmap = false;
        } else {
          glTexture.mipmap = texture.mipmap >= 1;
        }
        if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
          glTexture.wrapMode = WRAP_MODES$1.CLAMP;
        } else {
          glTexture.wrapMode = texture.wrapMode;
        }
        if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
          ;
        else {
          this.setStyle(texture, glTexture);
        }
        glTexture.dirtyStyleId = texture.dirtyStyleId;
      };
      TextureSystem2.prototype.setStyle = function(texture, glTexture) {
        var gl = this.gl;
        if (glTexture.mipmap) {
          gl.generateMipmap(texture.target);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
        if (glTexture.mipmap) {
          gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES$1.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
          var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
          if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES$1.LINEAR) {
            var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
          }
        } else {
          gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES$1.LINEAR ? gl.LINEAR : gl.NEAREST);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES$1.LINEAR ? gl.LINEAR : gl.NEAREST);
      };
      return TextureSystem2;
    }(System);
    var tempMatrix = new Matrix();
    var AbstractRenderer = function(_super) {
      __extends$h(AbstractRenderer2, _super);
      function AbstractRenderer2(type, options) {
        if (type === void 0) {
          type = RENDERER_TYPE$1.UNKNOWN;
        }
        var _this = _super.call(this) || this;
        options = Object.assign({}, settings.RENDER_OPTIONS, options);
        if (options.roundPixels) {
          settings.ROUND_PIXELS = options.roundPixels;
          deprecation("5.0.0", "Renderer roundPixels option is deprecated, please use PIXI.settings.ROUND_PIXELS", 2);
        }
        _this.options = options;
        _this.type = type;
        _this.screen = new Rectangle(0, 0, options.width, options.height);
        _this.view = options.view || document.createElement("canvas");
        _this.resolution = options.resolution || settings.RESOLUTION;
        _this.transparent = options.transparent;
        _this.autoDensity = options.autoDensity || options.autoResize || false;
        _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        _this.clearBeforeRender = options.clearBeforeRender;
        _this._backgroundColor = 0;
        _this._backgroundColorRgba = [0, 0, 0, 0];
        _this._backgroundColorString = "#000000";
        _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
        _this._lastObjectRendered = null;
        _this.plugins = {};
        return _this;
      }
      AbstractRenderer2.prototype.initPlugins = function(staticMap) {
        for (var o in staticMap) {
          this.plugins[o] = new staticMap[o](this);
        }
      };
      Object.defineProperty(AbstractRenderer2.prototype, "width", {
        get: function() {
          return this.view.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractRenderer2.prototype, "height", {
        get: function() {
          return this.view.height;
        },
        enumerable: false,
        configurable: true
      });
      AbstractRenderer2.prototype.resize = function(screenWidth, screenHeight) {
        this.screen.width = screenWidth;
        this.screen.height = screenHeight;
        this.view.width = screenWidth * this.resolution;
        this.view.height = screenHeight * this.resolution;
        if (this.autoDensity) {
          this.view.style.width = screenWidth + "px";
          this.view.style.height = screenHeight + "px";
        }
        this.emit("resize", screenWidth, screenHeight);
      };
      AbstractRenderer2.prototype.generateTexture = function(displayObject, scaleMode, resolution, region) {
        region = region || displayObject.getLocalBounds(null, true);
        if (region.width === 0) {
          region.width = 1;
        }
        if (region.height === 0) {
          region.height = 1;
        }
        var renderTexture = RenderTexture.create({
          width: region.width | 0,
          height: region.height | 0,
          scaleMode,
          resolution
        });
        tempMatrix.tx = -region.x;
        tempMatrix.ty = -region.y;
        this.render(displayObject, renderTexture, false, tempMatrix, !!displayObject.parent);
        return renderTexture;
      };
      AbstractRenderer2.prototype.destroy = function(removeView) {
        for (var o in this.plugins) {
          this.plugins[o].destroy();
          this.plugins[o] = null;
        }
        if (removeView && this.view.parentNode) {
          this.view.parentNode.removeChild(this.view);
        }
        var thisAny = this;
        thisAny.plugins = null;
        thisAny.type = RENDERER_TYPE$1.UNKNOWN;
        thisAny.view = null;
        thisAny.screen = null;
        thisAny._tempDisplayObjectParent = null;
        thisAny.options = null;
        this._backgroundColorRgba = null;
        this._backgroundColorString = null;
        this._lastObjectRendered = null;
      };
      Object.defineProperty(AbstractRenderer2.prototype, "backgroundColor", {
        get: function() {
          return this._backgroundColor;
        },
        set: function(value2) {
          this._backgroundColor = value2;
          this._backgroundColorString = hex2string(value2);
          hex2rgb(value2, this._backgroundColorRgba);
        },
        enumerable: false,
        configurable: true
      });
      return AbstractRenderer2;
    }(EventEmitter);
    var Renderer = function(_super) {
      __extends$h(Renderer2, _super);
      function Renderer2(options) {
        var _this = _super.call(this, RENDERER_TYPE$1.WEBGL, options) || this;
        options = _this.options;
        _this.gl = null;
        _this.CONTEXT_UID = 0;
        _this.runners = {
          destroy: new Runner("destroy"),
          contextChange: new Runner("contextChange"),
          reset: new Runner("reset"),
          update: new Runner("update"),
          postrender: new Runner("postrender"),
          prerender: new Runner("prerender"),
          resize: new Runner("resize")
        };
        _this.globalUniforms = new UniformGroup({
          projectionMatrix: new Matrix()
        }, true);
        _this.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch");
        _this.initPlugins(Renderer2.__plugins);
        if (options.context) {
          _this.context.initFromContext(options.context);
        } else {
          _this.context.initFromOptions({
            alpha: !!_this.transparent,
            antialias: options.antialias,
            premultipliedAlpha: _this.transparent && _this.transparent !== "notMultiplied",
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer,
            powerPreference: _this.options.powerPreference
          });
        }
        _this.renderingToScreen = true;
        sayHello(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
        _this.resize(_this.options.width, _this.options.height);
        return _this;
      }
      Renderer2.create = function(options) {
        if (isWebGLSupported()) {
          return new Renderer2(options);
        }
        throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
      };
      Renderer2.prototype.addSystem = function(ClassRef, name2) {
        if (!name2) {
          name2 = ClassRef.name;
        }
        var system = new ClassRef(this);
        if (this[name2]) {
          throw new Error('Whoops! The name "' + name2 + '" is already in use');
        }
        this[name2] = system;
        for (var i in this.runners) {
          this.runners[i].add(system);
        }
        return this;
      };
      Renderer2.prototype.render = function(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
        this.renderingToScreen = !renderTexture;
        this.runners.prerender.emit();
        this.emit("prerender");
        this.projection.transform = transform;
        if (this.context.isLost) {
          return;
        }
        if (!renderTexture) {
          this._lastObjectRendered = displayObject;
        }
        if (!skipUpdateTransform) {
          var cacheParent = displayObject.enableTempParent();
          displayObject.updateTransform();
          displayObject.disableTempParent(cacheParent);
        }
        this.renderTexture.bind(renderTexture);
        this.batch.currentRenderer.start();
        if (clear !== void 0 ? clear : this.clearBeforeRender) {
          this.renderTexture.clear();
        }
        displayObject.render(this);
        this.batch.currentRenderer.flush();
        if (renderTexture) {
          renderTexture.baseTexture.update();
        }
        this.runners.postrender.emit();
        this.projection.transform = null;
        this.emit("postrender");
      };
      Renderer2.prototype.resize = function(screenWidth, screenHeight) {
        _super.prototype.resize.call(this, screenWidth, screenHeight);
        this.runners.resize.emit(screenWidth, screenHeight);
      };
      Renderer2.prototype.reset = function() {
        this.runners.reset.emit();
        return this;
      };
      Renderer2.prototype.clear = function() {
        this.renderTexture.bind();
        this.renderTexture.clear();
      };
      Renderer2.prototype.destroy = function(removeView) {
        this.runners.destroy.emit();
        for (var r2 in this.runners) {
          this.runners[r2].destroy();
        }
        _super.prototype.destroy.call(this, removeView);
        this.gl = null;
      };
      Renderer2.registerPlugin = function(pluginName, ctor2) {
        Renderer2.__plugins = Renderer2.__plugins || {};
        Renderer2.__plugins[pluginName] = ctor2;
      };
      return Renderer2;
    }(AbstractRenderer);
    function autoDetectRenderer(options) {
      return Renderer.create(options);
    }
    var _default = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
    var defaultFilter = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
    var BatchDrawCall = function() {
      function BatchDrawCall2() {
        this.texArray = null;
        this.blend = 0;
        this.type = DRAW_MODES$1.TRIANGLES;
        this.start = 0;
        this.size = 0;
        this.data = null;
      }
      return BatchDrawCall2;
    }();
    var BatchTextureArray = function() {
      function BatchTextureArray2() {
        this.elements = [];
        this.ids = [];
        this.count = 0;
      }
      BatchTextureArray2.prototype.clear = function() {
        for (var i = 0; i < this.count; i++) {
          this.elements[i] = null;
        }
        this.count = 0;
      };
      return BatchTextureArray2;
    }();
    var ViewableBuffer = function() {
      function ViewableBuffer2(size2) {
        this.rawBinaryData = new ArrayBuffer(size2);
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
      }
      Object.defineProperty(ViewableBuffer2.prototype, "int8View", {
        get: function() {
          if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
          }
          return this._int8View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer2.prototype, "uint8View", {
        get: function() {
          if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
          }
          return this._uint8View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer2.prototype, "int16View", {
        get: function() {
          if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
          }
          return this._int16View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer2.prototype, "uint16View", {
        get: function() {
          if (!this._uint16View) {
            this._uint16View = new Uint16Array(this.rawBinaryData);
          }
          return this._uint16View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer2.prototype, "int32View", {
        get: function() {
          if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
          }
          return this._int32View;
        },
        enumerable: false,
        configurable: true
      });
      ViewableBuffer2.prototype.view = function(type) {
        return this[type + "View"];
      };
      ViewableBuffer2.prototype.destroy = function() {
        this.rawBinaryData = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this._uint16View = null;
        this._int32View = null;
        this.uint32View = null;
        this.float32View = null;
      };
      ViewableBuffer2.sizeOf = function(type) {
        switch (type) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(type + " isn't a valid view type");
        }
      };
      return ViewableBuffer2;
    }();
    var AbstractBatchRenderer = function(_super) {
      __extends$h(AbstractBatchRenderer2, _super);
      function AbstractBatchRenderer2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.shaderGenerator = null;
        _this.geometryClass = null;
        _this.vertexSize = null;
        _this.state = State.for2d();
        _this.size = settings.SPRITE_BATCH_SIZE * 4;
        _this._vertexCount = 0;
        _this._indexCount = 0;
        _this._bufferedElements = [];
        _this._bufferedTextures = [];
        _this._bufferSize = 0;
        _this._shader = null;
        _this._packedGeometries = [];
        _this._packedGeometryPoolSize = 2;
        _this._flushId = 0;
        _this._aBuffers = {};
        _this._iBuffers = {};
        _this.MAX_TEXTURES = 1;
        _this.renderer.on("prerender", _this.onPrerender, _this);
        renderer.runners.contextChange.add(_this);
        _this._dcIndex = 0;
        _this._aIndex = 0;
        _this._iIndex = 0;
        _this._attributeBuffer = null;
        _this._indexBuffer = null;
        _this._tempBoundTextures = [];
        return _this;
      }
      AbstractBatchRenderer2.prototype.contextChange = function() {
        var gl = this.renderer.gl;
        if (settings.PREFER_ENV === ENV$1.WEBGL_LEGACY) {
          this.MAX_TEXTURES = 1;
        } else {
          this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);
          this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
        }
        this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
        for (var i = 0; i < this._packedGeometryPoolSize; i++) {
          this._packedGeometries[i] = new this.geometryClass();
        }
        this.initFlushBuffers();
      };
      AbstractBatchRenderer2.prototype.initFlushBuffers = function() {
        var _drawCallPool = AbstractBatchRenderer2._drawCallPool, _textureArrayPool = AbstractBatchRenderer2._textureArrayPool;
        var MAX_SPRITES = this.size / 4;
        var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
        while (_drawCallPool.length < MAX_SPRITES) {
          _drawCallPool.push(new BatchDrawCall());
        }
        while (_textureArrayPool.length < MAX_TA) {
          _textureArrayPool.push(new BatchTextureArray());
        }
        for (var i = 0; i < this.MAX_TEXTURES; i++) {
          this._tempBoundTextures[i] = null;
        }
      };
      AbstractBatchRenderer2.prototype.onPrerender = function() {
        this._flushId = 0;
      };
      AbstractBatchRenderer2.prototype.render = function(element) {
        if (!element._texture.valid) {
          return;
        }
        if (this._vertexCount + element.vertexData.length / 2 > this.size) {
          this.flush();
        }
        this._vertexCount += element.vertexData.length / 2;
        this._indexCount += element.indices.length;
        this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
        this._bufferedElements[this._bufferSize++] = element;
      };
      AbstractBatchRenderer2.prototype.buildTexturesAndDrawCalls = function() {
        var _a2 = this, textures = _a2._bufferedTextures, MAX_TEXTURES = _a2.MAX_TEXTURES;
        var textureArrays = AbstractBatchRenderer2._textureArrayPool;
        var batch = this.renderer.batch;
        var boundTextures = this._tempBoundTextures;
        var touch = this.renderer.textureGC.count;
        var TICK = ++BaseTexture._globalBatch;
        var countTexArrays = 0;
        var texArray = textureArrays[0];
        var start = 0;
        batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
        for (var i = 0; i < this._bufferSize; ++i) {
          var tex = textures[i];
          textures[i] = null;
          if (tex._batchEnabled === TICK) {
            continue;
          }
          if (texArray.count >= MAX_TEXTURES) {
            batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
            this.buildDrawCalls(texArray, start, i);
            start = i;
            texArray = textureArrays[++countTexArrays];
            ++TICK;
          }
          tex._batchEnabled = TICK;
          tex.touched = touch;
          texArray.elements[texArray.count++] = tex;
        }
        if (texArray.count > 0) {
          batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
          this.buildDrawCalls(texArray, start, this._bufferSize);
          ++countTexArrays;
          ++TICK;
        }
        for (var i = 0; i < boundTextures.length; i++) {
          boundTextures[i] = null;
        }
        BaseTexture._globalBatch = TICK;
      };
      AbstractBatchRenderer2.prototype.buildDrawCalls = function(texArray, start, finish) {
        var _a2 = this, elements = _a2._bufferedElements, _attributeBuffer = _a2._attributeBuffer, _indexBuffer = _a2._indexBuffer, vertexSize = _a2.vertexSize;
        var drawCalls = AbstractBatchRenderer2._drawCallPool;
        var dcIndex = this._dcIndex;
        var aIndex = this._aIndex;
        var iIndex = this._iIndex;
        var drawCall = drawCalls[dcIndex];
        drawCall.start = this._iIndex;
        drawCall.texArray = texArray;
        for (var i = start; i < finish; ++i) {
          var sprite = elements[i];
          var tex = sprite._texture.baseTexture;
          var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
          elements[i] = null;
          if (start < i && drawCall.blend !== spriteBlendMode) {
            drawCall.size = iIndex - drawCall.start;
            start = i;
            drawCall = drawCalls[++dcIndex];
            drawCall.texArray = texArray;
            drawCall.start = iIndex;
          }
          this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
          aIndex += sprite.vertexData.length / 2 * vertexSize;
          iIndex += sprite.indices.length;
          drawCall.blend = spriteBlendMode;
        }
        if (start < finish) {
          drawCall.size = iIndex - drawCall.start;
          ++dcIndex;
        }
        this._dcIndex = dcIndex;
        this._aIndex = aIndex;
        this._iIndex = iIndex;
      };
      AbstractBatchRenderer2.prototype.bindAndClearTexArray = function(texArray) {
        var textureSystem = this.renderer.texture;
        for (var j = 0; j < texArray.count; j++) {
          textureSystem.bind(texArray.elements[j], texArray.ids[j]);
          texArray.elements[j] = null;
        }
        texArray.count = 0;
      };
      AbstractBatchRenderer2.prototype.updateGeometry = function() {
        var _a2 = this, packedGeometries = _a2._packedGeometries, attributeBuffer = _a2._attributeBuffer, indexBuffer = _a2._indexBuffer;
        if (!settings.CAN_UPLOAD_SAME_BUFFER) {
          if (this._packedGeometryPoolSize <= this._flushId) {
            this._packedGeometryPoolSize++;
            packedGeometries[this._flushId] = new this.geometryClass();
          }
          packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
          packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
          this.renderer.geometry.bind(packedGeometries[this._flushId]);
          this.renderer.geometry.updateBuffers();
          this._flushId++;
        } else {
          packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
          packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
          this.renderer.geometry.updateBuffers();
        }
      };
      AbstractBatchRenderer2.prototype.drawBatches = function() {
        var dcCount = this._dcIndex;
        var _a2 = this.renderer, gl = _a2.gl, stateSystem = _a2.state;
        var drawCalls = AbstractBatchRenderer2._drawCallPool;
        var curTexArray = null;
        for (var i = 0; i < dcCount; i++) {
          var _b = drawCalls[i], texArray = _b.texArray, type = _b.type, size2 = _b.size, start = _b.start, blend = _b.blend;
          if (curTexArray !== texArray) {
            curTexArray = texArray;
            this.bindAndClearTexArray(texArray);
          }
          this.state.blendMode = blend;
          stateSystem.set(this.state);
          gl.drawElements(type, size2, gl.UNSIGNED_SHORT, start * 2);
        }
      };
      AbstractBatchRenderer2.prototype.flush = function() {
        if (this._vertexCount === 0) {
          return;
        }
        this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
        this._indexBuffer = this.getIndexBuffer(this._indexCount);
        this._aIndex = 0;
        this._iIndex = 0;
        this._dcIndex = 0;
        this.buildTexturesAndDrawCalls();
        this.updateGeometry();
        this.drawBatches();
        this._bufferSize = 0;
        this._vertexCount = 0;
        this._indexCount = 0;
      };
      AbstractBatchRenderer2.prototype.start = function() {
        this.renderer.state.set(this.state);
        this.renderer.shader.bind(this._shader);
        if (settings.CAN_UPLOAD_SAME_BUFFER) {
          this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
        }
      };
      AbstractBatchRenderer2.prototype.stop = function() {
        this.flush();
      };
      AbstractBatchRenderer2.prototype.destroy = function() {
        for (var i = 0; i < this._packedGeometryPoolSize; i++) {
          if (this._packedGeometries[i]) {
            this._packedGeometries[i].destroy();
          }
        }
        this.renderer.off("prerender", this.onPrerender, this);
        this._aBuffers = null;
        this._iBuffers = null;
        this._packedGeometries = null;
        this._attributeBuffer = null;
        this._indexBuffer = null;
        if (this._shader) {
          this._shader.destroy();
          this._shader = null;
        }
        _super.prototype.destroy.call(this);
      };
      AbstractBatchRenderer2.prototype.getAttributeBuffer = function(size2) {
        var roundedP2 = nextPow2(Math.ceil(size2 / 8));
        var roundedSizeIndex = log2(roundedP2);
        var roundedSize = roundedP2 * 8;
        if (this._aBuffers.length <= roundedSizeIndex) {
          this._iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this._aBuffers[roundedSize];
        if (!buffer) {
          this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
        }
        return buffer;
      };
      AbstractBatchRenderer2.prototype.getIndexBuffer = function(size2) {
        var roundedP2 = nextPow2(Math.ceil(size2 / 12));
        var roundedSizeIndex = log2(roundedP2);
        var roundedSize = roundedP2 * 12;
        if (this._iBuffers.length <= roundedSizeIndex) {
          this._iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this._iBuffers[roundedSizeIndex];
        if (!buffer) {
          this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
        }
        return buffer;
      };
      AbstractBatchRenderer2.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
        var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
        var packedVertices = aIndex / this.vertexSize;
        var uvs = element.uvs;
        var indicies = element.indices;
        var vertexData = element.vertexData;
        var textureId = element._texture.baseTexture._batchLocation;
        var alpha = Math.min(element.worldAlpha, 1);
        var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
        for (var i = 0; i < vertexData.length; i += 2) {
          float32View[aIndex++] = vertexData[i];
          float32View[aIndex++] = vertexData[i + 1];
          float32View[aIndex++] = uvs[i];
          float32View[aIndex++] = uvs[i + 1];
          uint32View[aIndex++] = argb;
          float32View[aIndex++] = textureId;
        }
        for (var i = 0; i < indicies.length; i++) {
          indexBuffer[iIndex++] = packedVertices + indicies[i];
        }
      };
      AbstractBatchRenderer2._drawCallPool = [];
      AbstractBatchRenderer2._textureArrayPool = [];
      return AbstractBatchRenderer2;
    }(ObjectRenderer);
    var BatchShaderGenerator = function() {
      function BatchShaderGenerator2(vertexSrc, fragTemplate2) {
        this.vertexSrc = vertexSrc;
        this.fragTemplate = fragTemplate2;
        this.programCache = {};
        this.defaultGroupCache = {};
        if (fragTemplate2.indexOf("%count%") < 0) {
          throw new Error('Fragment template must contain "%count%".');
        }
        if (fragTemplate2.indexOf("%forloop%") < 0) {
          throw new Error('Fragment template must contain "%forloop%".');
        }
      }
      BatchShaderGenerator2.prototype.generateShader = function(maxTextures) {
        if (!this.programCache[maxTextures]) {
          var sampleValues = new Int32Array(maxTextures);
          for (var i = 0; i < maxTextures; i++) {
            sampleValues[i] = i;
          }
          this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
          var fragmentSrc = this.fragTemplate;
          fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
          fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
          this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
        }
        var uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: this.defaultGroupCache[maxTextures]
        };
        return new Shader(this.programCache[maxTextures], uniforms);
      };
      BatchShaderGenerator2.prototype.generateSampleSrc = function(maxTextures) {
        var src = "";
        src += "\n";
        src += "\n";
        for (var i = 0; i < maxTextures; i++) {
          if (i > 0) {
            src += "\nelse ";
          }
          if (i < maxTextures - 1) {
            src += "if(vTextureId < " + i + ".5)";
          }
          src += "\n{";
          src += "\n	color = texture2D(uSamplers[" + i + "], vTextureCoord);";
          src += "\n}";
        }
        src += "\n";
        src += "\n";
        return src;
      };
      return BatchShaderGenerator2;
    }();
    var BatchGeometry = function(_super) {
      __extends$h(BatchGeometry2, _super);
      function BatchGeometry2(_static) {
        if (_static === void 0) {
          _static = false;
        }
        var _this = _super.call(this) || this;
        _this._buffer = new Buffer$1(null, _static, false);
        _this._indexBuffer = new Buffer$1(null, _static, true);
        _this.addAttribute("aVertexPosition", _this._buffer, 2, false, TYPES$1.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, TYPES$1.FLOAT).addAttribute("aColor", _this._buffer, 4, true, TYPES$1.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, TYPES$1.FLOAT).addIndex(_this._indexBuffer);
        return _this;
      }
      return BatchGeometry2;
    }(Geometry);
    var defaultVertex$2 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
    var defaultFragment$2 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
    var BatchPluginFactory = function() {
      function BatchPluginFactory2() {
      }
      BatchPluginFactory2.create = function(options) {
        var _a2 = Object.assign({
          vertex: defaultVertex$2,
          fragment: defaultFragment$2,
          geometryClass: BatchGeometry,
          vertexSize: 6
        }, options), vertex2 = _a2.vertex, fragment2 = _a2.fragment, vertexSize = _a2.vertexSize, geometryClass = _a2.geometryClass;
        return function(_super) {
          __extends$h(BatchPlugin, _super);
          function BatchPlugin(renderer) {
            var _this = _super.call(this, renderer) || this;
            _this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
            _this.geometryClass = geometryClass;
            _this.vertexSize = vertexSize;
            return _this;
          }
          return BatchPlugin;
        }(AbstractBatchRenderer);
      };
      Object.defineProperty(BatchPluginFactory2, "defaultVertexSrc", {
        get: function() {
          return defaultVertex$2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BatchPluginFactory2, "defaultFragmentTemplate", {
        get: function() {
          return defaultFragment$2;
        },
        enumerable: false,
        configurable: true
      });
      return BatchPluginFactory2;
    }();
    var BatchRenderer = BatchPluginFactory.create();
    /*!
     * @pixi/app - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/app is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var Application = function() {
      function Application2(options) {
        var _this = this;
        options = Object.assign({
          forceCanvas: false
        }, options);
        this.renderer = autoDetectRenderer(options);
        this.stage = new Container();
        Application2._plugins.forEach(function(plugin) {
          plugin.init.call(_this, options);
        });
      }
      Application2.registerPlugin = function(plugin) {
        Application2._plugins.push(plugin);
      };
      Application2.prototype.render = function() {
        this.renderer.render(this.stage);
      };
      Object.defineProperty(Application2.prototype, "view", {
        get: function() {
          return this.renderer.view;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Application2.prototype, "screen", {
        get: function() {
          return this.renderer.screen;
        },
        enumerable: false,
        configurable: true
      });
      Application2.prototype.destroy = function(removeView, stageOptions) {
        var _this = this;
        var plugins = Application2._plugins.slice(0);
        plugins.reverse();
        plugins.forEach(function(plugin) {
          plugin.destroy.call(_this);
        });
        this.stage.destroy(stageOptions);
        this.stage = null;
        this.renderer.destroy(removeView);
        this.renderer = null;
      };
      return Application2;
    }();
    Application._plugins = [];
    var ResizePlugin = function() {
      function ResizePlugin2() {
      }
      ResizePlugin2.init = function(options) {
        var _this = this;
        Object.defineProperty(this, "resizeTo", {
          set: function(dom) {
            window.removeEventListener("resize", this.queueResize);
            this._resizeTo = dom;
            if (dom) {
              window.addEventListener("resize", this.queueResize);
              this.resize();
            }
          },
          get: function() {
            return this._resizeTo;
          }
        });
        this.queueResize = function() {
          if (!_this._resizeTo) {
            return;
          }
          _this.cancelResize();
          _this._resizeId = requestAnimationFrame(function() {
            return _this.resize();
          });
        };
        this.cancelResize = function() {
          if (_this._resizeId) {
            cancelAnimationFrame(_this._resizeId);
            _this._resizeId = null;
          }
        };
        this.resize = function() {
          if (!_this._resizeTo) {
            return;
          }
          _this.cancelResize();
          var width2;
          var height2;
          if (_this._resizeTo === window) {
            width2 = window.innerWidth;
            height2 = window.innerHeight;
          } else {
            var _a2 = _this._resizeTo, clientWidth = _a2.clientWidth, clientHeight = _a2.clientHeight;
            width2 = clientWidth;
            height2 = clientHeight;
          }
          _this.renderer.resize(width2, height2);
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
      };
      ResizePlugin2.destroy = function() {
        this.cancelResize();
        this.cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
      };
      return ResizePlugin2;
    }();
    Application.registerPlugin(ResizePlugin);
    /*!
     * @pixi/extract - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/extract is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var TEMP_RECT = new Rectangle();
    var BYTES_PER_PIXEL = 4;
    var Extract = function() {
      function Extract2(renderer) {
        this.renderer = renderer;
        renderer.extract = this;
      }
      Extract2.prototype.image = function(target, format2, quality) {
        var image = new Image();
        image.src = this.base64(target, format2, quality);
        return image;
      };
      Extract2.prototype.base64 = function(target, format2, quality) {
        return this.canvas(target).toDataURL(format2, quality);
      };
      Extract2.prototype.canvas = function(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var flipY = false;
        var renderTexture;
        var generated = false;
        if (target) {
          if (target instanceof RenderTexture) {
            renderTexture = target;
          } else {
            renderTexture = this.renderer.generateTexture(target);
            generated = true;
          }
        }
        if (renderTexture) {
          resolution = renderTexture.baseTexture.resolution;
          frame = renderTexture.frame;
          flipY = false;
          renderer.renderTexture.bind(renderTexture);
        } else {
          resolution = this.renderer.resolution;
          flipY = true;
          frame = TEMP_RECT;
          frame.width = this.renderer.width;
          frame.height = this.renderer.height;
          renderer.renderTexture.bind(null);
        }
        var width2 = Math.floor(frame.width * resolution + 1e-4);
        var height2 = Math.floor(frame.height * resolution + 1e-4);
        var canvasBuffer = new CanvasRenderTarget(width2, height2, 1);
        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width2 * height2);
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width2, height2, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        var canvasData = canvasBuffer.context.getImageData(0, 0, width2, height2);
        Extract2.arrayPostDivide(webglPixels, canvasData.data);
        canvasBuffer.context.putImageData(canvasData, 0, 0);
        if (flipY) {
          var target_1 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
          target_1.context.scale(1, -1);
          target_1.context.drawImage(canvasBuffer.canvas, 0, -height2);
          canvasBuffer.destroy();
          canvasBuffer = target_1;
        }
        if (generated) {
          renderTexture.destroy(true);
        }
        return canvasBuffer.canvas;
      };
      Extract2.prototype.pixels = function(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var renderTexture;
        var generated = false;
        if (target) {
          if (target instanceof RenderTexture) {
            renderTexture = target;
          } else {
            renderTexture = this.renderer.generateTexture(target);
            generated = true;
          }
        }
        if (renderTexture) {
          resolution = renderTexture.baseTexture.resolution;
          frame = renderTexture.frame;
          renderer.renderTexture.bind(renderTexture);
        } else {
          resolution = renderer.resolution;
          frame = TEMP_RECT;
          frame.width = renderer.width;
          frame.height = renderer.height;
          renderer.renderTexture.bind(null);
        }
        var width2 = frame.width * resolution;
        var height2 = frame.height * resolution;
        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width2 * height2);
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width2, height2, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        if (generated) {
          renderTexture.destroy(true);
        }
        Extract2.arrayPostDivide(webglPixels, webglPixels);
        return webglPixels;
      };
      Extract2.prototype.destroy = function() {
        this.renderer.extract = null;
        this.renderer = null;
      };
      Extract2.arrayPostDivide = function(pixels, out) {
        for (var i = 0; i < pixels.length; i += 4) {
          var alpha = out[i + 3] = pixels[i + 3];
          if (alpha !== 0) {
            out[i] = Math.round(Math.min(pixels[i] * 255 / alpha, 255));
            out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255 / alpha, 255));
            out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255 / alpha, 255));
          } else {
            out[i] = pixels[i];
            out[i + 1] = pixels[i + 1];
            out[i + 2] = pixels[i + 2];
          }
        }
      };
      return Extract2;
    }();
    function parseURI(str, opts) {
      if (!str)
        return void 0;
      opts = opts || {};
      var o = {
        key: [
          "source",
          "protocol",
          "authority",
          "userInfo",
          "user",
          "password",
          "host",
          "port",
          "relative",
          "path",
          "directory",
          "file",
          "query",
          "anchor"
        ],
        q: {
          name: "queryKey",
          parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
          strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
          loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
      };
      var m2 = o.parser[opts.strictMode ? "strict" : "loose"].exec(str);
      var uri = {};
      var i = 14;
      while (i--)
        uri[o.key[i]] = m2[i] || "";
      uri[o.q.name] = {};
      uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
        if ($1)
          uri[o.q.name][$1] = $2;
      });
      return uri;
    }
    var parseUri = parseURI;
    class MiniSignalBinding {
      constructor(fn, once2 = false, thisArg) {
        this._fn = fn;
        this._once = once2;
        this._thisArg = thisArg;
        this._next = this._prev = this._owner = null;
      }
      detach() {
        if (this._owner === null)
          return false;
        this._owner.detach(this);
        return true;
      }
    }
    function _addMiniSignalBinding(self2, node) {
      if (!self2._head) {
        self2._head = node;
        self2._tail = node;
      } else {
        self2._tail._next = node;
        node._prev = self2._tail;
        self2._tail = node;
      }
      node._owner = self2;
      return node;
    }
    class MiniSignal {
      constructor() {
        this._head = this._tail = void 0;
      }
      handlers(exists = false) {
        let node = this._head;
        if (exists)
          return !!node;
        const ee2 = [];
        while (node) {
          ee2.push(node);
          node = node._next;
        }
        return ee2;
      }
      has(node) {
        if (!(node instanceof MiniSignalBinding)) {
          throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");
        }
        return node._owner === this;
      }
      dispatch() {
        let node = this._head;
        if (!node)
          return false;
        while (node) {
          if (node._once)
            this.detach(node);
          node._fn.apply(node._thisArg, arguments);
          node = node._next;
        }
        return true;
      }
      add(fn, thisArg = null) {
        if (typeof fn !== "function") {
          throw new Error("MiniSignal#add(): First arg must be a Function.");
        }
        return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));
      }
      once(fn, thisArg = null) {
        if (typeof fn !== "function") {
          throw new Error("MiniSignal#once(): First arg must be a Function.");
        }
        return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));
      }
      detach(node) {
        if (!(node instanceof MiniSignalBinding)) {
          throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");
        }
        if (node._owner !== this)
          return this;
        if (node._prev)
          node._prev._next = node._next;
        if (node._next)
          node._next._prev = node._prev;
        if (node === this._head) {
          this._head = node._next;
          if (node._next === null) {
            this._tail = null;
          }
        } else if (node === this._tail) {
          this._tail = node._prev;
          this._tail._next = null;
        }
        node._owner = null;
        return this;
      }
      detachAll() {
        let node = this._head;
        if (!node)
          return this;
        this._head = this._tail = null;
        while (node) {
          node._owner = null;
          node = node._next;
        }
        return this;
      }
    }
    /*!
     * resource-loader - v3.0.1
     * https://github.com/pixijs/pixi-sound
     * Compiled Tue, 02 Jul 2019 14:06:18 UTC
     *
     * resource-loader is licensed under the MIT license.
     * http://www.opensource.org/licenses/mit-license
     */
    function _noop() {
    }
    function eachSeries(array, iterator, callback, deferNext) {
      var i = 0;
      var len = array.length;
      (function next(err) {
        if (err || i === len) {
          if (callback) {
            callback(err);
          }
          return;
        }
        if (deferNext) {
          setTimeout(function() {
            iterator(array[i++], next);
          }, 1);
        } else {
          iterator(array[i++], next);
        }
      })();
    }
    function onlyOnce(fn) {
      return function onceWrapper() {
        if (fn === null) {
          throw new Error("Callback was already called.");
        }
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    function queue(worker, concurrency) {
      if (concurrency == null) {
        concurrency = 1;
      } else if (concurrency === 0) {
        throw new Error("Concurrency must not be zero");
      }
      var workers = 0;
      var q2 = {
        _tasks: [],
        concurrency,
        saturated: _noop,
        unsaturated: _noop,
        buffer: concurrency / 4,
        empty: _noop,
        drain: _noop,
        error: _noop,
        started: false,
        paused: false,
        push: function push2(data, callback) {
          _insert(data, false, callback);
        },
        kill: function kill() {
          workers = 0;
          q2.drain = _noop;
          q2.started = false;
          q2._tasks = [];
        },
        unshift: function unshift(data, callback) {
          _insert(data, true, callback);
        },
        process: function process2() {
          while (!q2.paused && workers < q2.concurrency && q2._tasks.length) {
            var task = q2._tasks.shift();
            if (q2._tasks.length === 0) {
              q2.empty();
            }
            workers += 1;
            if (workers === q2.concurrency) {
              q2.saturated();
            }
            worker(task.data, onlyOnce(_next(task)));
          }
        },
        length: function length() {
          return q2._tasks.length;
        },
        running: function running() {
          return workers;
        },
        idle: function idle() {
          return q2._tasks.length + workers === 0;
        },
        pause: function pause() {
          if (q2.paused === true) {
            return;
          }
          q2.paused = true;
        },
        resume: function resume() {
          if (q2.paused === false) {
            return;
          }
          q2.paused = false;
          for (var w2 = 1; w2 <= q2.concurrency; w2++) {
            q2.process();
          }
        }
      };
      function _insert(data, insertAtFront, callback) {
        if (callback != null && typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q2.started = true;
        if (data == null && q2.idle()) {
          setTimeout(function() {
            return q2.drain();
          }, 1);
          return;
        }
        var item = {
          data,
          callback: typeof callback === "function" ? callback : _noop
        };
        if (insertAtFront) {
          q2._tasks.unshift(item);
        } else {
          q2._tasks.push(item);
        }
        setTimeout(function() {
          return q2.process();
        }, 1);
      }
      function _next(task) {
        return function next() {
          workers -= 1;
          task.callback.apply(task, arguments);
          if (arguments[0] != null) {
            q2.error(arguments[0], task.data);
          }
          if (workers <= q2.concurrency - q2.buffer) {
            q2.unsaturated();
          }
          if (q2.idle()) {
            q2.drain();
          }
          q2.process();
        };
      }
      return q2;
    }
    var cache$1 = {};
    function caching(resource, next) {
      var _this = this;
      if (cache$1[resource.url]) {
        resource.data = cache$1[resource.url];
        resource.complete();
      } else {
        resource.onComplete.once(function() {
          return cache$1[_this.url] = _this.data;
        });
      }
      next();
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var useXdr = !!(window.XDomainRequest && !("withCredentials" in new XMLHttpRequest()));
    var tempAnchor = null;
    var STATUS_NONE = 0;
    var STATUS_OK = 200;
    var STATUS_EMPTY = 204;
    var STATUS_IE_BUG_EMPTY = 1223;
    var STATUS_TYPE_OK = 2;
    function _noop$1() {
    }
    var Resource = /* @__PURE__ */ function() {
      Resource2.setExtensionLoadType = function setExtensionLoadType(extname, loadType) {
        setExtMap(Resource2._loadTypeMap, extname, loadType);
      };
      Resource2.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) {
        setExtMap(Resource2._xhrTypeMap, extname, xhrType);
      };
      function Resource2(name2, url2, options) {
        if (typeof name2 !== "string" || typeof url2 !== "string") {
          throw new Error("Both name and url are required for constructing a resource.");
        }
        options = options || {};
        this._flags = 0;
        this._setFlag(Resource2.STATUS_FLAGS.DATA_URL, url2.indexOf("data:") === 0);
        this.name = name2;
        this.url = url2;
        this.extension = this._getExtension();
        this.data = null;
        this.crossOrigin = options.crossOrigin === true ? "anonymous" : options.crossOrigin;
        this.timeout = options.timeout || 0;
        this.loadType = options.loadType || this._determineLoadType();
        this.xhrType = options.xhrType;
        this.metadata = options.metadata || {};
        this.error = null;
        this.xhr = null;
        this.children = [];
        this.type = Resource2.TYPE.UNKNOWN;
        this.progressChunk = 0;
        this._dequeue = _noop$1;
        this._onLoadBinding = null;
        this._elementTimer = 0;
        this._boundComplete = this.complete.bind(this);
        this._boundOnError = this._onError.bind(this);
        this._boundOnProgress = this._onProgress.bind(this);
        this._boundOnTimeout = this._onTimeout.bind(this);
        this._boundXhrOnError = this._xhrOnError.bind(this);
        this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);
        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
        this.onStart = new MiniSignal();
        this.onProgress = new MiniSignal();
        this.onComplete = new MiniSignal();
        this.onAfterMiddleware = new MiniSignal();
      }
      var _proto = Resource2.prototype;
      _proto.complete = function complete() {
        this._clearEvents();
        this._finish();
      };
      _proto.abort = function abort(message) {
        if (this.error) {
          return;
        }
        this.error = new Error(message);
        this._clearEvents();
        if (this.xhr) {
          this.xhr.abort();
        } else if (this.xdr) {
          this.xdr.abort();
        } else if (this.data) {
          if (this.data.src) {
            this.data.src = Resource2.EMPTY_GIF;
          } else {
            while (this.data.firstChild) {
              this.data.removeChild(this.data.firstChild);
            }
          }
        }
        this._finish();
      };
      _proto.load = function load(cb2) {
        var _this = this;
        if (this.isLoading) {
          return;
        }
        if (this.isComplete) {
          if (cb2) {
            setTimeout(function() {
              return cb2(_this);
            }, 1);
          }
          return;
        } else if (cb2) {
          this.onComplete.once(cb2);
        }
        this._setFlag(Resource2.STATUS_FLAGS.LOADING, true);
        this.onStart.dispatch(this);
        if (this.crossOrigin === false || typeof this.crossOrigin !== "string") {
          this.crossOrigin = this._determineCrossOrigin(this.url);
        }
        switch (this.loadType) {
          case Resource2.LOAD_TYPE.IMAGE:
            this.type = Resource2.TYPE.IMAGE;
            this._loadElement("image");
            break;
          case Resource2.LOAD_TYPE.AUDIO:
            this.type = Resource2.TYPE.AUDIO;
            this._loadSourceElement("audio");
            break;
          case Resource2.LOAD_TYPE.VIDEO:
            this.type = Resource2.TYPE.VIDEO;
            this._loadSourceElement("video");
            break;
          case Resource2.LOAD_TYPE.XHR:
          default:
            if (useXdr && this.crossOrigin) {
              this._loadXdr();
            } else {
              this._loadXhr();
            }
            break;
        }
      };
      _proto._hasFlag = function _hasFlag(flag) {
        return (this._flags & flag) !== 0;
      };
      _proto._setFlag = function _setFlag(flag, value2) {
        this._flags = value2 ? this._flags | flag : this._flags & ~flag;
      };
      _proto._clearEvents = function _clearEvents() {
        clearTimeout(this._elementTimer);
        if (this.data && this.data.removeEventListener) {
          this.data.removeEventListener("error", this._boundOnError, false);
          this.data.removeEventListener("load", this._boundComplete, false);
          this.data.removeEventListener("progress", this._boundOnProgress, false);
          this.data.removeEventListener("canplaythrough", this._boundComplete, false);
        }
        if (this.xhr) {
          if (this.xhr.removeEventListener) {
            this.xhr.removeEventListener("error", this._boundXhrOnError, false);
            this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false);
            this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false);
            this.xhr.removeEventListener("progress", this._boundOnProgress, false);
            this.xhr.removeEventListener("load", this._boundXhrOnLoad, false);
          } else {
            this.xhr.onerror = null;
            this.xhr.ontimeout = null;
            this.xhr.onprogress = null;
            this.xhr.onload = null;
          }
        }
      };
      _proto._finish = function _finish() {
        if (this.isComplete) {
          throw new Error("Complete called again for an already completed resource.");
        }
        this._setFlag(Resource2.STATUS_FLAGS.COMPLETE, true);
        this._setFlag(Resource2.STATUS_FLAGS.LOADING, false);
        this.onComplete.dispatch(this);
      };
      _proto._loadElement = function _loadElement(type) {
        if (this.metadata.loadElement) {
          this.data = this.metadata.loadElement;
        } else if (type === "image" && typeof window.Image !== "undefined") {
          this.data = new Image();
        } else {
          this.data = document.createElement(type);
        }
        if (this.crossOrigin) {
          this.data.crossOrigin = this.crossOrigin;
        }
        if (!this.metadata.skipSource) {
          this.data.src = this.url;
        }
        this.data.addEventListener("error", this._boundOnError, false);
        this.data.addEventListener("load", this._boundComplete, false);
        this.data.addEventListener("progress", this._boundOnProgress, false);
        if (this.timeout) {
          this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
        }
      };
      _proto._loadSourceElement = function _loadSourceElement(type) {
        if (this.metadata.loadElement) {
          this.data = this.metadata.loadElement;
        } else if (type === "audio" && typeof window.Audio !== "undefined") {
          this.data = new Audio();
        } else {
          this.data = document.createElement(type);
        }
        if (this.data === null) {
          this.abort("Unsupported element: " + type);
          return;
        }
        if (this.crossOrigin) {
          this.data.crossOrigin = this.crossOrigin;
        }
        if (!this.metadata.skipSource) {
          if (navigator.isCocoonJS) {
            this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
          } else if (Array.isArray(this.url)) {
            var mimeTypes = this.metadata.mimeType;
            for (var i = 0; i < this.url.length; ++i) {
              this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
            }
          } else {
            var _mimeTypes = this.metadata.mimeType;
            this.data.appendChild(this._createSource(type, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));
          }
        }
        this.data.addEventListener("error", this._boundOnError, false);
        this.data.addEventListener("load", this._boundComplete, false);
        this.data.addEventListener("progress", this._boundOnProgress, false);
        this.data.addEventListener("canplaythrough", this._boundComplete, false);
        this.data.load();
        if (this.timeout) {
          this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
        }
      };
      _proto._loadXhr = function _loadXhr() {
        if (typeof this.xhrType !== "string") {
          this.xhrType = this._determineXhrType();
        }
        var xhr2 = this.xhr = new XMLHttpRequest();
        xhr2.open("GET", this.url, true);
        xhr2.timeout = this.timeout;
        if (this.xhrType === Resource2.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource2.XHR_RESPONSE_TYPE.DOCUMENT) {
          xhr2.responseType = Resource2.XHR_RESPONSE_TYPE.TEXT;
        } else {
          xhr2.responseType = this.xhrType;
        }
        xhr2.addEventListener("error", this._boundXhrOnError, false);
        xhr2.addEventListener("timeout", this._boundXhrOnTimeout, false);
        xhr2.addEventListener("abort", this._boundXhrOnAbort, false);
        xhr2.addEventListener("progress", this._boundOnProgress, false);
        xhr2.addEventListener("load", this._boundXhrOnLoad, false);
        xhr2.send();
      };
      _proto._loadXdr = function _loadXdr() {
        if (typeof this.xhrType !== "string") {
          this.xhrType = this._determineXhrType();
        }
        var xdr = this.xhr = new XDomainRequest();
        xdr.timeout = this.timeout || 5e3;
        xdr.onerror = this._boundXhrOnError;
        xdr.ontimeout = this._boundXhrOnTimeout;
        xdr.onprogress = this._boundOnProgress;
        xdr.onload = this._boundXhrOnLoad;
        xdr.open("GET", this.url, true);
        setTimeout(function() {
          return xdr.send();
        }, 1);
      };
      _proto._createSource = function _createSource(type, url2, mime) {
        if (!mime) {
          mime = type + "/" + this._getExtension(url2);
        }
        var source = document.createElement("source");
        source.src = url2;
        source.type = mime;
        return source;
      };
      _proto._onError = function _onError(event) {
        this.abort("Failed to load element using: " + event.target.nodeName);
      };
      _proto._onProgress = function _onProgress(event) {
        if (event && event.lengthComputable) {
          this.onProgress.dispatch(this, event.loaded / event.total);
        }
      };
      _proto._onTimeout = function _onTimeout() {
        this.abort("Load timed out.");
      };
      _proto._xhrOnError = function _xhrOnError() {
        var xhr2 = this.xhr;
        this.abort(reqType(xhr2) + " Request failed. Status: " + xhr2.status + ', text: "' + xhr2.statusText + '"');
      };
      _proto._xhrOnTimeout = function _xhrOnTimeout() {
        var xhr2 = this.xhr;
        this.abort(reqType(xhr2) + " Request timed out.");
      };
      _proto._xhrOnAbort = function _xhrOnAbort() {
        var xhr2 = this.xhr;
        this.abort(reqType(xhr2) + " Request was aborted by the user.");
      };
      _proto._xhrOnLoad = function _xhrOnLoad() {
        var xhr2 = this.xhr;
        var text = "";
        var status = typeof xhr2.status === "undefined" ? STATUS_OK : xhr2.status;
        if (xhr2.responseType === "" || xhr2.responseType === "text" || typeof xhr2.responseType === "undefined") {
          text = xhr2.responseText;
        }
        if (status === STATUS_NONE && (text.length > 0 || xhr2.responseType === Resource2.XHR_RESPONSE_TYPE.BUFFER)) {
          status = STATUS_OK;
        } else if (status === STATUS_IE_BUG_EMPTY) {
          status = STATUS_EMPTY;
        }
        var statusType = status / 100 | 0;
        if (statusType === STATUS_TYPE_OK) {
          if (this.xhrType === Resource2.XHR_RESPONSE_TYPE.TEXT) {
            this.data = text;
            this.type = Resource2.TYPE.TEXT;
          } else if (this.xhrType === Resource2.XHR_RESPONSE_TYPE.JSON) {
            try {
              this.data = JSON.parse(text);
              this.type = Resource2.TYPE.JSON;
            } catch (e) {
              this.abort("Error trying to parse loaded json: " + e);
              return;
            }
          } else if (this.xhrType === Resource2.XHR_RESPONSE_TYPE.DOCUMENT) {
            try {
              if (window.DOMParser) {
                var domparser = new DOMParser();
                this.data = domparser.parseFromString(text, "text/xml");
              } else {
                var div = document.createElement("div");
                div.innerHTML = text;
                this.data = div;
              }
              this.type = Resource2.TYPE.XML;
            } catch (e) {
              this.abort("Error trying to parse loaded xml: " + e);
              return;
            }
          } else {
            this.data = xhr2.response || text;
          }
        } else {
          this.abort("[" + xhr2.status + "] " + xhr2.statusText + ": " + xhr2.responseURL);
          return;
        }
        this.complete();
      };
      _proto._determineCrossOrigin = function _determineCrossOrigin(url2, loc) {
        if (url2.indexOf("data:") === 0) {
          return "";
        }
        if (window.origin !== window.location.origin) {
          return "anonymous";
        }
        loc = loc || window.location;
        if (!tempAnchor) {
          tempAnchor = document.createElement("a");
        }
        tempAnchor.href = url2;
        url2 = parseUri(tempAnchor.href, {
          strictMode: true
        });
        var samePort = !url2.port && loc.port === "" || url2.port === loc.port;
        var protocol = url2.protocol ? url2.protocol + ":" : "";
        if (url2.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
          return "anonymous";
        }
        return "";
      };
      _proto._determineXhrType = function _determineXhrType() {
        return Resource2._xhrTypeMap[this.extension] || Resource2.XHR_RESPONSE_TYPE.TEXT;
      };
      _proto._determineLoadType = function _determineLoadType() {
        return Resource2._loadTypeMap[this.extension] || Resource2.LOAD_TYPE.XHR;
      };
      _proto._getExtension = function _getExtension() {
        var url2 = this.url;
        var ext = "";
        if (this.isDataUrl) {
          var slashIndex = url2.indexOf("/");
          ext = url2.substring(slashIndex + 1, url2.indexOf(";", slashIndex));
        } else {
          var queryStart = url2.indexOf("?");
          var hashStart = url2.indexOf("#");
          var index2 = Math.min(queryStart > -1 ? queryStart : url2.length, hashStart > -1 ? hashStart : url2.length);
          url2 = url2.substring(0, index2);
          ext = url2.substring(url2.lastIndexOf(".") + 1);
        }
        return ext.toLowerCase();
      };
      _proto._getMimeFromXhrType = function _getMimeFromXhrType(type) {
        switch (type) {
          case Resource2.XHR_RESPONSE_TYPE.BUFFER:
            return "application/octet-binary";
          case Resource2.XHR_RESPONSE_TYPE.BLOB:
            return "application/blob";
          case Resource2.XHR_RESPONSE_TYPE.DOCUMENT:
            return "application/xml";
          case Resource2.XHR_RESPONSE_TYPE.JSON:
            return "application/json";
          case Resource2.XHR_RESPONSE_TYPE.DEFAULT:
          case Resource2.XHR_RESPONSE_TYPE.TEXT:
          default:
            return "text/plain";
        }
      };
      _createClass(Resource2, [{
        key: "isDataUrl",
        get: function get2() {
          return this._hasFlag(Resource2.STATUS_FLAGS.DATA_URL);
        }
      }, {
        key: "isComplete",
        get: function get2() {
          return this._hasFlag(Resource2.STATUS_FLAGS.COMPLETE);
        }
      }, {
        key: "isLoading",
        get: function get2() {
          return this._hasFlag(Resource2.STATUS_FLAGS.LOADING);
        }
      }]);
      return Resource2;
    }();
    Resource.STATUS_FLAGS = {
      NONE: 0,
      DATA_URL: 1 << 0,
      COMPLETE: 1 << 1,
      LOADING: 1 << 2
    };
    Resource.TYPE = {
      UNKNOWN: 0,
      JSON: 1,
      XML: 2,
      IMAGE: 3,
      AUDIO: 4,
      VIDEO: 5,
      TEXT: 6
    };
    Resource.LOAD_TYPE = {
      XHR: 1,
      IMAGE: 2,
      AUDIO: 3,
      VIDEO: 4
    };
    Resource.XHR_RESPONSE_TYPE = {
      DEFAULT: "text",
      BUFFER: "arraybuffer",
      BLOB: "blob",
      DOCUMENT: "document",
      JSON: "json",
      TEXT: "text"
    };
    Resource._loadTypeMap = {
      gif: Resource.LOAD_TYPE.IMAGE,
      png: Resource.LOAD_TYPE.IMAGE,
      bmp: Resource.LOAD_TYPE.IMAGE,
      jpg: Resource.LOAD_TYPE.IMAGE,
      jpeg: Resource.LOAD_TYPE.IMAGE,
      tif: Resource.LOAD_TYPE.IMAGE,
      tiff: Resource.LOAD_TYPE.IMAGE,
      webp: Resource.LOAD_TYPE.IMAGE,
      tga: Resource.LOAD_TYPE.IMAGE,
      svg: Resource.LOAD_TYPE.IMAGE,
      "svg+xml": Resource.LOAD_TYPE.IMAGE,
      mp3: Resource.LOAD_TYPE.AUDIO,
      ogg: Resource.LOAD_TYPE.AUDIO,
      wav: Resource.LOAD_TYPE.AUDIO,
      mp4: Resource.LOAD_TYPE.VIDEO,
      webm: Resource.LOAD_TYPE.VIDEO
    };
    Resource._xhrTypeMap = {
      xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      gif: Resource.XHR_RESPONSE_TYPE.BLOB,
      png: Resource.XHR_RESPONSE_TYPE.BLOB,
      bmp: Resource.XHR_RESPONSE_TYPE.BLOB,
      jpg: Resource.XHR_RESPONSE_TYPE.BLOB,
      jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,
      tif: Resource.XHR_RESPONSE_TYPE.BLOB,
      tiff: Resource.XHR_RESPONSE_TYPE.BLOB,
      webp: Resource.XHR_RESPONSE_TYPE.BLOB,
      tga: Resource.XHR_RESPONSE_TYPE.BLOB,
      json: Resource.XHR_RESPONSE_TYPE.JSON,
      text: Resource.XHR_RESPONSE_TYPE.TEXT,
      txt: Resource.XHR_RESPONSE_TYPE.TEXT,
      ttf: Resource.XHR_RESPONSE_TYPE.BUFFER,
      otf: Resource.XHR_RESPONSE_TYPE.BUFFER
    };
    Resource.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
    function setExtMap(map2, extname, val) {
      if (extname && extname.indexOf(".") === 0) {
        extname = extname.substring(1);
      }
      if (!extname) {
        return;
      }
      map2[extname] = val;
    }
    function reqType(xhr2) {
      return xhr2.toString().replace("object ", "");
    }
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    function encodeBinary(input) {
      var output = "";
      var inx = 0;
      while (inx < input.length) {
        var bytebuffer = [0, 0, 0];
        var encodedCharIndexes = [0, 0, 0, 0];
        for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
          if (inx < input.length) {
            bytebuffer[jnx] = input.charCodeAt(inx++) & 255;
          } else {
            bytebuffer[jnx] = 0;
          }
        }
        encodedCharIndexes[0] = bytebuffer[0] >> 2;
        encodedCharIndexes[1] = (bytebuffer[0] & 3) << 4 | bytebuffer[1] >> 4;
        encodedCharIndexes[2] = (bytebuffer[1] & 15) << 2 | bytebuffer[2] >> 6;
        encodedCharIndexes[3] = bytebuffer[2] & 63;
        var paddingBytes = inx - (input.length - 1);
        switch (paddingBytes) {
          case 2:
            encodedCharIndexes[3] = 64;
            encodedCharIndexes[2] = 64;
            break;
          case 1:
            encodedCharIndexes[3] = 64;
            break;
        }
        for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) {
          output += _keyStr.charAt(encodedCharIndexes[_jnx]);
        }
      }
      return output;
    }
    var Url = window.URL || window.webkitURL;
    function parsing(resource, next) {
      if (!resource.data) {
        next();
        return;
      }
      if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {
        if (!window.Blob || typeof resource.data === "string") {
          var type = resource.xhr.getResponseHeader("content-type");
          if (type && type.indexOf("image") === 0) {
            resource.data = new Image();
            resource.data.src = "data:" + type + ";base64," + encodeBinary(resource.xhr.responseText);
            resource.type = Resource.TYPE.IMAGE;
            resource.data.onload = function() {
              resource.data.onload = null;
              next();
            };
            return;
          }
        } else if (resource.data.type.indexOf("image") === 0) {
          var src = Url.createObjectURL(resource.data);
          resource.blob = resource.data;
          resource.data = new Image();
          resource.data.src = src;
          resource.type = Resource.TYPE.IMAGE;
          resource.data.onload = function() {
            Url.revokeObjectURL(src);
            resource.data.onload = null;
            next();
          };
          return;
        }
      }
      next();
    }
    var index = {
      caching,
      parsing
    };
    var MAX_PROGRESS = 100;
    var rgxExtractUrlHash = /(#[\w-]+)?$/;
    var Loader$1 = /* @__PURE__ */ function() {
      function Loader2(baseUrl, concurrency) {
        var _this = this;
        if (baseUrl === void 0) {
          baseUrl = "";
        }
        if (concurrency === void 0) {
          concurrency = 10;
        }
        this.baseUrl = baseUrl;
        this.progress = 0;
        this.loading = false;
        this.defaultQueryString = "";
        this._beforeMiddleware = [];
        this._afterMiddleware = [];
        this._resourcesParsing = [];
        this._boundLoadResource = function(r2, d) {
          return _this._loadResource(r2, d);
        };
        this._queue = queue(this._boundLoadResource, concurrency);
        this._queue.pause();
        this.resources = {};
        this.onProgress = new MiniSignal();
        this.onError = new MiniSignal();
        this.onLoad = new MiniSignal();
        this.onStart = new MiniSignal();
        this.onComplete = new MiniSignal();
        for (var i = 0; i < Loader2._defaultBeforeMiddleware.length; ++i) {
          this.pre(Loader2._defaultBeforeMiddleware[i]);
        }
        for (var _i = 0; _i < Loader2._defaultAfterMiddleware.length; ++_i) {
          this.use(Loader2._defaultAfterMiddleware[_i]);
        }
      }
      var _proto = Loader2.prototype;
      _proto.add = function add2(name2, url2, options, cb2) {
        if (Array.isArray(name2)) {
          for (var i = 0; i < name2.length; ++i) {
            this.add(name2[i]);
          }
          return this;
        }
        if (typeof name2 === "object") {
          cb2 = url2 || name2.callback || name2.onComplete;
          options = name2;
          url2 = name2.url;
          name2 = name2.name || name2.key || name2.url;
        }
        if (typeof url2 !== "string") {
          cb2 = options;
          options = url2;
          url2 = name2;
        }
        if (typeof url2 !== "string") {
          throw new Error("No url passed to add resource to loader.");
        }
        if (typeof options === "function") {
          cb2 = options;
          options = null;
        }
        if (this.loading && (!options || !options.parentResource)) {
          throw new Error("Cannot add resources while the loader is running.");
        }
        if (this.resources[name2]) {
          throw new Error('Resource named "' + name2 + '" already exists.');
        }
        url2 = this._prepareUrl(url2);
        this.resources[name2] = new Resource(name2, url2, options);
        if (typeof cb2 === "function") {
          this.resources[name2].onAfterMiddleware.once(cb2);
        }
        if (this.loading) {
          var parent = options.parentResource;
          var incompleteChildren = [];
          for (var _i2 = 0; _i2 < parent.children.length; ++_i2) {
            if (!parent.children[_i2].isComplete) {
              incompleteChildren.push(parent.children[_i2]);
            }
          }
          var fullChunk = parent.progressChunk * (incompleteChildren.length + 1);
          var eachChunk = fullChunk / (incompleteChildren.length + 2);
          parent.children.push(this.resources[name2]);
          parent.progressChunk = eachChunk;
          for (var _i3 = 0; _i3 < incompleteChildren.length; ++_i3) {
            incompleteChildren[_i3].progressChunk = eachChunk;
          }
          this.resources[name2].progressChunk = eachChunk;
        }
        this._queue.push(this.resources[name2]);
        return this;
      };
      _proto.pre = function pre(fn) {
        this._beforeMiddleware.push(fn);
        return this;
      };
      _proto.use = function use(fn) {
        this._afterMiddleware.push(fn);
        return this;
      };
      _proto.reset = function reset() {
        this.progress = 0;
        this.loading = false;
        this._queue.kill();
        this._queue.pause();
        for (var k in this.resources) {
          var res = this.resources[k];
          if (res._onLoadBinding) {
            res._onLoadBinding.detach();
          }
          if (res.isLoading) {
            res.abort();
          }
        }
        this.resources = {};
        return this;
      };
      _proto.load = function load(cb2) {
        if (typeof cb2 === "function") {
          this.onComplete.once(cb2);
        }
        if (this.loading) {
          return this;
        }
        if (this._queue.idle()) {
          this._onStart();
          this._onComplete();
        } else {
          var numTasks = this._queue._tasks.length;
          var chunk2 = MAX_PROGRESS / numTasks;
          for (var i = 0; i < this._queue._tasks.length; ++i) {
            this._queue._tasks[i].data.progressChunk = chunk2;
          }
          this._onStart();
          this._queue.resume();
        }
        return this;
      };
      _proto._prepareUrl = function _prepareUrl(url2) {
        var parsedUrl = parseUri(url2, {
          strictMode: true
        });
        var result2;
        if (parsedUrl.protocol || !parsedUrl.path || url2.indexOf("//") === 0) {
          result2 = url2;
        } else if (this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && url2.charAt(0) !== "/") {
          result2 = this.baseUrl + "/" + url2;
        } else {
          result2 = this.baseUrl + url2;
        }
        if (this.defaultQueryString) {
          var hash = rgxExtractUrlHash.exec(result2)[0];
          result2 = result2.substr(0, result2.length - hash.length);
          if (result2.indexOf("?") !== -1) {
            result2 += "&" + this.defaultQueryString;
          } else {
            result2 += "?" + this.defaultQueryString;
          }
          result2 += hash;
        }
        return result2;
      };
      _proto._loadResource = function _loadResource(resource, dequeue) {
        var _this2 = this;
        resource._dequeue = dequeue;
        eachSeries(this._beforeMiddleware, function(fn, next) {
          fn.call(_this2, resource, function() {
            next(resource.isComplete ? {} : null);
          });
        }, function() {
          if (resource.isComplete) {
            _this2._onLoad(resource);
          } else {
            resource._onLoadBinding = resource.onComplete.once(_this2._onLoad, _this2);
            resource.load();
          }
        }, true);
      };
      _proto._onStart = function _onStart() {
        this.progress = 0;
        this.loading = true;
        this.onStart.dispatch(this);
      };
      _proto._onComplete = function _onComplete() {
        this.progress = MAX_PROGRESS;
        this.loading = false;
        this.onComplete.dispatch(this, this.resources);
      };
      _proto._onLoad = function _onLoad(resource) {
        var _this3 = this;
        resource._onLoadBinding = null;
        this._resourcesParsing.push(resource);
        resource._dequeue();
        eachSeries(this._afterMiddleware, function(fn, next) {
          fn.call(_this3, resource, next);
        }, function() {
          resource.onAfterMiddleware.dispatch(resource);
          _this3.progress = Math.min(MAX_PROGRESS, _this3.progress + resource.progressChunk);
          _this3.onProgress.dispatch(_this3, resource);
          if (resource.error) {
            _this3.onError.dispatch(resource.error, _this3, resource);
          } else {
            _this3.onLoad.dispatch(_this3, resource);
          }
          _this3._resourcesParsing.splice(_this3._resourcesParsing.indexOf(resource), 1);
          if (_this3._queue.idle() && _this3._resourcesParsing.length === 0) {
            _this3._onComplete();
          }
        }, true);
      };
      _createClass(Loader2, [{
        key: "concurrency",
        get: function get2() {
          return this._queue.concurrency;
        },
        set: function set2(concurrency) {
          this._queue.concurrency = concurrency;
        }
      }]);
      return Loader2;
    }();
    Loader$1._defaultBeforeMiddleware = [];
    Loader$1._defaultAfterMiddleware = [];
    Loader$1.pre = function LoaderPreStatic(fn) {
      Loader$1._defaultBeforeMiddleware.push(fn);
      return Loader$1;
    };
    Loader$1.use = function LoaderUseStatic(fn) {
      Loader$1._defaultAfterMiddleware.push(fn);
      return Loader$1;
    };
    /*!
     * @pixi/loaders - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/loaders is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var LoaderResource = Resource;
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$g = function(d, b) {
      extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$g(d, b);
    };
    function __extends$g(d, b) {
      extendStatics$g(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var TextureLoader = function() {
      function TextureLoader2() {
      }
      TextureLoader2.use = function(resource, next) {
        if (resource.data && resource.type === Resource.TYPE.IMAGE) {
          resource.texture = Texture.fromLoader(resource.data, resource.url, resource.name);
        }
        next();
      };
      return TextureLoader2;
    }();
    var Loader = function(_super) {
      __extends$g(Loader2, _super);
      function Loader2(baseUrl, concurrency) {
        var _this = _super.call(this, baseUrl, concurrency) || this;
        for (var i = 0; i < Loader2._plugins.length; ++i) {
          var plugin = Loader2._plugins[i];
          var pre = plugin.pre, use = plugin.use;
          if (pre) {
            _this.pre(pre);
          }
          if (use) {
            _this.use(use);
          }
        }
        _this._protected = false;
        return _this;
      }
      Loader2.prototype.destroy = function() {
        if (!this._protected) {
          this.reset();
        }
      };
      Object.defineProperty(Loader2, "shared", {
        get: function() {
          var shared = Loader2._shared;
          if (!shared) {
            shared = new Loader2();
            shared._protected = true;
            Loader2._shared = shared;
          }
          return shared;
        },
        enumerable: false,
        configurable: true
      });
      Loader2.registerPlugin = function(plugin) {
        Loader2._plugins.push(plugin);
        if (plugin.add) {
          plugin.add();
        }
        return Loader2;
      };
      Loader2._plugins = [];
      return Loader2;
    }(Loader$1);
    Loader.registerPlugin({ use: index.parsing });
    Loader.registerPlugin(TextureLoader);
    var AppLoaderPlugin = function() {
      function AppLoaderPlugin2() {
      }
      AppLoaderPlugin2.init = function(options) {
        options = Object.assign({
          sharedLoader: false
        }, options);
        this.loader = options.sharedLoader ? Loader.shared : new Loader();
      };
      AppLoaderPlugin2.destroy = function() {
        if (this.loader) {
          this.loader.destroy();
          this.loader = null;
        }
      };
      return AppLoaderPlugin2;
    }();
    /*!
     * @pixi/particles - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/particles is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$f = function(d, b) {
      extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$f(d, b);
    };
    function __extends$f(d, b) {
      extendStatics$f(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    (function(_super) {
      __extends$f(ParticleContainer, _super);
      function ParticleContainer(maxSize, properties, batchSize, autoResize) {
        if (maxSize === void 0) {
          maxSize = 1500;
        }
        if (batchSize === void 0) {
          batchSize = 16384;
        }
        if (autoResize === void 0) {
          autoResize = false;
        }
        var _this = _super.call(this) || this;
        var maxBatchSize = 16384;
        if (batchSize > maxBatchSize) {
          batchSize = maxBatchSize;
        }
        _this._properties = [false, true, false, false, false];
        _this._maxSize = maxSize;
        _this._batchSize = batchSize;
        _this._buffers = null;
        _this._bufferUpdateIDs = [];
        _this._updateID = 0;
        _this.interactiveChildren = false;
        _this.blendMode = BLEND_MODES$1.NORMAL;
        _this.autoResize = autoResize;
        _this.roundPixels = true;
        _this.baseTexture = null;
        _this.setProperties(properties);
        _this._tint = 0;
        _this.tintRgb = new Float32Array(4);
        _this.tint = 16777215;
        return _this;
      }
      ParticleContainer.prototype.setProperties = function(properties) {
        if (properties) {
          this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
          this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
          this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
          this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
          this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
        }
      };
      ParticleContainer.prototype.updateTransform = function() {
        this.displayObjectUpdateTransform();
      };
      Object.defineProperty(ParticleContainer.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value2) {
          this._tint = value2;
          hex2rgb(value2, this.tintRgb);
        },
        enumerable: false,
        configurable: true
      });
      ParticleContainer.prototype.render = function(renderer) {
        var _this = this;
        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
          return;
        }
        if (!this.baseTexture) {
          this.baseTexture = this.children[0]._texture.baseTexture;
          if (!this.baseTexture.valid) {
            this.baseTexture.once("update", function() {
              return _this.onChildrenChange(0);
            });
          }
        }
        renderer.batch.setObjectRenderer(renderer.plugins.particle);
        renderer.plugins.particle.render(this);
      };
      ParticleContainer.prototype.onChildrenChange = function(smallestChildIndex) {
        var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
        while (this._bufferUpdateIDs.length < bufferIndex) {
          this._bufferUpdateIDs.push(0);
        }
        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
      };
      ParticleContainer.prototype.dispose = function() {
        if (this._buffers) {
          for (var i = 0; i < this._buffers.length; ++i) {
            this._buffers[i].destroy();
          }
          this._buffers = null;
        }
      };
      ParticleContainer.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this.dispose();
        this._properties = null;
        this._buffers = null;
        this._bufferUpdateIDs = null;
      };
      return ParticleContainer;
    })(Container);
    var ParticleBuffer = function() {
      function ParticleBuffer2(properties, dynamicPropertyFlags, size2) {
        this.geometry = new Geometry();
        this.indexBuffer = null;
        this.size = size2;
        this.dynamicProperties = [];
        this.staticProperties = [];
        for (var i = 0; i < properties.length; ++i) {
          var property2 = properties[i];
          property2 = {
            attributeName: property2.attributeName,
            size: property2.size,
            uploadFunction: property2.uploadFunction,
            type: property2.type || TYPES$1.FLOAT,
            offset: property2.offset
          };
          if (dynamicPropertyFlags[i]) {
            this.dynamicProperties.push(property2);
          } else {
            this.staticProperties.push(property2);
          }
        }
        this.staticStride = 0;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        this.dynamicStride = 0;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this._updateID = 0;
        this.initBuffers();
      }
      ParticleBuffer2.prototype.initBuffers = function() {
        var geometry = this.geometry;
        var dynamicOffset = 0;
        this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), true, true);
        geometry.addIndex(this.indexBuffer);
        this.dynamicStride = 0;
        for (var i = 0; i < this.dynamicProperties.length; ++i) {
          var property2 = this.dynamicProperties[i];
          property2.offset = dynamicOffset;
          dynamicOffset += property2.size;
          this.dynamicStride += property2.size;
        }
        var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(dynBuffer);
        this.dynamicDataUint32 = new Uint32Array(dynBuffer);
        this.dynamicBuffer = new Buffer$1(this.dynamicData, false, false);
        var staticOffset = 0;
        this.staticStride = 0;
        for (var i = 0; i < this.staticProperties.length; ++i) {
          var property2 = this.staticProperties[i];
          property2.offset = staticOffset;
          staticOffset += property2.size;
          this.staticStride += property2.size;
        }
        var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(statBuffer);
        this.staticDataUint32 = new Uint32Array(statBuffer);
        this.staticBuffer = new Buffer$1(this.staticData, true, false);
        for (var i = 0; i < this.dynamicProperties.length; ++i) {
          var property2 = this.dynamicProperties[i];
          geometry.addAttribute(property2.attributeName, this.dynamicBuffer, 0, property2.type === TYPES$1.UNSIGNED_BYTE, property2.type, this.dynamicStride * 4, property2.offset * 4);
        }
        for (var i = 0; i < this.staticProperties.length; ++i) {
          var property2 = this.staticProperties[i];
          geometry.addAttribute(property2.attributeName, this.staticBuffer, 0, property2.type === TYPES$1.UNSIGNED_BYTE, property2.type, this.staticStride * 4, property2.offset * 4);
        }
      };
      ParticleBuffer2.prototype.uploadDynamic = function(children, startIndex, amount) {
        for (var i = 0; i < this.dynamicProperties.length; i++) {
          var property2 = this.dynamicProperties[i];
          property2.uploadFunction(children, startIndex, amount, property2.type === TYPES$1.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property2.offset);
        }
        this.dynamicBuffer._updateID++;
      };
      ParticleBuffer2.prototype.uploadStatic = function(children, startIndex, amount) {
        for (var i = 0; i < this.staticProperties.length; i++) {
          var property2 = this.staticProperties[i];
          property2.uploadFunction(children, startIndex, amount, property2.type === TYPES$1.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property2.offset);
        }
        this.staticBuffer._updateID++;
      };
      ParticleBuffer2.prototype.destroy = function() {
        this.indexBuffer = null;
        this.dynamicProperties = null;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this.staticProperties = null;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        this.geometry.destroy();
      };
      return ParticleBuffer2;
    }();
    var fragment$7 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
    var vertex$4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
    var ParticleRenderer = function(_super) {
      __extends$f(ParticleRenderer2, _super);
      function ParticleRenderer2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.shader = null;
        _this.properties = null;
        _this.tempMatrix = new Matrix();
        _this.properties = [
          {
            attributeName: "aVertexPosition",
            size: 2,
            uploadFunction: _this.uploadVertices,
            offset: 0
          },
          {
            attributeName: "aPositionCoord",
            size: 2,
            uploadFunction: _this.uploadPosition,
            offset: 0
          },
          {
            attributeName: "aRotation",
            size: 1,
            uploadFunction: _this.uploadRotation,
            offset: 0
          },
          {
            attributeName: "aTextureCoord",
            size: 2,
            uploadFunction: _this.uploadUvs,
            offset: 0
          },
          {
            attributeName: "aColor",
            size: 1,
            type: TYPES$1.UNSIGNED_BYTE,
            uploadFunction: _this.uploadTint,
            offset: 0
          }
        ];
        _this.shader = Shader.from(vertex$4, fragment$7, {});
        _this.state = State.for2d();
        return _this;
      }
      ParticleRenderer2.prototype.render = function(container) {
        var children = container.children;
        var maxSize = container._maxSize;
        var batchSize = container._batchSize;
        var renderer = this.renderer;
        var totalChildren = children.length;
        if (totalChildren === 0) {
          return;
        } else if (totalChildren > maxSize && !container.autoResize) {
          totalChildren = maxSize;
        }
        var buffers = container._buffers;
        if (!buffers) {
          buffers = container._buffers = this.generateBuffers(container);
        }
        var baseTexture = children[0]._texture.baseTexture;
        this.state.blendMode = correctBlendMode(container.blendMode, baseTexture.alphaMode);
        renderer.state.set(this.state);
        var gl = renderer.gl;
        var m2 = container.worldTransform.copyTo(this.tempMatrix);
        m2.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
        this.shader.uniforms.translationMatrix = m2.toArray(true);
        this.shader.uniforms.uColor = premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.alphaMode);
        this.shader.uniforms.uSampler = baseTexture;
        this.renderer.shader.bind(this.shader);
        var updateStatic = false;
        for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
          var amount = totalChildren - i;
          if (amount > batchSize) {
            amount = batchSize;
          }
          if (j >= buffers.length) {
            buffers.push(this._generateOneMoreBuffer(container));
          }
          var buffer = buffers[j];
          buffer.uploadDynamic(children, i, amount);
          var bid = container._bufferUpdateIDs[j] || 0;
          updateStatic = updateStatic || buffer._updateID < bid;
          if (updateStatic) {
            buffer._updateID = container._updateID;
            buffer.uploadStatic(children, i, amount);
          }
          renderer.geometry.bind(buffer.geometry);
          gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
        }
      };
      ParticleRenderer2.prototype.generateBuffers = function(container) {
        var buffers = [];
        var size2 = container._maxSize;
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        for (var i = 0; i < size2; i += batchSize) {
          buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
        }
        return buffers;
      };
      ParticleRenderer2.prototype._generateOneMoreBuffer = function(container) {
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
      };
      ParticleRenderer2.prototype.uploadVertices = function(children, startIndex, amount, array, stride, offset2) {
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        for (var i = 0; i < amount; ++i) {
          var sprite = children[startIndex + i];
          var texture = sprite._texture;
          var sx = sprite.scale.x;
          var sy = sprite.scale.y;
          var trim2 = texture.trim;
          var orig = texture.orig;
          if (trim2) {
            w1 = trim2.x - sprite.anchor.x * orig.width;
            w0 = w1 + trim2.width;
            h1 = trim2.y - sprite.anchor.y * orig.height;
            h0 = h1 + trim2.height;
          } else {
            w0 = orig.width * (1 - sprite.anchor.x);
            w1 = orig.width * -sprite.anchor.x;
            h0 = orig.height * (1 - sprite.anchor.y);
            h1 = orig.height * -sprite.anchor.y;
          }
          array[offset2] = w1 * sx;
          array[offset2 + 1] = h1 * sy;
          array[offset2 + stride] = w0 * sx;
          array[offset2 + stride + 1] = h1 * sy;
          array[offset2 + stride * 2] = w0 * sx;
          array[offset2 + stride * 2 + 1] = h0 * sy;
          array[offset2 + stride * 3] = w1 * sx;
          array[offset2 + stride * 3 + 1] = h0 * sy;
          offset2 += stride * 4;
        }
      };
      ParticleRenderer2.prototype.uploadPosition = function(children, startIndex, amount, array, stride, offset2) {
        for (var i = 0; i < amount; i++) {
          var spritePosition = children[startIndex + i].position;
          array[offset2] = spritePosition.x;
          array[offset2 + 1] = spritePosition.y;
          array[offset2 + stride] = spritePosition.x;
          array[offset2 + stride + 1] = spritePosition.y;
          array[offset2 + stride * 2] = spritePosition.x;
          array[offset2 + stride * 2 + 1] = spritePosition.y;
          array[offset2 + stride * 3] = spritePosition.x;
          array[offset2 + stride * 3 + 1] = spritePosition.y;
          offset2 += stride * 4;
        }
      };
      ParticleRenderer2.prototype.uploadRotation = function(children, startIndex, amount, array, stride, offset2) {
        for (var i = 0; i < amount; i++) {
          var spriteRotation = children[startIndex + i].rotation;
          array[offset2] = spriteRotation;
          array[offset2 + stride] = spriteRotation;
          array[offset2 + stride * 2] = spriteRotation;
          array[offset2 + stride * 3] = spriteRotation;
          offset2 += stride * 4;
        }
      };
      ParticleRenderer2.prototype.uploadUvs = function(children, startIndex, amount, array, stride, offset2) {
        for (var i = 0; i < amount; ++i) {
          var textureUvs = children[startIndex + i]._texture._uvs;
          if (textureUvs) {
            array[offset2] = textureUvs.x0;
            array[offset2 + 1] = textureUvs.y0;
            array[offset2 + stride] = textureUvs.x1;
            array[offset2 + stride + 1] = textureUvs.y1;
            array[offset2 + stride * 2] = textureUvs.x2;
            array[offset2 + stride * 2 + 1] = textureUvs.y2;
            array[offset2 + stride * 3] = textureUvs.x3;
            array[offset2 + stride * 3 + 1] = textureUvs.y3;
            offset2 += stride * 4;
          } else {
            array[offset2] = 0;
            array[offset2 + 1] = 0;
            array[offset2 + stride] = 0;
            array[offset2 + stride + 1] = 0;
            array[offset2 + stride * 2] = 0;
            array[offset2 + stride * 2 + 1] = 0;
            array[offset2 + stride * 3] = 0;
            array[offset2 + stride * 3 + 1] = 0;
            offset2 += stride * 4;
          }
        }
      };
      ParticleRenderer2.prototype.uploadTint = function(children, startIndex, amount, array, stride, offset2) {
        for (var i = 0; i < amount; ++i) {
          var sprite = children[startIndex + i];
          var premultiplied = sprite._texture.baseTexture.alphaMode > 0;
          var alpha = sprite.alpha;
          var argb = alpha < 1 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);
          array[offset2] = argb;
          array[offset2 + stride] = argb;
          array[offset2 + stride * 2] = argb;
          array[offset2 + stride * 3] = argb;
          offset2 += stride * 4;
        }
      };
      ParticleRenderer2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        if (this.shader) {
          this.shader.destroy();
          this.shader = null;
        }
        this.tempMatrix = null;
      };
      return ParticleRenderer2;
    }(ObjectRenderer);
    /*!
     * @pixi/graphics - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/graphics is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var LINE_JOIN;
    (function(LINE_JOIN2) {
      LINE_JOIN2["MITER"] = "miter";
      LINE_JOIN2["BEVEL"] = "bevel";
      LINE_JOIN2["ROUND"] = "round";
    })(LINE_JOIN || (LINE_JOIN = {}));
    var LINE_CAP;
    (function(LINE_CAP2) {
      LINE_CAP2["BUTT"] = "butt";
      LINE_CAP2["ROUND"] = "round";
      LINE_CAP2["SQUARE"] = "square";
    })(LINE_CAP || (LINE_CAP = {}));
    var GRAPHICS_CURVES = {
      adaptive: true,
      maxLength: 10,
      minSegments: 8,
      maxSegments: 2048,
      epsilon: 1e-4,
      _segmentsCount: function(length, defaultSegments) {
        if (defaultSegments === void 0) {
          defaultSegments = 20;
        }
        if (!this.adaptive || !length || isNaN(length)) {
          return defaultSegments;
        }
        var result2 = Math.ceil(length / this.maxLength);
        if (result2 < this.minSegments) {
          result2 = this.minSegments;
        } else if (result2 > this.maxSegments) {
          result2 = this.maxSegments;
        }
        return result2;
      }
    };
    var FillStyle = function() {
      function FillStyle2() {
        this.color = 16777215;
        this.alpha = 1;
        this.texture = Texture.WHITE;
        this.matrix = null;
        this.visible = false;
        this.reset();
      }
      FillStyle2.prototype.clone = function() {
        var obj = new FillStyle2();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        return obj;
      };
      FillStyle2.prototype.reset = function() {
        this.color = 16777215;
        this.alpha = 1;
        this.texture = Texture.WHITE;
        this.matrix = null;
        this.visible = false;
      };
      FillStyle2.prototype.destroy = function() {
        this.texture = null;
        this.matrix = null;
      };
      return FillStyle2;
    }();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$e = function(d, b) {
      extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$e(d, b);
    };
    function __extends$e(d, b) {
      extendStatics$e(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var buildPoly = {
      build: function(graphicsData) {
        graphicsData.points = graphicsData.shape.points.slice();
      },
      triangulate: function(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var holes = graphicsData.holes;
        var verts = graphicsGeometry.points;
        var indices2 = graphicsGeometry.indices;
        if (points.length >= 6) {
          var holeArray = [];
          for (var i = 0; i < holes.length; i++) {
            var hole = holes[i];
            holeArray.push(points.length / 2);
            points = points.concat(hole.points);
          }
          var triangles = earcut$1.exports(points, holeArray, 2);
          if (!triangles) {
            return;
          }
          var vertPos = verts.length / 2;
          for (var i = 0; i < triangles.length; i += 3) {
            indices2.push(triangles[i] + vertPos);
            indices2.push(triangles[i + 1] + vertPos);
            indices2.push(triangles[i + 2] + vertPos);
          }
          for (var i = 0; i < points.length; i++) {
            verts.push(points[i]);
          }
        }
      }
    };
    var buildCircle = {
      build: function(graphicsData) {
        var circleData = graphicsData.shape;
        var points = graphicsData.points;
        var x2 = circleData.x;
        var y2 = circleData.y;
        var width2;
        var height2;
        points.length = 0;
        if (graphicsData.type === SHAPES.CIRC) {
          width2 = circleData.radius;
          height2 = circleData.radius;
        } else {
          var ellipseData = graphicsData.shape;
          width2 = ellipseData.width;
          height2 = ellipseData.height;
        }
        if (width2 === 0 || height2 === 0) {
          return;
        }
        var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(width2 + height2));
        totalSegs /= 2.3;
        var seg = Math.PI * 2 / totalSegs;
        for (var i = 0; i < totalSegs - 0.5; i++) {
          points.push(x2 + Math.sin(-seg * i) * width2, y2 + Math.cos(-seg * i) * height2);
        }
        points.push(points[0], points[1]);
      },
      triangulate: function(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices2 = graphicsGeometry.indices;
        var vertPos = verts.length / 2;
        var center = vertPos;
        var circle = graphicsData.shape;
        var matrix = graphicsData.matrix;
        var x2 = circle.x;
        var y2 = circle.y;
        verts.push(graphicsData.matrix ? matrix.a * x2 + matrix.c * y2 + matrix.tx : x2, graphicsData.matrix ? matrix.b * x2 + matrix.d * y2 + matrix.ty : y2);
        for (var i = 0; i < points.length; i += 2) {
          verts.push(points[i], points[i + 1]);
          indices2.push(vertPos++, center, vertPos);
        }
      }
    };
    var buildRectangle = {
      build: function(graphicsData) {
        var rectData = graphicsData.shape;
        var x2 = rectData.x;
        var y2 = rectData.y;
        var width2 = rectData.width;
        var height2 = rectData.height;
        var points = graphicsData.points;
        points.length = 0;
        points.push(x2, y2, x2 + width2, y2, x2 + width2, y2 + height2, x2, y2 + height2);
      },
      triangulate: function(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var vertPos = verts.length / 2;
        verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
      }
    };
    function getPt(n1, n2, perc) {
      var diff2 = n2 - n1;
      return n1 + diff2 * perc;
    }
    function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
      if (out === void 0) {
        out = [];
      }
      var n2 = 20;
      var points = out;
      var xa2 = 0;
      var ya2 = 0;
      var xb2 = 0;
      var yb2 = 0;
      var x2 = 0;
      var y2 = 0;
      for (var i = 0, j = 0; i <= n2; ++i) {
        j = i / n2;
        xa2 = getPt(fromX, cpX, j);
        ya2 = getPt(fromY, cpY, j);
        xb2 = getPt(cpX, toX, j);
        yb2 = getPt(cpY, toY, j);
        x2 = getPt(xa2, xb2, j);
        y2 = getPt(ya2, yb2, j);
        points.push(x2, y2);
      }
      return points;
    }
    var buildRoundedRectangle = {
      build: function(graphicsData) {
        var rrectData = graphicsData.shape;
        var points = graphicsData.points;
        var x2 = rrectData.x;
        var y2 = rrectData.y;
        var width2 = rrectData.width;
        var height2 = rrectData.height;
        var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width2, height2) / 2));
        points.length = 0;
        if (!radius) {
          points.push(x2, y2, x2 + width2, y2, x2 + width2, y2 + height2, x2, y2 + height2);
        } else {
          quadraticBezierCurve(x2, y2 + radius, x2, y2, x2 + radius, y2, points);
          quadraticBezierCurve(x2 + width2 - radius, y2, x2 + width2, y2, x2 + width2, y2 + radius, points);
          quadraticBezierCurve(x2 + width2, y2 + height2 - radius, x2 + width2, y2 + height2, x2 + width2 - radius, y2 + height2, points);
          quadraticBezierCurve(x2 + radius, y2 + height2, x2, y2 + height2, x2, y2 + height2 - radius, points);
        }
      },
      triangulate: function(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices2 = graphicsGeometry.indices;
        var vecPos = verts.length / 2;
        var triangles = earcut$1.exports(points, null, 2);
        for (var i = 0, j = triangles.length; i < j; i += 3) {
          indices2.push(triangles[i] + vecPos);
          indices2.push(triangles[i + 1] + vecPos);
          indices2.push(triangles[i + 2] + vecPos);
        }
        for (var i = 0, j = points.length; i < j; i++) {
          verts.push(points[i], points[++i]);
        }
      }
    };
    function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
      var ix = x2 - nx * innerWeight;
      var iy = y2 - ny * innerWeight;
      var ox = x2 + nx * outerWeight;
      var oy = y2 + ny * outerWeight;
      var exx;
      var eyy;
      if (clockwise) {
        exx = ny;
        eyy = -nx;
      } else {
        exx = -ny;
        eyy = nx;
      }
      var eix = ix + exx;
      var eiy = iy + eyy;
      var eox = ox + exx;
      var eoy = oy + eyy;
      verts.push(eix, eiy);
      verts.push(eox, eoy);
      return 2;
    }
    function round$1(cx, cy, sx, sy, ex, ey, verts, clockwise) {
      var cx2p0x = sx - cx;
      var cy2p0y = sy - cy;
      var angle0 = Math.atan2(cx2p0x, cy2p0y);
      var angle1 = Math.atan2(ex - cx, ey - cy);
      if (clockwise && angle0 < angle1) {
        angle0 += Math.PI * 2;
      } else if (!clockwise && angle0 > angle1) {
        angle1 += Math.PI * 2;
      }
      var startAngle = angle0;
      var angleDiff = angle1 - angle0;
      var absAngleDiff = Math.abs(angleDiff);
      var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
      var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
      var angleInc = angleDiff / segCount;
      startAngle += angleInc;
      if (clockwise) {
        verts.push(cx, cy);
        verts.push(sx, sy);
        for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
          verts.push(cx, cy);
          verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
        }
        verts.push(cx, cy);
        verts.push(ex, ey);
      } else {
        verts.push(sx, sy);
        verts.push(cx, cy);
        for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
          verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
          verts.push(cx, cy);
        }
        verts.push(ex, ey);
        verts.push(cx, cy);
      }
      return segCount * 2;
    }
    function buildNonNativeLine(graphicsData, graphicsGeometry) {
      var shape = graphicsData.shape;
      var points = graphicsData.points || shape.points.slice();
      var eps = graphicsGeometry.closePointEps;
      if (points.length === 0) {
        return;
      }
      var style = graphicsData.lineStyle;
      var firstPoint = new Point(points[0], points[1]);
      var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
      var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
      var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
      if (closedShape) {
        points = points.slice();
        if (closedPath) {
          points.pop();
          points.pop();
          lastPoint.set(points[points.length - 2], points[points.length - 1]);
        }
        var midPointX = (firstPoint.x + lastPoint.x) * 0.5;
        var midPointY = (lastPoint.y + firstPoint.y) * 0.5;
        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
      }
      var verts = graphicsGeometry.points;
      var length = points.length / 2;
      var indexCount = points.length;
      var indexStart = verts.length / 2;
      var width2 = style.width / 2;
      var widthSquared = width2 * width2;
      var miterLimitSquared = style.miterLimit * style.miterLimit;
      var x0 = points[0];
      var y0 = points[1];
      var x1 = points[2];
      var y1 = points[3];
      var x2 = 0;
      var y2 = 0;
      var perpx = -(y0 - y1);
      var perpy = x0 - x1;
      var perp1x = 0;
      var perp1y = 0;
      var dist = Math.sqrt(perpx * perpx + perpy * perpy);
      perpx /= dist;
      perpy /= dist;
      perpx *= width2;
      perpy *= width2;
      var ratio = style.alignment;
      var innerWeight = (1 - ratio) * 2;
      var outerWeight = ratio * 2;
      if (!closedShape) {
        if (style.cap === LINE_CAP.ROUND) {
          indexCount += round$1(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
        } else if (style.cap === LINE_CAP.SQUARE) {
          indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
        }
      }
      verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);
      verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);
      for (var i = 1; i < length - 1; ++i) {
        x0 = points[(i - 1) * 2];
        y0 = points[(i - 1) * 2 + 1];
        x1 = points[i * 2];
        y1 = points[i * 2 + 1];
        x2 = points[(i + 1) * 2];
        y2 = points[(i + 1) * 2 + 1];
        perpx = -(y0 - y1);
        perpy = x0 - x1;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width2;
        perpy *= width2;
        perp1x = -(y1 - y2);
        perp1y = x1 - x2;
        dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
        perp1x /= dist;
        perp1y /= dist;
        perp1x *= width2;
        perp1y *= width2;
        var dx0 = x1 - x0;
        var dy0 = y0 - y1;
        var dx1 = x1 - x2;
        var dy1 = y2 - y1;
        var cross = dy0 * dx1 - dy1 * dx0;
        var clockwise = cross < 0;
        if (Math.abs(cross) < 0.1) {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          continue;
        }
        var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
        var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
        var px = (dx0 * c2 - dx1 * c1) / cross;
        var py = (dy1 * c1 - dy0 * c2) / cross;
        var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
        var imx = x1 + (px - x1) * innerWeight;
        var imy = y1 + (py - y1) * innerWeight;
        var omx = x1 - (px - x1) * outerWeight;
        var omy = y1 - (py - y1) * outerWeight;
        if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
            verts.push(omx, omy);
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
          indexCount += 2;
        } else if (style.join === LINE_JOIN.ROUND) {
          if (clockwise) {
            verts.push(imx, imy);
            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            indexCount += round$1(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy);
            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
            verts.push(omx, omy);
            indexCount += round$1(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
            verts.push(omx, omy);
          }
        } else {
          verts.push(imx, imy);
          verts.push(omx, omy);
        }
      }
      x0 = points[(length - 2) * 2];
      y0 = points[(length - 2) * 2 + 1];
      x1 = points[(length - 1) * 2];
      y1 = points[(length - 1) * 2 + 1];
      perpx = -(y0 - y1);
      perpy = x0 - x1;
      dist = Math.sqrt(perpx * perpx + perpy * perpy);
      perpx /= dist;
      perpy /= dist;
      perpx *= width2;
      perpy *= width2;
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (!closedShape) {
        if (style.cap === LINE_CAP.ROUND) {
          indexCount += round$1(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
        } else if (style.cap === LINE_CAP.SQUARE) {
          indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
        }
      }
      var indices2 = graphicsGeometry.indices;
      var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;
      for (var i = indexStart; i < indexCount + indexStart - 2; ++i) {
        x0 = verts[i * 2];
        y0 = verts[i * 2 + 1];
        x1 = verts[(i + 1) * 2];
        y1 = verts[(i + 1) * 2 + 1];
        x2 = verts[(i + 2) * 2];
        y2 = verts[(i + 2) * 2 + 1];
        if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
          continue;
        }
        indices2.push(i, i + 1, i + 2);
      }
    }
    function buildNativeLine(graphicsData, graphicsGeometry) {
      var i = 0;
      var shape = graphicsData.shape;
      var points = graphicsData.points || shape.points;
      var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
      if (points.length === 0) {
        return;
      }
      var verts = graphicsGeometry.points;
      var indices2 = graphicsGeometry.indices;
      var length = points.length / 2;
      var startIndex = verts.length / 2;
      var currentIndex = startIndex;
      verts.push(points[0], points[1]);
      for (i = 1; i < length; i++) {
        verts.push(points[i * 2], points[i * 2 + 1]);
        indices2.push(currentIndex, currentIndex + 1);
        currentIndex++;
      }
      if (closedShape) {
        indices2.push(currentIndex, startIndex);
      }
    }
    function buildLine(graphicsData, graphicsGeometry) {
      if (graphicsData.lineStyle.native) {
        buildNativeLine(graphicsData, graphicsGeometry);
      } else {
        buildNonNativeLine(graphicsData, graphicsGeometry);
      }
    }
    var Star = function(_super) {
      __extends$e(Star2, _super);
      function Star2(x2, y2, points, radius, innerRadius, rotation) {
        if (rotation === void 0) {
          rotation = 0;
        }
        var _this = this;
        innerRadius = innerRadius || radius / 2;
        var startAngle = -1 * Math.PI / 2 + rotation;
        var len = points * 2;
        var delta = PI_2 / len;
        var polygon = [];
        for (var i = 0; i < len; i++) {
          var r2 = i % 2 ? innerRadius : radius;
          var angle = i * delta + startAngle;
          polygon.push(x2 + r2 * Math.cos(angle), y2 + r2 * Math.sin(angle));
        }
        _this = _super.call(this, polygon) || this;
        return _this;
      }
      return Star2;
    }(Polygon);
    var ArcUtils = function() {
      function ArcUtils2() {
      }
      ArcUtils2.curveTo = function(x1, y1, x2, y2, radius, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var a1 = fromY - y1;
        var b1 = fromX - x1;
        var a2 = y2 - y1;
        var b2 = x2 - x1;
        var mm = Math.abs(a1 * b2 - b1 * a2);
        if (mm < 1e-8 || radius === 0) {
          if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
            points.push(x1, y1);
          }
          return null;
        }
        var dd2 = a1 * a1 + b1 * b1;
        var cc2 = a2 * a2 + b2 * b2;
        var tt = a1 * a2 + b1 * b2;
        var k1 = radius * Math.sqrt(dd2) / mm;
        var k2 = radius * Math.sqrt(cc2) / mm;
        var j1 = k1 * tt / dd2;
        var j2 = k2 * tt / cc2;
        var cx = k1 * b2 + k2 * b1;
        var cy = k1 * a2 + k2 * a1;
        var px = b1 * (k2 + j1);
        var py = a1 * (k2 + j1);
        var qx = b2 * (k1 + j2);
        var qy = a2 * (k1 + j2);
        var startAngle = Math.atan2(py - cy, px - cx);
        var endAngle = Math.atan2(qy - cy, qx - cx);
        return {
          cx: cx + x1,
          cy: cy + y1,
          radius,
          startAngle,
          endAngle,
          anticlockwise: b1 * a2 > b2 * a1
        };
      };
      ArcUtils2.arc = function(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
        var sweep = endAngle - startAngle;
        var n2 = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
        var theta = sweep / (n2 * 2);
        var theta2 = theta * 2;
        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);
        var segMinus = n2 - 1;
        var remainder = segMinus % 1 / segMinus;
        for (var i = 0; i <= segMinus; ++i) {
          var real = i + remainder * i;
          var angle = theta + startAngle + theta2 * real;
          var c = Math.cos(angle);
          var s = -Math.sin(angle);
          points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
        }
      };
      return ArcUtils2;
    }();
    var BezierUtils = function() {
      function BezierUtils2() {
      }
      BezierUtils2.curveLength = function(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
        var n2 = 10;
        var result2 = 0;
        var t2 = 0;
        var t22 = 0;
        var t3 = 0;
        var nt = 0;
        var nt2 = 0;
        var nt3 = 0;
        var x2 = 0;
        var y2 = 0;
        var dx = 0;
        var dy = 0;
        var prevX = fromX;
        var prevY = fromY;
        for (var i = 1; i <= n2; ++i) {
          t2 = i / n2;
          t22 = t2 * t2;
          t3 = t22 * t2;
          nt = 1 - t2;
          nt2 = nt * nt;
          nt3 = nt2 * nt;
          x2 = nt3 * fromX + 3 * nt2 * t2 * cpX + 3 * nt * t22 * cpX2 + t3 * toX;
          y2 = nt3 * fromY + 3 * nt2 * t2 * cpY + 3 * nt * t22 * cpY2 + t3 * toY;
          dx = prevX - x2;
          dy = prevY - y2;
          prevX = x2;
          prevY = y2;
          result2 += Math.sqrt(dx * dx + dy * dy);
        }
        return result2;
      };
      BezierUtils2.curveTo = function(cpX, cpY, cpX2, cpY2, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        points.length -= 2;
        var n2 = GRAPHICS_CURVES._segmentsCount(BezierUtils2.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
        var dt = 0;
        var dt2 = 0;
        var dt3 = 0;
        var t2 = 0;
        var t3 = 0;
        points.push(fromX, fromY);
        for (var i = 1, j = 0; i <= n2; ++i) {
          j = i / n2;
          dt = 1 - j;
          dt2 = dt * dt;
          dt3 = dt2 * dt;
          t2 = j * j;
          t3 = t2 * j;
          points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        }
      };
      return BezierUtils2;
    }();
    var QuadraticUtils = function() {
      function QuadraticUtils2() {
      }
      QuadraticUtils2.curveLength = function(fromX, fromY, cpX, cpY, toX, toY) {
        var ax = fromX - 2 * cpX + toX;
        var ay = fromY - 2 * cpY + toY;
        var bx = 2 * cpX - 2 * fromX;
        var by = 2 * cpY - 2 * fromY;
        var a = 4 * (ax * ax + ay * ay);
        var b = 4 * (ax * bx + ay * by);
        var c = bx * bx + by * by;
        var s = 2 * Math.sqrt(a + b + c);
        var a2 = Math.sqrt(a);
        var a32 = 2 * a * a2;
        var c2 = 2 * Math.sqrt(c);
        var ba2 = b / a2;
        return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba2 + s) / (ba2 + c2))) / (4 * a32);
      };
      QuadraticUtils2.curveTo = function(cpX, cpY, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var n2 = GRAPHICS_CURVES._segmentsCount(QuadraticUtils2.curveLength(fromX, fromY, cpX, cpY, toX, toY));
        var xa2 = 0;
        var ya2 = 0;
        for (var i = 1; i <= n2; ++i) {
          var j = i / n2;
          xa2 = fromX + (cpX - fromX) * j;
          ya2 = fromY + (cpY - fromY) * j;
          points.push(xa2 + (cpX + (toX - cpX) * j - xa2) * j, ya2 + (cpY + (toY - cpY) * j - ya2) * j);
        }
      };
      return QuadraticUtils2;
    }();
    var BatchPart = function() {
      function BatchPart2() {
        this.reset();
      }
      BatchPart2.prototype.begin = function(style, startIndex, attribStart) {
        this.reset();
        this.style = style;
        this.start = startIndex;
        this.attribStart = attribStart;
      };
      BatchPart2.prototype.end = function(endIndex, endAttrib) {
        this.attribSize = endAttrib - this.attribStart;
        this.size = endIndex - this.start;
      };
      BatchPart2.prototype.reset = function() {
        this.style = null;
        this.size = 0;
        this.start = 0;
        this.attribStart = 0;
        this.attribSize = 0;
      };
      return BatchPart2;
    }();
    var _a;
    var FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);
    var BATCH_POOL = [];
    var DRAW_CALL_POOL = [];
    var GraphicsData = function() {
      function GraphicsData2(shape, fillStyle, lineStyle, matrix) {
        if (fillStyle === void 0) {
          fillStyle = null;
        }
        if (lineStyle === void 0) {
          lineStyle = null;
        }
        if (matrix === void 0) {
          matrix = null;
        }
        this.shape = shape;
        this.lineStyle = lineStyle;
        this.fillStyle = fillStyle;
        this.matrix = matrix;
        this.type = shape.type;
        this.points = [];
        this.holes = [];
      }
      GraphicsData2.prototype.clone = function() {
        return new GraphicsData2(this.shape, this.fillStyle, this.lineStyle, this.matrix);
      };
      GraphicsData2.prototype.destroy = function() {
        this.shape = null;
        this.holes.length = 0;
        this.holes = null;
        this.points.length = 0;
        this.points = null;
        this.lineStyle = null;
        this.fillStyle = null;
      };
      return GraphicsData2;
    }();
    var tmpPoint = new Point();
    var tmpBounds = new Bounds();
    var GraphicsGeometry = function(_super) {
      __extends$e(GraphicsGeometry2, _super);
      function GraphicsGeometry2() {
        var _this = _super.call(this) || this;
        _this.uvsFloat32 = null;
        _this.indicesUint16 = null;
        _this.points = [];
        _this.colors = [];
        _this.uvs = [];
        _this.indices = [];
        _this.textureIds = [];
        _this.graphicsData = [];
        _this.dirty = 0;
        _this.batchDirty = -1;
        _this.cacheDirty = -1;
        _this.clearDirty = 0;
        _this.drawCalls = [];
        _this.batches = [];
        _this.shapeIndex = 0;
        _this._bounds = new Bounds();
        _this.boundsDirty = -1;
        _this.boundsPadding = 0;
        _this.batchable = false;
        _this.indicesUint16 = null;
        _this.uvsFloat32 = null;
        _this.closePointEps = 1e-4;
        return _this;
      }
      Object.defineProperty(GraphicsGeometry2.prototype, "bounds", {
        get: function() {
          if (this.boundsDirty !== this.dirty) {
            this.boundsDirty = this.dirty;
            this.calculateBounds();
          }
          return this._bounds;
        },
        enumerable: false,
        configurable: true
      });
      GraphicsGeometry2.prototype.invalidate = function() {
        this.boundsDirty = -1;
        this.dirty++;
        this.batchDirty++;
        this.shapeIndex = 0;
        this.points.length = 0;
        this.colors.length = 0;
        this.uvs.length = 0;
        this.indices.length = 0;
        this.textureIds.length = 0;
        for (var i = 0; i < this.drawCalls.length; i++) {
          this.drawCalls[i].texArray.clear();
          DRAW_CALL_POOL.push(this.drawCalls[i]);
        }
        this.drawCalls.length = 0;
        for (var i = 0; i < this.batches.length; i++) {
          var batchPart = this.batches[i];
          batchPart.reset();
          BATCH_POOL.push(batchPart);
        }
        this.batches.length = 0;
      };
      GraphicsGeometry2.prototype.clear = function() {
        if (this.graphicsData.length > 0) {
          this.invalidate();
          this.clearDirty++;
          this.graphicsData.length = 0;
        }
        return this;
      };
      GraphicsGeometry2.prototype.drawShape = function(shape, fillStyle, lineStyle, matrix) {
        if (fillStyle === void 0) {
          fillStyle = null;
        }
        if (lineStyle === void 0) {
          lineStyle = null;
        }
        if (matrix === void 0) {
          matrix = null;
        }
        var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
        this.graphicsData.push(data);
        this.dirty++;
        return this;
      };
      GraphicsGeometry2.prototype.drawHole = function(shape, matrix) {
        if (matrix === void 0) {
          matrix = null;
        }
        if (!this.graphicsData.length) {
          return null;
        }
        var data = new GraphicsData(shape, null, null, matrix);
        var lastShape = this.graphicsData[this.graphicsData.length - 1];
        data.lineStyle = lastShape.lineStyle;
        lastShape.holes.push(data);
        this.dirty++;
        return this;
      };
      GraphicsGeometry2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        for (var i = 0; i < this.graphicsData.length; ++i) {
          this.graphicsData[i].destroy();
        }
        this.points.length = 0;
        this.points = null;
        this.colors.length = 0;
        this.colors = null;
        this.uvs.length = 0;
        this.uvs = null;
        this.indices.length = 0;
        this.indices = null;
        this.indexBuffer.destroy();
        this.indexBuffer = null;
        this.graphicsData.length = 0;
        this.graphicsData = null;
        this.drawCalls.length = 0;
        this.drawCalls = null;
        this.batches.length = 0;
        this.batches = null;
        this._bounds = null;
      };
      GraphicsGeometry2.prototype.containsPoint = function(point) {
        var graphicsData = this.graphicsData;
        for (var i = 0; i < graphicsData.length; ++i) {
          var data = graphicsData[i];
          if (!data.fillStyle.visible) {
            continue;
          }
          if (data.shape) {
            if (data.matrix) {
              data.matrix.applyInverse(point, tmpPoint);
            } else {
              tmpPoint.copyFrom(point);
            }
            if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
              var hitHole = false;
              if (data.holes) {
                for (var i_1 = 0; i_1 < data.holes.length; i_1++) {
                  var hole = data.holes[i_1];
                  if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                    hitHole = true;
                    break;
                  }
                }
              }
              if (!hitHole) {
                return true;
              }
            }
          }
        }
        return false;
      };
      GraphicsGeometry2.prototype.updateBatches = function(allow32Indices) {
        if (!this.graphicsData.length) {
          this.batchable = true;
          return;
        }
        if (!this.validateBatching()) {
          return;
        }
        this.cacheDirty = this.dirty;
        var uvs = this.uvs;
        var graphicsData = this.graphicsData;
        var batchPart = null;
        var currentStyle = null;
        if (this.batches.length > 0) {
          batchPart = this.batches[this.batches.length - 1];
          currentStyle = batchPart.style;
        }
        for (var i = this.shapeIndex; i < graphicsData.length; i++) {
          this.shapeIndex++;
          var data = graphicsData[i];
          var fillStyle = data.fillStyle;
          var lineStyle = data.lineStyle;
          var command = FILL_COMMANDS[data.type];
          command.build(data);
          if (data.matrix) {
            this.transformPoints(data.points, data.matrix);
          }
          for (var j = 0; j < 2; j++) {
            var style = j === 0 ? fillStyle : lineStyle;
            if (!style.visible) {
              continue;
            }
            var nextTexture = style.texture.baseTexture;
            var index_1 = this.indices.length;
            var attribIndex = this.points.length / 2;
            nextTexture.wrapMode = WRAP_MODES$1.REPEAT;
            if (j === 0) {
              this.processFill(data);
            } else {
              this.processLine(data);
            }
            var size2 = this.points.length / 2 - attribIndex;
            if (size2 === 0) {
              continue;
            }
            if (batchPart && !this._compareStyles(currentStyle, style)) {
              batchPart.end(index_1, attribIndex);
              batchPart = null;
            }
            if (!batchPart) {
              batchPart = BATCH_POOL.pop() || new BatchPart();
              batchPart.begin(style, index_1, attribIndex);
              this.batches.push(batchPart);
              currentStyle = style;
            }
            this.addUvs(this.points, uvs, style.texture, attribIndex, size2, style.matrix);
          }
        }
        var index2 = this.indices.length;
        var attrib = this.points.length / 2;
        if (batchPart) {
          batchPart.end(index2, attrib);
        }
        if (this.batches.length === 0) {
          this.batchable = true;
          return;
        }
        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) {
          this.indicesUint16.set(this.indices);
        } else {
          var need32 = attrib > 65535 && allow32Indices;
          this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
        }
        this.batchable = this.isBatchable();
        if (this.batchable) {
          this.packBatches();
        } else {
          this.buildDrawCalls();
        }
      };
      GraphicsGeometry2.prototype._compareStyles = function(styleA, styleB) {
        if (!styleA || !styleB) {
          return false;
        }
        if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
          return false;
        }
        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
          return false;
        }
        if (!!styleA.native !== !!styleB.native) {
          return false;
        }
        return true;
      };
      GraphicsGeometry2.prototype.validateBatching = function() {
        if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
          return false;
        }
        for (var i = 0, l2 = this.graphicsData.length; i < l2; i++) {
          var data = this.graphicsData[i];
          var fill = data.fillStyle;
          var line = data.lineStyle;
          if (fill && !fill.texture.baseTexture.valid) {
            return false;
          }
          if (line && !line.texture.baseTexture.valid) {
            return false;
          }
        }
        return true;
      };
      GraphicsGeometry2.prototype.packBatches = function() {
        this.batchDirty++;
        this.uvsFloat32 = new Float32Array(this.uvs);
        var batches = this.batches;
        for (var i = 0, l2 = batches.length; i < l2; i++) {
          var batch = batches[i];
          for (var j = 0; j < batch.size; j++) {
            var index2 = batch.start + j;
            this.indicesUint16[index2] = this.indicesUint16[index2] - batch.attribStart;
          }
        }
      };
      GraphicsGeometry2.prototype.isBatchable = function() {
        if (this.points.length > 65535 * 2) {
          return false;
        }
        var batches = this.batches;
        for (var i = 0; i < batches.length; i++) {
          if (batches[i].style.native) {
            return false;
          }
        }
        return this.points.length < GraphicsGeometry2.BATCHABLE_SIZE * 2;
      };
      GraphicsGeometry2.prototype.buildDrawCalls = function() {
        var TICK = ++BaseTexture._globalBatch;
        for (var i = 0; i < this.drawCalls.length; i++) {
          this.drawCalls[i].texArray.clear();
          DRAW_CALL_POOL.push(this.drawCalls[i]);
        }
        this.drawCalls.length = 0;
        var colors = this.colors;
        var textureIds = this.textureIds;
        var currentGroup = DRAW_CALL_POOL.pop();
        if (!currentGroup) {
          currentGroup = new BatchDrawCall();
          currentGroup.texArray = new BatchTextureArray();
        }
        currentGroup.texArray.count = 0;
        currentGroup.start = 0;
        currentGroup.size = 0;
        currentGroup.type = DRAW_MODES$1.TRIANGLES;
        var textureCount = 0;
        var currentTexture = null;
        var textureId = 0;
        var native = false;
        var drawMode = DRAW_MODES$1.TRIANGLES;
        var index2 = 0;
        this.drawCalls.push(currentGroup);
        for (var i = 0; i < this.batches.length; i++) {
          var data = this.batches[i];
          var MAX_TEXTURES = 8;
          var style = data.style;
          var nextTexture = style.texture.baseTexture;
          if (native !== !!style.native) {
            native = !!style.native;
            drawMode = native ? DRAW_MODES$1.LINES : DRAW_MODES$1.TRIANGLES;
            currentTexture = null;
            textureCount = MAX_TEXTURES;
            TICK++;
          }
          if (currentTexture !== nextTexture) {
            currentTexture = nextTexture;
            if (nextTexture._batchEnabled !== TICK) {
              if (textureCount === MAX_TEXTURES) {
                TICK++;
                textureCount = 0;
                if (currentGroup.size > 0) {
                  currentGroup = DRAW_CALL_POOL.pop();
                  if (!currentGroup) {
                    currentGroup = new BatchDrawCall();
                    currentGroup.texArray = new BatchTextureArray();
                  }
                  this.drawCalls.push(currentGroup);
                }
                currentGroup.start = index2;
                currentGroup.size = 0;
                currentGroup.texArray.count = 0;
                currentGroup.type = drawMode;
              }
              nextTexture.touched = 1;
              nextTexture._batchEnabled = TICK;
              nextTexture._batchLocation = textureCount;
              nextTexture.wrapMode = 10497;
              currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
              textureCount++;
            }
          }
          currentGroup.size += data.size;
          index2 += data.size;
          textureId = nextTexture._batchLocation;
          this.addColors(colors, style.color, style.alpha, data.attribSize);
          this.addTextureIds(textureIds, textureId, data.attribSize);
        }
        BaseTexture._globalBatch = TICK;
        this.packAttributes();
      };
      GraphicsGeometry2.prototype.packAttributes = function() {
        var verts = this.points;
        var uvs = this.uvs;
        var colors = this.colors;
        var textureIds = this.textureIds;
        var glPoints = new ArrayBuffer(verts.length * 3 * 4);
        var f32 = new Float32Array(glPoints);
        var u32 = new Uint32Array(glPoints);
        var p2 = 0;
        for (var i = 0; i < verts.length / 2; i++) {
          f32[p2++] = verts[i * 2];
          f32[p2++] = verts[i * 2 + 1];
          f32[p2++] = uvs[i * 2];
          f32[p2++] = uvs[i * 2 + 1];
          u32[p2++] = colors[i];
          f32[p2++] = textureIds[i];
        }
        this._buffer.update(glPoints);
        this._indexBuffer.update(this.indicesUint16);
      };
      GraphicsGeometry2.prototype.processFill = function(data) {
        if (data.holes.length) {
          this.processHoles(data.holes);
          buildPoly.triangulate(data, this);
        } else {
          var command = FILL_COMMANDS[data.type];
          command.triangulate(data, this);
        }
      };
      GraphicsGeometry2.prototype.processLine = function(data) {
        buildLine(data, this);
        for (var i = 0; i < data.holes.length; i++) {
          buildLine(data.holes[i], this);
        }
      };
      GraphicsGeometry2.prototype.processHoles = function(holes) {
        for (var i = 0; i < holes.length; i++) {
          var hole = holes[i];
          var command = FILL_COMMANDS[hole.type];
          command.build(hole);
          if (hole.matrix) {
            this.transformPoints(hole.points, hole.matrix);
          }
        }
      };
      GraphicsGeometry2.prototype.calculateBounds = function() {
        var bounds = this._bounds;
        var sequenceBounds = tmpBounds;
        var curMatrix = Matrix.IDENTITY;
        this._bounds.clear();
        sequenceBounds.clear();
        for (var i = 0; i < this.graphicsData.length; i++) {
          var data = this.graphicsData[i];
          var shape = data.shape;
          var type = data.type;
          var lineStyle = data.lineStyle;
          var nextMatrix = data.matrix || Matrix.IDENTITY;
          var lineWidth = 0;
          if (lineStyle && lineStyle.visible) {
            var alignment = lineStyle.alignment;
            lineWidth = lineStyle.width;
            if (type === SHAPES.POLY) {
              lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));
            } else {
              lineWidth = lineWidth * Math.max(0, alignment);
            }
          }
          if (curMatrix !== nextMatrix) {
            if (!sequenceBounds.isEmpty()) {
              bounds.addBoundsMatrix(sequenceBounds, curMatrix);
              sequenceBounds.clear();
            }
            curMatrix = nextMatrix;
          }
          if (type === SHAPES.RECT || type === SHAPES.RREC) {
            var rect = shape;
            sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);
          } else if (type === SHAPES.CIRC) {
            var circle = shape;
            sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);
          } else if (type === SHAPES.ELIP) {
            var ellipse = shape;
            sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);
          } else {
            var poly = shape;
            bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);
          }
        }
        if (!sequenceBounds.isEmpty()) {
          bounds.addBoundsMatrix(sequenceBounds, curMatrix);
        }
        bounds.pad(this.boundsPadding, this.boundsPadding);
      };
      GraphicsGeometry2.prototype.transformPoints = function(points, matrix) {
        for (var i = 0; i < points.length / 2; i++) {
          var x2 = points[i * 2];
          var y2 = points[i * 2 + 1];
          points[i * 2] = matrix.a * x2 + matrix.c * y2 + matrix.tx;
          points[i * 2 + 1] = matrix.b * x2 + matrix.d * y2 + matrix.ty;
        }
      };
      GraphicsGeometry2.prototype.addColors = function(colors, color, alpha, size2) {
        var rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);
        var rgba = premultiplyTint(rgb, alpha);
        while (size2-- > 0) {
          colors.push(rgba);
        }
      };
      GraphicsGeometry2.prototype.addTextureIds = function(textureIds, id2, size2) {
        while (size2-- > 0) {
          textureIds.push(id2);
        }
      };
      GraphicsGeometry2.prototype.addUvs = function(verts, uvs, texture, start, size2, matrix) {
        if (matrix === void 0) {
          matrix = null;
        }
        var index2 = 0;
        var uvsStart = uvs.length;
        var frame = texture.frame;
        while (index2 < size2) {
          var x2 = verts[(start + index2) * 2];
          var y2 = verts[(start + index2) * 2 + 1];
          if (matrix) {
            var nx = matrix.a * x2 + matrix.c * y2 + matrix.tx;
            y2 = matrix.b * x2 + matrix.d * y2 + matrix.ty;
            x2 = nx;
          }
          index2++;
          uvs.push(x2 / frame.width, y2 / frame.height);
        }
        var baseTexture = texture.baseTexture;
        if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
          this.adjustUvs(uvs, texture, uvsStart, size2);
        }
      };
      GraphicsGeometry2.prototype.adjustUvs = function(uvs, texture, start, size2) {
        var baseTexture = texture.baseTexture;
        var eps = 1e-6;
        var finish = start + size2 * 2;
        var frame = texture.frame;
        var scaleX = frame.width / baseTexture.width;
        var scaleY = frame.height / baseTexture.height;
        var offsetX = frame.x / frame.width;
        var offsetY = frame.y / frame.height;
        var minX = Math.floor(uvs[start] + eps);
        var minY = Math.floor(uvs[start + 1] + eps);
        for (var i = start + 2; i < finish; i += 2) {
          minX = Math.min(minX, Math.floor(uvs[i] + eps));
          minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
        }
        offsetX -= minX;
        offsetY -= minY;
        for (var i = start; i < finish; i += 2) {
          uvs[i] = (uvs[i] + offsetX) * scaleX;
          uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
        }
      };
      GraphicsGeometry2.BATCHABLE_SIZE = 100;
      return GraphicsGeometry2;
    }(BatchGeometry);
    var LineStyle = function(_super) {
      __extends$e(LineStyle2, _super);
      function LineStyle2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.width = 0;
        _this.alignment = 0.5;
        _this.native = false;
        _this.cap = LINE_CAP.BUTT;
        _this.join = LINE_JOIN.MITER;
        _this.miterLimit = 10;
        return _this;
      }
      LineStyle2.prototype.clone = function() {
        var obj = new LineStyle2();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        obj.width = this.width;
        obj.alignment = this.alignment;
        obj.native = this.native;
        obj.cap = this.cap;
        obj.join = this.join;
        obj.miterLimit = this.miterLimit;
        return obj;
      };
      LineStyle2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this.color = 0;
        this.alignment = 0.5;
        this.width = 0;
        this.native = false;
      };
      return LineStyle2;
    }(FillStyle);
    var temp = new Float32Array(3);
    var DEFAULT_SHADERS = {};
    var Graphics = function(_super) {
      __extends$e(Graphics2, _super);
      function Graphics2(geometry) {
        if (geometry === void 0) {
          geometry = null;
        }
        var _this = _super.call(this) || this;
        _this._geometry = geometry || new GraphicsGeometry();
        _this._geometry.refCount++;
        _this.shader = null;
        _this.state = State.for2d();
        _this._fillStyle = new FillStyle();
        _this._lineStyle = new LineStyle();
        _this._matrix = null;
        _this._holeMode = false;
        _this.currentPath = null;
        _this.batches = [];
        _this.batchTint = -1;
        _this.batchDirty = -1;
        _this.vertexData = null;
        _this.pluginName = "batch";
        _this._transformID = -1;
        _this.tint = 16777215;
        _this.blendMode = BLEND_MODES$1.NORMAL;
        return _this;
      }
      Object.defineProperty(Graphics2.prototype, "geometry", {
        get: function() {
          return this._geometry;
        },
        enumerable: false,
        configurable: true
      });
      Graphics2.prototype.clone = function() {
        this.finishPoly();
        return new Graphics2(this._geometry);
      };
      Object.defineProperty(Graphics2.prototype, "blendMode", {
        get: function() {
          return this.state.blendMode;
        },
        set: function(value2) {
          this.state.blendMode = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Graphics2.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value2) {
          this._tint = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Graphics2.prototype, "fill", {
        get: function() {
          return this._fillStyle;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Graphics2.prototype, "line", {
        get: function() {
          return this._lineStyle;
        },
        enumerable: false,
        configurable: true
      });
      Graphics2.prototype.lineStyle = function(options) {
        if (options === void 0) {
          options = null;
        }
        if (typeof options === "number") {
          var args = arguments;
          options = {
            width: args[0] || 0,
            color: args[1] || 0,
            alpha: args[2] !== void 0 ? args[2] : 1,
            alignment: args[3] !== void 0 ? args[3] : 0.5,
            native: !!args[4]
          };
        }
        return this.lineTextureStyle(options);
      };
      Graphics2.prototype.lineTextureStyle = function(options) {
        if (typeof options === "number") {
          deprecation("v5.2.0", "Please use object-based options for Graphics#lineTextureStyle");
          var _a2 = arguments, width2 = _a2[0], texture = _a2[1], color = _a2[2], alpha = _a2[3], matrix = _a2[4], alignment = _a2[5], native = _a2[6];
          options = { width: width2, texture, color, alpha, matrix, alignment, native };
          Object.keys(options).forEach(function(key) {
            return options[key] === void 0 && delete options[key];
          });
        }
        options = Object.assign({
          width: 0,
          texture: Texture.WHITE,
          color: options && options.texture ? 16777215 : 0,
          alpha: 1,
          matrix: null,
          alignment: 0.5,
          native: false,
          cap: LINE_CAP.BUTT,
          join: LINE_JOIN.MITER,
          miterLimit: 10
        }, options);
        if (this.currentPath) {
          this.startPoly();
        }
        var visible = options.width > 0 && options.alpha > 0;
        if (!visible) {
          this._lineStyle.reset();
        } else {
          if (options.matrix) {
            options.matrix = options.matrix.clone();
            options.matrix.invert();
          }
          Object.assign(this._lineStyle, { visible }, options);
        }
        return this;
      };
      Graphics2.prototype.startPoly = function() {
        if (this.currentPath) {
          var points = this.currentPath.points;
          var len = this.currentPath.points.length;
          if (len > 2) {
            this.drawShape(this.currentPath);
            this.currentPath = new Polygon();
            this.currentPath.closeStroke = false;
            this.currentPath.points.push(points[len - 2], points[len - 1]);
          }
        } else {
          this.currentPath = new Polygon();
          this.currentPath.closeStroke = false;
        }
      };
      Graphics2.prototype.finishPoly = function() {
        if (this.currentPath) {
          if (this.currentPath.points.length > 2) {
            this.drawShape(this.currentPath);
            this.currentPath = null;
          } else {
            this.currentPath.points.length = 0;
          }
        }
      };
      Graphics2.prototype.moveTo = function(x2, y2) {
        this.startPoly();
        this.currentPath.points[0] = x2;
        this.currentPath.points[1] = y2;
        return this;
      };
      Graphics2.prototype.lineTo = function(x2, y2) {
        if (!this.currentPath) {
          this.moveTo(0, 0);
        }
        var points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        if (fromX !== x2 || fromY !== y2) {
          points.push(x2, y2);
        }
        return this;
      };
      Graphics2.prototype._initCurve = function(x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (this.currentPath) {
          if (this.currentPath.points.length === 0) {
            this.currentPath.points = [x2, y2];
          }
        } else {
          this.moveTo(x2, y2);
        }
      };
      Graphics2.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
        this._initCurve();
        var points = this.currentPath.points;
        if (points.length === 0) {
          this.moveTo(0, 0);
        }
        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
        return this;
      };
      Graphics2.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
        this._initCurve();
        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
        return this;
      };
      Graphics2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
        this._initCurve(x1, y1);
        var points = this.currentPath.points;
        var result2 = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
        if (result2) {
          var cx = result2.cx, cy = result2.cy, radius_1 = result2.radius, startAngle = result2.startAngle, endAngle = result2.endAngle, anticlockwise = result2.anticlockwise;
          this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);
        }
        return this;
      };
      Graphics2.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
        if (anticlockwise === void 0) {
          anticlockwise = false;
        }
        if (startAngle === endAngle) {
          return this;
        }
        if (!anticlockwise && endAngle <= startAngle) {
          endAngle += PI_2;
        } else if (anticlockwise && startAngle <= endAngle) {
          startAngle += PI_2;
        }
        var sweep = endAngle - startAngle;
        if (sweep === 0) {
          return this;
        }
        var startX = cx + Math.cos(startAngle) * radius;
        var startY = cy + Math.sin(startAngle) * radius;
        var eps = this._geometry.closePointEps;
        var points = this.currentPath ? this.currentPath.points : null;
        if (points) {
          var xDiff = Math.abs(points[points.length - 2] - startX);
          var yDiff = Math.abs(points[points.length - 1] - startY);
          if (xDiff < eps && yDiff < eps)
            ;
          else {
            points.push(startX, startY);
          }
        } else {
          this.moveTo(startX, startY);
          points = this.currentPath.points;
        }
        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
        return this;
      };
      Graphics2.prototype.beginFill = function(color, alpha) {
        if (color === void 0) {
          color = 0;
        }
        if (alpha === void 0) {
          alpha = 1;
        }
        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
      };
      Graphics2.prototype.beginTextureFill = function(options) {
        if (options instanceof Texture) {
          deprecation("v5.2.0", "Please use object-based options for Graphics#beginTextureFill");
          var _a2 = arguments, texture = _a2[0], color = _a2[1], alpha = _a2[2], matrix = _a2[3];
          options = { texture, color, alpha, matrix };
          Object.keys(options).forEach(function(key) {
            return options[key] === void 0 && delete options[key];
          });
        }
        options = Object.assign({
          texture: Texture.WHITE,
          color: 16777215,
          alpha: 1,
          matrix: null
        }, options);
        if (this.currentPath) {
          this.startPoly();
        }
        var visible = options.alpha > 0;
        if (!visible) {
          this._fillStyle.reset();
        } else {
          if (options.matrix) {
            options.matrix = options.matrix.clone();
            options.matrix.invert();
          }
          Object.assign(this._fillStyle, { visible }, options);
        }
        return this;
      };
      Graphics2.prototype.endFill = function() {
        this.finishPoly();
        this._fillStyle.reset();
        return this;
      };
      Graphics2.prototype.drawRect = function(x2, y2, width2, height2) {
        return this.drawShape(new Rectangle(x2, y2, width2, height2));
      };
      Graphics2.prototype.drawRoundedRect = function(x2, y2, width2, height2, radius) {
        return this.drawShape(new RoundedRectangle(x2, y2, width2, height2, radius));
      };
      Graphics2.prototype.drawCircle = function(x2, y2, radius) {
        return this.drawShape(new Circle(x2, y2, radius));
      };
      Graphics2.prototype.drawEllipse = function(x2, y2, width2, height2) {
        return this.drawShape(new Ellipse(x2, y2, width2, height2));
      };
      Graphics2.prototype.drawPolygon = function() {
        var arguments$1 = arguments;
        var path = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          path[_i] = arguments$1[_i];
        }
        var points;
        var closeStroke = true;
        var poly = path[0];
        if (poly.points) {
          closeStroke = poly.closeStroke;
          points = poly.points;
        } else if (Array.isArray(path[0])) {
          points = path[0];
        } else {
          points = path;
        }
        var shape = new Polygon(points);
        shape.closeStroke = closeStroke;
        this.drawShape(shape);
        return this;
      };
      Graphics2.prototype.drawShape = function(shape) {
        if (!this._holeMode) {
          this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
        } else {
          this._geometry.drawHole(shape, this._matrix);
        }
        return this;
      };
      Graphics2.prototype.drawStar = function(x2, y2, points, radius, innerRadius, rotation) {
        if (rotation === void 0) {
          rotation = 0;
        }
        return this.drawPolygon(new Star(x2, y2, points, radius, innerRadius, rotation));
      };
      Graphics2.prototype.clear = function() {
        this._geometry.clear();
        this._lineStyle.reset();
        this._fillStyle.reset();
        this._boundsID++;
        this._matrix = null;
        this._holeMode = false;
        this.currentPath = null;
        return this;
      };
      Graphics2.prototype.isFastRect = function() {
        var data = this._geometry.graphicsData;
        return data.length === 1 && data[0].shape.type === SHAPES.RECT && !(data[0].lineStyle.visible && data[0].lineStyle.width);
      };
      Graphics2.prototype._render = function(renderer) {
        this.finishPoly();
        var geometry = this._geometry;
        var hasuit32 = renderer.context.supports.uint32Indices;
        geometry.updateBatches(hasuit32);
        if (geometry.batchable) {
          if (this.batchDirty !== geometry.batchDirty) {
            this._populateBatches();
          }
          this._renderBatched(renderer);
        } else {
          renderer.batch.flush();
          this._renderDirect(renderer);
        }
      };
      Graphics2.prototype._populateBatches = function() {
        var geometry = this._geometry;
        var blendMode = this.blendMode;
        var len = geometry.batches.length;
        this.batchTint = -1;
        this._transformID = -1;
        this.batchDirty = geometry.batchDirty;
        this.batches.length = len;
        this.vertexData = new Float32Array(geometry.points);
        for (var i = 0; i < len; i++) {
          var gI = geometry.batches[i];
          var color = gI.style.color;
          var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
          var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
          var indices2 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
          var batch = {
            vertexData,
            blendMode,
            indices: indices2,
            uvs,
            _batchRGB: hex2rgb(color),
            _tintRGB: color,
            _texture: gI.style.texture,
            alpha: gI.style.alpha,
            worldAlpha: 1
          };
          this.batches[i] = batch;
        }
      };
      Graphics2.prototype._renderBatched = function(renderer) {
        if (!this.batches.length) {
          return;
        }
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        this.calculateVertices();
        this.calculateTints();
        for (var i = 0, l2 = this.batches.length; i < l2; i++) {
          var batch = this.batches[i];
          batch.worldAlpha = this.worldAlpha * batch.alpha;
          renderer.plugins[this.pluginName].render(batch);
        }
      };
      Graphics2.prototype._renderDirect = function(renderer) {
        var shader = this._resolveDirectShader(renderer);
        var geometry = this._geometry;
        var tint = this.tint;
        var worldAlpha = this.worldAlpha;
        var uniforms = shader.uniforms;
        var drawCalls = geometry.drawCalls;
        uniforms.translationMatrix = this.transform.worldTransform;
        uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
        uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
        uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
        uniforms.tint[3] = worldAlpha;
        renderer.shader.bind(shader);
        renderer.geometry.bind(geometry, shader);
        renderer.state.set(this.state);
        for (var i = 0, l2 = drawCalls.length; i < l2; i++) {
          this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
        }
      };
      Graphics2.prototype._renderDrawCallDirect = function(renderer, drawCall) {
        var texArray = drawCall.texArray, type = drawCall.type, size2 = drawCall.size, start = drawCall.start;
        var groupTextureCount = texArray.count;
        for (var j = 0; j < groupTextureCount; j++) {
          renderer.texture.bind(texArray.elements[j], j);
        }
        renderer.geometry.draw(type, size2, start);
      };
      Graphics2.prototype._resolveDirectShader = function(renderer) {
        var shader = this.shader;
        var pluginName = this.pluginName;
        if (!shader) {
          if (!DEFAULT_SHADERS[pluginName]) {
            var sampleValues = new Int32Array(16);
            for (var i = 0; i < 16; i++) {
              sampleValues[i] = i;
            }
            var uniforms = {
              tint: new Float32Array([1, 1, 1, 1]),
              translationMatrix: new Matrix(),
              default: UniformGroup.from({ uSamplers: sampleValues }, true)
            };
            var program = renderer.plugins[pluginName]._shader.program;
            DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
          }
          shader = DEFAULT_SHADERS[pluginName];
        }
        return shader;
      };
      Graphics2.prototype._calculateBounds = function() {
        this.finishPoly();
        var geometry = this._geometry;
        if (!geometry.graphicsData.length) {
          return;
        }
        var _a2 = geometry.bounds, minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY = _a2.maxY;
        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
      };
      Graphics2.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, Graphics2._TEMP_POINT);
        return this._geometry.containsPoint(Graphics2._TEMP_POINT);
      };
      Graphics2.prototype.calculateTints = function() {
        if (this.batchTint !== this.tint) {
          this.batchTint = this.tint;
          var tintRGB = hex2rgb(this.tint, temp);
          for (var i = 0; i < this.batches.length; i++) {
            var batch = this.batches[i];
            var batchTint = batch._batchRGB;
            var r2 = tintRGB[0] * batchTint[0] * 255;
            var g2 = tintRGB[1] * batchTint[1] * 255;
            var b = tintRGB[2] * batchTint[2] * 255;
            var color = (r2 << 16) + (g2 << 8) + (b | 0);
            batch._tintRGB = (color >> 16) + (color & 65280) + ((color & 255) << 16);
          }
        }
      };
      Graphics2.prototype.calculateVertices = function() {
        var wtID = this.transform._worldID;
        if (this._transformID === wtID) {
          return;
        }
        this._transformID = wtID;
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var data = this._geometry.points;
        var vertexData = this.vertexData;
        var count = 0;
        for (var i = 0; i < data.length; i += 2) {
          var x2 = data[i];
          var y2 = data[i + 1];
          vertexData[count++] = a * x2 + c * y2 + tx;
          vertexData[count++] = d * y2 + b * x2 + ty;
        }
      };
      Graphics2.prototype.closePath = function() {
        var currentPath = this.currentPath;
        if (currentPath) {
          currentPath.closeStroke = true;
        }
        return this;
      };
      Graphics2.prototype.setMatrix = function(matrix) {
        this._matrix = matrix;
        return this;
      };
      Graphics2.prototype.beginHole = function() {
        this.finishPoly();
        this._holeMode = true;
        return this;
      };
      Graphics2.prototype.endHole = function() {
        this.finishPoly();
        this._holeMode = false;
        return this;
      };
      Graphics2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this._geometry.refCount--;
        if (this._geometry.refCount === 0) {
          this._geometry.dispose();
        }
        this._matrix = null;
        this.currentPath = null;
        this._lineStyle.destroy();
        this._lineStyle = null;
        this._fillStyle.destroy();
        this._fillStyle = null;
        this._geometry = null;
        this.shader = null;
        this.vertexData = null;
        this.batches.length = 0;
        this.batches = null;
        _super.prototype.destroy.call(this, options);
      };
      Graphics2._TEMP_POINT = new Point();
      return Graphics2;
    }(Container);
    /*!
     * @pixi/sprite - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/sprite is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$d = function(d, b) {
      extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$d(d, b);
    };
    function __extends$d(d, b) {
      extendStatics$d(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var tempPoint$2 = new Point();
    var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
    var Sprite = function(_super) {
      __extends$d(Sprite2, _super);
      function Sprite2(texture) {
        var _this = _super.call(this) || this;
        _this._anchor = new ObservablePoint(_this._onAnchorUpdate, _this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
        _this._texture = null;
        _this._width = 0;
        _this._height = 0;
        _this._tint = null;
        _this._tintRGB = null;
        _this.tint = 16777215;
        _this.blendMode = BLEND_MODES$1.NORMAL;
        _this._cachedTint = 16777215;
        _this.uvs = null;
        _this.texture = texture || Texture.EMPTY;
        _this.vertexData = new Float32Array(8);
        _this.vertexTrimmedData = null;
        _this._transformID = -1;
        _this._textureID = -1;
        _this._transformTrimmedID = -1;
        _this._textureTrimmedID = -1;
        _this.indices = indices;
        _this.pluginName = "batch";
        _this.isSprite = true;
        _this._roundPixels = settings.ROUND_PIXELS;
        return _this;
      }
      Sprite2.prototype._onTextureUpdate = function() {
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this._cachedTint = 16777215;
        if (this._width) {
          this.scale.x = sign$1(this.scale.x) * this._width / this._texture.orig.width;
        }
        if (this._height) {
          this.scale.y = sign$1(this.scale.y) * this._height / this._texture.orig.height;
        }
      };
      Sprite2.prototype._onAnchorUpdate = function() {
        this._transformID = -1;
        this._transformTrimmedID = -1;
      };
      Sprite2.prototype.calculateVertices = function() {
        var texture = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
          return;
        }
        if (this._textureID !== texture._updateID) {
          this.uvs = this._texture._uvs.uvsFloat32;
        }
        this._transformID = this.transform._worldID;
        this._textureID = texture._updateID;
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        var trim2 = texture.trim;
        var orig = texture.orig;
        var anchor = this._anchor;
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        if (trim2) {
          w1 = trim2.x - anchor._x * orig.width;
          w0 = w1 + trim2.width;
          h1 = trim2.y - anchor._y * orig.height;
          h0 = h1 + trim2.height;
        } else {
          w1 = -anchor._x * orig.width;
          w0 = w1 + orig.width;
          h1 = -anchor._y * orig.height;
          h0 = h1 + orig.height;
        }
        vertexData[0] = a * w1 + c * h1 + tx;
        vertexData[1] = d * h1 + b * w1 + ty;
        vertexData[2] = a * w0 + c * h1 + tx;
        vertexData[3] = d * h1 + b * w0 + ty;
        vertexData[4] = a * w0 + c * h0 + tx;
        vertexData[5] = d * h0 + b * w0 + ty;
        vertexData[6] = a * w1 + c * h0 + tx;
        vertexData[7] = d * h0 + b * w1 + ty;
        if (this._roundPixels) {
          var resolution = settings.RESOLUTION;
          for (var i = 0; i < vertexData.length; ++i) {
            vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);
          }
        }
      };
      Sprite2.prototype.calculateTrimmedVertices = function() {
        if (!this.vertexTrimmedData) {
          this.vertexTrimmedData = new Float32Array(8);
        } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
          return;
        }
        this._transformTrimmedID = this.transform._worldID;
        this._textureTrimmedID = this._texture._updateID;
        var texture = this._texture;
        var vertexData = this.vertexTrimmedData;
        var orig = texture.orig;
        var anchor = this._anchor;
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var w1 = -anchor._x * orig.width;
        var w0 = w1 + orig.width;
        var h1 = -anchor._y * orig.height;
        var h0 = h1 + orig.height;
        vertexData[0] = a * w1 + c * h1 + tx;
        vertexData[1] = d * h1 + b * w1 + ty;
        vertexData[2] = a * w0 + c * h1 + tx;
        vertexData[3] = d * h1 + b * w0 + ty;
        vertexData[4] = a * w0 + c * h0 + tx;
        vertexData[5] = d * h0 + b * w0 + ty;
        vertexData[6] = a * w1 + c * h0 + tx;
        vertexData[7] = d * h0 + b * w1 + ty;
      };
      Sprite2.prototype._render = function(renderer) {
        this.calculateVertices();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
      };
      Sprite2.prototype._calculateBounds = function() {
        var trim2 = this._texture.trim;
        var orig = this._texture.orig;
        if (!trim2 || trim2.width === orig.width && trim2.height === orig.height) {
          this.calculateVertices();
          this._bounds.addQuad(this.vertexData);
        } else {
          this.calculateTrimmedVertices();
          this._bounds.addQuad(this.vertexTrimmedData);
        }
      };
      Sprite2.prototype.getLocalBounds = function(rect) {
        if (this.children.length === 0) {
          this._bounds.minX = this._texture.orig.width * -this._anchor._x;
          this._bounds.minY = this._texture.orig.height * -this._anchor._y;
          this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
          this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
          if (!rect) {
            if (!this._localBoundsRect) {
              this._localBoundsRect = new Rectangle();
            }
            rect = this._localBoundsRect;
          }
          return this._bounds.getRectangle(rect);
        }
        return _super.prototype.getLocalBounds.call(this, rect);
      };
      Sprite2.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, tempPoint$2);
        var width2 = this._texture.orig.width;
        var height2 = this._texture.orig.height;
        var x1 = -width2 * this.anchor.x;
        var y1 = 0;
        if (tempPoint$2.x >= x1 && tempPoint$2.x < x1 + width2) {
          y1 = -height2 * this.anchor.y;
          if (tempPoint$2.y >= y1 && tempPoint$2.y < y1 + height2) {
            return true;
          }
        }
        return false;
      };
      Sprite2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this._texture.off("update", this._onTextureUpdate, this);
        this._anchor = null;
        var destroyTexture = typeof options === "boolean" ? options : options && options.texture;
        if (destroyTexture) {
          var destroyBaseTexture = typeof options === "boolean" ? options : options && options.baseTexture;
          this._texture.destroy(!!destroyBaseTexture);
        }
        this._texture = null;
      };
      Sprite2.from = function(source, options) {
        var texture = source instanceof Texture ? source : Texture.from(source, options);
        return new Sprite2(texture);
      };
      Object.defineProperty(Sprite2.prototype, "roundPixels", {
        get: function() {
          return this._roundPixels;
        },
        set: function(value2) {
          if (this._roundPixels !== value2) {
            this._transformID = -1;
          }
          this._roundPixels = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "width", {
        get: function() {
          return Math.abs(this.scale.x) * this._texture.orig.width;
        },
        set: function(value2) {
          var s = sign$1(this.scale.x) || 1;
          this.scale.x = s * value2 / this._texture.orig.width;
          this._width = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "height", {
        get: function() {
          return Math.abs(this.scale.y) * this._texture.orig.height;
        },
        set: function(value2) {
          var s = sign$1(this.scale.y) || 1;
          this.scale.y = s * value2 / this._texture.orig.height;
          this._height = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "anchor", {
        get: function() {
          return this._anchor;
        },
        set: function(value2) {
          this._anchor.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value2) {
          this._tint = value2;
          this._tintRGB = (value2 >> 16) + (value2 & 65280) + ((value2 & 255) << 16);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "texture", {
        get: function() {
          return this._texture;
        },
        set: function(value2) {
          if (this._texture === value2) {
            return;
          }
          if (this._texture) {
            this._texture.off("update", this._onTextureUpdate, this);
          }
          this._texture = value2 || Texture.EMPTY;
          this._cachedTint = 16777215;
          this._textureID = -1;
          this._textureTrimmedID = -1;
          if (value2) {
            if (value2.baseTexture.valid) {
              this._onTextureUpdate();
            } else {
              value2.once("update", this._onTextureUpdate, this);
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      return Sprite2;
    }(Container);
    /*!
     * @pixi/text - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/text is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$c = function(d, b) {
      extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$c(d, b);
    };
    function __extends$c(d, b) {
      extendStatics$c(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var TEXT_GRADIENT;
    (function(TEXT_GRADIENT2) {
      TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
      TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
    })(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
    var defaultStyle = {
      align: "left",
      breakWords: false,
      dropShadow: false,
      dropShadowAlpha: 1,
      dropShadowAngle: Math.PI / 6,
      dropShadowBlur: 0,
      dropShadowColor: "black",
      dropShadowDistance: 5,
      fill: "black",
      fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
      fillGradientStops: [],
      fontFamily: "Arial",
      fontSize: 26,
      fontStyle: "normal",
      fontVariant: "normal",
      fontWeight: "normal",
      letterSpacing: 0,
      lineHeight: 0,
      lineJoin: "miter",
      miterLimit: 10,
      padding: 0,
      stroke: "black",
      strokeThickness: 0,
      textBaseline: "alphabetic",
      trim: false,
      whiteSpace: "pre",
      wordWrap: false,
      wordWrapWidth: 100,
      leading: 0
    };
    var genericFontFamilies = [
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui"
    ];
    var TextStyle = function() {
      function TextStyle2(style) {
        this.styleID = 0;
        this.reset();
        deepCopyProperties(this, style, style);
      }
      TextStyle2.prototype.clone = function() {
        var clonedProperties = {};
        deepCopyProperties(clonedProperties, this, defaultStyle);
        return new TextStyle2(clonedProperties);
      };
      TextStyle2.prototype.reset = function() {
        deepCopyProperties(this, defaultStyle, defaultStyle);
      };
      Object.defineProperty(TextStyle2.prototype, "align", {
        get: function() {
          return this._align;
        },
        set: function(align) {
          if (this._align !== align) {
            this._align = align;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "breakWords", {
        get: function() {
          return this._breakWords;
        },
        set: function(breakWords) {
          if (this._breakWords !== breakWords) {
            this._breakWords = breakWords;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadow", {
        get: function() {
          return this._dropShadow;
        },
        set: function(dropShadow) {
          if (this._dropShadow !== dropShadow) {
            this._dropShadow = dropShadow;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowAlpha", {
        get: function() {
          return this._dropShadowAlpha;
        },
        set: function(dropShadowAlpha) {
          if (this._dropShadowAlpha !== dropShadowAlpha) {
            this._dropShadowAlpha = dropShadowAlpha;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowAngle", {
        get: function() {
          return this._dropShadowAngle;
        },
        set: function(dropShadowAngle) {
          if (this._dropShadowAngle !== dropShadowAngle) {
            this._dropShadowAngle = dropShadowAngle;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowBlur", {
        get: function() {
          return this._dropShadowBlur;
        },
        set: function(dropShadowBlur) {
          if (this._dropShadowBlur !== dropShadowBlur) {
            this._dropShadowBlur = dropShadowBlur;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowColor", {
        get: function() {
          return this._dropShadowColor;
        },
        set: function(dropShadowColor) {
          var outputColor = getColor(dropShadowColor);
          if (this._dropShadowColor !== outputColor) {
            this._dropShadowColor = outputColor;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowDistance", {
        get: function() {
          return this._dropShadowDistance;
        },
        set: function(dropShadowDistance) {
          if (this._dropShadowDistance !== dropShadowDistance) {
            this._dropShadowDistance = dropShadowDistance;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fill", {
        get: function() {
          return this._fill;
        },
        set: function(fill) {
          var outputColor = getColor(fill);
          if (this._fill !== outputColor) {
            this._fill = outputColor;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fillGradientType", {
        get: function() {
          return this._fillGradientType;
        },
        set: function(fillGradientType) {
          if (this._fillGradientType !== fillGradientType) {
            this._fillGradientType = fillGradientType;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fillGradientStops", {
        get: function() {
          return this._fillGradientStops;
        },
        set: function(fillGradientStops) {
          if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
            this._fillGradientStops = fillGradientStops;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontFamily", {
        get: function() {
          return this._fontFamily;
        },
        set: function(fontFamily) {
          if (this.fontFamily !== fontFamily) {
            this._fontFamily = fontFamily;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontSize", {
        get: function() {
          return this._fontSize;
        },
        set: function(fontSize) {
          if (this._fontSize !== fontSize) {
            this._fontSize = fontSize;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontStyle", {
        get: function() {
          return this._fontStyle;
        },
        set: function(fontStyle) {
          if (this._fontStyle !== fontStyle) {
            this._fontStyle = fontStyle;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontVariant", {
        get: function() {
          return this._fontVariant;
        },
        set: function(fontVariant) {
          if (this._fontVariant !== fontVariant) {
            this._fontVariant = fontVariant;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontWeight", {
        get: function() {
          return this._fontWeight;
        },
        set: function(fontWeight) {
          if (this._fontWeight !== fontWeight) {
            this._fontWeight = fontWeight;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "letterSpacing", {
        get: function() {
          return this._letterSpacing;
        },
        set: function(letterSpacing) {
          if (this._letterSpacing !== letterSpacing) {
            this._letterSpacing = letterSpacing;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "lineHeight", {
        get: function() {
          return this._lineHeight;
        },
        set: function(lineHeight) {
          if (this._lineHeight !== lineHeight) {
            this._lineHeight = lineHeight;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "leading", {
        get: function() {
          return this._leading;
        },
        set: function(leading) {
          if (this._leading !== leading) {
            this._leading = leading;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "lineJoin", {
        get: function() {
          return this._lineJoin;
        },
        set: function(lineJoin) {
          if (this._lineJoin !== lineJoin) {
            this._lineJoin = lineJoin;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "miterLimit", {
        get: function() {
          return this._miterLimit;
        },
        set: function(miterLimit) {
          if (this._miterLimit !== miterLimit) {
            this._miterLimit = miterLimit;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "padding", {
        get: function() {
          return this._padding;
        },
        set: function(padding) {
          if (this._padding !== padding) {
            this._padding = padding;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "stroke", {
        get: function() {
          return this._stroke;
        },
        set: function(stroke) {
          var outputColor = getColor(stroke);
          if (this._stroke !== outputColor) {
            this._stroke = outputColor;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "strokeThickness", {
        get: function() {
          return this._strokeThickness;
        },
        set: function(strokeThickness) {
          if (this._strokeThickness !== strokeThickness) {
            this._strokeThickness = strokeThickness;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "textBaseline", {
        get: function() {
          return this._textBaseline;
        },
        set: function(textBaseline) {
          if (this._textBaseline !== textBaseline) {
            this._textBaseline = textBaseline;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "trim", {
        get: function() {
          return this._trim;
        },
        set: function(trim2) {
          if (this._trim !== trim2) {
            this._trim = trim2;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "whiteSpace", {
        get: function() {
          return this._whiteSpace;
        },
        set: function(whiteSpace) {
          if (this._whiteSpace !== whiteSpace) {
            this._whiteSpace = whiteSpace;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "wordWrap", {
        get: function() {
          return this._wordWrap;
        },
        set: function(wordWrap) {
          if (this._wordWrap !== wordWrap) {
            this._wordWrap = wordWrap;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "wordWrapWidth", {
        get: function() {
          return this._wordWrapWidth;
        },
        set: function(wordWrapWidth) {
          if (this._wordWrapWidth !== wordWrapWidth) {
            this._wordWrapWidth = wordWrapWidth;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      TextStyle2.prototype.toFontString = function() {
        var fontSizeString = typeof this.fontSize === "number" ? this.fontSize + "px" : this.fontSize;
        var fontFamilies = this.fontFamily;
        if (!Array.isArray(this.fontFamily)) {
          fontFamilies = this.fontFamily.split(",");
        }
        for (var i = fontFamilies.length - 1; i >= 0; i--) {
          var fontFamily = fontFamilies[i].trim();
          if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
            fontFamily = '"' + fontFamily + '"';
          }
          fontFamilies[i] = fontFamily;
        }
        return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
      };
      return TextStyle2;
    }();
    function getSingleColor(color) {
      if (typeof color === "number") {
        return hex2string(color);
      } else if (typeof color === "string") {
        if (color.indexOf("0x") === 0) {
          color = color.replace("0x", "#");
        }
      }
      return color;
    }
    function getColor(color) {
      if (!Array.isArray(color)) {
        return getSingleColor(color);
      } else {
        for (var i = 0; i < color.length; ++i) {
          color[i] = getSingleColor(color[i]);
        }
        return color;
      }
    }
    function areArraysEqual(array1, array2) {
      if (!Array.isArray(array1) || !Array.isArray(array2)) {
        return false;
      }
      if (array1.length !== array2.length) {
        return false;
      }
      for (var i = 0; i < array1.length; ++i) {
        if (array1[i] !== array2[i]) {
          return false;
        }
      }
      return true;
    }
    function deepCopyProperties(target, source, propertyObj) {
      for (var prop in propertyObj) {
        if (Array.isArray(source[prop])) {
          target[prop] = source[prop].slice();
        } else {
          target[prop] = source[prop];
        }
      }
    }
    var TextMetrics = function() {
      function TextMetrics2(text, style, width2, height2, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width2;
        this.height = height2;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
      }
      TextMetrics2.measureText = function(text, style, wordWrap, canvas2) {
        if (canvas2 === void 0) {
          canvas2 = TextMetrics2._canvas;
        }
        wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
        var font = style.toFontString();
        var fontProperties = TextMetrics2.measureFont(font);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = style.fontSize;
          fontProperties.ascent = style.fontSize;
        }
        var context2 = canvas2.getContext("2d");
        context2.font = font;
        var outputText = wordWrap ? TextMetrics2.wordWrap(text, style, canvas2) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
          var lineWidth = context2.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;
          lineWidths[i] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width2 = maxLineWidth + style.strokeThickness;
        if (style.dropShadow) {
          width2 += style.dropShadowDistance;
        }
        var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        var height2 = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);
        if (style.dropShadow) {
          height2 += style.dropShadowDistance;
        }
        return new TextMetrics2(text, style, width2, height2, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
      };
      TextMetrics2.wordWrap = function(text, style, canvas2) {
        if (canvas2 === void 0) {
          canvas2 = TextMetrics2._canvas;
        }
        var context2 = canvas2.getContext("2d");
        var width2 = 0;
        var line = "";
        var lines = "";
        var cache2 = {};
        var letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace;
        var collapseSpaces = TextMetrics2.collapseSpaces(whiteSpace);
        var collapseNewlines = TextMetrics2.collapseNewlines(whiteSpace);
        var canPrependSpaces = !collapseSpaces;
        var wordWrapWidth = style.wordWrapWidth + letterSpacing;
        var tokens2 = TextMetrics2.tokenize(text);
        for (var i = 0; i < tokens2.length; i++) {
          var token2 = tokens2[i];
          if (TextMetrics2.isNewline(token2)) {
            if (!collapseNewlines) {
              lines += TextMetrics2.addLine(line);
              canPrependSpaces = !collapseSpaces;
              line = "";
              width2 = 0;
              continue;
            }
            token2 = " ";
          }
          if (collapseSpaces) {
            var currIsBreakingSpace = TextMetrics2.isBreakingSpace(token2);
            var lastIsBreakingSpace = TextMetrics2.isBreakingSpace(line[line.length - 1]);
            if (currIsBreakingSpace && lastIsBreakingSpace) {
              continue;
            }
          }
          var tokenWidth = TextMetrics2.getFromCache(token2, letterSpacing, cache2, context2);
          if (tokenWidth > wordWrapWidth) {
            if (line !== "") {
              lines += TextMetrics2.addLine(line);
              line = "";
              width2 = 0;
            }
            if (TextMetrics2.canBreakWords(token2, style.breakWords)) {
              var characters = TextMetrics2.wordWrapSplit(token2);
              for (var j = 0; j < characters.length; j++) {
                var char = characters[j];
                var k = 1;
                while (characters[j + k]) {
                  var nextChar = characters[j + k];
                  var lastChar = char[char.length - 1];
                  if (!TextMetrics2.canBreakChars(lastChar, nextChar, token2, j, style.breakWords)) {
                    char += nextChar;
                  } else {
                    break;
                  }
                  k++;
                }
                j += char.length - 1;
                var characterWidth = TextMetrics2.getFromCache(char, letterSpacing, cache2, context2);
                if (characterWidth + width2 > wordWrapWidth) {
                  lines += TextMetrics2.addLine(line);
                  canPrependSpaces = false;
                  line = "";
                  width2 = 0;
                }
                line += char;
                width2 += characterWidth;
              }
            } else {
              if (line.length > 0) {
                lines += TextMetrics2.addLine(line);
                line = "";
                width2 = 0;
              }
              var isLastToken = i === tokens2.length - 1;
              lines += TextMetrics2.addLine(token2, !isLastToken);
              canPrependSpaces = false;
              line = "";
              width2 = 0;
            }
          } else {
            if (tokenWidth + width2 > wordWrapWidth) {
              canPrependSpaces = false;
              lines += TextMetrics2.addLine(line);
              line = "";
              width2 = 0;
            }
            if (line.length > 0 || !TextMetrics2.isBreakingSpace(token2) || canPrependSpaces) {
              line += token2;
              width2 += tokenWidth;
            }
          }
        }
        lines += TextMetrics2.addLine(line, false);
        return lines;
      };
      TextMetrics2.addLine = function(line, newLine) {
        if (newLine === void 0) {
          newLine = true;
        }
        line = TextMetrics2.trimRight(line);
        line = newLine ? line + "\n" : line;
        return line;
      };
      TextMetrics2.getFromCache = function(key, letterSpacing, cache2, context2) {
        var width2 = cache2[key];
        if (width2 === void 0) {
          var spacing = key.length * letterSpacing;
          width2 = context2.measureText(key).width + spacing;
          cache2[key] = width2;
        }
        return width2;
      };
      TextMetrics2.collapseSpaces = function(whiteSpace) {
        return whiteSpace === "normal" || whiteSpace === "pre-line";
      };
      TextMetrics2.collapseNewlines = function(whiteSpace) {
        return whiteSpace === "normal";
      };
      TextMetrics2.trimRight = function(text) {
        if (typeof text !== "string") {
          return "";
        }
        for (var i = text.length - 1; i >= 0; i--) {
          var char = text[i];
          if (!TextMetrics2.isBreakingSpace(char)) {
            break;
          }
          text = text.slice(0, -1);
        }
        return text;
      };
      TextMetrics2.isNewline = function(char) {
        if (typeof char !== "string") {
          return false;
        }
        return TextMetrics2._newlines.indexOf(char.charCodeAt(0)) >= 0;
      };
      TextMetrics2.isBreakingSpace = function(char) {
        if (typeof char !== "string") {
          return false;
        }
        return TextMetrics2._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
      };
      TextMetrics2.tokenize = function(text) {
        var tokens2 = [];
        var token2 = "";
        if (typeof text !== "string") {
          return tokens2;
        }
        for (var i = 0; i < text.length; i++) {
          var char = text[i];
          if (TextMetrics2.isBreakingSpace(char) || TextMetrics2.isNewline(char)) {
            if (token2 !== "") {
              tokens2.push(token2);
              token2 = "";
            }
            tokens2.push(char);
            continue;
          }
          token2 += char;
        }
        if (token2 !== "") {
          tokens2.push(token2);
        }
        return tokens2;
      };
      TextMetrics2.canBreakWords = function(_token, breakWords) {
        return breakWords;
      };
      TextMetrics2.canBreakChars = function(_char, _nextChar, _token, _index, _breakWords) {
        return true;
      };
      TextMetrics2.wordWrapSplit = function(token2) {
        return token2.split("");
      };
      TextMetrics2.measureFont = function(font) {
        if (TextMetrics2._fonts[font]) {
          return TextMetrics2._fonts[font];
        }
        var properties = {
          ascent: 0,
          descent: 0,
          fontSize: 0
        };
        var canvas2 = TextMetrics2._canvas;
        var context2 = TextMetrics2._context;
        context2.font = font;
        var metricsString = TextMetrics2.METRICS_STRING + TextMetrics2.BASELINE_SYMBOL;
        var width2 = Math.ceil(context2.measureText(metricsString).width);
        var baseline = Math.ceil(context2.measureText(TextMetrics2.BASELINE_SYMBOL).width);
        var height2 = 2 * baseline;
        baseline = baseline * TextMetrics2.BASELINE_MULTIPLIER | 0;
        canvas2.width = width2;
        canvas2.height = height2;
        context2.fillStyle = "#f00";
        context2.fillRect(0, 0, width2, height2);
        context2.font = font;
        context2.textBaseline = "alphabetic";
        context2.fillStyle = "#000";
        context2.fillText(metricsString, 0, baseline);
        var imagedata = context2.getImageData(0, 0, width2, height2).data;
        var pixels = imagedata.length;
        var line = width2 * 4;
        var i = 0;
        var idx = 0;
        var stop = false;
        for (i = 0; i < baseline; ++i) {
          for (var j = 0; j < line; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx += line;
          } else {
            break;
          }
        }
        properties.ascent = baseline - i;
        idx = pixels - line;
        stop = false;
        for (i = height2; i > baseline; --i) {
          for (var j = 0; j < line; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx -= line;
          } else {
            break;
          }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        TextMetrics2._fonts[font] = properties;
        return properties;
      };
      TextMetrics2.clearMetrics = function(font) {
        if (font === void 0) {
          font = "";
        }
        if (font) {
          delete TextMetrics2._fonts[font];
        } else {
          TextMetrics2._fonts = {};
        }
      };
      return TextMetrics2;
    }();
    var canvas = function() {
      try {
        var c = new OffscreenCanvas(0, 0);
        var context2 = c.getContext("2d");
        if (context2 && context2.measureText) {
          return c;
        }
        return document.createElement("canvas");
      } catch (ex) {
        return document.createElement("canvas");
      }
    }();
    canvas.width = canvas.height = 10;
    TextMetrics._canvas = canvas;
    TextMetrics._context = canvas.getContext("2d");
    TextMetrics._fonts = {};
    TextMetrics.METRICS_STRING = "|q";
    TextMetrics.BASELINE_SYMBOL = "M";
    TextMetrics.BASELINE_MULTIPLIER = 1.4;
    TextMetrics._newlines = [
      10,
      13
    ];
    TextMetrics._breakingSpaces = [
      9,
      32,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8200,
      8201,
      8202,
      8287,
      12288
    ];
    var defaultDestroyOptions = {
      texture: true,
      children: false,
      baseTexture: true
    };
    var Text = function(_super) {
      __extends$c(Text2, _super);
      function Text2(text, style, canvas2) {
        var _this = this;
        var ownCanvas = false;
        if (!canvas2) {
          canvas2 = document.createElement("canvas");
          ownCanvas = true;
        }
        canvas2.width = 3;
        canvas2.height = 3;
        var texture = Texture.from(canvas2);
        texture.orig = new Rectangle();
        texture.trim = new Rectangle();
        _this = _super.call(this, texture) || this;
        _this._ownCanvas = ownCanvas;
        _this.canvas = canvas2;
        _this.context = _this.canvas.getContext("2d");
        _this._resolution = settings.RESOLUTION;
        _this._autoResolution = true;
        _this._text = null;
        _this._style = null;
        _this._styleListener = null;
        _this._font = "";
        _this.text = text;
        _this.style = style;
        _this.localStyleID = -1;
        return _this;
      }
      Text2.prototype.updateText = function(respectDirty) {
        var style = this._style;
        if (this.localStyleID !== style.styleID) {
          this.dirty = true;
          this.localStyleID = style.styleID;
        }
        if (!this.dirty && respectDirty) {
          return;
        }
        this._font = this._style.toFontString();
        var context2 = this.context;
        var measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
        var width2 = measured.width;
        var height2 = measured.height;
        var lines = measured.lines;
        var lineHeight = measured.lineHeight;
        var lineWidths = measured.lineWidths;
        var maxLineWidth = measured.maxLineWidth;
        var fontProperties = measured.fontProperties;
        this.canvas.width = Math.ceil((Math.max(1, width2) + style.padding * 2) * this._resolution);
        this.canvas.height = Math.ceil((Math.max(1, height2) + style.padding * 2) * this._resolution);
        context2.scale(this._resolution, this._resolution);
        context2.clearRect(0, 0, this.canvas.width, this.canvas.height);
        context2.font = this._font;
        context2.lineWidth = style.strokeThickness;
        context2.textBaseline = style.textBaseline;
        context2.lineJoin = style.lineJoin;
        context2.miterLimit = style.miterLimit;
        var linePositionX;
        var linePositionY;
        var passesCount = style.dropShadow ? 2 : 1;
        for (var i = 0; i < passesCount; ++i) {
          var isShadowPass = style.dropShadow && i === 0;
          var dsOffsetText = isShadowPass ? height2 * 2 : 0;
          var dsOffsetShadow = dsOffsetText * this.resolution;
          if (isShadowPass) {
            context2.fillStyle = "black";
            context2.strokeStyle = "black";
            var dropShadowColor = style.dropShadowColor;
            var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
            context2.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
            context2.shadowBlur = style.dropShadowBlur;
            context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
            context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance + dsOffsetShadow;
          } else {
            context2.fillStyle = this._generateFillStyle(style, lines, measured);
            context2.strokeStyle = style.stroke;
            context2.shadowColor = "0";
            context2.shadowBlur = 0;
            context2.shadowOffsetX = 0;
            context2.shadowOffsetY = 0;
          }
          for (var i_1 = 0; i_1 < lines.length; i_1++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = style.strokeThickness / 2 + i_1 * lineHeight + fontProperties.ascent;
            if (style.align === "right") {
              linePositionX += maxLineWidth - lineWidths[i_1];
            } else if (style.align === "center") {
              linePositionX += (maxLineWidth - lineWidths[i_1]) / 2;
            }
            if (style.stroke && style.strokeThickness) {
              this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
            }
            if (style.fill) {
              this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
            }
          }
        }
        this.updateTexture();
      };
      Text2.prototype.drawLetterSpacing = function(text, x2, y2, isStroke) {
        if (isStroke === void 0) {
          isStroke = false;
        }
        var style = this._style;
        var letterSpacing = style.letterSpacing;
        if (letterSpacing === 0) {
          if (isStroke) {
            this.context.strokeText(text, x2, y2);
          } else {
            this.context.fillText(text, x2, y2);
          }
          return;
        }
        var currentPosition = x2;
        var stringArray = Array.from ? Array.from(text) : text.split("");
        var previousWidth = this.context.measureText(text).width;
        var currentWidth = 0;
        for (var i = 0; i < stringArray.length; ++i) {
          var currentChar = stringArray[i];
          if (isStroke) {
            this.context.strokeText(currentChar, currentPosition, y2);
          } else {
            this.context.fillText(currentChar, currentPosition, y2);
          }
          currentWidth = this.context.measureText(text.substring(i + 1)).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
      };
      Text2.prototype.updateTexture = function() {
        var canvas2 = this.canvas;
        if (this._style.trim) {
          var trimmed = trimCanvas(canvas2);
          if (trimmed.data) {
            canvas2.width = trimmed.width;
            canvas2.height = trimmed.height;
            this.context.putImageData(trimmed.data, 0, 0);
          }
        }
        var texture = this._texture;
        var style = this._style;
        var padding = style.trim ? 0 : style.padding;
        var baseTexture = texture.baseTexture;
        texture.trim.width = texture._frame.width = Math.ceil(canvas2.width / this._resolution);
        texture.trim.height = texture._frame.height = Math.ceil(canvas2.height / this._resolution);
        texture.trim.x = -padding;
        texture.trim.y = -padding;
        texture.orig.width = texture._frame.width - padding * 2;
        texture.orig.height = texture._frame.height - padding * 2;
        this._onTextureUpdate();
        baseTexture.setRealSize(canvas2.width, canvas2.height, this._resolution);
        this._recursivePostUpdateTransform();
        this.dirty = false;
      };
      Text2.prototype._render = function(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
          this._resolution = renderer.resolution;
          this.dirty = true;
        }
        this.updateText(true);
        _super.prototype._render.call(this, renderer);
      };
      Text2.prototype.getLocalBounds = function(rect) {
        this.updateText(true);
        return _super.prototype.getLocalBounds.call(this, rect);
      };
      Text2.prototype._calculateBounds = function() {
        this.updateText(true);
        this.calculateVertices();
        this._bounds.addQuad(this.vertexData);
      };
      Text2.prototype._generateFillStyle = function(style, lines, metrics) {
        var fillStyle = style.fill;
        if (!Array.isArray(fillStyle)) {
          return fillStyle;
        } else if (fillStyle.length === 1) {
          return fillStyle[0];
        }
        var gradient;
        var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
        var padding = style.padding || 0;
        var width2 = Math.ceil(this.canvas.width / this._resolution) - dropShadowCorrection - padding * 2;
        var height2 = Math.ceil(this.canvas.height / this._resolution) - dropShadowCorrection - padding * 2;
        var fill = fillStyle.slice();
        var fillGradientStops = style.fillGradientStops.slice();
        if (!fillGradientStops.length) {
          var lengthPlus1 = fill.length + 1;
          for (var i = 1; i < lengthPlus1; ++i) {
            fillGradientStops.push(i / lengthPlus1);
          }
        }
        fill.unshift(fillStyle[0]);
        fillGradientStops.unshift(0);
        fill.push(fillStyle[fillStyle.length - 1]);
        fillGradientStops.push(1);
        if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
          gradient = this.context.createLinearGradient(width2 / 2, padding, width2 / 2, height2 + padding);
          var lastIterationStop = 0;
          var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
          var gradStopLineHeight = textHeight / height2;
          for (var i = 0; i < lines.length; i++) {
            var thisLineTop = metrics.lineHeight * i;
            for (var j = 0; j < fill.length; j++) {
              var lineStop = 0;
              if (typeof fillGradientStops[j] === "number") {
                lineStop = fillGradientStops[j];
              } else {
                lineStop = j / fill.length;
              }
              var globalStop = thisLineTop / height2 + lineStop * gradStopLineHeight;
              var clampedStop = Math.max(lastIterationStop, globalStop);
              clampedStop = Math.min(clampedStop, 1);
              gradient.addColorStop(clampedStop, fill[j]);
              lastIterationStop = clampedStop;
            }
          }
        } else {
          gradient = this.context.createLinearGradient(padding, height2 / 2, width2 + padding, height2 / 2);
          var totalIterations = fill.length + 1;
          var currentIteration = 1;
          for (var i = 0; i < fill.length; i++) {
            var stop = void 0;
            if (typeof fillGradientStops[i] === "number") {
              stop = fillGradientStops[i];
            } else {
              stop = currentIteration / totalIterations;
            }
            gradient.addColorStop(stop, fill[i]);
            currentIteration++;
          }
        }
        return gradient;
      };
      Text2.prototype.destroy = function(options) {
        if (typeof options === "boolean") {
          options = { children: options };
        }
        options = Object.assign({}, defaultDestroyOptions, options);
        _super.prototype.destroy.call(this, options);
        if (this._ownCanvas) {
          this.canvas.height = this.canvas.width = 0;
        }
        this.context = null;
        this.canvas = null;
        this._style = null;
      };
      Object.defineProperty(Text2.prototype, "width", {
        get: function() {
          this.updateText(true);
          return Math.abs(this.scale.x) * this._texture.orig.width;
        },
        set: function(value2) {
          this.updateText(true);
          var s = sign$1(this.scale.x) || 1;
          this.scale.x = s * value2 / this._texture.orig.width;
          this._width = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text2.prototype, "height", {
        get: function() {
          this.updateText(true);
          return Math.abs(this.scale.y) * this._texture.orig.height;
        },
        set: function(value2) {
          this.updateText(true);
          var s = sign$1(this.scale.y) || 1;
          this.scale.y = s * value2 / this._texture.orig.height;
          this._height = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text2.prototype, "style", {
        get: function() {
          return this._style;
        },
        set: function(style) {
          style = style || {};
          if (style instanceof TextStyle) {
            this._style = style;
          } else {
            this._style = new TextStyle(style);
          }
          this.localStyleID = -1;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text2.prototype, "text", {
        get: function() {
          return this._text;
        },
        set: function(text) {
          text = String(text === null || text === void 0 ? "" : text);
          if (this._text === text) {
            return;
          }
          this._text = text;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text2.prototype, "resolution", {
        get: function() {
          return this._resolution;
        },
        set: function(value2) {
          this._autoResolution = false;
          if (this._resolution === value2) {
            return;
          }
          this._resolution = value2;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      return Text2;
    }(Sprite);
    /*!
     * @pixi/prepare - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/prepare is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    settings.UPLOADS_PER_FRAME = 4;
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$b = function(d, b) {
      extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$b(d, b);
    };
    function __extends$b(d, b) {
      extendStatics$b(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var CountLimiter = function() {
      function CountLimiter2(maxItemsPerFrame) {
        this.maxItemsPerFrame = maxItemsPerFrame;
        this.itemsLeft = 0;
      }
      CountLimiter2.prototype.beginFrame = function() {
        this.itemsLeft = this.maxItemsPerFrame;
      };
      CountLimiter2.prototype.allowedToUpload = function() {
        return this.itemsLeft-- > 0;
      };
      return CountLimiter2;
    }();
    function findMultipleBaseTextures(item, queue2) {
      var result2 = false;
      if (item && item._textures && item._textures.length) {
        for (var i = 0; i < item._textures.length; i++) {
          if (item._textures[i] instanceof Texture) {
            var baseTexture = item._textures[i].baseTexture;
            if (queue2.indexOf(baseTexture) === -1) {
              queue2.push(baseTexture);
              result2 = true;
            }
          }
        }
      }
      return result2;
    }
    function findBaseTexture(item, queue2) {
      if (item.baseTexture instanceof BaseTexture) {
        var texture = item.baseTexture;
        if (queue2.indexOf(texture) === -1) {
          queue2.push(texture);
        }
        return true;
      }
      return false;
    }
    function findTexture(item, queue2) {
      if (item._texture && item._texture instanceof Texture) {
        var texture = item._texture.baseTexture;
        if (queue2.indexOf(texture) === -1) {
          queue2.push(texture);
        }
        return true;
      }
      return false;
    }
    function drawText(_helper, item) {
      if (item instanceof Text) {
        item.updateText(true);
        return true;
      }
      return false;
    }
    function calculateTextStyle(_helper, item) {
      if (item instanceof TextStyle) {
        var font = item.toFontString();
        TextMetrics.measureFont(font);
        return true;
      }
      return false;
    }
    function findText(item, queue2) {
      if (item instanceof Text) {
        if (queue2.indexOf(item.style) === -1) {
          queue2.push(item.style);
        }
        if (queue2.indexOf(item) === -1) {
          queue2.push(item);
        }
        var texture = item._texture.baseTexture;
        if (queue2.indexOf(texture) === -1) {
          queue2.push(texture);
        }
        return true;
      }
      return false;
    }
    function findTextStyle(item, queue2) {
      if (item instanceof TextStyle) {
        if (queue2.indexOf(item) === -1) {
          queue2.push(item);
        }
        return true;
      }
      return false;
    }
    var BasePrepare = function() {
      function BasePrepare2(renderer) {
        var _this = this;
        this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);
        this.renderer = renderer;
        this.uploadHookHelper = null;
        this.queue = [];
        this.addHooks = [];
        this.uploadHooks = [];
        this.completes = [];
        this.ticking = false;
        this.delayedTick = function() {
          if (!_this.queue) {
            return;
          }
          _this.prepareItems();
        };
        this.registerFindHook(findText);
        this.registerFindHook(findTextStyle);
        this.registerFindHook(findMultipleBaseTextures);
        this.registerFindHook(findBaseTexture);
        this.registerFindHook(findTexture);
        this.registerUploadHook(drawText);
        this.registerUploadHook(calculateTextStyle);
      }
      BasePrepare2.prototype.upload = function(item, done) {
        if (typeof item === "function") {
          done = item;
          item = null;
        }
        if (item) {
          this.add(item);
        }
        if (this.queue.length) {
          if (done) {
            this.completes.push(done);
          }
          if (!this.ticking) {
            this.ticking = true;
            Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
          }
        } else if (done) {
          done();
        }
      };
      BasePrepare2.prototype.tick = function() {
        setTimeout(this.delayedTick, 0);
      };
      BasePrepare2.prototype.prepareItems = function() {
        this.limiter.beginFrame();
        while (this.queue.length && this.limiter.allowedToUpload()) {
          var item = this.queue[0];
          var uploaded = false;
          if (item && !item._destroyed) {
            for (var i = 0, len = this.uploadHooks.length; i < len; i++) {
              if (this.uploadHooks[i](this.uploadHookHelper, item)) {
                this.queue.shift();
                uploaded = true;
                break;
              }
            }
          }
          if (!uploaded) {
            this.queue.shift();
          }
        }
        if (!this.queue.length) {
          this.ticking = false;
          var completes = this.completes.slice(0);
          this.completes.length = 0;
          for (var i = 0, len = completes.length; i < len; i++) {
            completes[i]();
          }
        } else {
          Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
        }
      };
      BasePrepare2.prototype.registerFindHook = function(addHook) {
        if (addHook) {
          this.addHooks.push(addHook);
        }
        return this;
      };
      BasePrepare2.prototype.registerUploadHook = function(uploadHook) {
        if (uploadHook) {
          this.uploadHooks.push(uploadHook);
        }
        return this;
      };
      BasePrepare2.prototype.add = function(item) {
        for (var i = 0, len = this.addHooks.length; i < len; i++) {
          if (this.addHooks[i](item, this.queue)) {
            break;
          }
        }
        if (item instanceof Container) {
          for (var i = item.children.length - 1; i >= 0; i--) {
            this.add(item.children[i]);
          }
        }
        return this;
      };
      BasePrepare2.prototype.destroy = function() {
        if (this.ticking) {
          Ticker.system.remove(this.tick, this);
        }
        this.ticking = false;
        this.addHooks = null;
        this.uploadHooks = null;
        this.renderer = null;
        this.completes = null;
        this.queue = null;
        this.limiter = null;
        this.uploadHookHelper = null;
      };
      return BasePrepare2;
    }();
    function uploadBaseTextures(renderer, item) {
      if (item instanceof BaseTexture) {
        if (!item._glTextures[renderer.CONTEXT_UID]) {
          renderer.texture.bind(item);
        }
        return true;
      }
      return false;
    }
    function uploadGraphics(renderer, item) {
      if (!(item instanceof Graphics)) {
        return false;
      }
      var geometry = item.geometry;
      item.finishPoly();
      geometry.updateBatches();
      var batches = geometry.batches;
      for (var i = 0; i < batches.length; i++) {
        var texture = batches[i].style.texture;
        if (texture) {
          uploadBaseTextures(renderer, texture.baseTexture);
        }
      }
      if (!geometry.batchable) {
        renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
      }
      return true;
    }
    function findGraphics(item, queue2) {
      if (item instanceof Graphics) {
        queue2.push(item);
        return true;
      }
      return false;
    }
    var Prepare = function(_super) {
      __extends$b(Prepare2, _super);
      function Prepare2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.uploadHookHelper = _this.renderer;
        _this.registerFindHook(findGraphics);
        _this.registerUploadHook(uploadBaseTextures);
        _this.registerUploadHook(uploadGraphics);
        return _this;
      }
      return Prepare2;
    }(BasePrepare);
    /*!
     * @pixi/spritesheet - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/spritesheet is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var Spritesheet = function() {
      function Spritesheet2(texture, data, resolutionFilename) {
        if (resolutionFilename === void 0) {
          resolutionFilename = null;
        }
        this._texture = texture instanceof Texture ? texture : null;
        this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;
        this.textures = {};
        this.animations = {};
        this.data = data;
        var resource = this.baseTexture.resource;
        this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
        this._frames = this.data.frames;
        this._frameKeys = Object.keys(this._frames);
        this._batchIndex = 0;
        this._callback = null;
      }
      Spritesheet2.prototype._updateResolution = function(resolutionFilename) {
        if (resolutionFilename === void 0) {
          resolutionFilename = null;
        }
        var scale = this.data.meta.scale;
        var resolution = getResolutionOfUrl(resolutionFilename, null);
        if (resolution === null) {
          resolution = scale !== void 0 ? parseFloat(scale) : 1;
        }
        if (resolution !== 1) {
          this.baseTexture.setResolution(resolution);
        }
        return resolution;
      };
      Spritesheet2.prototype.parse = function(callback) {
        this._batchIndex = 0;
        this._callback = callback;
        if (this._frameKeys.length <= Spritesheet2.BATCH_SIZE) {
          this._processFrames(0);
          this._processAnimations();
          this._parseComplete();
        } else {
          this._nextBatch();
        }
      };
      Spritesheet2.prototype._processFrames = function(initialFrameIndex) {
        var frameIndex = initialFrameIndex;
        var maxFrames = Spritesheet2.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
          var i = this._frameKeys[frameIndex];
          var data = this._frames[i];
          var rect = data.frame;
          if (rect) {
            var frame = null;
            var trim2 = null;
            var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
            var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
            if (data.rotated) {
              frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
            } else {
              frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
            }
            if (data.trimmed !== false && data.spriteSourceSize) {
              trim2 = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
            }
            this.textures[i] = new Texture(this.baseTexture, frame, orig, trim2, data.rotated ? 2 : 0, data.anchor);
            Texture.addToCache(this.textures[i], i);
          }
          frameIndex++;
        }
      };
      Spritesheet2.prototype._processAnimations = function() {
        var animations = this.data.animations || {};
        for (var animName in animations) {
          this.animations[animName] = [];
          for (var i = 0; i < animations[animName].length; i++) {
            var frameName = animations[animName][i];
            this.animations[animName].push(this.textures[frameName]);
          }
        }
      };
      Spritesheet2.prototype._parseComplete = function() {
        var callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
      };
      Spritesheet2.prototype._nextBatch = function() {
        var _this = this;
        this._processFrames(this._batchIndex * Spritesheet2.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(function() {
          if (_this._batchIndex * Spritesheet2.BATCH_SIZE < _this._frameKeys.length) {
            _this._nextBatch();
          } else {
            _this._processAnimations();
            _this._parseComplete();
          }
        }, 0);
      };
      Spritesheet2.prototype.destroy = function(destroyBase) {
        var _a2;
        if (destroyBase === void 0) {
          destroyBase = false;
        }
        for (var i in this.textures) {
          this.textures[i].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
          (_a2 = this._texture) === null || _a2 === void 0 ? void 0 : _a2.destroy();
          this.baseTexture.destroy();
        }
        this._texture = null;
        this.baseTexture = null;
      };
      Spritesheet2.BATCH_SIZE = 1e3;
      return Spritesheet2;
    }();
    var SpritesheetLoader = function() {
      function SpritesheetLoader2() {
      }
      SpritesheetLoader2.use = function(resource, next) {
        var loader = this;
        var imageResourceName = resource.name + "_image";
        if (!resource.data || resource.type !== LoaderResource.TYPE.JSON || !resource.data.frames || loader.resources[imageResourceName]) {
          next();
          return;
        }
        var loadOptions = {
          crossOrigin: resource.crossOrigin,
          metadata: resource.metadata.imageMetadata,
          parentResource: resource
        };
        var resourcePath = SpritesheetLoader2.getResourcePath(resource, loader.baseUrl);
        loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {
          if (res.error) {
            next(res.error);
            return;
          }
          var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);
          spritesheet.parse(function() {
            resource.spritesheet = spritesheet;
            resource.textures = spritesheet.textures;
            next();
          });
        });
      };
      SpritesheetLoader2.getResourcePath = function(resource, baseUrl) {
        if (resource.isDataUrl) {
          return resource.data.meta.image;
        }
        return url.resolve(resource.url.replace(baseUrl, ""), resource.data.meta.image);
      };
      return SpritesheetLoader2;
    }();
    /*!
     * @pixi/sprite-tiling - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/sprite-tiling is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$a = function(d, b) {
      extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$a(d, b);
    };
    function __extends$a(d, b) {
      extendStatics$a(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var tempPoint$1 = new Point();
    (function(_super) {
      __extends$a(TilingSprite, _super);
      function TilingSprite(texture, width2, height2) {
        if (width2 === void 0) {
          width2 = 100;
        }
        if (height2 === void 0) {
          height2 = 100;
        }
        var _this = _super.call(this, texture) || this;
        _this.tileTransform = new Transform();
        _this._width = width2;
        _this._height = height2;
        _this.uvMatrix = texture.uvMatrix || new TextureMatrix(texture);
        _this.pluginName = "tilingSprite";
        _this.uvRespectAnchor = false;
        return _this;
      }
      Object.defineProperty(TilingSprite.prototype, "clampMargin", {
        get: function() {
          return this.uvMatrix.clampMargin;
        },
        set: function(value2) {
          this.uvMatrix.clampMargin = value2;
          this.uvMatrix.update(true);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TilingSprite.prototype, "tileScale", {
        get: function() {
          return this.tileTransform.scale;
        },
        set: function(value2) {
          this.tileTransform.scale.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TilingSprite.prototype, "tilePosition", {
        get: function() {
          return this.tileTransform.position;
        },
        set: function(value2) {
          this.tileTransform.position.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      TilingSprite.prototype._onTextureUpdate = function() {
        if (this.uvMatrix) {
          this.uvMatrix.texture = this._texture;
        }
        this._cachedTint = 16777215;
      };
      TilingSprite.prototype._render = function(renderer) {
        var texture = this._texture;
        if (!texture || !texture.valid) {
          return;
        }
        this.tileTransform.updateLocalTransform();
        this.uvMatrix.update();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
      };
      TilingSprite.prototype._calculateBounds = function() {
        var minX = this._width * -this._anchor._x;
        var minY = this._height * -this._anchor._y;
        var maxX = this._width * (1 - this._anchor._x);
        var maxY = this._height * (1 - this._anchor._y);
        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
      };
      TilingSprite.prototype.getLocalBounds = function(rect) {
        if (this.children.length === 0) {
          this._bounds.minX = this._width * -this._anchor._x;
          this._bounds.minY = this._height * -this._anchor._y;
          this._bounds.maxX = this._width * (1 - this._anchor._x);
          this._bounds.maxY = this._height * (1 - this._anchor._y);
          if (!rect) {
            if (!this._localBoundsRect) {
              this._localBoundsRect = new Rectangle();
            }
            rect = this._localBoundsRect;
          }
          return this._bounds.getRectangle(rect);
        }
        return _super.prototype.getLocalBounds.call(this, rect);
      };
      TilingSprite.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, tempPoint$1);
        var width2 = this._width;
        var height2 = this._height;
        var x1 = -width2 * this.anchor._x;
        if (tempPoint$1.x >= x1 && tempPoint$1.x < x1 + width2) {
          var y1 = -height2 * this.anchor._y;
          if (tempPoint$1.y >= y1 && tempPoint$1.y < y1 + height2) {
            return true;
          }
        }
        return false;
      };
      TilingSprite.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this.tileTransform = null;
        this.uvMatrix = null;
      };
      TilingSprite.from = function(source, options) {
        if (typeof options === "number") {
          deprecation("5.3.0", "TilingSprite.from use options instead of width and height args");
          options = { width: options, height: arguments[2] };
        }
        return new TilingSprite(Texture.from(source, options), options.width, options.height);
      };
      Object.defineProperty(TilingSprite.prototype, "width", {
        get: function() {
          return this._width;
        },
        set: function(value2) {
          this._width = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TilingSprite.prototype, "height", {
        get: function() {
          return this._height;
        },
        set: function(value2) {
          this._height = value2;
        },
        enumerable: false,
        configurable: true
      });
      return TilingSprite;
    })(Sprite);
    var vertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
    var fragment$6 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord - floor(vTextureCoord - uClampOffset);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture2D(uSampler, coord);\n    gl_FragColor = texSample * uColor;\n}\n";
    var fragmentSimple = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = sample * uColor;\n}\n";
    var tempMat = new Matrix();
    var TilingSpriteRenderer = function(_super) {
      __extends$a(TilingSpriteRenderer2, _super);
      function TilingSpriteRenderer2(renderer) {
        var _this = _super.call(this, renderer) || this;
        var uniforms = { globals: _this.renderer.globalUniforms };
        _this.shader = Shader.from(vertex$3, fragment$6, uniforms);
        _this.simpleShader = Shader.from(vertex$3, fragmentSimple, uniforms);
        _this.quad = new QuadUv();
        _this.state = State.for2d();
        return _this;
      }
      TilingSpriteRenderer2.prototype.render = function(ts) {
        var renderer = this.renderer;
        var quad = this.quad;
        var vertices = quad.vertices;
        vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
        vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
        vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
        if (ts.uvRespectAnchor) {
          vertices = quad.uvs;
          vertices[0] = vertices[6] = -ts.anchor.x;
          vertices[1] = vertices[3] = -ts.anchor.y;
          vertices[2] = vertices[4] = 1 - ts.anchor.x;
          vertices[5] = vertices[7] = 1 - ts.anchor.y;
        }
        quad.invalidate();
        var tex = ts._texture;
        var baseTex = tex.baseTexture;
        var lt = ts.tileTransform.localTransform;
        var uv = ts.uvMatrix;
        var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
        if (isSimple) {
          if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
            if (baseTex.wrapMode === WRAP_MODES$1.CLAMP) {
              baseTex.wrapMode = WRAP_MODES$1.REPEAT;
            }
          } else {
            isSimple = baseTex.wrapMode !== WRAP_MODES$1.CLAMP;
          }
        }
        var shader = isSimple ? this.simpleShader : this.shader;
        var w2 = tex.width;
        var h2 = tex.height;
        var W2 = ts._width;
        var H2 = ts._height;
        tempMat.set(lt.a * w2 / W2, lt.b * w2 / H2, lt.c * h2 / W2, lt.d * h2 / H2, lt.tx / W2, lt.ty / H2);
        tempMat.invert();
        if (isSimple) {
          tempMat.prepend(uv.mapCoord);
        } else {
          shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
          shader.uniforms.uClampFrame = uv.uClampFrame;
          shader.uniforms.uClampOffset = uv.uClampOffset;
        }
        shader.uniforms.uTransform = tempMat.toArray(true);
        shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.alphaMode);
        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
        shader.uniforms.uSampler = tex;
        renderer.shader.bind(shader);
        renderer.geometry.bind(quad);
        this.state.blendMode = correctBlendMode(ts.blendMode, baseTex.alphaMode);
        renderer.state.set(this.state);
        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
      };
      return TilingSpriteRenderer2;
    }(ObjectRenderer);
    /*!
     * @pixi/mesh - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/mesh is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$9 = function(d, b) {
      extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$9(d, b);
    };
    function __extends$9(d, b) {
      extendStatics$9(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var MeshBatchUvs = function() {
      function MeshBatchUvs2(uvBuffer, uvMatrix) {
        this.uvBuffer = uvBuffer;
        this.uvMatrix = uvMatrix;
        this.data = null;
        this._bufferUpdateId = -1;
        this._textureUpdateId = -1;
        this._updateID = 0;
      }
      MeshBatchUvs2.prototype.update = function(forceUpdate) {
        if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
          return;
        }
        this._bufferUpdateId = this.uvBuffer._updateID;
        this._textureUpdateId = this.uvMatrix._updateID;
        var data = this.uvBuffer.data;
        if (!this.data || this.data.length !== data.length) {
          this.data = new Float32Array(data.length);
        }
        this.uvMatrix.multiplyUvs(data, this.data);
        this._updateID++;
      };
      return MeshBatchUvs2;
    }();
    var tempPoint = new Point();
    var tempPolygon = new Polygon();
    var Mesh = function(_super) {
      __extends$9(Mesh2, _super);
      function Mesh2(geometry, shader, state, drawMode) {
        if (drawMode === void 0) {
          drawMode = DRAW_MODES$1.TRIANGLES;
        }
        var _this = _super.call(this) || this;
        _this.geometry = geometry;
        geometry.refCount++;
        _this.shader = shader;
        _this.state = state || State.for2d();
        _this.drawMode = drawMode;
        _this.start = 0;
        _this.size = 0;
        _this.uvs = null;
        _this.indices = null;
        _this.vertexData = new Float32Array(1);
        _this.vertexDirty = 0;
        _this._transformID = -1;
        _this.tint = 16777215;
        _this.blendMode = BLEND_MODES$1.NORMAL;
        _this._roundPixels = settings.ROUND_PIXELS;
        _this.batchUvs = null;
        return _this;
      }
      Object.defineProperty(Mesh2.prototype, "uvBuffer", {
        get: function() {
          return this.geometry.buffers[1];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "verticesBuffer", {
        get: function() {
          return this.geometry.buffers[0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "material", {
        get: function() {
          return this.shader;
        },
        set: function(value2) {
          this.shader = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "blendMode", {
        get: function() {
          return this.state.blendMode;
        },
        set: function(value2) {
          this.state.blendMode = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "roundPixels", {
        get: function() {
          return this._roundPixels;
        },
        set: function(value2) {
          if (this._roundPixels !== value2) {
            this._transformID = -1;
          }
          this._roundPixels = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "tint", {
        get: function() {
          return this.shader.tint;
        },
        set: function(value2) {
          this.shader.tint = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "texture", {
        get: function() {
          return this.shader.texture;
        },
        set: function(value2) {
          this.shader.texture = value2;
        },
        enumerable: false,
        configurable: true
      });
      Mesh2.prototype._render = function(renderer) {
        var vertices = this.geometry.buffers[0].data;
        if (this.shader.batchable && this.drawMode === DRAW_MODES$1.TRIANGLES && vertices.length < Mesh2.BATCHABLE_SIZE * 2) {
          this._renderToBatch(renderer);
        } else {
          this._renderDefault(renderer);
        }
      };
      Mesh2.prototype._renderDefault = function(renderer) {
        var shader = this.shader;
        shader.alpha = this.worldAlpha;
        if (shader.update) {
          shader.update();
        }
        renderer.batch.flush();
        if (shader.program.uniformData.translationMatrix) {
          shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
        }
        renderer.shader.bind(shader);
        renderer.state.set(this.state);
        renderer.geometry.bind(this.geometry, shader);
        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
      };
      Mesh2.prototype._renderToBatch = function(renderer) {
        var geometry = this.geometry;
        if (this.shader.uvMatrix) {
          this.shader.uvMatrix.update();
          this.calculateUvs();
        }
        this.calculateVertices();
        this.indices = geometry.indexBuffer.data;
        this._tintRGB = this.shader._tintRGB;
        this._texture = this.shader.texture;
        var pluginName = this.material.pluginName;
        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
        renderer.plugins[pluginName].render(this);
      };
      Mesh2.prototype.calculateVertices = function() {
        var geometry = this.geometry;
        var vertices = geometry.buffers[0].data;
        if (geometry.vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
          return;
        }
        this._transformID = this.transform._worldID;
        if (this.vertexData.length !== vertices.length) {
          this.vertexData = new Float32Array(vertices.length);
        }
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        for (var i = 0; i < vertexData.length / 2; i++) {
          var x2 = vertices[i * 2];
          var y2 = vertices[i * 2 + 1];
          vertexData[i * 2] = a * x2 + c * y2 + tx;
          vertexData[i * 2 + 1] = b * x2 + d * y2 + ty;
        }
        if (this._roundPixels) {
          var resolution = settings.RESOLUTION;
          for (var i = 0; i < vertexData.length; ++i) {
            vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);
          }
        }
        this.vertexDirty = geometry.vertexDirtyId;
      };
      Mesh2.prototype.calculateUvs = function() {
        var geomUvs = this.geometry.buffers[1];
        if (!this.shader.uvMatrix.isSimple) {
          if (!this.batchUvs) {
            this.batchUvs = new MeshBatchUvs(geomUvs, this.shader.uvMatrix);
          }
          this.batchUvs.update();
          this.uvs = this.batchUvs.data;
        } else {
          this.uvs = geomUvs.data;
        }
      };
      Mesh2.prototype._calculateBounds = function() {
        this.calculateVertices();
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
      };
      Mesh2.prototype.containsPoint = function(point) {
        if (!this.getBounds().contains(point.x, point.y)) {
          return false;
        }
        this.worldTransform.applyInverse(point, tempPoint);
        var vertices = this.geometry.getBuffer("aVertexPosition").data;
        var points = tempPolygon.points;
        var indices2 = this.geometry.getIndex().data;
        var len = indices2.length;
        var step = this.drawMode === 4 ? 3 : 1;
        for (var i = 0; i + 2 < len; i += step) {
          var ind0 = indices2[i] * 2;
          var ind1 = indices2[i + 1] * 2;
          var ind2 = indices2[i + 2] * 2;
          points[0] = vertices[ind0];
          points[1] = vertices[ind0 + 1];
          points[2] = vertices[ind1];
          points[3] = vertices[ind1 + 1];
          points[4] = vertices[ind2];
          points[5] = vertices[ind2 + 1];
          if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
            return true;
          }
        }
        return false;
      };
      Mesh2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this.geometry.refCount--;
        if (this.geometry.refCount === 0) {
          this.geometry.dispose();
        }
        this.geometry = null;
        this.shader = null;
        this.state = null;
        this.uvs = null;
        this.indices = null;
        this.vertexData = null;
      };
      Mesh2.BATCHABLE_SIZE = 100;
      return Mesh2;
    }(Container);
    var fragment$5 = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
    var vertex$2 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
    var MeshMaterial = function(_super) {
      __extends$9(MeshMaterial2, _super);
      function MeshMaterial2(uSampler, options) {
        var _this = this;
        var uniforms = {
          uSampler,
          alpha: 1,
          uTextureMatrix: Matrix.IDENTITY,
          uColor: new Float32Array([1, 1, 1, 1])
        };
        options = Object.assign({
          tint: 16777215,
          alpha: 1,
          pluginName: "batch"
        }, options);
        if (options.uniforms) {
          Object.assign(uniforms, options.uniforms);
        }
        _this = _super.call(this, options.program || Program.from(vertex$2, fragment$5), uniforms) || this;
        _this._colorDirty = false;
        _this.uvMatrix = new TextureMatrix(uSampler);
        _this.batchable = options.program === void 0;
        _this.pluginName = options.pluginName;
        _this.tint = options.tint;
        _this.alpha = options.alpha;
        return _this;
      }
      Object.defineProperty(MeshMaterial2.prototype, "texture", {
        get: function() {
          return this.uniforms.uSampler;
        },
        set: function(value2) {
          if (this.uniforms.uSampler !== value2) {
            this.uniforms.uSampler = value2;
            this.uvMatrix.texture = value2;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MeshMaterial2.prototype, "alpha", {
        get: function() {
          return this._alpha;
        },
        set: function(value2) {
          if (value2 === this._alpha) {
            return;
          }
          this._alpha = value2;
          this._colorDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MeshMaterial2.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value2) {
          if (value2 === this._tint) {
            return;
          }
          this._tint = value2;
          this._tintRGB = (value2 >> 16) + (value2 & 65280) + ((value2 & 255) << 16);
          this._colorDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      MeshMaterial2.prototype.update = function() {
        if (this._colorDirty) {
          this._colorDirty = false;
          var baseTexture = this.texture.baseTexture;
          premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);
        }
        if (this.uvMatrix.update()) {
          this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
        }
      };
      return MeshMaterial2;
    }(Shader);
    var MeshGeometry = function(_super) {
      __extends$9(MeshGeometry2, _super);
      function MeshGeometry2(vertices, uvs, index2) {
        var _this = _super.call(this) || this;
        var verticesBuffer = new Buffer$1(vertices);
        var uvsBuffer = new Buffer$1(uvs, true);
        var indexBuffer = new Buffer$1(index2, true, true);
        _this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES$1.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES$1.FLOAT).addIndex(indexBuffer);
        _this._updateId = -1;
        return _this;
      }
      Object.defineProperty(MeshGeometry2.prototype, "vertexDirtyId", {
        get: function() {
          return this.buffers[0]._updateID;
        },
        enumerable: false,
        configurable: true
      });
      return MeshGeometry2;
    }(Geometry);
    /*!
     * @pixi/text-bitmap - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/text-bitmap is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$8 = function(d, b) {
      extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$8(d, b);
    };
    function __extends$8(d, b) {
      extendStatics$8(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var BitmapFontData = function() {
      function BitmapFontData2() {
        this.info = [];
        this.common = [];
        this.page = [];
        this.char = [];
        this.kerning = [];
      }
      return BitmapFontData2;
    }();
    var TextFormat = function() {
      function TextFormat2() {
      }
      TextFormat2.test = function(data) {
        return typeof data === "string" && data.indexOf("info face=") === 0;
      };
      TextFormat2.parse = function(txt) {
        var items2 = txt.match(/^[a-z]+\s+.+$/gm);
        var rawData = {
          info: [],
          common: [],
          page: [],
          char: [],
          chars: [],
          kerning: []
        };
        for (var i in items2) {
          var name2 = items2[i].match(/^[a-z]+/gm)[0];
          var attributeList = items2[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
          var itemData = {};
          for (var i_1 in attributeList) {
            var split = attributeList[i_1].split("=");
            var key = split[0];
            var strValue = split[1].replace(/"/gm, "");
            var floatValue = parseFloat(strValue);
            var value2 = isNaN(floatValue) ? strValue : floatValue;
            itemData[key] = value2;
          }
          rawData[name2].push(itemData);
        }
        var font = new BitmapFontData();
        rawData.info.forEach(function(info) {
          return font.info.push({
            face: info.face,
            size: parseInt(info.size, 10)
          });
        });
        rawData.common.forEach(function(common) {
          return font.common.push({
            lineHeight: parseInt(common.lineHeight, 10)
          });
        });
        rawData.page.forEach(function(page) {
          return font.page.push({
            id: parseInt(page.id, 10),
            file: page.file
          });
        });
        rawData.char.forEach(function(char) {
          return font.char.push({
            id: parseInt(char.id, 10),
            page: parseInt(char.page, 10),
            x: parseInt(char.x, 10),
            y: parseInt(char.y, 10),
            width: parseInt(char.width, 10),
            height: parseInt(char.height, 10),
            xoffset: parseInt(char.xoffset, 10),
            yoffset: parseInt(char.yoffset, 10),
            xadvance: parseInt(char.xadvance, 10)
          });
        });
        rawData.kerning.forEach(function(kerning) {
          return font.kerning.push({
            first: parseInt(kerning.first, 10),
            second: parseInt(kerning.second, 10),
            amount: parseInt(kerning.amount, 10)
          });
        });
        return font;
      };
      return TextFormat2;
    }();
    var XMLFormat = function() {
      function XMLFormat2() {
      }
      XMLFormat2.test = function(data) {
        return data instanceof XMLDocument && data.getElementsByTagName("page").length && data.getElementsByTagName("info")[0].getAttribute("face") !== null;
      };
      XMLFormat2.parse = function(xml) {
        var data = new BitmapFontData();
        var info = xml.getElementsByTagName("info");
        var common = xml.getElementsByTagName("common");
        var page = xml.getElementsByTagName("page");
        var char = xml.getElementsByTagName("char");
        var kerning = xml.getElementsByTagName("kerning");
        for (var i = 0; i < info.length; i++) {
          data.info.push({
            face: info[i].getAttribute("face"),
            size: parseInt(info[i].getAttribute("size"), 10)
          });
        }
        for (var i = 0; i < common.length; i++) {
          data.common.push({
            lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
          });
        }
        for (var i = 0; i < page.length; i++) {
          data.page.push({
            id: parseInt(page[i].getAttribute("id"), 10) || 0,
            file: page[i].getAttribute("file")
          });
        }
        for (var i = 0; i < char.length; i++) {
          var letter = char[i];
          data.char.push({
            id: parseInt(letter.getAttribute("id"), 10),
            page: parseInt(letter.getAttribute("page"), 10) || 0,
            x: parseInt(letter.getAttribute("x"), 10),
            y: parseInt(letter.getAttribute("y"), 10),
            width: parseInt(letter.getAttribute("width"), 10),
            height: parseInt(letter.getAttribute("height"), 10),
            xoffset: parseInt(letter.getAttribute("xoffset"), 10),
            yoffset: parseInt(letter.getAttribute("yoffset"), 10),
            xadvance: parseInt(letter.getAttribute("xadvance"), 10)
          });
        }
        for (var i = 0; i < kerning.length; i++) {
          data.kerning.push({
            first: parseInt(kerning[i].getAttribute("first"), 10),
            second: parseInt(kerning[i].getAttribute("second"), 10),
            amount: parseInt(kerning[i].getAttribute("amount"), 10)
          });
        }
        return data;
      };
      return XMLFormat2;
    }();
    var formats = [
      TextFormat,
      XMLFormat
    ];
    function autoDetectFormat(data) {
      for (var i = 0; i < formats.length; i++) {
        if (formats[i].test(data)) {
          return formats[i];
        }
      }
      return null;
    }
    function generateFillStyle(canvas2, context2, style, resolution, lines, metrics) {
      var fillStyle = style.fill;
      if (!Array.isArray(fillStyle)) {
        return fillStyle;
      } else if (fillStyle.length === 1) {
        return fillStyle[0];
      }
      var gradient;
      var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
      var padding = style.padding || 0;
      var width2 = Math.ceil(canvas2.width / resolution) - dropShadowCorrection - padding * 2;
      var height2 = Math.ceil(canvas2.height / resolution) - dropShadowCorrection - padding * 2;
      var fill = fillStyle.slice();
      var fillGradientStops = style.fillGradientStops.slice();
      if (!fillGradientStops.length) {
        var lengthPlus1 = fill.length + 1;
        for (var i = 1; i < lengthPlus1; ++i) {
          fillGradientStops.push(i / lengthPlus1);
        }
      }
      fill.unshift(fillStyle[0]);
      fillGradientStops.unshift(0);
      fill.push(fillStyle[fillStyle.length - 1]);
      fillGradientStops.push(1);
      if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
        gradient = context2.createLinearGradient(width2 / 2, padding, width2 / 2, height2 + padding);
        var lastIterationStop = 0;
        var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
        var gradStopLineHeight = textHeight / height2;
        for (var i = 0; i < lines.length; i++) {
          var thisLineTop = metrics.lineHeight * i;
          for (var j = 0; j < fill.length; j++) {
            var lineStop = 0;
            if (typeof fillGradientStops[j] === "number") {
              lineStop = fillGradientStops[j];
            } else {
              lineStop = j / fill.length;
            }
            var globalStop = thisLineTop / height2 + lineStop * gradStopLineHeight;
            var clampedStop = Math.max(lastIterationStop, globalStop);
            clampedStop = Math.min(clampedStop, 1);
            gradient.addColorStop(clampedStop, fill[j]);
            lastIterationStop = clampedStop;
          }
        }
      } else {
        gradient = context2.createLinearGradient(padding, height2 / 2, width2 + padding, height2 / 2);
        var totalIterations = fill.length + 1;
        var currentIteration = 1;
        for (var i = 0; i < fill.length; i++) {
          var stop = void 0;
          if (typeof fillGradientStops[i] === "number") {
            stop = fillGradientStops[i];
          } else {
            stop = currentIteration / totalIterations;
          }
          gradient.addColorStop(stop, fill[i]);
          currentIteration++;
        }
      }
      return gradient;
    }
    function drawGlyph(canvas2, context2, metrics, x2, y2, resolution, style) {
      var char = metrics.text;
      var fontProperties = metrics.fontProperties;
      context2.translate(x2, y2);
      context2.scale(resolution, resolution);
      var tx = style.strokeThickness / 2;
      var ty = -(style.strokeThickness / 2);
      context2.font = style.toFontString();
      context2.lineWidth = style.strokeThickness;
      context2.textBaseline = style.textBaseline;
      context2.lineJoin = style.lineJoin;
      context2.miterLimit = style.miterLimit;
      context2.fillStyle = generateFillStyle(canvas2, context2, style, resolution, [char], metrics);
      context2.strokeStyle = style.stroke;
      context2.font = style.toFontString();
      context2.lineWidth = style.strokeThickness;
      context2.textBaseline = style.textBaseline;
      context2.lineJoin = style.lineJoin;
      context2.miterLimit = style.miterLimit;
      context2.fillStyle = generateFillStyle(canvas2, context2, style, resolution, [char], metrics);
      context2.strokeStyle = style.stroke;
      var dropShadowColor = style.dropShadowColor;
      var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
      if (style.dropShadow) {
        context2.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
        context2.shadowBlur = style.dropShadowBlur;
        context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
        context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;
      } else {
        context2.shadowColor = "0";
        context2.shadowBlur = 0;
        context2.shadowOffsetX = 0;
        context2.shadowOffsetY = 0;
      }
      if (style.stroke && style.strokeThickness) {
        context2.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
      }
      if (style.fill) {
        context2.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
      }
      context2.setTransform();
      context2.fillStyle = "rgba(0, 0, 0, 0)";
    }
    function resolveCharacters(chars) {
      if (typeof chars === "string") {
        chars = [chars];
      }
      var result2 = [];
      for (var i = 0, j = chars.length; i < j; i++) {
        var item = chars[i];
        if (Array.isArray(item)) {
          if (item.length !== 2) {
            throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + item.length + ".");
          }
          var startCode = item[0].charCodeAt(0);
          var endCode = item[1].charCodeAt(0);
          if (endCode < startCode) {
            throw new Error("[BitmapFont]: Invalid character range.");
          }
          for (var i_1 = startCode, j_1 = endCode; i_1 <= j_1; i_1++) {
            result2.push(String.fromCharCode(i_1));
          }
        } else {
          result2.push.apply(result2, item.split(""));
        }
      }
      if (result2.length === 0) {
        throw new Error("[BitmapFont]: Empty set when resolving characters.");
      }
      return result2;
    }
    var BitmapFont = function() {
      function BitmapFont2(data, textures) {
        var info = data.info[0];
        var common = data.common[0];
        var page = data.page[0];
        var res = getResolutionOfUrl(page.file);
        var pageTextures = {};
        this.font = info.face;
        this.size = info.size;
        this.lineHeight = common.lineHeight / res;
        this.chars = {};
        this.pageTextures = pageTextures;
        for (var i = 0; i < data.page.length; i++) {
          var _a2 = data.page[i], id2 = _a2.id, file = _a2.file;
          pageTextures[id2] = textures instanceof Array ? textures[i] : textures[file];
        }
        for (var i = 0; i < data.char.length; i++) {
          var _b = data.char[i], id2 = _b.id, page_1 = _b.page;
          var _c = data.char[i], x2 = _c.x, y2 = _c.y, width2 = _c.width, height2 = _c.height, xoffset = _c.xoffset, yoffset = _c.yoffset, xadvance = _c.xadvance;
          x2 /= res;
          y2 /= res;
          width2 /= res;
          height2 /= res;
          xoffset /= res;
          yoffset /= res;
          xadvance /= res;
          var rect = new Rectangle(x2 + pageTextures[page_1].frame.x / res, y2 + pageTextures[page_1].frame.y / res, width2, height2);
          this.chars[id2] = {
            xOffset: xoffset,
            yOffset: yoffset,
            xAdvance: xadvance,
            kerning: {},
            texture: new Texture(pageTextures[page_1].baseTexture, rect),
            page: page_1
          };
        }
        for (var i = 0; i < data.kerning.length; i++) {
          var _d = data.kerning[i], first2 = _d.first, second = _d.second, amount = _d.amount;
          first2 /= res;
          second /= res;
          amount /= res;
          if (this.chars[second]) {
            this.chars[second].kerning[first2] = amount;
          }
        }
      }
      BitmapFont2.prototype.destroy = function() {
        for (var id2 in this.chars) {
          this.chars[id2].texture.destroy();
          this.chars[id2].texture = null;
        }
        for (var id2 in this.pageTextures) {
          this.pageTextures[id2].destroy(true);
          this.pageTextures[id2] = null;
        }
        this.chars = null;
        this.pageTextures = null;
      };
      BitmapFont2.install = function(data, textures) {
        var fontData;
        if (data instanceof BitmapFontData) {
          fontData = data;
        } else {
          var format2 = autoDetectFormat(data);
          if (!format2) {
            throw new Error("Unrecognized data format for font.");
          }
          fontData = format2.parse(data);
        }
        if (textures instanceof Texture) {
          textures = [textures];
        }
        var font = new BitmapFont2(fontData, textures);
        BitmapFont2.available[font.font] = font;
        return font;
      };
      BitmapFont2.uninstall = function(name2) {
        var font = BitmapFont2.available[name2];
        if (!font) {
          throw new Error("No font found named '" + name2 + "'");
        }
        font.destroy();
        delete BitmapFont2.available[name2];
      };
      BitmapFont2.from = function(name2, textStyle, options) {
        if (!name2) {
          throw new Error("[BitmapFont] Property `name` is required.");
        }
        var _a2 = Object.assign({}, BitmapFont2.defaultOptions, options), chars = _a2.chars, padding = _a2.padding, resolution = _a2.resolution, textureWidth = _a2.textureWidth, textureHeight = _a2.textureHeight;
        var charsList = resolveCharacters(chars);
        var style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
        var lineWidth = textureWidth;
        var fontData = new BitmapFontData();
        fontData.info[0] = {
          face: style.fontFamily,
          size: style.fontSize
        };
        fontData.common[0] = {
          lineHeight: style.fontSize
        };
        var positionX = 0;
        var positionY = 0;
        var canvas2;
        var context2;
        var baseTexture;
        var maxCharHeight = 0;
        var textures = [];
        for (var i = 0; i < charsList.length; i++) {
          if (!canvas2) {
            canvas2 = document.createElement("canvas");
            canvas2.width = textureWidth;
            canvas2.height = textureHeight;
            context2 = canvas2.getContext("2d");
            baseTexture = new BaseTexture(canvas2, { resolution });
            textures.push(new Texture(baseTexture));
            fontData.page.push({
              id: textures.length - 1,
              file: ""
            });
          }
          var metrics = TextMetrics.measureText(charsList[i], style, false, canvas2);
          var width2 = metrics.width;
          var height2 = Math.ceil(metrics.height);
          var textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width2);
          if (positionY >= textureHeight - height2 * resolution) {
            if (positionY === 0) {
              throw new Error("[BitmapFont] textureHeight " + textureHeight + "px is " + ("too small for " + style.fontSize + "px fonts"));
            }
            --i;
            canvas2 = null;
            context2 = null;
            baseTexture = null;
            positionY = 0;
            positionX = 0;
            maxCharHeight = 0;
            continue;
          }
          maxCharHeight = Math.max(height2 + metrics.fontProperties.descent, maxCharHeight);
          if (textureGlyphWidth * resolution + positionX >= lineWidth) {
            --i;
            positionY += maxCharHeight * resolution;
            positionY = Math.ceil(positionY);
            positionX = 0;
            maxCharHeight = 0;
            continue;
          }
          drawGlyph(canvas2, context2, metrics, positionX, positionY, resolution, style);
          var id2 = metrics.text.charCodeAt(0);
          fontData.char.push({
            id: id2,
            page: textures.length - 1,
            x: positionX / resolution,
            y: positionY / resolution,
            width: textureGlyphWidth,
            height: height2,
            xoffset: 0,
            yoffset: 0,
            xadvance: Math.ceil(width2 - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))
          });
          positionX += (textureGlyphWidth + 2 * padding) * resolution;
          positionX = Math.ceil(positionX);
        }
        var font = new BitmapFont2(fontData, textures);
        if (BitmapFont2.available[name2] !== void 0) {
          BitmapFont2.uninstall(name2);
        }
        BitmapFont2.available[name2] = font;
        return font;
      };
      BitmapFont2.ALPHA = [["a", "z"], ["A", "Z"], " "];
      BitmapFont2.NUMERIC = [["0", "9"]];
      BitmapFont2.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
      BitmapFont2.ASCII = [[" ", "~"]];
      BitmapFont2.defaultOptions = {
        resolution: 1,
        textureWidth: 512,
        textureHeight: 512,
        padding: 4,
        chars: BitmapFont2.ALPHANUMERIC
      };
      BitmapFont2.available = {};
      return BitmapFont2;
    }();
    var pageMeshDataPool = [];
    var charRenderDataPool = [];
    (function(_super) {
      __extends$8(BitmapText, _super);
      function BitmapText(text, style) {
        if (style === void 0) {
          style = {};
        }
        var _this = _super.call(this) || this;
        _this._tint = 16777215;
        if (style.font) {
          deprecation("5.3.0", "PIXI.BitmapText constructor style.font property is deprecated.");
          _this._upgradeStyle(style);
        }
        var _a2 = Object.assign({}, BitmapText.styleDefaults, style), align = _a2.align, tint = _a2.tint, maxWidth = _a2.maxWidth, letterSpacing = _a2.letterSpacing, fontName = _a2.fontName, fontSize = _a2.fontSize;
        if (!BitmapFont.available[fontName]) {
          throw new Error('Missing BitmapFont "' + fontName + '"');
        }
        _this._activePagesMeshData = [];
        _this._textWidth = 0;
        _this._textHeight = 0;
        _this._align = align;
        _this._tint = tint;
        _this._fontName = fontName;
        _this._fontSize = fontSize || BitmapFont.available[fontName].size;
        _this._text = text;
        _this._maxWidth = maxWidth;
        _this._maxLineHeight = 0;
        _this._letterSpacing = letterSpacing;
        _this._anchor = new ObservablePoint(function() {
          _this.dirty = true;
        }, _this, 0, 0);
        _this.roundPixels = settings.ROUND_PIXELS;
        _this.dirty = true;
        return _this;
      }
      BitmapText.prototype.updateText = function() {
        var _a2;
        var data = BitmapFont.available[this._fontName];
        var scale = this._fontSize / data.size;
        var pos = new Point();
        var chars = [];
        var lineWidths = [];
        var text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
        var textLength = text.length;
        var maxWidth = this._maxWidth * data.size / this._fontSize;
        var prevCharCode = null;
        var lastLineWidth = 0;
        var maxLineWidth = 0;
        var line = 0;
        var lastBreakPos = -1;
        var lastBreakWidth = 0;
        var spacesRemoved = 0;
        var maxLineHeight = 0;
        for (var i = 0; i < textLength; i++) {
          var charCode = text.charCodeAt(i);
          var char = text.charAt(i);
          if (/(?:\s)/.test(char)) {
            lastBreakPos = i;
            lastBreakWidth = lastLineWidth;
          }
          if (char === "\r" || char === "\n") {
            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            ++line;
            ++spacesRemoved;
            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
          }
          var charData = data.chars[charCode];
          if (!charData) {
            continue;
          }
          if (prevCharCode && charData.kerning[prevCharCode]) {
            pos.x += charData.kerning[prevCharCode];
          }
          var charRenderData = charRenderDataPool.pop() || {
            texture: Texture.EMPTY,
            line: 0,
            charCode: 0,
            position: new Point()
          };
          charRenderData.texture = charData.texture;
          charRenderData.line = line;
          charRenderData.charCode = charCode;
          charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;
          charRenderData.position.y = pos.y + charData.yOffset;
          chars.push(charRenderData);
          pos.x += charData.xAdvance + this._letterSpacing;
          lastLineWidth = pos.x;
          maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
          prevCharCode = charCode;
          if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
            ++spacesRemoved;
            removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
            i = lastBreakPos;
            lastBreakPos = -1;
            lineWidths.push(lastBreakWidth);
            maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
            line++;
            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
          }
        }
        var lastChar = text.charAt(text.length - 1);
        if (lastChar !== "\r" && lastChar !== "\n") {
          if (/(?:\s)/.test(lastChar)) {
            lastLineWidth = lastBreakWidth;
          }
          lineWidths.push(lastLineWidth);
          maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        }
        var lineAlignOffsets = [];
        for (var i = 0; i <= line; i++) {
          var alignOffset = 0;
          if (this._align === "right") {
            alignOffset = maxLineWidth - lineWidths[i];
          } else if (this._align === "center") {
            alignOffset = (maxLineWidth - lineWidths[i]) / 2;
          }
          lineAlignOffsets.push(alignOffset);
        }
        var lenChars = chars.length;
        var pagesMeshData = {};
        var newPagesMeshData = [];
        var activePagesMeshData = this._activePagesMeshData;
        for (var i = 0; i < activePagesMeshData.length; i++) {
          pageMeshDataPool.push(activePagesMeshData[i]);
        }
        for (var i = 0; i < lenChars; i++) {
          var texture = chars[i].texture;
          var baseTextureUid = texture.baseTexture.uid;
          if (!pagesMeshData[baseTextureUid]) {
            var pageMeshData = pageMeshDataPool.pop();
            if (!pageMeshData) {
              var geometry = new MeshGeometry();
              var material = new MeshMaterial(Texture.EMPTY);
              var mesh = new Mesh(geometry, material);
              pageMeshData = {
                index: 0,
                indexCount: 0,
                vertexCount: 0,
                uvsCount: 0,
                total: 0,
                mesh,
                vertices: null,
                uvs: null,
                indices: null
              };
            }
            pageMeshData.index = 0;
            pageMeshData.indexCount = 0;
            pageMeshData.vertexCount = 0;
            pageMeshData.uvsCount = 0;
            pageMeshData.total = 0;
            pageMeshData.mesh.texture = new Texture(texture.baseTexture);
            pageMeshData.mesh.tint = this._tint;
            newPagesMeshData.push(pageMeshData);
            pagesMeshData[baseTextureUid] = pageMeshData;
          }
          pagesMeshData[baseTextureUid].total++;
        }
        for (var i = 0; i < activePagesMeshData.length; i++) {
          if (newPagesMeshData.indexOf(activePagesMeshData[i]) === -1) {
            this.removeChild(activePagesMeshData[i].mesh);
          }
        }
        for (var i = 0; i < newPagesMeshData.length; i++) {
          if (newPagesMeshData[i].mesh.parent !== this) {
            this.addChild(newPagesMeshData[i].mesh);
          }
        }
        this._activePagesMeshData = newPagesMeshData;
        for (var i in pagesMeshData) {
          var pageMeshData = pagesMeshData[i];
          var total = pageMeshData.total;
          if (!(((_a2 = pageMeshData.indices) === null || _a2 === void 0 ? void 0 : _a2.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
            pageMeshData.vertices = new Float32Array(4 * 2 * total);
            pageMeshData.uvs = new Float32Array(4 * 2 * total);
            pageMeshData.indices = new Uint16Array(6 * total);
          }
          pageMeshData.mesh.size = 6 * total;
        }
        for (var i = 0; i < lenChars; i++) {
          var char = chars[i];
          var xPos = (char.position.x + lineAlignOffsets[char.line]) * scale;
          var yPos = char.position.y * scale;
          var texture = char.texture;
          var pageMesh = pagesMeshData[texture.baseTexture.uid];
          var textureFrame = texture.frame;
          var textureUvs = texture._uvs;
          var index2 = pageMesh.index++;
          pageMesh.indices[index2 * 6 + 0] = 0 + index2 * 4;
          pageMesh.indices[index2 * 6 + 1] = 1 + index2 * 4;
          pageMesh.indices[index2 * 6 + 2] = 2 + index2 * 4;
          pageMesh.indices[index2 * 6 + 3] = 0 + index2 * 4;
          pageMesh.indices[index2 * 6 + 4] = 2 + index2 * 4;
          pageMesh.indices[index2 * 6 + 5] = 3 + index2 * 4;
          pageMesh.vertices[index2 * 8 + 0] = xPos;
          pageMesh.vertices[index2 * 8 + 1] = yPos;
          pageMesh.vertices[index2 * 8 + 2] = xPos + textureFrame.width * scale;
          pageMesh.vertices[index2 * 8 + 3] = yPos;
          pageMesh.vertices[index2 * 8 + 4] = xPos + textureFrame.width * scale;
          pageMesh.vertices[index2 * 8 + 5] = yPos + textureFrame.height * scale;
          pageMesh.vertices[index2 * 8 + 6] = xPos;
          pageMesh.vertices[index2 * 8 + 7] = yPos + textureFrame.height * scale;
          pageMesh.uvs[index2 * 8 + 0] = textureUvs.x0;
          pageMesh.uvs[index2 * 8 + 1] = textureUvs.y0;
          pageMesh.uvs[index2 * 8 + 2] = textureUvs.x1;
          pageMesh.uvs[index2 * 8 + 3] = textureUvs.y1;
          pageMesh.uvs[index2 * 8 + 4] = textureUvs.x2;
          pageMesh.uvs[index2 * 8 + 5] = textureUvs.y2;
          pageMesh.uvs[index2 * 8 + 6] = textureUvs.x3;
          pageMesh.uvs[index2 * 8 + 7] = textureUvs.y3;
        }
        this._textWidth = maxLineWidth * scale;
        this._textHeight = (pos.y + data.lineHeight) * scale;
        for (var i in pagesMeshData) {
          var pageMeshData = pagesMeshData[i];
          if (this.anchor.x !== 0 || this.anchor.y !== 0) {
            var vertexCount = 0;
            var anchorOffsetX = this._textWidth * this.anchor.x;
            var anchorOffsetY = this._textHeight * this.anchor.y;
            for (var i_1 = 0; i_1 < pageMeshData.total; i_1++) {
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            }
          }
          this._maxLineHeight = maxLineHeight * scale;
          var vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
          var textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
          var indexBuffer = pageMeshData.mesh.geometry.getIndex();
          vertexBuffer.data = pageMeshData.vertices;
          textureBuffer.data = pageMeshData.uvs;
          indexBuffer.data = pageMeshData.indices;
          vertexBuffer.update();
          textureBuffer.update();
          indexBuffer.update();
        }
        for (var i = 0; i < chars.length; i++) {
          charRenderDataPool.push(chars[i]);
        }
      };
      BitmapText.prototype.updateTransform = function() {
        this.validate();
        this.containerUpdateTransform();
      };
      BitmapText.prototype.getLocalBounds = function() {
        this.validate();
        return _super.prototype.getLocalBounds.call(this);
      };
      BitmapText.prototype.validate = function() {
        if (this.dirty) {
          this.updateText();
          this.dirty = false;
        }
      };
      Object.defineProperty(BitmapText.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value2) {
          if (this._tint === value2) {
            return;
          }
          this._tint = value2;
          for (var i = 0; i < this._activePagesMeshData.length; i++) {
            this._activePagesMeshData[i].mesh.tint = value2;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "align", {
        get: function() {
          return this._align;
        },
        set: function(value2) {
          if (this._align !== value2) {
            this._align = value2;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "fontName", {
        get: function() {
          return this._fontName;
        },
        set: function(value2) {
          if (!BitmapFont.available[value2]) {
            throw new Error('Missing BitmapFont "' + value2 + '"');
          }
          if (this._fontName !== value2) {
            this._fontName = value2;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "fontSize", {
        get: function() {
          return this._fontSize;
        },
        set: function(value2) {
          if (this._fontSize !== value2) {
            this._fontSize = value2;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "anchor", {
        get: function() {
          return this._anchor;
        },
        set: function(value2) {
          if (typeof value2 === "number") {
            this._anchor.set(value2);
          } else {
            this._anchor.copyFrom(value2);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "text", {
        get: function() {
          return this._text;
        },
        set: function(text) {
          text = String(text === null || text === void 0 ? "" : text);
          if (this._text === text) {
            return;
          }
          this._text = text;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "maxWidth", {
        get: function() {
          return this._maxWidth;
        },
        set: function(value2) {
          if (this._maxWidth === value2) {
            return;
          }
          this._maxWidth = value2;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "maxLineHeight", {
        get: function() {
          this.validate();
          return this._maxLineHeight;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "textWidth", {
        get: function() {
          this.validate();
          return this._textWidth;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "letterSpacing", {
        get: function() {
          return this._letterSpacing;
        },
        set: function(value2) {
          if (this._letterSpacing !== value2) {
            this._letterSpacing = value2;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "textHeight", {
        get: function() {
          this.validate();
          return this._textHeight;
        },
        enumerable: false,
        configurable: true
      });
      BitmapText.prototype._upgradeStyle = function(style) {
        if (typeof style.font === "string") {
          var valueSplit = style.font.split(" ");
          style.fontName = valueSplit.length === 1 ? valueSplit[0] : valueSplit.slice(1).join(" ");
          if (valueSplit.length >= 2) {
            style.fontSize = parseInt(valueSplit[0], 10);
          }
        } else {
          style.fontName = style.font.name;
          style.fontSize = typeof style.font.size === "number" ? style.font.size : parseInt(style.font.size, 10);
        }
      };
      BitmapText.registerFont = function(data, textures) {
        deprecation("5.3.0", "PIXI.BitmapText.registerFont is deprecated, use PIXI.BitmapFont.install");
        return BitmapFont.install(data, textures);
      };
      Object.defineProperty(BitmapText, "fonts", {
        get: function() {
          deprecation("5.3.0", "PIXI.BitmapText.fonts is deprecated, use PIXI.BitmapFont.available");
          return BitmapFont.available;
        },
        enumerable: false,
        configurable: true
      });
      BitmapText.styleDefaults = {
        align: "left",
        tint: 16777215,
        maxWidth: 0,
        letterSpacing: 0
      };
      return BitmapText;
    })(Container);
    var BitmapFontLoader = function() {
      function BitmapFontLoader2() {
      }
      BitmapFontLoader2.add = function() {
        LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT);
      };
      BitmapFontLoader2.use = function(resource, next) {
        var format2 = autoDetectFormat(resource.data);
        if (!format2) {
          next();
          return;
        }
        var baseUrl = BitmapFontLoader2.getBaseUrl(this, resource);
        var data = format2.parse(resource.data);
        var textures = {};
        var completed = function(page) {
          textures[page.metadata.pageFile] = page.texture;
          if (Object.keys(textures).length === data.page.length) {
            resource.bitmapFont = BitmapFont.install(data, textures);
            next();
          }
        };
        for (var i = 0; i < data.page.length; ++i) {
          var pageFile = data.page[i].file;
          var url2 = baseUrl + pageFile;
          var exists = false;
          for (var name2 in this.resources) {
            var bitmapResource = this.resources[name2];
            if (bitmapResource.url === url2) {
              bitmapResource.metadata.pageFile = pageFile;
              if (bitmapResource.texture) {
                completed(bitmapResource);
              } else {
                bitmapResource.onAfterMiddleware.add(completed);
              }
              exists = true;
              break;
            }
          }
          if (!exists) {
            var options = {
              crossOrigin: resource.crossOrigin,
              loadType: LoaderResource.LOAD_TYPE.IMAGE,
              metadata: Object.assign({ pageFile }, resource.metadata.imageMetadata),
              parentResource: resource
            };
            this.add(url2, options, completed);
          }
        }
      };
      BitmapFontLoader2.getBaseUrl = function(loader, resource) {
        var resUrl = !resource.isDataUrl ? BitmapFontLoader2.dirname(resource.url) : "";
        if (resource.isDataUrl) {
          if (resUrl === ".") {
            resUrl = "";
          }
          if (loader.baseUrl && resUrl) {
            if (loader.baseUrl.charAt(loader.baseUrl.length - 1) === "/") {
              resUrl += "/";
            }
          }
        }
        resUrl = resUrl.replace(loader.baseUrl, "");
        if (resUrl && resUrl.charAt(resUrl.length - 1) !== "/") {
          resUrl += "/";
        }
        return resUrl;
      };
      BitmapFontLoader2.dirname = function(url2) {
        var dir = url2.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
        if (dir === url2) {
          return ".";
        } else if (dir === "") {
          return "/";
        }
        return dir;
      };
      return BitmapFontLoader2;
    }();
    /*!
     * @pixi/filter-alpha - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/filter-alpha is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$7 = function(d, b) {
      extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$7(d, b);
    };
    function __extends$7(d, b) {
      extendStatics$7(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var fragment$4 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";
    (function(_super) {
      __extends$7(AlphaFilter, _super);
      function AlphaFilter(alpha) {
        if (alpha === void 0) {
          alpha = 1;
        }
        var _this = _super.call(this, _default, fragment$4, { uAlpha: 1 }) || this;
        _this.alpha = alpha;
        return _this;
      }
      Object.defineProperty(AlphaFilter.prototype, "alpha", {
        get: function() {
          return this.uniforms.uAlpha;
        },
        set: function(value2) {
          this.uniforms.uAlpha = value2;
        },
        enumerable: false,
        configurable: true
      });
      return AlphaFilter;
    })(Filter);
    /*!
     * @pixi/filter-blur - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/filter-blur is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$6 = function(d, b) {
      extendStatics$6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$6(d, b);
    };
    function __extends$6(d, b) {
      extendStatics$6(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
    function generateBlurVertSource(kernelSize, x2) {
      var halfLength = Math.ceil(kernelSize / 2);
      var vertSource = vertTemplate;
      var blurLoop = "";
      var template2;
      if (x2) {
        template2 = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
      } else {
        template2 = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
      }
      for (var i = 0; i < kernelSize; i++) {
        var blur = template2.replace("%index%", i.toString());
        blur = blur.replace("%sampleIndex%", i - (halfLength - 1) + ".0");
        blurLoop += blur;
        blurLoop += "\n";
      }
      vertSource = vertSource.replace("%blur%", blurLoop);
      vertSource = vertSource.replace("%size%", kernelSize.toString());
      return vertSource;
    }
    var GAUSSIAN_VALUES = {
      5: [0.153388, 0.221461, 0.250301],
      7: [0.071303, 0.131514, 0.189879, 0.214607],
      9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
      11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
      13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
      15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
    };
    var fragTemplate = [
      "varying vec2 vBlurTexCoords[%size%];",
      "uniform sampler2D uSampler;",
      "void main(void)",
      "{",
      "    gl_FragColor = vec4(0.0);",
      "    %blur%",
      "}"
    ].join("\n");
    function generateBlurFragSource(kernelSize) {
      var kernel = GAUSSIAN_VALUES[kernelSize];
      var halfLength = kernel.length;
      var fragSource = fragTemplate;
      var blurLoop = "";
      var template2 = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
      var value2;
      for (var i = 0; i < kernelSize; i++) {
        var blur = template2.replace("%index%", i.toString());
        value2 = i;
        if (i >= halfLength) {
          value2 = kernelSize - i - 1;
        }
        blur = blur.replace("%value%", kernel[value2].toString());
        blurLoop += blur;
        blurLoop += "\n";
      }
      fragSource = fragSource.replace("%blur%", blurLoop);
      fragSource = fragSource.replace("%size%", kernelSize.toString());
      return fragSource;
    }
    var ENV;
    (function(ENV2) {
      ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
      ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
      ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
    })(ENV || (ENV = {}));
    var RENDERER_TYPE;
    (function(RENDERER_TYPE2) {
      RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
      RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
      RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
    })(RENDERER_TYPE || (RENDERER_TYPE = {}));
    var BUFFER_BITS;
    (function(BUFFER_BITS2) {
      BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
      BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
      BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
    })(BUFFER_BITS || (BUFFER_BITS = {}));
    var BLEND_MODES;
    (function(BLEND_MODES2) {
      BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
      BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
      BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
      BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
      BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
      BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
      BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
      BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
      BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
      BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
      BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
      BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
      BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
      BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
      BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
      BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
      BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
      BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
      BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
      BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
      BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
      BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
      BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
      BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
      BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
      BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
      BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
      BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
      BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
      BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
      BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
      BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
    })(BLEND_MODES || (BLEND_MODES = {}));
    var DRAW_MODES;
    (function(DRAW_MODES2) {
      DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
      DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
      DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
      DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
      DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
      DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
      DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    })(DRAW_MODES || (DRAW_MODES = {}));
    var FORMATS;
    (function(FORMATS2) {
      FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
      FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
      FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
      FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
      FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    })(FORMATS || (FORMATS = {}));
    var TARGETS;
    (function(TARGETS2) {
      TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    })(TARGETS || (TARGETS = {}));
    var TYPES;
    (function(TYPES2) {
      TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
      TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
    })(TYPES || (TYPES = {}));
    var SCALE_MODES;
    (function(SCALE_MODES2) {
      SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
      SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
    })(SCALE_MODES || (SCALE_MODES = {}));
    var WRAP_MODES;
    (function(WRAP_MODES2) {
      WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
      WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
      WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    })(WRAP_MODES || (WRAP_MODES = {}));
    var MIPMAP_MODES;
    (function(MIPMAP_MODES2) {
      MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
      MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
      MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
    })(MIPMAP_MODES || (MIPMAP_MODES = {}));
    var ALPHA_MODES;
    (function(ALPHA_MODES2) {
      ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
      ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
      ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
      ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
      ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
      ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
    })(ALPHA_MODES || (ALPHA_MODES = {}));
    var CLEAR_MODES;
    (function(CLEAR_MODES2) {
      CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
      CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
      CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
      CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
      CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
      CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
    })(CLEAR_MODES || (CLEAR_MODES = {}));
    var GC_MODES;
    (function(GC_MODES2) {
      GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
      GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
    })(GC_MODES || (GC_MODES = {}));
    var PRECISION;
    (function(PRECISION2) {
      PRECISION2["LOW"] = "lowp";
      PRECISION2["MEDIUM"] = "mediump";
      PRECISION2["HIGH"] = "highp";
    })(PRECISION || (PRECISION = {}));
    var MASK_TYPES;
    (function(MASK_TYPES2) {
      MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
      MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
      MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
      MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
    })(MASK_TYPES || (MASK_TYPES = {}));
    var MSAA_QUALITY;
    (function(MSAA_QUALITY2) {
      MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
      MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
      MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
      MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
    })(MSAA_QUALITY || (MSAA_QUALITY = {}));
    var BlurFilterPass = function(_super) {
      __extends$6(BlurFilterPass2, _super);
      function BlurFilterPass2(horizontal, strength, quality, resolution, kernelSize) {
        if (strength === void 0) {
          strength = 8;
        }
        if (quality === void 0) {
          quality = 4;
        }
        if (resolution === void 0) {
          resolution = settings.RESOLUTION;
        }
        if (kernelSize === void 0) {
          kernelSize = 5;
        }
        var _this = this;
        var vertSrc = generateBlurVertSource(kernelSize, horizontal);
        var fragSrc = generateBlurFragSource(kernelSize);
        _this = _super.call(
          this,
          vertSrc,
          fragSrc
        ) || this;
        _this.horizontal = horizontal;
        _this.resolution = resolution;
        _this._quality = 0;
        _this.quality = quality;
        _this.blur = strength;
        return _this;
      }
      BlurFilterPass2.prototype.apply = function(filterManager, input, output, clearMode) {
        if (output) {
          if (this.horizontal) {
            this.uniforms.strength = 1 / output.width * (output.width / input.width);
          } else {
            this.uniforms.strength = 1 / output.height * (output.height / input.height);
          }
        } else {
          if (this.horizontal) {
            this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
          } else {
            this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
          }
        }
        this.uniforms.strength *= this.strength;
        this.uniforms.strength /= this.passes;
        if (this.passes === 1) {
          filterManager.applyFilter(this, input, output, clearMode);
        } else {
          var renderTarget = filterManager.getFilterTexture();
          var renderer = filterManager.renderer;
          var flip = input;
          var flop = renderTarget;
          this.state.blend = false;
          filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);
          for (var i = 1; i < this.passes - 1; i++) {
            filterManager.bindAndClear(flip, CLEAR_MODES.BLIT);
            this.uniforms.uSampler = flop;
            var temp2 = flop;
            flop = flip;
            flip = temp2;
            renderer.shader.bind(this);
            renderer.geometry.draw(5);
          }
          this.state.blend = true;
          filterManager.applyFilter(this, flop, output, clearMode);
          filterManager.returnFilterTexture(renderTarget);
        }
      };
      Object.defineProperty(BlurFilterPass2.prototype, "blur", {
        get: function() {
          return this.strength;
        },
        set: function(value2) {
          this.padding = 1 + Math.abs(value2) * 2;
          this.strength = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilterPass2.prototype, "quality", {
        get: function() {
          return this._quality;
        },
        set: function(value2) {
          this._quality = value2;
          this.passes = value2;
        },
        enumerable: false,
        configurable: true
      });
      return BlurFilterPass2;
    }(Filter);
    (function(_super) {
      __extends$6(BlurFilter, _super);
      function BlurFilter(strength, quality, resolution, kernelSize) {
        if (strength === void 0) {
          strength = 8;
        }
        if (quality === void 0) {
          quality = 4;
        }
        if (resolution === void 0) {
          resolution = settings.RESOLUTION;
        }
        if (kernelSize === void 0) {
          kernelSize = 5;
        }
        var _this = _super.call(this) || this;
        _this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
        _this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
        _this.resolution = resolution;
        _this.quality = quality;
        _this.blur = strength;
        _this.repeatEdgePixels = false;
        return _this;
      }
      BlurFilter.prototype.apply = function(filterManager, input, output, clearMode) {
        var xStrength = Math.abs(this.blurXFilter.strength);
        var yStrength = Math.abs(this.blurYFilter.strength);
        if (xStrength && yStrength) {
          var renderTarget = filterManager.getFilterTexture();
          this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR);
          this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
          filterManager.returnFilterTexture(renderTarget);
        } else if (yStrength) {
          this.blurYFilter.apply(filterManager, input, output, clearMode);
        } else {
          this.blurXFilter.apply(filterManager, input, output, clearMode);
        }
      };
      BlurFilter.prototype.updatePadding = function() {
        if (this._repeatEdgePixels) {
          this.padding = 0;
        } else {
          this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
        }
      };
      Object.defineProperty(BlurFilter.prototype, "blur", {
        get: function() {
          return this.blurXFilter.blur;
        },
        set: function(value2) {
          this.blurXFilter.blur = this.blurYFilter.blur = value2;
          this.updatePadding();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter.prototype, "quality", {
        get: function() {
          return this.blurXFilter.quality;
        },
        set: function(value2) {
          this.blurXFilter.quality = this.blurYFilter.quality = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter.prototype, "blurX", {
        get: function() {
          return this.blurXFilter.blur;
        },
        set: function(value2) {
          this.blurXFilter.blur = value2;
          this.updatePadding();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter.prototype, "blurY", {
        get: function() {
          return this.blurYFilter.blur;
        },
        set: function(value2) {
          this.blurYFilter.blur = value2;
          this.updatePadding();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter.prototype, "blendMode", {
        get: function() {
          return this.blurYFilter.blendMode;
        },
        set: function(value2) {
          this.blurYFilter.blendMode = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter.prototype, "repeatEdgePixels", {
        get: function() {
          return this._repeatEdgePixels;
        },
        set: function(value2) {
          this._repeatEdgePixels = value2;
          this.updatePadding();
        },
        enumerable: false,
        configurable: true
      });
      return BlurFilter;
    })(Filter);
    /*!
     * @pixi/filter-color-matrix - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/filter-color-matrix is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$5 = function(d, b) {
      extendStatics$5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$5(d, b);
    };
    function __extends$5(d, b) {
      extendStatics$5(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var fragment$3 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
    var ColorMatrixFilter = function(_super) {
      __extends$5(ColorMatrixFilter2, _super);
      function ColorMatrixFilter2() {
        var _this = this;
        var uniforms = {
          m: new Float32Array([
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ]),
          uAlpha: 1
        };
        _this = _super.call(this, defaultFilter, fragment$3, uniforms) || this;
        _this.alpha = 1;
        return _this;
      }
      ColorMatrixFilter2.prototype._loadMatrix = function(matrix, multiply) {
        if (multiply === void 0) {
          multiply = false;
        }
        var newMatrix = matrix;
        if (multiply) {
          this._multiply(newMatrix, this.uniforms.m, matrix);
          newMatrix = this._colorMatrix(newMatrix);
        }
        this.uniforms.m = newMatrix;
      };
      ColorMatrixFilter2.prototype._multiply = function(out, a, b) {
        out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
        out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
        out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
        out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
        out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];
        out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
        out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
        out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
        out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
        out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];
        out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
        out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
        out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
        out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
        out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];
        out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
        out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
        out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
        out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
        out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];
        return out;
      };
      ColorMatrixFilter2.prototype._colorMatrix = function(matrix) {
        var m2 = new Float32Array(matrix);
        m2[4] /= 255;
        m2[9] /= 255;
        m2[14] /= 255;
        m2[19] /= 255;
        return m2;
      };
      ColorMatrixFilter2.prototype.brightness = function(b, multiply) {
        var matrix = [
          b,
          0,
          0,
          0,
          0,
          0,
          b,
          0,
          0,
          0,
          0,
          0,
          b,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.greyscale = function(scale, multiply) {
        var matrix = [
          scale,
          scale,
          scale,
          0,
          0,
          scale,
          scale,
          scale,
          0,
          0,
          scale,
          scale,
          scale,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.blackAndWhite = function(multiply) {
        var matrix = [
          0.3,
          0.6,
          0.1,
          0,
          0,
          0.3,
          0.6,
          0.1,
          0,
          0,
          0.3,
          0.6,
          0.1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.hue = function(rotation, multiply) {
        rotation = (rotation || 0) / 180 * Math.PI;
        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);
        var sqrt = Math.sqrt;
        var w2 = 1 / 3;
        var sqrW = sqrt(w2);
        var a00 = cosR + (1 - cosR) * w2;
        var a01 = w2 * (1 - cosR) - sqrW * sinR;
        var a02 = w2 * (1 - cosR) + sqrW * sinR;
        var a10 = w2 * (1 - cosR) + sqrW * sinR;
        var a11 = cosR + w2 * (1 - cosR);
        var a12 = w2 * (1 - cosR) - sqrW * sinR;
        var a20 = w2 * (1 - cosR) - sqrW * sinR;
        var a21 = w2 * (1 - cosR) + sqrW * sinR;
        var a22 = cosR + w2 * (1 - cosR);
        var matrix = [
          a00,
          a01,
          a02,
          0,
          0,
          a10,
          a11,
          a12,
          0,
          0,
          a20,
          a21,
          a22,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.contrast = function(amount, multiply) {
        var v2 = (amount || 0) + 1;
        var o = -0.5 * (v2 - 1);
        var matrix = [
          v2,
          0,
          0,
          0,
          o,
          0,
          v2,
          0,
          0,
          o,
          0,
          0,
          v2,
          0,
          o,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.saturate = function(amount, multiply) {
        if (amount === void 0) {
          amount = 0;
        }
        var x2 = amount * 2 / 3 + 1;
        var y2 = (x2 - 1) * -0.5;
        var matrix = [
          x2,
          y2,
          y2,
          0,
          0,
          y2,
          x2,
          y2,
          0,
          0,
          y2,
          y2,
          x2,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.desaturate = function() {
        this.saturate(-1);
      };
      ColorMatrixFilter2.prototype.negative = function(multiply) {
        var matrix = [
          -1,
          0,
          0,
          1,
          0,
          0,
          -1,
          0,
          1,
          0,
          0,
          0,
          -1,
          1,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.sepia = function(multiply) {
        var matrix = [
          0.393,
          0.7689999,
          0.18899999,
          0,
          0,
          0.349,
          0.6859999,
          0.16799999,
          0,
          0,
          0.272,
          0.5339999,
          0.13099999,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.technicolor = function(multiply) {
        var matrix = [
          1.9125277891456083,
          -0.8545344976951645,
          -0.09155508482755585,
          0,
          11.793603434377337,
          -0.3087833385928097,
          1.7658908555458428,
          -0.10601743074722245,
          0,
          -70.35205161461398,
          -0.231103377548616,
          -0.7501899197440212,
          1.847597816108189,
          0,
          30.950940869491138,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.polaroid = function(multiply) {
        var matrix = [
          1.438,
          -0.062,
          -0.062,
          0,
          0,
          -0.122,
          1.378,
          -0.122,
          0,
          0,
          -0.016,
          -0.016,
          1.483,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.toBGR = function(multiply) {
        var matrix = [
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.kodachrome = function(multiply) {
        var matrix = [
          1.1285582396593525,
          -0.3967382283601348,
          -0.03992559172921793,
          0,
          63.72958762196502,
          -0.16404339962244616,
          1.0835251566291304,
          -0.05498805115633132,
          0,
          24.732407896706203,
          -0.16786010706155763,
          -0.5603416277695248,
          1.6014850761964943,
          0,
          35.62982807460946,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.browni = function(multiply) {
        var matrix = [
          0.5997023498159715,
          0.34553243048391263,
          -0.2708298674538042,
          0,
          47.43192855600873,
          -0.037703249837783157,
          0.8609577587992641,
          0.15059552388459913,
          0,
          -36.96841498319127,
          0.24113635128153335,
          -0.07441037908422492,
          0.44972182064877153,
          0,
          -7.562075277591283,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.vintage = function(multiply) {
        var matrix = [
          0.6279345635605994,
          0.3202183420819367,
          -0.03965408211312453,
          0,
          9.651285835294123,
          0.02578397704808868,
          0.6441188644374771,
          0.03259127616149294,
          0,
          7.462829176470591,
          0.0466055556782719,
          -0.0851232987247891,
          0.5241648018700465,
          0,
          5.159190588235296,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.colorTone = function(desaturation, toned, lightColor, darkColor, multiply) {
        desaturation = desaturation || 0.2;
        toned = toned || 0.15;
        lightColor = lightColor || 16770432;
        darkColor = darkColor || 3375104;
        var lR = (lightColor >> 16 & 255) / 255;
        var lG = (lightColor >> 8 & 255) / 255;
        var lB = (lightColor & 255) / 255;
        var dR = (darkColor >> 16 & 255) / 255;
        var dG = (darkColor >> 8 & 255) / 255;
        var dB = (darkColor & 255) / 255;
        var matrix = [
          0.3,
          0.59,
          0.11,
          0,
          0,
          lR,
          lG,
          lB,
          desaturation,
          0,
          dR,
          dG,
          dB,
          toned,
          0,
          lR - dR,
          lG - dG,
          lB - dB,
          0,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.night = function(intensity, multiply) {
        intensity = intensity || 0.1;
        var matrix = [
          intensity * -2,
          -intensity,
          0,
          0,
          0,
          -intensity,
          0,
          intensity,
          0,
          0,
          0,
          intensity,
          intensity * 2,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.predator = function(amount, multiply) {
        var matrix = [
          11.224130630493164 * amount,
          -4.794486999511719 * amount,
          -2.8746118545532227 * amount,
          0 * amount,
          0.40342438220977783 * amount,
          -3.6330697536468506 * amount,
          9.193157196044922 * amount,
          -2.951810836791992 * amount,
          0 * amount,
          -1.316135048866272 * amount,
          -3.2184197902679443 * amount,
          -4.2375030517578125 * amount,
          7.476448059082031 * amount,
          0 * amount,
          0.8044459223747253 * amount,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.lsd = function(multiply) {
        var matrix = [
          2,
          -0.4,
          0.5,
          0,
          0,
          -0.5,
          2,
          -0.4,
          0,
          0,
          -0.4,
          -0.5,
          3,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.reset = function() {
        var matrix = [
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, false);
      };
      Object.defineProperty(ColorMatrixFilter2.prototype, "matrix", {
        get: function() {
          return this.uniforms.m;
        },
        set: function(value2) {
          this.uniforms.m = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorMatrixFilter2.prototype, "alpha", {
        get: function() {
          return this.uniforms.uAlpha;
        },
        set: function(value2) {
          this.uniforms.uAlpha = value2;
        },
        enumerable: false,
        configurable: true
      });
      return ColorMatrixFilter2;
    }(Filter);
    ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
    /*!
     * @pixi/filter-displacement - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/filter-displacement is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$4 = function(d, b) {
      extendStatics$4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$4(d, b);
    };
    function __extends$4(d, b) {
      extendStatics$4(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var fragment$2 = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";
    var vertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";
    (function(_super) {
      __extends$4(DisplacementFilter, _super);
      function DisplacementFilter(sprite, scale) {
        var _this = this;
        var maskMatrix = new Matrix();
        sprite.renderable = false;
        _this = _super.call(this, vertex$1, fragment$2, {
          mapSampler: sprite._texture,
          filterMatrix: maskMatrix,
          scale: { x: 1, y: 1 },
          rotation: new Float32Array([1, 0, 0, 1])
        }) || this;
        _this.maskSprite = sprite;
        _this.maskMatrix = maskMatrix;
        if (scale === null || scale === void 0) {
          scale = 20;
        }
        _this.scale = new Point(scale, scale);
        return _this;
      }
      DisplacementFilter.prototype.apply = function(filterManager, input, output, clearMode) {
        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
        this.uniforms.scale.x = this.scale.x;
        this.uniforms.scale.y = this.scale.y;
        var wt = this.maskSprite.worldTransform;
        var lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
        var lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
        if (lenX !== 0 && lenY !== 0) {
          this.uniforms.rotation[0] = wt.a / lenX;
          this.uniforms.rotation[1] = wt.b / lenX;
          this.uniforms.rotation[2] = wt.c / lenY;
          this.uniforms.rotation[3] = wt.d / lenY;
        }
        filterManager.applyFilter(this, input, output, clearMode);
      };
      Object.defineProperty(DisplacementFilter.prototype, "map", {
        get: function() {
          return this.uniforms.mapSampler;
        },
        set: function(value2) {
          this.uniforms.mapSampler = value2;
        },
        enumerable: false,
        configurable: true
      });
      return DisplacementFilter;
    })(Filter);
    /*!
     * @pixi/filter-fxaa - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/filter-fxaa is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$3 = function(d, b) {
      extendStatics$3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$3(d, b);
    };
    function __extends$3(d, b) {
      extendStatics$3(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var vertex = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputPixel;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";
    var fragment$1 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputPixel;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
    (function(_super) {
      __extends$3(FXAAFilter, _super);
      function FXAAFilter() {
        return _super.call(this, vertex, fragment$1) || this;
      }
      return FXAAFilter;
    })(Filter);
    /*!
     * @pixi/filter-noise - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/filter-noise is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$2 = function(d, b) {
      extendStatics$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$2(d, b);
    };
    function __extends$2(d, b) {
      extendStatics$2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var fragment = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";
    (function(_super) {
      __extends$2(NoiseFilter, _super);
      function NoiseFilter(noise, seed) {
        if (noise === void 0) {
          noise = 0.5;
        }
        if (seed === void 0) {
          seed = Math.random();
        }
        var _this = _super.call(this, defaultFilter, fragment, {
          uNoise: 0,
          uSeed: 0
        }) || this;
        _this.noise = noise;
        _this.seed = seed;
        return _this;
      }
      Object.defineProperty(NoiseFilter.prototype, "noise", {
        get: function() {
          return this.uniforms.uNoise;
        },
        set: function(value2) {
          this.uniforms.uNoise = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NoiseFilter.prototype, "seed", {
        get: function() {
          return this.uniforms.uSeed;
        },
        set: function(value2) {
          this.uniforms.uSeed = value2;
        },
        enumerable: false,
        configurable: true
      });
      return NoiseFilter;
    })(Filter);
    /*!
     * @pixi/mixin-cache-as-bitmap - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var _tempMatrix = new Matrix();
    DisplayObject.prototype._cacheAsBitmap = false;
    DisplayObject.prototype._cacheData = null;
    var CacheData = function() {
      function CacheData2() {
        this.textureCacheId = null;
        this.originalRender = null;
        this.originalRenderCanvas = null;
        this.originalCalculateBounds = null;
        this.originalGetLocalBounds = null;
        this.originalUpdateTransform = null;
        this.originalDestroy = null;
        this.originalMask = null;
        this.originalFilterArea = null;
        this.originalContainsPoint = null;
        this.sprite = null;
      }
      return CacheData2;
    }();
    Object.defineProperties(DisplayObject.prototype, {
      cacheAsBitmap: {
        get: function() {
          return this._cacheAsBitmap;
        },
        set: function(value2) {
          if (this._cacheAsBitmap === value2) {
            return;
          }
          this._cacheAsBitmap = value2;
          var data;
          if (value2) {
            if (!this._cacheData) {
              this._cacheData = new CacheData();
            }
            data = this._cacheData;
            data.originalRender = this.render;
            data.originalRenderCanvas = this.renderCanvas;
            data.originalUpdateTransform = this.updateTransform;
            data.originalCalculateBounds = this.calculateBounds;
            data.originalGetLocalBounds = this.getLocalBounds;
            data.originalDestroy = this.destroy;
            data.originalContainsPoint = this.containsPoint;
            data.originalMask = this._mask;
            data.originalFilterArea = this.filterArea;
            this.render = this._renderCached;
            this.renderCanvas = this._renderCachedCanvas;
            this.destroy = this._cacheAsBitmapDestroy;
          } else {
            data = this._cacheData;
            if (data.sprite) {
              this._destroyCachedDisplayObject();
            }
            this.render = data.originalRender;
            this.renderCanvas = data.originalRenderCanvas;
            this.calculateBounds = data.originalCalculateBounds;
            this.getLocalBounds = data.originalGetLocalBounds;
            this.destroy = data.originalDestroy;
            this.updateTransform = data.originalUpdateTransform;
            this.containsPoint = data.originalContainsPoint;
            this._mask = data.originalMask;
            this.filterArea = data.originalFilterArea;
          }
        }
      }
    });
    DisplayObject.prototype._renderCached = function _renderCached(renderer) {
      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
      }
      this._initCachedDisplayObject(renderer);
      this._cacheData.sprite.transform._worldID = this.transform._worldID;
      this._cacheData.sprite.worldAlpha = this.worldAlpha;
      this._cacheData.sprite._render(renderer);
    };
    DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
      if (this._cacheData && this._cacheData.sprite) {
        return;
      }
      var cacheAlpha = this.alpha;
      this.alpha = 1;
      renderer.batch.flush();
      var bounds = this.getLocalBounds(null, true).clone();
      if (this.filters) {
        var padding = this.filters[0].padding;
        bounds.pad(padding);
      }
      bounds.ceil(settings.RESOLUTION);
      var cachedRenderTexture = renderer.renderTexture.current;
      var cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
      var cachedProjectionTransform = renderer.projection.transform;
      var renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
      var textureCacheId = "cacheAsBitmap_" + uid();
      this._cacheData.textureCacheId = textureCacheId;
      BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
      Texture.addToCache(renderTexture, textureCacheId);
      var m2 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
      this.render = this._cacheData.originalRender;
      renderer.render(this, renderTexture, true, m2, false);
      renderer.projection.transform = cachedProjectionTransform;
      renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame);
      this.render = this._renderCached;
      this.updateTransform = this.displayObjectUpdateTransform;
      this.calculateBounds = this._calculateCachedBounds;
      this.getLocalBounds = this._getCachedLocalBounds;
      this._mask = null;
      this.filterArea = null;
      var cachedSprite = new Sprite(renderTexture);
      cachedSprite.transform.worldTransform = this.transform.worldTransform;
      cachedSprite.anchor.x = -(bounds.x / bounds.width);
      cachedSprite.anchor.y = -(bounds.y / bounds.height);
      cachedSprite.alpha = cacheAlpha;
      cachedSprite._bounds = this._bounds;
      this._cacheData.sprite = cachedSprite;
      this.transform._parentID = -1;
      if (!this.parent) {
        this.enableTempParent();
        this.updateTransform();
        this.disableTempParent(null);
      } else {
        this.updateTransform();
      }
      this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    };
    DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
      }
      this._initCachedDisplayObjectCanvas(renderer);
      this._cacheData.sprite.worldAlpha = this.worldAlpha;
      this._cacheData.sprite._renderCanvas(renderer);
    };
    DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
      if (this._cacheData && this._cacheData.sprite) {
        return;
      }
      var bounds = this.getLocalBounds(null, true);
      var cacheAlpha = this.alpha;
      this.alpha = 1;
      var cachedRenderTarget = renderer.context;
      var cachedProjectionTransform = renderer._projTransform;
      bounds.ceil(settings.RESOLUTION);
      var renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
      var textureCacheId = "cacheAsBitmap_" + uid();
      this._cacheData.textureCacheId = textureCacheId;
      BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
      Texture.addToCache(renderTexture, textureCacheId);
      var m2 = _tempMatrix;
      this.transform.localTransform.copyTo(m2);
      m2.invert();
      m2.tx -= bounds.x;
      m2.ty -= bounds.y;
      this.renderCanvas = this._cacheData.originalRenderCanvas;
      renderer.render(this, renderTexture, true, m2, false);
      renderer.context = cachedRenderTarget;
      renderer._projTransform = cachedProjectionTransform;
      this.renderCanvas = this._renderCachedCanvas;
      this.updateTransform = this.displayObjectUpdateTransform;
      this.calculateBounds = this._calculateCachedBounds;
      this.getLocalBounds = this._getCachedLocalBounds;
      this._mask = null;
      this.filterArea = null;
      var cachedSprite = new Sprite(renderTexture);
      cachedSprite.transform.worldTransform = this.transform.worldTransform;
      cachedSprite.anchor.x = -(bounds.x / bounds.width);
      cachedSprite.anchor.y = -(bounds.y / bounds.height);
      cachedSprite.alpha = cacheAlpha;
      cachedSprite._bounds = this._bounds;
      this._cacheData.sprite = cachedSprite;
      this.transform._parentID = -1;
      if (!this.parent) {
        this.parent = renderer._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this.updateTransform();
      }
      this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    };
    DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
      this._bounds.clear();
      this._cacheData.sprite.transform._worldID = this.transform._worldID;
      this._cacheData.sprite._calculateBounds();
      this._bounds.updateID = this._boundsID;
    };
    DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
      return this._cacheData.sprite.getLocalBounds(null);
    };
    DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
      this._cacheData.sprite._texture.destroy(true);
      this._cacheData.sprite = null;
      BaseTexture.removeFromCache(this._cacheData.textureCacheId);
      Texture.removeFromCache(this._cacheData.textureCacheId);
      this._cacheData.textureCacheId = null;
    };
    DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
      this.cacheAsBitmap = false;
      this.destroy(options);
    };
    /*!
     * @pixi/mixin-get-child-by-name - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/mixin-get-child-by-name is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    DisplayObject.prototype.name = null;
    Container.prototype.getChildByName = function getChildByName(name2, deep) {
      for (var i = 0, j = this.children.length; i < j; i++) {
        if (this.children[i].name === name2) {
          return this.children[i];
        }
      }
      if (deep) {
        for (var i = 0, j = this.children.length; i < j; i++) {
          var child = this.children[i];
          if (!child.getChildByName) {
            continue;
          }
          var target = this.children[i].getChildByName(name2, true);
          if (target) {
            return target;
          }
        }
      }
      return null;
    };
    /*!
     * @pixi/mixin-get-global-position - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/mixin-get-global-position is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point, skipUpdate) {
      if (point === void 0) {
        point = new Point();
      }
      if (skipUpdate === void 0) {
        skipUpdate = false;
      }
      if (this.parent) {
        this.parent.toGlobal(this.position, point, skipUpdate);
      } else {
        point.x = this.position.x;
        point.y = this.position.y;
      }
      return point;
    };
    /*!
     * @pixi/mesh-extras - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/mesh-extras is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$1 = function(d, b) {
      extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$1(d, b);
    };
    function __extends$1(d, b) {
      extendStatics$1(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var PlaneGeometry = function(_super) {
      __extends$1(PlaneGeometry2, _super);
      function PlaneGeometry2(width2, height2, segWidth, segHeight) {
        if (width2 === void 0) {
          width2 = 100;
        }
        if (height2 === void 0) {
          height2 = 100;
        }
        if (segWidth === void 0) {
          segWidth = 10;
        }
        if (segHeight === void 0) {
          segHeight = 10;
        }
        var _this = _super.call(this) || this;
        _this.segWidth = segWidth;
        _this.segHeight = segHeight;
        _this.width = width2;
        _this.height = height2;
        _this.build();
        return _this;
      }
      PlaneGeometry2.prototype.build = function() {
        var total = this.segWidth * this.segHeight;
        var verts = [];
        var uvs = [];
        var indices2 = [];
        var segmentsX = this.segWidth - 1;
        var segmentsY = this.segHeight - 1;
        var sizeX = this.width / segmentsX;
        var sizeY = this.height / segmentsY;
        for (var i = 0; i < total; i++) {
          var x2 = i % this.segWidth;
          var y2 = i / this.segWidth | 0;
          verts.push(x2 * sizeX, y2 * sizeY);
          uvs.push(x2 / segmentsX, y2 / segmentsY);
        }
        var totalSub = segmentsX * segmentsY;
        for (var i = 0; i < totalSub; i++) {
          var xpos = i % segmentsX;
          var ypos = i / segmentsX | 0;
          var value2 = ypos * this.segWidth + xpos;
          var value22 = ypos * this.segWidth + xpos + 1;
          var value3 = (ypos + 1) * this.segWidth + xpos;
          var value4 = (ypos + 1) * this.segWidth + xpos + 1;
          indices2.push(value2, value22, value3, value22, value4, value3);
        }
        this.buffers[0].data = new Float32Array(verts);
        this.buffers[1].data = new Float32Array(uvs);
        this.indexBuffer.data = new Uint16Array(indices2);
        this.buffers[0].update();
        this.buffers[1].update();
        this.indexBuffer.update();
      };
      return PlaneGeometry2;
    }(MeshGeometry);
    var RopeGeometry = function(_super) {
      __extends$1(RopeGeometry2, _super);
      function RopeGeometry2(width2, points, textureScale) {
        if (width2 === void 0) {
          width2 = 200;
        }
        if (textureScale === void 0) {
          textureScale = 0;
        }
        var _this = _super.call(this, new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6)) || this;
        _this.points = points;
        _this._width = width2;
        _this.textureScale = textureScale;
        _this.build();
        return _this;
      }
      Object.defineProperty(RopeGeometry2.prototype, "width", {
        get: function() {
          return this._width;
        },
        enumerable: false,
        configurable: true
      });
      RopeGeometry2.prototype.build = function() {
        var points = this.points;
        if (!points) {
          return;
        }
        var vertexBuffer = this.getBuffer("aVertexPosition");
        var uvBuffer = this.getBuffer("aTextureCoord");
        var indexBuffer = this.getIndex();
        if (points.length < 1) {
          return;
        }
        if (vertexBuffer.data.length / 4 !== points.length) {
          vertexBuffer.data = new Float32Array(points.length * 4);
          uvBuffer.data = new Float32Array(points.length * 4);
          indexBuffer.data = new Uint16Array((points.length - 1) * 6);
        }
        var uvs = uvBuffer.data;
        var indices2 = indexBuffer.data;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        var amount = 0;
        var prev = points[0];
        var textureWidth = this._width * this.textureScale;
        var total = points.length;
        for (var i = 0; i < total; i++) {
          var index2 = i * 4;
          if (this.textureScale > 0) {
            var dx = prev.x - points[i].x;
            var dy = prev.y - points[i].y;
            var distance = Math.sqrt(dx * dx + dy * dy);
            prev = points[i];
            amount += distance / textureWidth;
          } else {
            amount = i / (total - 1);
          }
          uvs[index2] = amount;
          uvs[index2 + 1] = 0;
          uvs[index2 + 2] = amount;
          uvs[index2 + 3] = 1;
        }
        var indexCount = 0;
        for (var i = 0; i < total - 1; i++) {
          var index2 = i * 2;
          indices2[indexCount++] = index2;
          indices2[indexCount++] = index2 + 1;
          indices2[indexCount++] = index2 + 2;
          indices2[indexCount++] = index2 + 2;
          indices2[indexCount++] = index2 + 1;
          indices2[indexCount++] = index2 + 3;
        }
        uvBuffer.update();
        indexBuffer.update();
        this.updateVertices();
      };
      RopeGeometry2.prototype.updateVertices = function() {
        var points = this.points;
        if (points.length < 1) {
          return;
        }
        var lastPoint = points[0];
        var nextPoint;
        var perpX = 0;
        var perpY = 0;
        var vertices = this.buffers[0].data;
        var total = points.length;
        for (var i = 0; i < total; i++) {
          var point = points[i];
          var index2 = i * 4;
          if (i < points.length - 1) {
            nextPoint = points[i + 1];
          } else {
            nextPoint = point;
          }
          perpY = -(nextPoint.x - lastPoint.x);
          perpX = nextPoint.y - lastPoint.y;
          var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
          var num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
          perpX /= perpLength;
          perpY /= perpLength;
          perpX *= num;
          perpY *= num;
          vertices[index2] = point.x + perpX;
          vertices[index2 + 1] = point.y + perpY;
          vertices[index2 + 2] = point.x - perpX;
          vertices[index2 + 3] = point.y - perpY;
          lastPoint = point;
        }
        this.buffers[0].update();
      };
      RopeGeometry2.prototype.update = function() {
        if (this.textureScale > 0) {
          this.build();
        } else {
          this.updateVertices();
        }
      };
      return RopeGeometry2;
    }(MeshGeometry);
    (function(_super) {
      __extends$1(SimpleRope, _super);
      function SimpleRope(texture, points, textureScale) {
        if (textureScale === void 0) {
          textureScale = 0;
        }
        var _this = this;
        var ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
        var meshMaterial = new MeshMaterial(texture);
        if (textureScale > 0) {
          texture.baseTexture.wrapMode = WRAP_MODES$1.REPEAT;
        }
        _this = _super.call(this, ropeGeometry, meshMaterial) || this;
        _this.autoUpdate = true;
        return _this;
      }
      SimpleRope.prototype._render = function(renderer) {
        var geometry = this.geometry;
        if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
          geometry._width = this.shader.texture.height;
          geometry.update();
        }
        _super.prototype._render.call(this, renderer);
      };
      return SimpleRope;
    })(Mesh);
    var SimplePlane = function(_super) {
      __extends$1(SimplePlane2, _super);
      function SimplePlane2(texture, verticesX, verticesY) {
        var _this = this;
        var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
        var meshMaterial = new MeshMaterial(Texture.WHITE);
        _this = _super.call(this, planeGeometry, meshMaterial) || this;
        _this.texture = texture;
        return _this;
      }
      SimplePlane2.prototype.textureUpdated = function() {
        this._textureID = this.shader.texture._updateID;
        var geometry = this.geometry;
        geometry.width = this.shader.texture.width;
        geometry.height = this.shader.texture.height;
        geometry.build();
      };
      Object.defineProperty(SimplePlane2.prototype, "texture", {
        get: function() {
          return this.shader.texture;
        },
        set: function(value2) {
          if (this.shader.texture === value2) {
            return;
          }
          this.shader.texture = value2;
          this._textureID = -1;
          if (value2.baseTexture.valid) {
            this.textureUpdated();
          } else {
            value2.once("update", this.textureUpdated, this);
          }
        },
        enumerable: false,
        configurable: true
      });
      SimplePlane2.prototype._render = function(renderer) {
        if (this._textureID !== this.shader.texture._updateID) {
          this.textureUpdated();
        }
        _super.prototype._render.call(this, renderer);
      };
      return SimplePlane2;
    }(Mesh);
    (function(_super) {
      __extends$1(SimpleMesh, _super);
      function SimpleMesh(texture, vertices, uvs, indices2, drawMode) {
        if (texture === void 0) {
          texture = Texture.EMPTY;
        }
        var _this = this;
        var geometry = new MeshGeometry(vertices, uvs, indices2);
        geometry.getBuffer("aVertexPosition").static = false;
        var meshMaterial = new MeshMaterial(texture);
        _this = _super.call(this, geometry, meshMaterial, null, drawMode) || this;
        _this.autoUpdate = true;
        return _this;
      }
      Object.defineProperty(SimpleMesh.prototype, "vertices", {
        get: function() {
          return this.geometry.getBuffer("aVertexPosition").data;
        },
        set: function(value2) {
          this.geometry.getBuffer("aVertexPosition").data = value2;
        },
        enumerable: false,
        configurable: true
      });
      SimpleMesh.prototype._render = function(renderer) {
        if (this.autoUpdate) {
          this.geometry.getBuffer("aVertexPosition").update();
        }
        _super.prototype._render.call(this, renderer);
      };
      return SimpleMesh;
    })(Mesh);
    var DEFAULT_BORDER_SIZE = 10;
    (function(_super) {
      __extends$1(NineSlicePlane, _super);
      function NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
        if (leftWidth === void 0) {
          leftWidth = DEFAULT_BORDER_SIZE;
        }
        if (topHeight === void 0) {
          topHeight = DEFAULT_BORDER_SIZE;
        }
        if (rightWidth === void 0) {
          rightWidth = DEFAULT_BORDER_SIZE;
        }
        if (bottomHeight === void 0) {
          bottomHeight = DEFAULT_BORDER_SIZE;
        }
        var _this = _super.call(this, Texture.WHITE, 4, 4) || this;
        _this._origWidth = texture.orig.width;
        _this._origHeight = texture.orig.height;
        _this._width = _this._origWidth;
        _this._height = _this._origHeight;
        _this._leftWidth = leftWidth;
        _this._rightWidth = rightWidth;
        _this._topHeight = topHeight;
        _this._bottomHeight = bottomHeight;
        _this.texture = texture;
        return _this;
      }
      NineSlicePlane.prototype.textureUpdated = function() {
        this._textureID = this.shader.texture._updateID;
        this._refresh();
      };
      Object.defineProperty(NineSlicePlane.prototype, "vertices", {
        get: function() {
          return this.geometry.getBuffer("aVertexPosition").data;
        },
        set: function(value2) {
          this.geometry.getBuffer("aVertexPosition").data = value2;
        },
        enumerable: false,
        configurable: true
      });
      NineSlicePlane.prototype.updateHorizontalVertices = function() {
        var vertices = this.vertices;
        var scale = this._getMinScale();
        vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
        vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
        vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
      };
      NineSlicePlane.prototype.updateVerticalVertices = function() {
        var vertices = this.vertices;
        var scale = this._getMinScale();
        vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
        vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
        vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
      };
      NineSlicePlane.prototype._getMinScale = function() {
        var w2 = this._leftWidth + this._rightWidth;
        var scaleW = this._width > w2 ? 1 : this._width / w2;
        var h2 = this._topHeight + this._bottomHeight;
        var scaleH = this._height > h2 ? 1 : this._height / h2;
        var scale = Math.min(scaleW, scaleH);
        return scale;
      };
      Object.defineProperty(NineSlicePlane.prototype, "width", {
        get: function() {
          return this._width;
        },
        set: function(value2) {
          this._width = value2;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane.prototype, "height", {
        get: function() {
          return this._height;
        },
        set: function(value2) {
          this._height = value2;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane.prototype, "leftWidth", {
        get: function() {
          return this._leftWidth;
        },
        set: function(value2) {
          this._leftWidth = value2;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane.prototype, "rightWidth", {
        get: function() {
          return this._rightWidth;
        },
        set: function(value2) {
          this._rightWidth = value2;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane.prototype, "topHeight", {
        get: function() {
          return this._topHeight;
        },
        set: function(value2) {
          this._topHeight = value2;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane.prototype, "bottomHeight", {
        get: function() {
          return this._bottomHeight;
        },
        set: function(value2) {
          this._bottomHeight = value2;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      NineSlicePlane.prototype._refresh = function() {
        var texture = this.texture;
        var uvs = this.geometry.buffers[1].data;
        this._origWidth = texture.orig.width;
        this._origHeight = texture.orig.height;
        var _uvw = 1 / this._origWidth;
        var _uvh = 1 / this._origHeight;
        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
        this.updateHorizontalVertices();
        this.updateVerticalVertices();
        this.geometry.buffers[0].update();
        this.geometry.buffers[1].update();
      };
      return NineSlicePlane;
    })(SimplePlane);
    /*!
     * @pixi/sprite-animated - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * @pixi/sprite-animated is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var AnimatedSprite = function(_super) {
      __extends(AnimatedSprite2, _super);
      function AnimatedSprite2(textures, autoUpdate) {
        if (autoUpdate === void 0) {
          autoUpdate = true;
        }
        var _this = _super.call(this, textures[0] instanceof Texture ? textures[0] : textures[0].texture) || this;
        _this._textures = null;
        _this._durations = null;
        _this._autoUpdate = autoUpdate;
        _this._isConnectedToTicker = false;
        _this.animationSpeed = 1;
        _this.loop = true;
        _this.updateAnchor = false;
        _this.onComplete = null;
        _this.onFrameChange = null;
        _this.onLoop = null;
        _this._currentTime = 0;
        _this._playing = false;
        _this._previousFrame = null;
        _this.textures = textures;
        return _this;
      }
      AnimatedSprite2.prototype.stop = function() {
        if (!this._playing) {
          return;
        }
        this._playing = false;
        if (this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        }
      };
      AnimatedSprite2.prototype.play = function() {
        if (this._playing) {
          return;
        }
        this._playing = true;
        if (this._autoUpdate && !this._isConnectedToTicker) {
          Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
          this._isConnectedToTicker = true;
        }
      };
      AnimatedSprite2.prototype.gotoAndStop = function(frameNumber) {
        this.stop();
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
          this.updateTexture();
        }
      };
      AnimatedSprite2.prototype.gotoAndPlay = function(frameNumber) {
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
          this.updateTexture();
        }
        this.play();
      };
      AnimatedSprite2.prototype.update = function(deltaTime) {
        var elapsed = this.animationSpeed * deltaTime;
        var previousFrame = this.currentFrame;
        if (this._durations !== null) {
          var lag = this._currentTime % 1 * this._durations[this.currentFrame];
          lag += elapsed / 60 * 1e3;
          while (lag < 0) {
            this._currentTime--;
            lag += this._durations[this.currentFrame];
          }
          var sign2 = Math.sign(this.animationSpeed * deltaTime);
          this._currentTime = Math.floor(this._currentTime);
          while (lag >= this._durations[this.currentFrame]) {
            lag -= this._durations[this.currentFrame] * sign2;
            this._currentTime += sign2;
          }
          this._currentTime += lag / this._durations[this.currentFrame];
        } else {
          this._currentTime += elapsed;
        }
        if (this._currentTime < 0 && !this.loop) {
          this.gotoAndStop(0);
          if (this.onComplete) {
            this.onComplete();
          }
        } else if (this._currentTime >= this._textures.length && !this.loop) {
          this.gotoAndStop(this._textures.length - 1);
          if (this.onComplete) {
            this.onComplete();
          }
        } else if (previousFrame !== this.currentFrame) {
          if (this.loop && this.onLoop) {
            if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
              this.onLoop();
            } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
              this.onLoop();
            }
          }
          this.updateTexture();
        }
      };
      AnimatedSprite2.prototype.updateTexture = function() {
        var currentFrame = this.currentFrame;
        if (this._previousFrame === currentFrame) {
          return;
        }
        this._previousFrame = currentFrame;
        this._texture = this._textures[currentFrame];
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this._cachedTint = 16777215;
        this.uvs = this._texture._uvs.uvsFloat32;
        if (this.updateAnchor) {
          this._anchor.copyFrom(this._texture.defaultAnchor);
        }
        if (this.onFrameChange) {
          this.onFrameChange(this.currentFrame);
        }
      };
      AnimatedSprite2.prototype.destroy = function(options) {
        this.stop();
        _super.prototype.destroy.call(this, options);
        this.onComplete = null;
        this.onFrameChange = null;
        this.onLoop = null;
      };
      AnimatedSprite2.fromFrames = function(frames) {
        var textures = [];
        for (var i = 0; i < frames.length; ++i) {
          textures.push(Texture.from(frames[i]));
        }
        return new AnimatedSprite2(textures);
      };
      AnimatedSprite2.fromImages = function(images) {
        var textures = [];
        for (var i = 0; i < images.length; ++i) {
          textures.push(Texture.from(images[i]));
        }
        return new AnimatedSprite2(textures);
      };
      Object.defineProperty(AnimatedSprite2.prototype, "totalFrames", {
        get: function() {
          return this._textures.length;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimatedSprite2.prototype, "textures", {
        get: function() {
          return this._textures;
        },
        set: function(value2) {
          if (value2[0] instanceof Texture) {
            this._textures = value2;
            this._durations = null;
          } else {
            this._textures = [];
            this._durations = [];
            for (var i = 0; i < value2.length; i++) {
              this._textures.push(value2[i].texture);
              this._durations.push(value2[i].time);
            }
          }
          this._previousFrame = null;
          this.gotoAndStop(0);
          this.updateTexture();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimatedSprite2.prototype, "currentFrame", {
        get: function() {
          var currentFrame = Math.floor(this._currentTime) % this._textures.length;
          if (currentFrame < 0) {
            currentFrame += this._textures.length;
          }
          return currentFrame;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimatedSprite2.prototype, "playing", {
        get: function() {
          return this._playing;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimatedSprite2.prototype, "autoUpdate", {
        get: function() {
          return this._autoUpdate;
        },
        set: function(value2) {
          if (value2 !== this._autoUpdate) {
            this._autoUpdate = value2;
            if (!this._autoUpdate && this._isConnectedToTicker) {
              Ticker.shared.remove(this.update, this);
              this._isConnectedToTicker = false;
            } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
              Ticker.shared.add(this.update, this);
              this._isConnectedToTicker = true;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      return AnimatedSprite2;
    }(Sprite);
    /*!
     * pixi.js - v5.3.3
     * Compiled Tue, 04 Aug 2020 16:23:09 UTC
     *
     * pixi.js is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    Renderer.registerPlugin("accessibility", AccessibilityManager);
    Renderer.registerPlugin("extract", Extract);
    Renderer.registerPlugin("interaction", InteractionManager);
    Renderer.registerPlugin("particle", ParticleRenderer);
    Renderer.registerPlugin("prepare", Prepare);
    Renderer.registerPlugin("batch", BatchRenderer);
    Renderer.registerPlugin("tilingSprite", TilingSpriteRenderer);
    Loader.registerPlugin(BitmapFontLoader);
    Loader.registerPlugin(SpritesheetLoader);
    Application.registerPlugin(TickerPlugin);
    Application.registerPlugin(AppLoaderPlugin);
    class Entity {
      constructor(x2, y2) {
        __publicField(this, "container");
        __publicField(this, "parts", {});
        __publicField(this, "spawned");
        __publicField(this, "tag", "entity");
        __publicField(this, "timeSinceSpawned", () => {
          return performance.now() - this.spawned;
        });
        __publicField(this, "sprite", (from2) => {
          let sprite = new Sprite.from(from2);
          sprite.anchor.set(0.5);
          this.parts.sprite = sprite;
          this.container.addChild(this.parts.sprite);
          return this.parts.sprite;
        });
        __publicField(this, "part", (key) => {
          return this.parts[key];
        });
        __publicField(this, "add", (key, value2) => {
          this.parts[key] = value2;
          this.container.addChild(value2);
        });
        __publicField(this, "onUpdate", (delta) => {
        });
        __publicField(this, "onEvent", (eventType, event) => {
        });
        __publicField(this, "draw", (delta) => {
        });
        let container = new Container();
        container.pivot.x = Math.round(container.width / 2);
        container.pivot.y = Math.round(container.height / 2);
        container.x = x2;
        container.y = y2;
        this.container = container;
        this.spawned = performance.now();
      }
    }
    const bulletSprite = createIdenticon("bullet");
    class Bullet extends Entity {
      constructor(x2, y2, target) {
        super(x2, y2);
        __publicField(this, "width", 10);
        __publicField(this, "height", 10);
        __publicField(this, "target");
        __publicField(this, "enemyDelta");
        __publicField(this, "onUpdate", (delta) => {
          let vec = this.enemyDelta.getVector(this.enemyDelta.distance, this.enemyDelta.angle);
          this.container.x += vec.x * (delta / 10);
          this.container.y += vec.y * (delta / 10);
          if (this.hit()) {
            this.target.takeDamage();
            Game$1.remove(this);
          }
        });
        __publicField(this, "hit", () => {
          if (this.container.x >= this.target.container.x - this.target.container.width / 2 && this.container.x <= this.target.container.x + this.target.container.width / 2 && this.container.y >= this.target.container.y - this.target.container.height / 2 && this.container.y <= this.target.container.y + this.target.container.height / 2) {
            return true;
          }
          return false;
        });
        __publicField(this, "draw", () => {
        });
        this.sprite(bulletSprite);
        this.part("sprite").width = this.width;
        this.part("sprite").height = this.height;
        this.target = target;
        this.enemyDelta = new AngleDelta(
          this.container.x,
          this.container.y,
          this.target.container.x,
          this.target.container.y
        );
      }
    }
    class Emitter {
      constructor() {
        __publicField(this, "on", (e, callback) => {
          if (!this.events[e]) {
            this.events[e] = [];
          }
          this.events[e].push(callback);
        });
        __publicField(this, "emit", (e, ...data) => {
          this.events[e].forEach((callback) => {
            callback(...data);
          });
        });
        this.events = {};
      }
      static getInstance() {
        if (!Emitter._instance) {
          Emitter._instance = new Emitter();
        }
        return Emitter._instance;
      }
    }
    const events = function() {
      return Emitter.getInstance();
    }();
    class Player extends Entity {
      constructor(playerName, x2, y2) {
        super(x2, y2);
        __publicField(this, "width", 40);
        __publicField(this, "height", 40);
        __publicField(this, "target");
        __publicField(this, "name");
        __publicField(this, "shouldResetTarget", (key) => {
          return key.toLowerCase() == "backspace" && this.target !== null;
        });
        __publicField(this, "onEvent", (eventType, event) => {
          if (eventType !== "keydown") {
            return;
          }
          const { key } = event;
          if (this.shouldResetTarget(key)) {
            this.target.isTargeted(false);
            this.target = null;
          }
          let target = this.getTarget(key);
          if (target) {
            this.makeAttack(target, key);
          }
        });
        __publicField(this, "getTarget", (key) => {
          if (this.target) {
            return this.target;
          }
          let enemies = Game$1.find("enemy").filter(
            (e) => e.word.toLowerCase().startsWith(key.toLowerCase())
          );
          if (enemies.length === 0) {
            return;
          }
          enemies = enemies.sort((a, b) => a.container.y - b.container.y);
          let enemy = enemies.pop();
          this.target = enemy;
          this.target.isTargeted(true);
          return this.target;
        });
        __publicField(this, "makeAttack", (target, key) => {
          let missed = true;
          if (target.word.toLowerCase().startsWith(key.toLowerCase())) {
            Game$1.add(new Bullet(this.container.x, this.container.y, target));
            target.takeHit();
            if (target.isDead()) {
              this.target = null;
            }
            missed = false;
          }
          events.emit("shotFired", missed);
        });
        this.name = playerName;
        this.sprite(createIdenticon(playerName));
        this.part("sprite").width = this.width;
        this.part("sprite").height = this.height;
      }
    }
    class Enemy extends Entity {
      constructor(word, target, wave, velocityCalculator) {
        super(
          Math.random() * (400 - 20) + 20,
          Math.random() * (-100 - 50) + -50
        );
        __publicField(this, "angle", 0);
        __publicField(this, "velocity", 2);
        __publicField(this, "rotationSpeed", 0.01);
        __publicField(this, "maxRotationSpeed", 0.02);
        __publicField(this, "playerDelta");
        __publicField(this, "follow", false);
        __publicField(this, "alertTime", 1e3);
        __publicField(this, "word");
        __publicField(this, "originalWord");
        __publicField(this, "targeted", false);
        __publicField(this, "dead", false);
        __publicField(this, "target", null);
        __publicField(this, "image");
        __publicField(this, "width", 30);
        __publicField(this, "height", 30);
        __publicField(this, "life", 1);
        __publicField(this, "stunned", 0);
        __publicField(this, "velocityCalculator");
        __publicField(this, "draw", (delta) => {
          if (this.targeted) {
            this.part("text").style.fill = 16748288;
          } else {
            this.part("text").style.fill = 16777215;
          }
          this.drawWord();
        });
        __publicField(this, "drawWord", () => {
          let textMetrics = TextMetrics.measureText(this.word, this.part("text").style);
          this.part("blackBar").width = textMetrics.width + 10;
          if (this.word === "") {
            this.part("blackBar").alpha = 0;
          }
          this.part("text").text = this.word;
        });
        __publicField(this, "onUpdate", (delta) => {
          if (this.stunned) {
            this.stunned -= Ticker.shared.elapsedMS;
            if (this.stunned <= 0) {
              this.stunned = 0;
            }
            return;
          }
          if (this.container.x >= this.target.container.x - this.target.container.width / 2 && this.container.x <= this.target.container.x + this.target.container.width / 2 && this.container.y >= this.target.container.y - this.target.container.height / 2 && this.container.y <= this.target.container.y + this.target.container.height / 2) {
            events.emit("playerDeath");
            console.log("Player should be dead now. Killed by word: ", this.word);
          }
          if (!this.follow) {
            this.follow = this.timeSinceSpawned() - this.alertTime > 0;
            if (this.container.x < 150 && this.container.x > 350) {
              this.follow = true;
            }
          }
          let dx = this.container.x - this.target.container.x;
          let dy = this.container.y - this.target.container.y;
          let angle = Math.atan2(dy, dx);
          let dangle = angle - this.angle;
          if (this.follow && dangle !== 0) {
            if (dangle > 0) {
              this.angle += this.rotationSpeed * delta;
            } else {
              this.angle -= this.rotationSpeed * delta;
            }
            if (dangle > -0.01 && dangle < 0.01) {
              this.angle = angle;
            }
          }
          let oldX = this.container.x;
          let oldY = this.container.y;
          this.container.x -= this.velocity * delta * Math.cos(this.angle);
          this.container.y -= this.velocity * delta * Math.sin(this.angle);
          this.part("sprite").angle = Math.atan2(
            oldY - this.container.y,
            oldX - this.container.x
          ) * 180 / Math.PI + 90;
        });
        __publicField(this, "takeDamage", () => {
          this.life--;
          this.stunned = 100;
          this.parts.sprite.tint = 16711680;
          setTimeout(() => {
            this.parts.sprite.tint = 16777215;
          }, 100);
          if (this.life === 0) {
            events.emit("enemyDeath");
            this.deathAnimation(() => {
              Game$1.remove(this);
            });
          }
        });
        __publicField(this, "deathAnimation", (callback) => {
          let rndImages = [
            createIdenticon("asd"),
            createIdenticon("3433"),
            createIdenticon("dsds"),
            createIdenticon("Math.random()"),
            createIdenticon("ssssMath.random()")
          ];
          let textureArray = [];
          for (let i = 0; i < 4; i++) {
            let texture = Texture.from(rndImages[i]);
            textureArray.push(texture);
          }
          this.parts.sprite.removeChild();
          let animation = new AnimatedSprite(textureArray);
          animation.width = 30;
          animation.height = 30;
          animation.anchor.set(0.5);
          animation.onComplete = () => {
            callback();
          };
          animation.loop = false;
          this.container.addChild(animation);
          animation.play();
        });
        __publicField(this, "takeHit", () => {
          this.word = this.word.substring(1);
          if (this.word.length === 0) {
            this.dead = true;
          }
        });
        __publicField(this, "isDead", () => {
          return this.dead;
        });
        __publicField(this, "isTargeted", (status) => {
          if (status) {
            events.emit("enemyTargeted", this);
          }
          this.targeted = status;
        });
        __publicField(this, "createBlackBar", (width2, height2) => {
          let block = new Sprite.from(Texture.WHITE);
          block.anchor.set(0.5);
          block.width = width2;
          block.height = height2;
          block.tint = 0;
          block.y = 30;
          return block;
        });
        __publicField(this, "createWordText", (from2) => {
          let textStyle = new TextStyle({
            fontFamily: "Poppins",
            fontSize: 16,
            align: "center",
            fill: 16777215
          });
          let text = new Text(from2, textStyle);
          text.anchor.set(0.5);
          text.y = 30;
          return text;
        });
        this.sprite(createIdenticon(word));
        this.part("sprite").width = 30;
        this.part("sprite").height = 30;
        this.velocity = velocityCalculator.calculate(wave);
        this.rotationSpeed = (Math.floor(Math.random() * (this.maxRotationSpeed * 1e4)) + 100) / 1e4;
        let text = this.createWordText(word);
        let style = text.style;
        let textMetrics = TextMetrics.measureText(word, style);
        this.add("blackBar", this.createBlackBar(textMetrics.width, textMetrics.height));
        this.add("text", text);
        this.life = word.length;
        this.tag = "enemy";
        this.word = word;
        this.originalWord = word;
        this.target = target;
        this.alertTime = Math.floor(Math.random() * (3e3 - 1e3)) + 1e3;
        let startRotation = Math.floor(Math.random() * 60) - 30;
        this.angle = (-90 + startRotation) * Math.PI / 180;
        this.playerDelta = new AngleDelta(
          this.container.x,
          this.container.y,
          this.target.container.x,
          this.target.container.y
        );
      }
    }
    var axios$3 = { exports: {} };
    var axios$2 = { exports: {} };
    var bind$3 = function bind2(fn, thisArg) {
      return function wrap2() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
    var bind$2 = bind$3;
    var toString$2 = Object.prototype.toString;
    function isArray$2(val) {
      return toString$2.call(val) === "[object Array]";
    }
    function isUndefined$2(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined$2(val) && val.constructor !== null && !isUndefined$2(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer$1(val) {
      return toString$2.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result2;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result2 = ArrayBuffer.isView(val);
      } else {
        result2 = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result2;
    }
    function isString$2(val) {
      return typeof val === "string";
    }
    function isNumber$2(val) {
      return typeof val === "number";
    }
    function isObject$2(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString$2.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate$2(val) {
      return toString$2.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString$2.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString$2.call(val) === "[object Blob]";
    }
    function isFunction$3(val) {
      return toString$2.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject$2(val) && isFunction$3(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray$2(obj)) {
        for (var i = 0, l2 = obj.length; i < l2; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result2 = {};
      function assignValue(val, key) {
        if (isPlainObject(result2[key]) && isPlainObject(val)) {
          result2[key] = merge(result2[key], val);
        } else if (isPlainObject(val)) {
          result2[key] = merge({}, val);
        } else if (isArray$2(val)) {
          result2[key] = val.slice();
        } else {
          result2[key] = val;
        }
      }
      for (var i = 0, l2 = arguments.length; i < l2; i++) {
        forEach(arguments[i], assignValue);
      }
      return result2;
    }
    function extend$2(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind$2(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    var utils$9 = {
      isArray: isArray$2,
      isArrayBuffer: isArrayBuffer$1,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString$2,
      isNumber: isNumber$2,
      isObject: isObject$2,
      isPlainObject,
      isUndefined: isUndefined$2,
      isDate: isDate$2,
      isFile,
      isBlob,
      isFunction: isFunction$3,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend: extend$2,
      trim,
      stripBOM
    };
    var utils$8 = utils$9;
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    var buildURL$1 = function buildURL2(url2, params, paramsSerializer) {
      if (!params) {
        return url2;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils$8.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils$8.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils$8.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils$8.forEach(val, function parseValue(v2) {
            if (utils$8.isDate(v2)) {
              v2 = v2.toISOString();
            } else if (utils$8.isObject(v2)) {
              v2 = JSON.stringify(v2);
            }
            parts.push(encode(key) + "=" + encode(v2));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url2.indexOf("#");
        if (hashmarkIndex !== -1) {
          url2 = url2.slice(0, hashmarkIndex);
        }
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    };
    var utils$7 = utils$9;
    function InterceptorManager$1() {
      this.handlers = [];
    }
    InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager$1.prototype.eject = function eject(id2) {
      if (this.handlers[id2]) {
        this.handlers[id2] = null;
      }
    };
    InterceptorManager$1.prototype.forEach = function forEach2(fn) {
      utils$7.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    };
    var InterceptorManager_1 = InterceptorManager$1;
    var utils$6 = utils$9;
    var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
      utils$6.forEach(headers, function processHeader(value2, name2) {
        if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value2;
          delete headers[name2];
        }
      });
    };
    var enhanceError$1 = function enhanceError2(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON2() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code
        };
      };
      return error;
    };
    var createError;
    var hasRequiredCreateError;
    function requireCreateError() {
      if (hasRequiredCreateError)
        return createError;
      hasRequiredCreateError = 1;
      var enhanceError2 = enhanceError$1;
      createError = function createError2(message, config, code, request, response) {
        var error = new Error(message);
        return enhanceError2(error, config, code, request, response);
      };
      return createError;
    }
    var settle;
    var hasRequiredSettle;
    function requireSettle() {
      if (hasRequiredSettle)
        return settle;
      hasRequiredSettle = 1;
      var createError2 = requireCreateError();
      settle = function settle2(resolve, reject2, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject2(createError2(
            "Request failed with status code " + response.status,
            response.config,
            null,
            response.request,
            response
          ));
        }
      };
      return settle;
    }
    var cookies;
    var hasRequiredCookies;
    function requireCookies() {
      if (hasRequiredCookies)
        return cookies;
      hasRequiredCookies = 1;
      var utils2 = utils$9;
      cookies = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
        return {
          write: function write(name2, value2, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name2 + "=" + encodeURIComponent(value2));
            if (utils2.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils2.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils2.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name2) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name2) {
            this.write(name2, "", Date.now() - 864e5);
          }
        };
      }() : function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }();
      return cookies;
    }
    var isAbsoluteURL;
    var hasRequiredIsAbsoluteURL;
    function requireIsAbsoluteURL() {
      if (hasRequiredIsAbsoluteURL)
        return isAbsoluteURL;
      hasRequiredIsAbsoluteURL = 1;
      isAbsoluteURL = function isAbsoluteURL2(url2) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url2);
      };
      return isAbsoluteURL;
    }
    var combineURLs;
    var hasRequiredCombineURLs;
    function requireCombineURLs() {
      if (hasRequiredCombineURLs)
        return combineURLs;
      hasRequiredCombineURLs = 1;
      combineURLs = function combineURLs2(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
      return combineURLs;
    }
    var buildFullPath;
    var hasRequiredBuildFullPath;
    function requireBuildFullPath() {
      if (hasRequiredBuildFullPath)
        return buildFullPath;
      hasRequiredBuildFullPath = 1;
      var isAbsoluteURL2 = requireIsAbsoluteURL();
      var combineURLs2 = requireCombineURLs();
      buildFullPath = function buildFullPath2(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL2(requestedURL)) {
          return combineURLs2(baseURL, requestedURL);
        }
        return requestedURL;
      };
      return buildFullPath;
    }
    var parseHeaders;
    var hasRequiredParseHeaders;
    function requireParseHeaders() {
      if (hasRequiredParseHeaders)
        return parseHeaders;
      hasRequiredParseHeaders = 1;
      var utils2 = utils$9;
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      parseHeaders = function parseHeaders2(headers) {
        var parsed = {};
        var key;
        var val;
        var i;
        if (!headers) {
          return parsed;
        }
        utils2.forEach(headers.split("\n"), function parser(line) {
          i = line.indexOf(":");
          key = utils2.trim(line.substr(0, i)).toLowerCase();
          val = utils2.trim(line.substr(i + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
      return parseHeaders;
    }
    var isURLSameOrigin;
    var hasRequiredIsURLSameOrigin;
    function requireIsURLSameOrigin() {
      if (hasRequiredIsURLSameOrigin)
        return isURLSameOrigin;
      hasRequiredIsURLSameOrigin = 1;
      var utils2 = utils$9;
      isURLSameOrigin = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url2) {
          var href = url2;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }() : function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }();
      return isURLSameOrigin;
    }
    var xhr;
    var hasRequiredXhr;
    function requireXhr() {
      if (hasRequiredXhr)
        return xhr;
      hasRequiredXhr = 1;
      var utils2 = utils$9;
      var settle2 = requireSettle();
      var cookies2 = requireCookies();
      var buildURL2 = buildURL$1;
      var buildFullPath2 = requireBuildFullPath();
      var parseHeaders2 = requireParseHeaders();
      var isURLSameOrigin2 = requireIsURLSameOrigin();
      var createError2 = requireCreateError();
      xhr = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject2) {
          var requestData = config.data;
          var requestHeaders = config.headers;
          var responseType = config.responseType;
          if (utils2.isFormData(requestData)) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath2(config.baseURL, config.url);
          request.open(config.method.toUpperCase(), buildURL2(fullPath, config.params, config.paramsSerializer), true);
          request.timeout = config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders2(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request
            };
            settle2(resolve, reject2, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject2(createError2("Request aborted", config, "ECONNABORTED", request));
            request = null;
          };
          request.onerror = function handleError() {
            reject2(createError2("Network Error", config, null, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject2(createError2(
              timeoutErrorMessage,
              config,
              config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              request
            ));
            request = null;
          };
          if (utils2.isStandardBrowserEnv()) {
            var xsrfValue = (config.withCredentials || isURLSameOrigin2(fullPath)) && config.xsrfCookieName ? cookies2.read(config.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils2.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
          }
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config.onUploadProgress);
          }
          if (config.cancelToken) {
            config.cancelToken.promise.then(function onCanceled(cancel) {
              if (!request) {
                return;
              }
              request.abort();
              reject2(cancel);
              request = null;
            });
          }
          if (!requestData) {
            requestData = null;
          }
          request.send(requestData);
        });
      };
      return xhr;
    }
    var utils$5 = utils$9;
    var normalizeHeaderName = normalizeHeaderName$1;
    var enhanceError = enhanceError$1;
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value2) {
      if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value2;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = requireXhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = requireXhr();
      }
      return adapter;
    }
    var defaults$5 = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils$5.isFormData(data) || utils$5.isArrayBuffer(data) || utils$5.isBuffer(data) || utils$5.isStream(data) || utils$5.isFile(data) || utils$5.isBlob(data)) {
          return data;
        }
        if (utils$5.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$5.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils$5.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return JSON.stringify(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    defaults$5.headers = {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    };
    utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults$5.headers[method] = {};
    });
    utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults$5.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
    });
    var defaults_1 = defaults$5;
    var utils$4 = utils$9;
    var defaults$4 = defaults_1;
    var transformData$1 = function transformData2(data, headers, fns) {
      var context2 = this || defaults$4;
      utils$4.forEach(fns, function transform(fn) {
        data = fn.call(context2, data, headers);
      });
      return data;
    };
    var isCancel$1;
    var hasRequiredIsCancel;
    function requireIsCancel() {
      if (hasRequiredIsCancel)
        return isCancel$1;
      hasRequiredIsCancel = 1;
      isCancel$1 = function isCancel2(value2) {
        return !!(value2 && value2.__CANCEL__);
      };
      return isCancel$1;
    }
    var utils$3 = utils$9;
    var transformData = transformData$1;
    var isCancel = requireIsCancel();
    var defaults$3 = defaults_1;
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    var dispatchRequest$1 = function dispatchRequest2(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils$3.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils$3.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults$3.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
    var utils$2 = utils$9;
    var mergeConfig$2 = function mergeConfig2(config1, config2) {
      config2 = config2 || {};
      var config = {};
      var valueFromConfig2Keys = ["url", "method", "data"];
      var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
      var defaultToConfig2Keys = [
        "baseURL",
        "transformRequest",
        "transformResponse",
        "paramsSerializer",
        "timeout",
        "timeoutMessage",
        "withCredentials",
        "adapter",
        "responseType",
        "xsrfCookieName",
        "xsrfHeaderName",
        "onUploadProgress",
        "onDownloadProgress",
        "decompress",
        "maxContentLength",
        "maxBodyLength",
        "maxRedirects",
        "transport",
        "httpAgent",
        "httpsAgent",
        "cancelToken",
        "socketPath",
        "responseEncoding"
      ];
      var directMergeKeys = ["validateStatus"];
      function getMergedValue(target, source) {
        if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
          return utils$2.merge(target, source);
        } else if (utils$2.isPlainObject(source)) {
          return utils$2.merge({}, source);
        } else if (utils$2.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils$2.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils$2.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      }
      utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils$2.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        }
      });
      utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
      utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils$2.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        } else if (!utils$2.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      utils$2.forEach(directMergeKeys, function merge2(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
      var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });
      utils$2.forEach(otherKeys, mergeDeepProperties);
      return config;
    };
    const name = "axios";
    const version = "0.21.2";
    const description = "Promise based HTTP client for the browser and node.js";
    const main = "index.js";
    const scripts = {
      test: "grunt test",
      start: "node ./sandbox/server.js",
      build: "NODE_ENV=production grunt build",
      preversion: "npm test",
      version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
      postversion: "git push && git push --tags",
      examples: "node ./examples/server.js",
      coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
      fix: "eslint --fix lib/**/*.js"
    };
    const repository = {
      type: "git",
      url: "https://github.com/axios/axios.git"
    };
    const keywords = [
      "xhr",
      "http",
      "ajax",
      "promise",
      "node"
    ];
    const author = "Matt Zabriskie";
    const license = "MIT";
    const bugs = {
      url: "https://github.com/axios/axios/issues"
    };
    const homepage = "https://axios-http.com";
    const devDependencies = {
      coveralls: "^3.0.0",
      "es6-promise": "^4.2.4",
      grunt: "^1.3.0",
      "grunt-banner": "^0.6.0",
      "grunt-cli": "^1.2.0",
      "grunt-contrib-clean": "^1.1.0",
      "grunt-contrib-watch": "^1.0.0",
      "grunt-eslint": "^23.0.0",
      "grunt-karma": "^4.0.0",
      "grunt-mocha-test": "^0.13.3",
      "grunt-ts": "^6.0.0-beta.19",
      "grunt-webpack": "^4.0.2",
      "istanbul-instrumenter-loader": "^1.0.0",
      "jasmine-core": "^2.4.1",
      karma: "^6.3.2",
      "karma-chrome-launcher": "^3.1.0",
      "karma-firefox-launcher": "^2.1.0",
      "karma-jasmine": "^1.1.1",
      "karma-jasmine-ajax": "^0.1.13",
      "karma-safari-launcher": "^1.0.0",
      "karma-sauce-launcher": "^4.3.6",
      "karma-sinon": "^1.0.5",
      "karma-sourcemap-loader": "^0.3.8",
      "karma-webpack": "^4.0.2",
      "load-grunt-tasks": "^3.5.2",
      minimist: "^1.2.0",
      mocha: "^8.2.1",
      sinon: "^4.5.0",
      "terser-webpack-plugin": "^4.2.3",
      typescript: "^4.0.5",
      "url-search-params": "^0.10.0",
      webpack: "^4.44.2",
      "webpack-dev-server": "^3.11.0"
    };
    const browser = {
      "./lib/adapters/http.js": "./lib/adapters/xhr.js"
    };
    const jsdelivr = "dist/axios.min.js";
    const unpkg = "dist/axios.min.js";
    const typings = "./index.d.ts";
    const dependencies = {
      "follow-redirects": "^1.14.0"
    };
    const bundlesize = [
      {
        path: "./dist/axios.min.js",
        threshold: "5kB"
      }
    ];
    const require$$0$1 = {
      name,
      version,
      description,
      main,
      scripts,
      repository,
      keywords,
      author,
      license,
      bugs,
      homepage,
      devDependencies,
      browser,
      jsdelivr,
      unpkg,
      typings,
      dependencies,
      bundlesize
    };
    var pkg = require$$0$1;
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    var currentVerArr = pkg.version.split(".");
    function isOlderVersion(version2, thanVersion) {
      var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
      var destVer = version2.split(".");
      for (var i = 0; i < 3; i++) {
        if (pkgVersionArr[i] > destVer[i]) {
          return true;
        } else if (pkgVersionArr[i] < destVer[i]) {
          return false;
        }
      }
      return false;
    }
    validators$1.transitional = function transitional(validator2, version2, message) {
      var isDeprecated = version2 && isOlderVersion(version2);
      function formatMessage(opt, desc) {
        return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value2, opt, opts) {
        if (validator2 === false) {
          throw new Error(formatMessage(opt, " has been removed in " + version2));
        }
        if (isDeprecated && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value2, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys2 = Object.keys(options);
      var i = keys2.length;
      while (i-- > 0) {
        var opt = keys2[i];
        var validator2 = schema[opt];
        if (validator2) {
          var value2 = options[opt];
          var result2 = value2 === void 0 || validator2(value2, opt, options);
          if (result2 !== true) {
            throw new TypeError("option " + opt + " must be " + result2);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    var validator$1 = {
      isOlderVersion,
      assertOptions,
      validators: validators$1
    };
    var utils$1 = utils$9;
    var buildURL = buildURL$1;
    var InterceptorManager = InterceptorManager_1;
    var dispatchRequest = dispatchRequest$1;
    var mergeConfig$1 = mergeConfig$2;
    var validator = validator$1;
    var validators = validator.validators;
    function Axios$1(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios$1.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig$1(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise2;
      if (!synchronousRequestInterceptors) {
        var chain2 = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain2, requestInterceptorChain);
        chain2.concat(responseInterceptorChain);
        promise2 = Promise.resolve(config);
        while (chain2.length) {
          promise2 = promise2.then(chain2.shift(), chain2.shift());
        }
        return promise2;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise2 = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise2 = promise2.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise2;
    };
    Axios$1.prototype.getUri = function getUri(config) {
      config = mergeConfig$1(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios$1.prototype[method] = function(url2, config) {
        return this.request(mergeConfig$1(config || {}, {
          method,
          url: url2,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios$1.prototype[method] = function(url2, data, config) {
        return this.request(mergeConfig$1(config || {}, {
          method,
          url: url2,
          data
        }));
      };
    });
    var Axios_1 = Axios$1;
    var Cancel_1;
    var hasRequiredCancel;
    function requireCancel() {
      if (hasRequiredCancel)
        return Cancel_1;
      hasRequiredCancel = 1;
      function Cancel(message) {
        this.message = message;
      }
      Cancel.prototype.toString = function toString2() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };
      Cancel.prototype.__CANCEL__ = true;
      Cancel_1 = Cancel;
      return Cancel_1;
    }
    var CancelToken_1;
    var hasRequiredCancelToken;
    function requireCancelToken() {
      if (hasRequiredCancelToken)
        return CancelToken_1;
      hasRequiredCancelToken = 1;
      var Cancel = requireCancel();
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token2 = this;
        executor(function cancel(message) {
          if (token2.reason) {
            return;
          }
          token2.reason = new Cancel(message);
          resolvePromise(token2.reason);
        });
      }
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken.source = function source() {
        var cancel;
        var token2 = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token: token2,
          cancel
        };
      };
      CancelToken_1 = CancelToken;
      return CancelToken_1;
    }
    var spread;
    var hasRequiredSpread;
    function requireSpread() {
      if (hasRequiredSpread)
        return spread;
      hasRequiredSpread = 1;
      spread = function spread2(callback) {
        return function wrap2(arr) {
          return callback.apply(null, arr);
        };
      };
      return spread;
    }
    var isAxiosError;
    var hasRequiredIsAxiosError;
    function requireIsAxiosError() {
      if (hasRequiredIsAxiosError)
        return isAxiosError;
      hasRequiredIsAxiosError = 1;
      isAxiosError = function isAxiosError2(payload) {
        return typeof payload === "object" && payload.isAxiosError === true;
      };
      return isAxiosError;
    }
    var utils = utils$9;
    var bind$1 = bind$3;
    var Axios = Axios_1;
    var mergeConfig = mergeConfig$2;
    var defaults$2 = defaults_1;
    function createInstance(defaultConfig) {
      var context2 = new Axios(defaultConfig);
      var instance = bind$1(Axios.prototype.request, context2);
      utils.extend(instance, Axios.prototype, context2);
      utils.extend(instance, context2);
      return instance;
    }
    var axios$1 = createInstance(defaults$2);
    axios$1.Axios = Axios;
    axios$1.create = function create2(instanceConfig) {
      return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
    };
    axios$1.Cancel = requireCancel();
    axios$1.CancelToken = requireCancelToken();
    axios$1.isCancel = requireIsCancel();
    axios$1.all = function all(promises) {
      return Promise.all(promises);
    };
    axios$1.spread = requireSpread();
    axios$1.isAxiosError = requireIsAxiosError();
    axios$2.exports = axios$1;
    axios$2.exports.default = axios$1;
    (function(module2) {
      module2.exports = axios$2.exports;
    })(axios$3);
    const axios = /* @__PURE__ */ getDefaultExportFromCjs(axios$3.exports);
    var VERSION = "1.12.1";
    var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
    var ArrayProto = Array.prototype, ObjProto = Object.prototype;
    var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
    var push = ArrayProto.push, slice = ArrayProto.slice, toString$1 = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
    var supportsArrayBuffer = typeof ArrayBuffer !== "undefined", supportsDataView = typeof DataView !== "undefined";
    var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
    var _isNaN = isNaN, _isFinite = isFinite;
    var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
    var nonEnumerableProps = [
      "valueOf",
      "isPrototypeOf",
      "toString",
      "propertyIsEnumerable",
      "hasOwnProperty",
      "toLocaleString"
    ];
    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
    function restArguments(func, startIndex) {
      startIndex = startIndex == null ? func.length - 1 : +startIndex;
      return function() {
        var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index2 = 0;
        for (; index2 < length; index2++) {
          rest2[index2] = arguments[index2 + startIndex];
        }
        switch (startIndex) {
          case 0:
            return func.call(this, rest2);
          case 1:
            return func.call(this, arguments[0], rest2);
          case 2:
            return func.call(this, arguments[0], arguments[1], rest2);
        }
        var args = Array(startIndex + 1);
        for (index2 = 0; index2 < startIndex; index2++) {
          args[index2] = arguments[index2];
        }
        args[startIndex] = rest2;
        return func.apply(this, args);
      };
    }
    function isObject$1(obj) {
      var type = typeof obj;
      return type === "function" || type === "object" && !!obj;
    }
    function isNull(obj) {
      return obj === null;
    }
    function isUndefined$1(obj) {
      return obj === void 0;
    }
    function isBoolean(obj) {
      return obj === true || obj === false || toString$1.call(obj) === "[object Boolean]";
    }
    function isElement(obj) {
      return !!(obj && obj.nodeType === 1);
    }
    function tagTester(name2) {
      var tag = "[object " + name2 + "]";
      return function(obj) {
        return toString$1.call(obj) === tag;
      };
    }
    const isString$1 = tagTester("String");
    const isNumber$1 = tagTester("Number");
    const isDate$1 = tagTester("Date");
    const isRegExp = tagTester("RegExp");
    const isError = tagTester("Error");
    const isSymbol = tagTester("Symbol");
    const isArrayBuffer = tagTester("ArrayBuffer");
    var isFunction$1 = tagTester("Function");
    var nodelist = root.document && root.document.childNodes;
    if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
      isFunction$1 = function(obj) {
        return typeof obj == "function" || false;
      };
    }
    const isFunction$2 = isFunction$1;
    const hasObjectTag = tagTester("Object");
    var hasStringTagBug = supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8))), isIE11 = typeof Map !== "undefined" && hasObjectTag(/* @__PURE__ */ new Map());
    var isDataView = tagTester("DataView");
    function ie10IsDataView(obj) {
      return obj != null && isFunction$2(obj.getInt8) && isArrayBuffer(obj.buffer);
    }
    const isDataView$1 = hasStringTagBug ? ie10IsDataView : isDataView;
    const isArray$1 = nativeIsArray || tagTester("Array");
    function has$1(obj, key) {
      return obj != null && hasOwnProperty.call(obj, key);
    }
    var isArguments = tagTester("Arguments");
    (function() {
      if (!isArguments(arguments)) {
        isArguments = function(obj) {
          return has$1(obj, "callee");
        };
      }
    })();
    const isArguments$1 = isArguments;
    function isFinite$1(obj) {
      return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
    }
    function isNaN$1(obj) {
      return isNumber$1(obj) && _isNaN(obj);
    }
    function constant(value2) {
      return function() {
        return value2;
      };
    }
    function createSizePropertyCheck(getSizeProperty) {
      return function(collection) {
        var sizeProperty = getSizeProperty(collection);
        return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
      };
    }
    function shallowProperty(key) {
      return function(obj) {
        return obj == null ? void 0 : obj[key];
      };
    }
    const getByteLength = shallowProperty("byteLength");
    const isBufferLike = createSizePropertyCheck(getByteLength);
    var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    function isTypedArray(obj) {
      return nativeIsView ? nativeIsView(obj) && !isDataView$1(obj) : isBufferLike(obj) && typedArrayPattern.test(toString$1.call(obj));
    }
    const isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);
    const getLength = shallowProperty("length");
    function emulatedSet(keys2) {
      var hash = {};
      for (var l2 = keys2.length, i = 0; i < l2; ++i)
        hash[keys2[i]] = true;
      return {
        contains: function(key) {
          return hash[key];
        },
        push: function(key) {
          hash[key] = true;
          return keys2.push(key);
        }
      };
    }
    function collectNonEnumProps(obj, keys2) {
      keys2 = emulatedSet(keys2);
      var nonEnumIdx = nonEnumerableProps.length;
      var constructor = obj.constructor;
      var proto2 = isFunction$2(constructor) && constructor.prototype || ObjProto;
      var prop = "constructor";
      if (has$1(obj, prop) && !keys2.contains(prop))
        keys2.push(prop);
      while (nonEnumIdx--) {
        prop = nonEnumerableProps[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto2[prop] && !keys2.contains(prop)) {
          keys2.push(prop);
        }
      }
    }
    function keys$1(obj) {
      if (!isObject$1(obj))
        return [];
      if (nativeKeys)
        return nativeKeys(obj);
      var keys2 = [];
      for (var key in obj)
        if (has$1(obj, key))
          keys2.push(key);
      if (hasEnumBug)
        collectNonEnumProps(obj, keys2);
      return keys2;
    }
    function isEmpty(obj) {
      if (obj == null)
        return true;
      var length = getLength(obj);
      if (typeof length == "number" && (isArray$1(obj) || isString$1(obj) || isArguments$1(obj)))
        return length === 0;
      return getLength(keys$1(obj)) === 0;
    }
    function isMatch(object2, attrs) {
      var _keys = keys$1(attrs), length = _keys.length;
      if (object2 == null)
        return !length;
      var obj = Object(object2);
      for (var i = 0; i < length; i++) {
        var key = _keys[i];
        if (attrs[key] !== obj[key] || !(key in obj))
          return false;
      }
      return true;
    }
    function _$1(obj) {
      if (obj instanceof _$1)
        return obj;
      if (!(this instanceof _$1))
        return new _$1(obj);
      this._wrapped = obj;
    }
    _$1.VERSION = VERSION;
    _$1.prototype.value = function() {
      return this._wrapped;
    };
    _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;
    _$1.prototype.toString = function() {
      return String(this._wrapped);
    };
    function toBufferView(bufferSource) {
      return new Uint8Array(
        bufferSource.buffer || bufferSource,
        bufferSource.byteOffset || 0,
        getByteLength(bufferSource)
      );
    }
    var tagDataView = "[object DataView]";
    function eq(a, b, aStack, bStack) {
      if (a === b)
        return a !== 0 || 1 / a === 1 / b;
      if (a == null || b == null)
        return false;
      if (a !== a)
        return b !== b;
      var type = typeof a;
      if (type !== "function" && type !== "object" && typeof b != "object")
        return false;
      return deepEq(a, b, aStack, bStack);
    }
    function deepEq(a, b, aStack, bStack) {
      if (a instanceof _$1)
        a = a._wrapped;
      if (b instanceof _$1)
        b = b._wrapped;
      var className = toString$1.call(a);
      if (className !== toString$1.call(b))
        return false;
      if (hasStringTagBug && className == "[object Object]" && isDataView$1(a)) {
        if (!isDataView$1(b))
          return false;
        className = tagDataView;
      }
      switch (className) {
        case "[object RegExp]":
        case "[object String]":
          return "" + a === "" + b;
        case "[object Number]":
          if (+a !== +a)
            return +b !== +b;
          return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case "[object Date]":
        case "[object Boolean]":
          return +a === +b;
        case "[object Symbol]":
          return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
        case "[object ArrayBuffer]":
        case tagDataView:
          return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
      }
      var areArrays = className === "[object Array]";
      if (!areArrays && isTypedArray$1(a)) {
        var byteLength = getByteLength(a);
        if (byteLength !== getByteLength(b))
          return false;
        if (a.buffer === b.buffer && a.byteOffset === b.byteOffset)
          return true;
        areArrays = true;
      }
      if (!areArrays) {
        if (typeof a != "object" || typeof b != "object")
          return false;
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(isFunction$2(aCtor) && aCtor instanceof aCtor && isFunction$2(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
          return false;
        }
      }
      aStack = aStack || [];
      bStack = bStack || [];
      var length = aStack.length;
      while (length--) {
        if (aStack[length] === a)
          return bStack[length] === b;
      }
      aStack.push(a);
      bStack.push(b);
      if (areArrays) {
        length = a.length;
        if (length !== b.length)
          return false;
        while (length--) {
          if (!eq(a[length], b[length], aStack, bStack))
            return false;
        }
      } else {
        var _keys = keys$1(a), key;
        length = _keys.length;
        if (keys$1(b).length !== length)
          return false;
        while (length--) {
          key = _keys[length];
          if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack)))
            return false;
        }
      }
      aStack.pop();
      bStack.pop();
      return true;
    }
    function isEqual(a, b) {
      return eq(a, b);
    }
    function allKeys(obj) {
      if (!isObject$1(obj))
        return [];
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      if (hasEnumBug)
        collectNonEnumProps(obj, keys2);
      return keys2;
    }
    function ie11fingerprint(methods) {
      var length = getLength(methods);
      return function(obj) {
        if (obj == null)
          return false;
        var keys2 = allKeys(obj);
        if (getLength(keys2))
          return false;
        for (var i = 0; i < length; i++) {
          if (!isFunction$2(obj[methods[i]]))
            return false;
        }
        return methods !== weakMapMethods || !isFunction$2(obj[forEachName]);
      };
    }
    var forEachName = "forEach", hasName = "has", commonInit = ["clear", "delete"], mapTail = ["get", hasName, "set"];
    var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = ["add"].concat(commonInit, forEachName, hasName);
    const isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
    const isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
    const isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
    const isWeakSet = tagTester("WeakSet");
    function values(obj) {
      var _keys = keys$1(obj);
      var length = _keys.length;
      var values2 = Array(length);
      for (var i = 0; i < length; i++) {
        values2[i] = obj[_keys[i]];
      }
      return values2;
    }
    function pairs(obj) {
      var _keys = keys$1(obj);
      var length = _keys.length;
      var pairs2 = Array(length);
      for (var i = 0; i < length; i++) {
        pairs2[i] = [_keys[i], obj[_keys[i]]];
      }
      return pairs2;
    }
    function invert(obj) {
      var result2 = {};
      var _keys = keys$1(obj);
      for (var i = 0, length = _keys.length; i < length; i++) {
        result2[obj[_keys[i]]] = _keys[i];
      }
      return result2;
    }
    function functions(obj) {
      var names = [];
      for (var key in obj) {
        if (isFunction$2(obj[key]))
          names.push(key);
      }
      return names.sort();
    }
    function createAssigner(keysFunc, defaults2) {
      return function(obj) {
        var length = arguments.length;
        if (defaults2)
          obj = Object(obj);
        if (length < 2 || obj == null)
          return obj;
        for (var index2 = 1; index2 < length; index2++) {
          var source = arguments[index2], keys2 = keysFunc(source), l2 = keys2.length;
          for (var i = 0; i < l2; i++) {
            var key = keys2[i];
            if (!defaults2 || obj[key] === void 0)
              obj[key] = source[key];
          }
        }
        return obj;
      };
    }
    const extend$1 = createAssigner(allKeys);
    const extendOwn = createAssigner(keys$1);
    const defaults$1 = createAssigner(allKeys, true);
    function ctor() {
      return function() {
      };
    }
    function baseCreate(prototype) {
      if (!isObject$1(prototype))
        return {};
      if (nativeCreate)
        return nativeCreate(prototype);
      var Ctor = ctor();
      Ctor.prototype = prototype;
      var result2 = new Ctor();
      Ctor.prototype = null;
      return result2;
    }
    function create(prototype, props) {
      var result2 = baseCreate(prototype);
      if (props)
        extendOwn(result2, props);
      return result2;
    }
    function clone$2(obj) {
      if (!isObject$1(obj))
        return obj;
      return isArray$1(obj) ? obj.slice() : extend$1({}, obj);
    }
    function tap(obj, interceptor) {
      interceptor(obj);
      return obj;
    }
    function toPath$1(path) {
      return isArray$1(path) ? path : [path];
    }
    _$1.toPath = toPath$1;
    function toPath(path) {
      return _$1.toPath(path);
    }
    function deepGet(obj, path) {
      var length = path.length;
      for (var i = 0; i < length; i++) {
        if (obj == null)
          return void 0;
        obj = obj[path[i]];
      }
      return length ? obj : void 0;
    }
    function get$3(object2, path, defaultValue2) {
      var value2 = deepGet(object2, toPath(path));
      return isUndefined$1(value2) ? defaultValue2 : value2;
    }
    function has(obj, path) {
      path = toPath(path);
      var length = path.length;
      for (var i = 0; i < length; i++) {
        var key = path[i];
        if (!has$1(obj, key))
          return false;
        obj = obj[key];
      }
      return !!length;
    }
    function identity(value2) {
      return value2;
    }
    function matcher(attrs) {
      attrs = extendOwn({}, attrs);
      return function(obj) {
        return isMatch(obj, attrs);
      };
    }
    function property(path) {
      path = toPath(path);
      return function(obj) {
        return deepGet(obj, path);
      };
    }
    function optimizeCb(func, context2, argCount) {
      if (context2 === void 0)
        return func;
      switch (argCount == null ? 3 : argCount) {
        case 1:
          return function(value2) {
            return func.call(context2, value2);
          };
        case 3:
          return function(value2, index2, collection) {
            return func.call(context2, value2, index2, collection);
          };
        case 4:
          return function(accumulator, value2, index2, collection) {
            return func.call(context2, accumulator, value2, index2, collection);
          };
      }
      return function() {
        return func.apply(context2, arguments);
      };
    }
    function baseIteratee(value2, context2, argCount) {
      if (value2 == null)
        return identity;
      if (isFunction$2(value2))
        return optimizeCb(value2, context2, argCount);
      if (isObject$1(value2) && !isArray$1(value2))
        return matcher(value2);
      return property(value2);
    }
    function iteratee(value2, context2) {
      return baseIteratee(value2, context2, Infinity);
    }
    _$1.iteratee = iteratee;
    function cb(value2, context2, argCount) {
      if (_$1.iteratee !== iteratee)
        return _$1.iteratee(value2, context2);
      return baseIteratee(value2, context2, argCount);
    }
    function mapObject(obj, iteratee2, context2) {
      iteratee2 = cb(iteratee2, context2);
      var _keys = keys$1(obj), length = _keys.length, results = {};
      for (var index2 = 0; index2 < length; index2++) {
        var currentKey = _keys[index2];
        results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
      }
      return results;
    }
    function noop() {
    }
    function propertyOf(obj) {
      if (obj == null)
        return noop;
      return function(path) {
        return get$3(obj, path);
      };
    }
    function times(n2, iteratee2, context2) {
      var accum = Array(Math.max(0, n2));
      iteratee2 = optimizeCb(iteratee2, context2, 1);
      for (var i = 0; i < n2; i++)
        accum[i] = iteratee2(i);
      return accum;
    }
    function random(min2, max2) {
      if (max2 == null) {
        max2 = min2;
        min2 = 0;
      }
      return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
    }
    const now$1 = Date.now || function() {
      return new Date().getTime();
    };
    function createEscaper(map2) {
      var escaper = function(match) {
        return map2[match];
      };
      var source = "(?:" + keys$1(map2).join("|") + ")";
      var testRegexp = RegExp(source);
      var replaceRegexp = RegExp(source, "g");
      return function(string) {
        string = string == null ? "" : "" + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
      };
    }
    const escapeMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
    const escape$1 = createEscaper(escapeMap);
    const unescapeMap = invert(escapeMap);
    const unescape$1 = createEscaper(unescapeMap);
    const templateSettings = _$1.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };
    var noMatch = /(.)^/;
    var escapes = {
      "'": "'",
      "\\": "\\",
      "\r": "r",
      "\n": "n",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
    function escapeChar(match) {
      return "\\" + escapes[match];
    }
    var bareIdentifier = /^\s*(\w|\$)+\s*$/;
    function template(text, settings2, oldSettings) {
      if (!settings2 && oldSettings)
        settings2 = oldSettings;
      settings2 = defaults$1({}, settings2, _$1.templateSettings);
      var matcher2 = RegExp([
        (settings2.escape || noMatch).source,
        (settings2.interpolate || noMatch).source,
        (settings2.evaluate || noMatch).source
      ].join("|") + "|$", "g");
      var index2 = 0;
      var source = "__p+='";
      text.replace(matcher2, function(match, escape2, interpolate, evaluate, offset2) {
        source += text.slice(index2, offset2).replace(escapeRegExp, escapeChar);
        index2 = offset2 + match.length;
        if (escape2) {
          source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
        } else if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        } else if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }
        return match;
      });
      source += "';\n";
      var argument = settings2.variable;
      if (argument) {
        if (!bareIdentifier.test(argument))
          throw new Error(argument);
      } else {
        source = "with(obj||{}){\n" + source + "}\n";
        argument = "obj";
      }
      source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
      var render;
      try {
        render = new Function(argument, "_", source);
      } catch (e) {
        e.source = source;
        throw e;
      }
      var template2 = function(data) {
        return render.call(this, data, _$1);
      };
      template2.source = "function(" + argument + "){\n" + source + "}";
      return template2;
    }
    function result(obj, path, fallback) {
      path = toPath(path);
      var length = path.length;
      if (!length) {
        return isFunction$2(fallback) ? fallback.call(obj) : fallback;
      }
      for (var i = 0; i < length; i++) {
        var prop = obj == null ? void 0 : obj[path[i]];
        if (prop === void 0) {
          prop = fallback;
          i = length;
        }
        obj = isFunction$2(prop) ? prop.call(obj) : prop;
      }
      return obj;
    }
    var idCounter = 0;
    function uniqueId(prefix) {
      var id2 = ++idCounter + "";
      return prefix ? prefix + id2 : id2;
    }
    function chain(obj) {
      var instance = _$1(obj);
      instance._chain = true;
      return instance;
    }
    function executeBound(sourceFunc, boundFunc, context2, callingContext, args) {
      if (!(callingContext instanceof boundFunc))
        return sourceFunc.apply(context2, args);
      var self2 = baseCreate(sourceFunc.prototype);
      var result2 = sourceFunc.apply(self2, args);
      if (isObject$1(result2))
        return result2;
      return self2;
    }
    var partial = restArguments(function(func, boundArgs) {
      var placeholder = partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        }
        while (position < arguments.length)
          args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });
    partial.placeholder = _$1;
    const bind = restArguments(function(func, context2, args) {
      if (!isFunction$2(func))
        throw new TypeError("Bind must be called on a function");
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context2, this, args.concat(callArgs));
      });
      return bound;
    });
    const isArrayLike = createSizePropertyCheck(getLength);
    function flatten$1(input, depth, strict, output) {
      output = output || [];
      if (!depth && depth !== 0) {
        depth = Infinity;
      } else if (depth <= 0) {
        return output.concat(input);
      }
      var idx = output.length;
      for (var i = 0, length = getLength(input); i < length; i++) {
        var value2 = input[i];
        if (isArrayLike(value2) && (isArray$1(value2) || isArguments$1(value2))) {
          if (depth > 1) {
            flatten$1(value2, depth - 1, strict, output);
            idx = output.length;
          } else {
            var j = 0, len = value2.length;
            while (j < len)
              output[idx++] = value2[j++];
          }
        } else if (!strict) {
          output[idx++] = value2;
        }
      }
      return output;
    }
    const bindAll = restArguments(function(obj, keys2) {
      keys2 = flatten$1(keys2, false, false);
      var index2 = keys2.length;
      if (index2 < 1)
        throw new Error("bindAll must be passed function names");
      while (index2--) {
        var key = keys2[index2];
        obj[key] = bind(obj[key], obj);
      }
      return obj;
    });
    function memoize(func, hasher) {
      var memoize2 = function(key) {
        var cache2 = memoize2.cache;
        var address = "" + (hasher ? hasher.apply(this, arguments) : key);
        if (!has$1(cache2, address))
          cache2[address] = func.apply(this, arguments);
        return cache2[address];
      };
      memoize2.cache = {};
      return memoize2;
    }
    const delay = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });
    const defer = partial(delay, _$1, 1);
    function throttle(func, wait, options) {
      var timeout, context2, args, result2;
      var previous = 0;
      if (!options)
        options = {};
      var later = function() {
        previous = options.leading === false ? 0 : now$1();
        timeout = null;
        result2 = func.apply(context2, args);
        if (!timeout)
          context2 = args = null;
      };
      var throttled = function() {
        var _now = now$1();
        if (!previous && options.leading === false)
          previous = _now;
        var remaining = wait - (_now - previous);
        context2 = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = _now;
          result2 = func.apply(context2, args);
          if (!timeout)
            context2 = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result2;
      };
      throttled.cancel = function() {
        clearTimeout(timeout);
        previous = 0;
        timeout = context2 = args = null;
      };
      return throttled;
    }
    function debounce(func, wait, immediate) {
      var timeout, previous, args, result2, context2;
      var later = function() {
        var passed = now$1() - previous;
        if (wait > passed) {
          timeout = setTimeout(later, wait - passed);
        } else {
          timeout = null;
          if (!immediate)
            result2 = func.apply(context2, args);
          if (!timeout)
            args = context2 = null;
        }
      };
      var debounced = restArguments(function(_args) {
        context2 = this;
        args = _args;
        previous = now$1();
        if (!timeout) {
          timeout = setTimeout(later, wait);
          if (immediate)
            result2 = func.apply(context2, args);
        }
        return result2;
      });
      debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = args = context2 = null;
      };
      return debounced;
    }
    function wrap(func, wrapper) {
      return partial(wrapper, func);
    }
    function negate(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    }
    function compose() {
      var args = arguments;
      var start = args.length - 1;
      return function() {
        var i = start;
        var result2 = args[start].apply(this, arguments);
        while (i--)
          result2 = args[i].call(this, result2);
        return result2;
      };
    }
    function after(times2, func) {
      return function() {
        if (--times2 < 1) {
          return func.apply(this, arguments);
        }
      };
    }
    function before(times2, func) {
      var memo;
      return function() {
        if (--times2 > 0) {
          memo = func.apply(this, arguments);
        }
        if (times2 <= 1)
          func = null;
        return memo;
      };
    }
    const once = partial(before, 2);
    function findKey(obj, predicate, context2) {
      predicate = cb(predicate, context2);
      var _keys = keys$1(obj), key;
      for (var i = 0, length = _keys.length; i < length; i++) {
        key = _keys[i];
        if (predicate(obj[key], key, obj))
          return key;
      }
    }
    function createPredicateIndexFinder(dir) {
      return function(array, predicate, context2) {
        predicate = cb(predicate, context2);
        var length = getLength(array);
        var index2 = dir > 0 ? 0 : length - 1;
        for (; index2 >= 0 && index2 < length; index2 += dir) {
          if (predicate(array[index2], index2, array))
            return index2;
        }
        return -1;
      };
    }
    const findIndex = createPredicateIndexFinder(1);
    const findLastIndex = createPredicateIndexFinder(-1);
    function sortedIndex(array, obj, iteratee2, context2) {
      iteratee2 = cb(iteratee2, context2, 1);
      var value2 = iteratee2(obj);
      var low = 0, high = getLength(array);
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (iteratee2(array[mid]) < value2)
          low = mid + 1;
        else
          high = mid;
      }
      return low;
    }
    function createIndexFinder(dir, predicateFind, sortedIndex2) {
      return function(array, item, idx) {
        var i = 0, length = getLength(array);
        if (typeof idx == "number") {
          if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
          } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
          }
        } else if (sortedIndex2 && idx && length) {
          idx = sortedIndex2(array, item);
          return array[idx] === item ? idx : -1;
        }
        if (item !== item) {
          idx = predicateFind(slice.call(array, i, length), isNaN$1);
          return idx >= 0 ? idx + i : -1;
        }
        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
          if (array[idx] === item)
            return idx;
        }
        return -1;
      };
    }
    const indexOf$1 = createIndexFinder(1, findIndex, sortedIndex);
    const lastIndexOf = createIndexFinder(-1, findLastIndex);
    function find(obj, predicate, context2) {
      var keyFinder = isArrayLike(obj) ? findIndex : findKey;
      var key = keyFinder(obj, predicate, context2);
      if (key !== void 0 && key !== -1)
        return obj[key];
    }
    function findWhere(obj, attrs) {
      return find(obj, matcher(attrs));
    }
    function each(obj, iteratee2, context2) {
      iteratee2 = optimizeCb(iteratee2, context2);
      var i, length;
      if (isArrayLike(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
          iteratee2(obj[i], i, obj);
        }
      } else {
        var _keys = keys$1(obj);
        for (i = 0, length = _keys.length; i < length; i++) {
          iteratee2(obj[_keys[i]], _keys[i], obj);
        }
      }
      return obj;
    }
    function map$1(obj, iteratee2, context2) {
      iteratee2 = cb(iteratee2, context2);
      var _keys = !isArrayLike(obj) && keys$1(obj), length = (_keys || obj).length, results = Array(length);
      for (var index2 = 0; index2 < length; index2++) {
        var currentKey = _keys ? _keys[index2] : index2;
        results[index2] = iteratee2(obj[currentKey], currentKey, obj);
      }
      return results;
    }
    function createReduce(dir) {
      var reducer = function(obj, iteratee2, memo, initial2) {
        var _keys = !isArrayLike(obj) && keys$1(obj), length = (_keys || obj).length, index2 = dir > 0 ? 0 : length - 1;
        if (!initial2) {
          memo = obj[_keys ? _keys[index2] : index2];
          index2 += dir;
        }
        for (; index2 >= 0 && index2 < length; index2 += dir) {
          var currentKey = _keys ? _keys[index2] : index2;
          memo = iteratee2(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
      };
      return function(obj, iteratee2, memo, context2) {
        var initial2 = arguments.length >= 3;
        return reducer(obj, optimizeCb(iteratee2, context2, 4), memo, initial2);
      };
    }
    const reduce = createReduce(1);
    const reduceRight = createReduce(-1);
    function filter(obj, predicate, context2) {
      var results = [];
      predicate = cb(predicate, context2);
      each(obj, function(value2, index2, list) {
        if (predicate(value2, index2, list))
          results.push(value2);
      });
      return results;
    }
    function reject(obj, predicate, context2) {
      return filter(obj, negate(cb(predicate)), context2);
    }
    function every(obj, predicate, context2) {
      predicate = cb(predicate, context2);
      var _keys = !isArrayLike(obj) && keys$1(obj), length = (_keys || obj).length;
      for (var index2 = 0; index2 < length; index2++) {
        var currentKey = _keys ? _keys[index2] : index2;
        if (!predicate(obj[currentKey], currentKey, obj))
          return false;
      }
      return true;
    }
    function some$1(obj, predicate, context2) {
      predicate = cb(predicate, context2);
      var _keys = !isArrayLike(obj) && keys$1(obj), length = (_keys || obj).length;
      for (var index2 = 0; index2 < length; index2++) {
        var currentKey = _keys ? _keys[index2] : index2;
        if (predicate(obj[currentKey], currentKey, obj))
          return true;
      }
      return false;
    }
    function contains(obj, item, fromIndex, guard) {
      if (!isArrayLike(obj))
        obj = values(obj);
      if (typeof fromIndex != "number" || guard)
        fromIndex = 0;
      return indexOf$1(obj, item, fromIndex) >= 0;
    }
    const invoke = restArguments(function(obj, path, args) {
      var contextPath, func;
      if (isFunction$2(path)) {
        func = path;
      } else {
        path = toPath(path);
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
      }
      return map$1(obj, function(context2) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context2 = deepGet(context2, contextPath);
          }
          if (context2 == null)
            return void 0;
          method = context2[path];
        }
        return method == null ? method : method.apply(context2, args);
      });
    });
    function pluck(obj, key) {
      return map$1(obj, property(key));
    }
    function where(obj, attrs) {
      return filter(obj, matcher(attrs));
    }
    function max$1(obj, iteratee2, context2) {
      var result2 = -Infinity, lastComputed = -Infinity, value2, computed;
      if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
        obj = isArrayLike(obj) ? obj : values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value2 = obj[i];
          if (value2 != null && value2 > result2) {
            result2 = value2;
          }
        }
      } else {
        iteratee2 = cb(iteratee2, context2);
        each(obj, function(v2, index2, list) {
          computed = iteratee2(v2, index2, list);
          if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
            result2 = v2;
            lastComputed = computed;
          }
        });
      }
      return result2;
    }
    function min$1(obj, iteratee2, context2) {
      var result2 = Infinity, lastComputed = Infinity, value2, computed;
      if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
        obj = isArrayLike(obj) ? obj : values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value2 = obj[i];
          if (value2 != null && value2 < result2) {
            result2 = value2;
          }
        }
      } else {
        iteratee2 = cb(iteratee2, context2);
        each(obj, function(v2, index2, list) {
          computed = iteratee2(v2, index2, list);
          if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
            result2 = v2;
            lastComputed = computed;
          }
        });
      }
      return result2;
    }
    function sample(obj, n2, guard) {
      if (n2 == null || guard) {
        if (!isArrayLike(obj))
          obj = values(obj);
        return obj[random(obj.length - 1)];
      }
      var sample2 = isArrayLike(obj) ? clone$2(obj) : values(obj);
      var length = getLength(sample2);
      n2 = Math.max(Math.min(n2, length), 0);
      var last2 = length - 1;
      for (var index2 = 0; index2 < n2; index2++) {
        var rand = random(index2, last2);
        var temp2 = sample2[index2];
        sample2[index2] = sample2[rand];
        sample2[rand] = temp2;
      }
      return sample2.slice(0, n2);
    }
    function shuffle(obj) {
      return sample(obj, Infinity);
    }
    function sortBy(obj, iteratee2, context2) {
      var index2 = 0;
      iteratee2 = cb(iteratee2, context2);
      return pluck(map$1(obj, function(value2, key, list) {
        return {
          value: value2,
          index: index2++,
          criteria: iteratee2(value2, key, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0)
            return 1;
          if (a < b || b === void 0)
            return -1;
        }
        return left.index - right.index;
      }), "value");
    }
    function group(behavior, partition2) {
      return function(obj, iteratee2, context2) {
        var result2 = partition2 ? [[], []] : {};
        iteratee2 = cb(iteratee2, context2);
        each(obj, function(value2, index2) {
          var key = iteratee2(value2, index2, obj);
          behavior(result2, value2, key);
        });
        return result2;
      };
    }
    const groupBy = group(function(result2, value2, key) {
      if (has$1(result2, key))
        result2[key].push(value2);
      else
        result2[key] = [value2];
    });
    const indexBy = group(function(result2, value2, key) {
      result2[key] = value2;
    });
    const countBy = group(function(result2, value2, key) {
      if (has$1(result2, key))
        result2[key]++;
      else
        result2[key] = 1;
    });
    const partition = group(function(result2, value2, pass) {
      result2[pass ? 0 : 1].push(value2);
    }, true);
    var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
    function toArray$2(obj) {
      if (!obj)
        return [];
      if (isArray$1(obj))
        return slice.call(obj);
      if (isString$1(obj)) {
        return obj.match(reStrSymbol);
      }
      if (isArrayLike(obj))
        return map$1(obj, identity);
      return values(obj);
    }
    function size(obj) {
      if (obj == null)
        return 0;
      return isArrayLike(obj) ? obj.length : keys$1(obj).length;
    }
    function keyInObj(value2, key, obj) {
      return key in obj;
    }
    const pick = restArguments(function(obj, keys2) {
      var result2 = {}, iteratee2 = keys2[0];
      if (obj == null)
        return result2;
      if (isFunction$2(iteratee2)) {
        if (keys2.length > 1)
          iteratee2 = optimizeCb(iteratee2, keys2[1]);
        keys2 = allKeys(obj);
      } else {
        iteratee2 = keyInObj;
        keys2 = flatten$1(keys2, false, false);
        obj = Object(obj);
      }
      for (var i = 0, length = keys2.length; i < length; i++) {
        var key = keys2[i];
        var value2 = obj[key];
        if (iteratee2(value2, key, obj))
          result2[key] = value2;
      }
      return result2;
    });
    const omit = restArguments(function(obj, keys2) {
      var iteratee2 = keys2[0], context2;
      if (isFunction$2(iteratee2)) {
        iteratee2 = negate(iteratee2);
        if (keys2.length > 1)
          context2 = keys2[1];
      } else {
        keys2 = map$1(flatten$1(keys2, false, false), String);
        iteratee2 = function(value2, key) {
          return !contains(keys2, key);
        };
      }
      return pick(obj, iteratee2, context2);
    });
    function initial(array, n2, guard) {
      return slice.call(array, 0, Math.max(0, array.length - (n2 == null || guard ? 1 : n2)));
    }
    function first(array, n2, guard) {
      if (array == null || array.length < 1)
        return n2 == null || guard ? void 0 : [];
      if (n2 == null || guard)
        return array[0];
      return initial(array, array.length - n2);
    }
    function rest(array, n2, guard) {
      return slice.call(array, n2 == null || guard ? 1 : n2);
    }
    function last(array, n2, guard) {
      if (array == null || array.length < 1)
        return n2 == null || guard ? void 0 : [];
      if (n2 == null || guard)
        return array[array.length - 1];
      return rest(array, Math.max(0, array.length - n2));
    }
    function compact(array) {
      return filter(array, Boolean);
    }
    function flatten(array, depth) {
      return flatten$1(array, depth, false);
    }
    const difference = restArguments(function(array, rest2) {
      rest2 = flatten$1(rest2, true, true);
      return filter(array, function(value2) {
        return !contains(rest2, value2);
      });
    });
    const without = restArguments(function(array, otherArrays) {
      return difference(array, otherArrays);
    });
    function uniq(array, isSorted, iteratee2, context2) {
      if (!isBoolean(isSorted)) {
        context2 = iteratee2;
        iteratee2 = isSorted;
        isSorted = false;
      }
      if (iteratee2 != null)
        iteratee2 = cb(iteratee2, context2);
      var result2 = [];
      var seen = [];
      for (var i = 0, length = getLength(array); i < length; i++) {
        var value2 = array[i], computed = iteratee2 ? iteratee2(value2, i, array) : value2;
        if (isSorted && !iteratee2) {
          if (!i || seen !== computed)
            result2.push(value2);
          seen = computed;
        } else if (iteratee2) {
          if (!contains(seen, computed)) {
            seen.push(computed);
            result2.push(value2);
          }
        } else if (!contains(result2, value2)) {
          result2.push(value2);
        }
      }
      return result2;
    }
    const union = restArguments(function(arrays) {
      return uniq(flatten$1(arrays, true, true));
    });
    function intersection(array) {
      var result2 = [];
      var argsLength = arguments.length;
      for (var i = 0, length = getLength(array); i < length; i++) {
        var item = array[i];
        if (contains(result2, item))
          continue;
        var j;
        for (j = 1; j < argsLength; j++) {
          if (!contains(arguments[j], item))
            break;
        }
        if (j === argsLength)
          result2.push(item);
      }
      return result2;
    }
    function unzip(array) {
      var length = array && max$1(array, getLength).length || 0;
      var result2 = Array(length);
      for (var index2 = 0; index2 < length; index2++) {
        result2[index2] = pluck(array, index2);
      }
      return result2;
    }
    const zip = restArguments(unzip);
    function object(list, values2) {
      var result2 = {};
      for (var i = 0, length = getLength(list); i < length; i++) {
        if (values2) {
          result2[list[i]] = values2[i];
        } else {
          result2[list[i][0]] = list[i][1];
        }
      }
      return result2;
    }
    function range(start, stop, step) {
      if (stop == null) {
        stop = start || 0;
        start = 0;
      }
      if (!step) {
        step = stop < start ? -1 : 1;
      }
      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var range2 = Array(length);
      for (var idx = 0; idx < length; idx++, start += step) {
        range2[idx] = start;
      }
      return range2;
    }
    function chunk(array, count) {
      if (count == null || count < 1)
        return [];
      var result2 = [];
      var i = 0, length = array.length;
      while (i < length) {
        result2.push(slice.call(array, i, i += count));
      }
      return result2;
    }
    function chainResult(instance, obj) {
      return instance._chain ? _$1(obj).chain() : obj;
    }
    function mixin(obj) {
      each(functions(obj), function(name2) {
        var func = _$1[name2] = obj[name2];
        _$1.prototype[name2] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return chainResult(this, func.apply(_$1, args));
        };
      });
      return _$1;
    }
    each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name2) {
      var method = ArrayProto[name2];
      _$1.prototype[name2] = function() {
        var obj = this._wrapped;
        if (obj != null) {
          method.apply(obj, arguments);
          if ((name2 === "shift" || name2 === "splice") && obj.length === 0) {
            delete obj[0];
          }
        }
        return chainResult(this, obj);
      };
    });
    each(["concat", "join", "slice"], function(name2) {
      var method = ArrayProto[name2];
      _$1.prototype[name2] = function() {
        var obj = this._wrapped;
        if (obj != null)
          obj = method.apply(obj, arguments);
        return chainResult(this, obj);
      };
    });
    const allExports = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      VERSION,
      restArguments,
      isObject: isObject$1,
      isNull,
      isUndefined: isUndefined$1,
      isBoolean,
      isElement,
      isString: isString$1,
      isNumber: isNumber$1,
      isDate: isDate$1,
      isRegExp,
      isError,
      isSymbol,
      isArrayBuffer,
      isDataView: isDataView$1,
      isArray: isArray$1,
      isFunction: isFunction$2,
      isArguments: isArguments$1,
      isFinite: isFinite$1,
      isNaN: isNaN$1,
      isTypedArray: isTypedArray$1,
      isEmpty,
      isMatch,
      isEqual,
      isMap,
      isWeakMap,
      isSet,
      isWeakSet,
      keys: keys$1,
      allKeys,
      values,
      pairs,
      invert,
      functions,
      methods: functions,
      extend: extend$1,
      extendOwn,
      assign: extendOwn,
      defaults: defaults$1,
      create,
      clone: clone$2,
      tap,
      get: get$3,
      has,
      mapObject,
      identity,
      constant,
      noop,
      toPath: toPath$1,
      property,
      propertyOf,
      matcher,
      matches: matcher,
      times,
      random,
      now: now$1,
      escape: escape$1,
      unescape: unescape$1,
      templateSettings,
      template,
      result,
      uniqueId,
      chain,
      iteratee,
      partial,
      bind,
      bindAll,
      memoize,
      delay,
      defer,
      throttle,
      debounce,
      wrap,
      negate,
      compose,
      after,
      before,
      once,
      findKey,
      findIndex,
      findLastIndex,
      sortedIndex,
      indexOf: indexOf$1,
      lastIndexOf,
      find,
      detect: find,
      findWhere,
      each,
      forEach: each,
      map: map$1,
      collect: map$1,
      reduce,
      foldl: reduce,
      inject: reduce,
      reduceRight,
      foldr: reduceRight,
      filter,
      select: filter,
      reject,
      every,
      all: every,
      some: some$1,
      any: some$1,
      contains,
      includes: contains,
      include: contains,
      invoke,
      pluck,
      where,
      max: max$1,
      min: min$1,
      shuffle,
      sample,
      sortBy,
      groupBy,
      indexBy,
      countBy,
      partition,
      toArray: toArray$2,
      size,
      pick,
      omit,
      first,
      head: first,
      take: first,
      initial,
      last,
      rest,
      tail: rest,
      drop: rest,
      compact,
      flatten,
      without,
      uniq,
      unique: uniq,
      union,
      intersection,
      difference,
      unzip,
      transpose: unzip,
      zip,
      object,
      range,
      chunk,
      mixin,
      default: _$1
    }, Symbol.toStringTag, { value: "Module" }));
    var _ = mixin(allExports);
    _._ = _;
    class WordList {
      constructor() {
        __publicField(this, "text");
        __publicField(this, "list");
        __publicField(this, "counter", 0);
        __publicField(this, "load", async () => {
          let res = await axios.get(window.location.href + "/data/test.txt");
          let text = res.data;
          this.text = text;
          this.split();
          return this.list;
        });
        __publicField(this, "split", () => {
          let words2 = this.text.split(/[\s,.()\/\\=?<>`!"#%&\[\]_:;\*'^~\-\+{}|]/gm).filter((w2) => w2.length > 0).map((w2) => w2.toLowerCase());
          let list = [
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            []
          ];
          words2.forEach((word) => {
            switch (true) {
              case word.startsWith("a"):
                list[0].push(word);
                break;
              case word.startsWith("b"):
                list[1].push(word);
                break;
              case word.startsWith("c"):
                list[2].push(word);
                break;
              case word.startsWith("d"):
                list[3].push(word);
                break;
              case word.startsWith("e"):
                list[4].push(word);
                break;
              case word.startsWith("f"):
                list[5].push(word);
                break;
              case word.startsWith("g"):
                list[6].push(word);
                break;
              case word.startsWith("h"):
                list[7].push(word);
                break;
              case word.startsWith("i"):
                list[8].push(word);
                break;
              case word.startsWith("j"):
                list[9].push(word);
                break;
              case word.startsWith("k"):
                list[10].push(word);
                break;
              case word.startsWith("l"):
                list[11].push(word);
                break;
              case word.startsWith("m"):
                list[12].push(word);
                break;
              case word.startsWith("n"):
                list[13].push(word);
                break;
              case word.startsWith("o"):
                list[14].push(word);
                break;
              case word.startsWith("p"):
                list[15].push(word);
                break;
              case word.startsWith("q"):
                list[16].push(word);
                break;
              case word.startsWith("r"):
                list[17].push(word);
                break;
              case word.startsWith("s"):
                list[18].push(word);
                break;
              case word.startsWith("t"):
                list[19].push(word);
                break;
              case word.startsWith("u"):
                list[20].push(word);
                break;
              case word.startsWith("v"):
                list[21].push(word);
                break;
              case word.startsWith("w"):
                list[22].push(word);
                break;
              case word.startsWith("x"):
                list[23].push(word);
                break;
              case word.startsWith("y"):
                list[24].push(word);
                break;
              case word.startsWith("z"):
                list[25].push(word);
                break;
            }
          });
          this.list = list;
          console.log(this.list);
        });
        __publicField(this, "setOrdered", (to2) => {
          this.orderedMode = to2;
        });
        __publicField(this, "next", () => {
          if (this.counter >= this.list.length) {
            this.counter = 0;
          }
          let wordGroup = this.list[this.counter];
          let word = _.sample(wordGroup).trim();
          this.counter++;
          return word;
        });
      }
    }
    const sleep = (ms) => {
      return new Promise((resolve) => setTimeout(resolve, ms));
    };
    const abbreviateNumber = (value2) => {
      let newValue = value2;
      if (value2 < 1e3) {
        return value2;
      }
      const suffixes = ["", "k", "m", "b", "t"];
      const suffixNum = Math.floor(("" + value2).length / 3);
      let shortValue = "";
      for (var precision = 2; precision >= 1; precision--) {
        shortValue = parseFloat((suffixNum != 0 ? value2 / Math.pow(1e3, suffixNum) : value2).toPrecision(precision));
        var dotLessShortValue = (shortValue + "").replace(/[^a-zA-Z 0-9]+/g, "");
        if (dotLessShortValue.length <= 2) {
          break;
        }
      }
      if (shortValue % 1 != 0)
        shortValue = shortValue.toFixed(1);
      newValue = shortValue + suffixes[suffixNum];
      return newValue;
    };
    const truncate = (str, length) => {
      return str.length > length ? str.substr(0, length - 1) + "..." : str;
    };
    const MIN_VELOCITY = 0.475;
    const MAX_VELOCITY = 4;
    const DIFF_PER_WAVE = 0.025;
    class Velocity {
      constructor() {
        __publicField(this, "maxVelocity", MAX_VELOCITY);
        __publicField(this, "minVelocity", MIN_VELOCITY);
        __publicField(this, "velocity", MIN_VELOCITY);
        __publicField(this, "wave", 0);
        __publicField(this, "calculate", (wave) => {
          if (this._hasReachedMaximumVelocity()) {
            return this.maxVelocity;
          }
          if (this.wave != wave) {
            this.velocity += DIFF_PER_WAVE;
            this.wave = wave;
          }
          console.log(this.velocity);
          return this.velocity;
        });
        __publicField(this, "_hasReachedMaximumVelocity", () => {
          return this.velocity >= this.maxVelocity;
        });
      }
    }
    let app$1;
    let width;
    let height;
    let player;
    let dead = false;
    let words = [];
    let entities = [];
    let paused = false;
    let restarted = false;
    let waveStart = 0;
    let waveEnd = 0;
    let enemiesKilled = 0;
    let shotsFired = 0;
    let shotsMissed = 0;
    let velocity = new Velocity();
    const spawnEnemies = async (amount, wave) => {
      for (let i = 1; i <= amount; i++) {
        Game.add(new Enemy(words.next(), player, wave, velocity));
        if (i % 3 === 0) {
          await sleep(1e3);
        }
      }
    };
    const initEvents = () => {
      if (restarted) {
        return;
      }
      console.log("Setting up events");
      window.addEventListener("keydown", (e) => {
        if (paused) {
          return;
        }
        entities.forEach((entity) => {
          entity.onEvent("keydown", e);
        });
      });
      events.on("enemyDeath", () => {
        enemiesKilled++;
      });
      events.on("enemyTargeted", (enemy) => {
        Game.remove(enemy);
        Game.add(enemy);
      });
      events.on("shotFired", (missed) => {
        if (missed) {
          shotsMissed++;
        }
        shotsFired++;
      });
      events.on("playerDeath", () => {
        if (dead) {
          return;
        }
        dead = true;
        waveEnd = Date.now();
        events.emit("gameOver", {
          waveStart,
          waveEnd,
          enemiesKilled,
          shotsFired,
          shotsMissed
        });
      });
    };
    const animate$1 = (delta) => {
      if (dead) {
        app$1.ticker.stop();
        return;
      }
      entities.forEach((entity) => {
        entity.onUpdate(delta);
      });
      entities.forEach((entity) => {
        entity.draw(delta);
      });
      if (!Game.find("enemy").length) {
        waveEnd = Date.now();
        events.emit("waveEnd", {
          waveStart,
          waveEnd,
          enemiesKilled,
          shotsFired,
          shotsMissed
        });
        app$1.ticker.stop();
        return;
      }
    };
    const Game = {
      start: async (playerName) => {
        app$1 = new Application({
          width: 500,
          height: 800,
          antialias: true,
          autoResize: true,
          backgroundColor: 1777702,
          resolution: window.devicePixelRatio
        });
        document.body.querySelector(".grid").appendChild(app$1.view);
        width = app$1.screen.width;
        height = app$1.screen.height;
        words = new WordList();
        await words.load();
        player = new Player(playerName, width / 2, height - 60);
        Game.add(player);
        initEvents();
        app$1.ticker.stop();
        app$1.ticker.add(animate$1);
      },
      nextWave: (number) => {
        waveStart = Date.now();
        shotsFired = 0;
        shotsMissed = 0;
        enemiesKilled = 0;
        let enemies = 3;
        let multiplier = 3;
        let roundsMultiplier = 4;
        spawnEnemies(enemies + Math.ceil(number / roundsMultiplier) * multiplier, number);
        app$1.ticker.start();
      },
      add: (entity) => {
        entities.push(entity);
        app$1.stage.addChild(entity.container);
      },
      find: (tag) => {
        return entities.filter((a) => a.tag === tag);
      },
      remove: (entity) => {
        app$1.stage.removeChild(entity.container);
        const index2 = entities.indexOf(entity);
        if (index2 > -1) {
          entities.splice(index2, 1);
        }
      },
      pause: (status) => {
        paused = status;
        if (paused) {
          app$1.ticker.stop();
        } else {
          app$1.ticker.start();
        }
      },
      reset: () => {
        restarted = true;
        paused = false;
        shotsFired = 0;
        shotsMissed = 0;
        enemiesKilled = 0;
        dead = false;
        app$1.ticker.destroy();
        words = [];
        entities = [];
        player = null;
      }
    };
    const Game$1 = Game;
    class Background extends react.exports.Component {
      constructor(props) {
        super(props);
      }
      render() {
        const { hidden } = this.props;
        const classes = "background" + (hidden ? " hidden" : "");
        return /* @__PURE__ */ jsxs("div", { className: classes, children: [
          /* @__PURE__ */ jsx("svg", { className: "front", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1440 320", children: /* @__PURE__ */ jsx("path", { fill: "#0099ff", fillOpacity: "1", d: "M0,128L34.3,112C68.6,96,137,64,206,58.7C274.3,53,343,75,411,112C480,149,549,203,617,224C685.7,245,754,235,823,224C891.4,213,960,203,1029,218.7C1097.1,235,1166,277,1234,277.3C1302.9,277,1371,235,1406,213.3L1440,192L1440,320L1405.7,320C1371.4,320,1303,320,1234,320C1165.7,320,1097,320,1029,320C960,320,891,320,823,320C754.3,320,686,320,617,320C548.6,320,480,320,411,320C342.9,320,274,320,206,320C137.1,320,69,320,34,320L0,320Z" }) }),
          /* @__PURE__ */ jsx("div", { className: "front filler" }),
          /* @__PURE__ */ jsx("svg", { className: "back", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1440 320", children: /* @__PURE__ */ jsx("path", { fill: "#0099ff", fillOpacity: "0.6", d: "M0,256L34.3,213.3C68.6,171,137,85,206,58.7C274.3,32,343,64,411,101.3C480,139,549,181,617,213.3C685.7,245,754,267,823,272C891.4,277,960,267,1029,224C1097.1,181,1166,107,1234,96C1302.9,85,1371,139,1406,165.3L1440,192L1440,320L1405.7,320C1371.4,320,1303,320,1234,320C1165.7,320,1097,320,1029,320C960,320,891,320,823,320C754.3,320,686,320,617,320C548.6,320,480,320,411,320C342.9,320,274,320,206,320C137.1,320,69,320,34,320L0,320Z" }) }),
          /* @__PURE__ */ jsx("div", { className: "back filler" }),
          /* @__PURE__ */ jsx("svg", { className: "bumpy", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1440 320", children: /* @__PURE__ */ jsx("path", { fill: "#0099ff", fillOpacity: "0.2", d: "M0,192L34.3,181.3C68.6,171,137,149,206,149.3C274.3,149,343,171,411,160C480,149,549,107,617,90.7C685.7,75,754,85,823,90.7C891.4,96,960,96,1029,112C1097.1,128,1166,160,1234,149.3C1302.9,139,1371,85,1406,58.7L1440,32L1440,320L1405.7,320C1371.4,320,1303,320,1234,320C1165.7,320,1097,320,1029,320C960,320,891,320,823,320C754.3,320,686,320,617,320C548.6,320,480,320,411,320C342.9,320,274,320,206,320C137.1,320,69,320,34,320L0,320Z" }) }),
          /* @__PURE__ */ jsx("div", { className: "bumpy filler" })
        ] });
      }
    }
    class Button extends react.exports.Component {
      constructor(props) {
        super(props);
        __publicField(this, "_handleKeyDown", (e) => {
          let key = e.key;
          let hint = this.props.hint;
          if (!hint) {
            return;
          }
          if (hint.toLowerCase() === "ret") {
            hint = "Enter";
          }
          if (hint.toLowerCase() === "esc") {
            hint = "Escape";
          }
          if (key.toLowerCase() !== hint.toLowerCase()) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
          this.props.onClick();
        });
      }
      componentDidMount() {
        document.addEventListener("keydown", this._handleKeyDown, false);
      }
      componentWillUnmount() {
        document.removeEventListener("keydown", this._handleKeyDown, false);
      }
      render() {
        const { hint, text, onClick, mini, disabled, danger } = this.props;
        let classes = !hint ? "rounded" : "";
        let containerClasses = "buttonContainer" + (danger ? " danger" : "") + (mini ? " sub" : "") + (disabled ? " disabled" : "");
        let click = disabled ? () => {
        } : onClick;
        return /* @__PURE__ */ jsxs("div", { className: containerClasses, children: [
          /* @__PURE__ */ jsx("div", { className: classes, onClick: click, children: text }),
          hint && /* @__PURE__ */ jsx("div", { className: "shortcutHint", children: hint })
        ] });
      }
    }
    var defaultInstanceSettings = {
      update: null,
      begin: null,
      loopBegin: null,
      changeBegin: null,
      change: null,
      changeComplete: null,
      loopComplete: null,
      complete: null,
      loop: 1,
      direction: "normal",
      autoplay: true,
      timelineOffset: 0
    };
    var defaultTweenSettings = {
      duration: 1e3,
      delay: 0,
      endDelay: 0,
      easing: "easeOutElastic(1, .5)",
      round: 0
    };
    var validTransforms = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective", "matrix", "matrix3d"];
    var cache = {
      CSS: {},
      springs: {}
    };
    function minMax(val, min2, max2) {
      return Math.min(Math.max(val, min2), max2);
    }
    function stringContains(str, text) {
      return str.indexOf(text) > -1;
    }
    function applyArguments(func, args) {
      return func.apply(null, args);
    }
    var is = {
      arr: function(a) {
        return Array.isArray(a);
      },
      obj: function(a) {
        return stringContains(Object.prototype.toString.call(a), "Object");
      },
      pth: function(a) {
        return is.obj(a) && a.hasOwnProperty("totalLength");
      },
      svg: function(a) {
        return a instanceof SVGElement;
      },
      inp: function(a) {
        return a instanceof HTMLInputElement;
      },
      dom: function(a) {
        return a.nodeType || is.svg(a);
      },
      str: function(a) {
        return typeof a === "string";
      },
      fnc: function(a) {
        return typeof a === "function";
      },
      und: function(a) {
        return typeof a === "undefined";
      },
      nil: function(a) {
        return is.und(a) || a === null;
      },
      hex: function(a) {
        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);
      },
      rgb: function(a) {
        return /^rgb/.test(a);
      },
      hsl: function(a) {
        return /^hsl/.test(a);
      },
      col: function(a) {
        return is.hex(a) || is.rgb(a) || is.hsl(a);
      },
      key: function(a) {
        return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== "targets" && a !== "keyframes";
      }
    };
    function parseEasingParameters(string) {
      var match = /\(([^)]+)\)/.exec(string);
      return match ? match[1].split(",").map(function(p2) {
        return parseFloat(p2);
      }) : [];
    }
    function spring(string, duration) {
      var params = parseEasingParameters(string);
      var mass = minMax(is.und(params[0]) ? 1 : params[0], 0.1, 100);
      var stiffness = minMax(is.und(params[1]) ? 100 : params[1], 0.1, 100);
      var damping = minMax(is.und(params[2]) ? 10 : params[2], 0.1, 100);
      var velocity2 = minMax(is.und(params[3]) ? 0 : params[3], 0.1, 100);
      var w0 = Math.sqrt(stiffness / mass);
      var zeta = damping / (2 * Math.sqrt(stiffness * mass));
      var wd2 = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
      var a = 1;
      var b = zeta < 1 ? (zeta * w0 + -velocity2) / wd2 : -velocity2 + w0;
      function solver(t2) {
        var progress = duration ? duration * t2 / 1e3 : t2;
        if (zeta < 1) {
          progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd2 * progress) + b * Math.sin(wd2 * progress));
        } else {
          progress = (a + b * progress) * Math.exp(-progress * w0);
        }
        if (t2 === 0 || t2 === 1) {
          return t2;
        }
        return 1 - progress;
      }
      function getDuration() {
        var cached = cache.springs[string];
        if (cached) {
          return cached;
        }
        var frame = 1 / 6;
        var elapsed = 0;
        var rest2 = 0;
        while (true) {
          elapsed += frame;
          if (solver(elapsed) === 1) {
            rest2++;
            if (rest2 >= 16) {
              break;
            }
          } else {
            rest2 = 0;
          }
        }
        var duration2 = elapsed * frame * 1e3;
        cache.springs[string] = duration2;
        return duration2;
      }
      return duration ? solver : getDuration;
    }
    function steps(steps2) {
      if (steps2 === void 0)
        steps2 = 10;
      return function(t2) {
        return Math.ceil(minMax(t2, 1e-6, 1) * steps2) * (1 / steps2);
      };
    }
    var bezier = function() {
      var kSplineTableSize = 11;
      var kSampleStepSize = 1 / (kSplineTableSize - 1);
      function A2(aA1, aA2) {
        return 1 - 3 * aA2 + 3 * aA1;
      }
      function B2(aA1, aA2) {
        return 3 * aA2 - 6 * aA1;
      }
      function C2(aA1) {
        return 3 * aA1;
      }
      function calcBezier(aT, aA1, aA2) {
        return ((A2(aA1, aA2) * aT + B2(aA1, aA2)) * aT + C2(aA1)) * aT;
      }
      function getSlope(aT, aA1, aA2) {
        return 3 * A2(aA1, aA2) * aT * aT + 2 * B2(aA1, aA2) * aT + C2(aA1);
      }
      function binarySubdivide(aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i = 0;
        do {
          currentT = aA + (aB - aA) / 2;
          currentX = calcBezier(currentT, mX1, mX2) - aX;
          if (currentX > 0) {
            aB = currentT;
          } else {
            aA = currentT;
          }
        } while (Math.abs(currentX) > 1e-7 && ++i < 10);
        return currentT;
      }
      function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        for (var i = 0; i < 4; ++i) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);
          if (currentSlope === 0) {
            return aGuessT;
          }
          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
      }
      function bezier2(mX1, mY1, mX2, mY2) {
        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
          return;
        }
        var sampleValues = new Float32Array(kSplineTableSize);
        if (mX1 !== mY1 || mX2 !== mY2) {
          for (var i = 0; i < kSplineTableSize; ++i) {
            sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
          }
        }
        function getTForX(aX) {
          var intervalStart = 0;
          var currentSample = 1;
          var lastSample = kSplineTableSize - 1;
          for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }
          --currentSample;
          var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
          var guessForT = intervalStart + dist * kSampleStepSize;
          var initialSlope = getSlope(guessForT, mX1, mX2);
          if (initialSlope >= 1e-3) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
          } else if (initialSlope === 0) {
            return guessForT;
          } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }
        }
        return function(x2) {
          if (mX1 === mY1 && mX2 === mY2) {
            return x2;
          }
          if (x2 === 0 || x2 === 1) {
            return x2;
          }
          return calcBezier(getTForX(x2), mY1, mY2);
        };
      }
      return bezier2;
    }();
    var penner = function() {
      var eases = { linear: function() {
        return function(t2) {
          return t2;
        };
      } };
      var functionEasings = {
        Sine: function() {
          return function(t2) {
            return 1 - Math.cos(t2 * Math.PI / 2);
          };
        },
        Circ: function() {
          return function(t2) {
            return 1 - Math.sqrt(1 - t2 * t2);
          };
        },
        Back: function() {
          return function(t2) {
            return t2 * t2 * (3 * t2 - 2);
          };
        },
        Bounce: function() {
          return function(t2) {
            var pow2, b = 4;
            while (t2 < ((pow2 = Math.pow(2, --b)) - 1) / 11) {
            }
            return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t2, 2);
          };
        },
        Elastic: function(amplitude, period) {
          if (amplitude === void 0)
            amplitude = 1;
          if (period === void 0)
            period = 0.5;
          var a = minMax(amplitude, 1, 10);
          var p2 = minMax(period, 0.1, 2);
          return function(t2) {
            return t2 === 0 || t2 === 1 ? t2 : -a * Math.pow(2, 10 * (t2 - 1)) * Math.sin((t2 - 1 - p2 / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p2);
          };
        }
      };
      var baseEasings = ["Quad", "Cubic", "Quart", "Quint", "Expo"];
      baseEasings.forEach(function(name2, i) {
        functionEasings[name2] = function() {
          return function(t2) {
            return Math.pow(t2, i + 2);
          };
        };
      });
      Object.keys(functionEasings).forEach(function(name2) {
        var easeIn = functionEasings[name2];
        eases["easeIn" + name2] = easeIn;
        eases["easeOut" + name2] = function(a, b) {
          return function(t2) {
            return 1 - easeIn(a, b)(1 - t2);
          };
        };
        eases["easeInOut" + name2] = function(a, b) {
          return function(t2) {
            return t2 < 0.5 ? easeIn(a, b)(t2 * 2) / 2 : 1 - easeIn(a, b)(t2 * -2 + 2) / 2;
          };
        };
        eases["easeOutIn" + name2] = function(a, b) {
          return function(t2) {
            return t2 < 0.5 ? (1 - easeIn(a, b)(1 - t2 * 2)) / 2 : (easeIn(a, b)(t2 * 2 - 1) + 1) / 2;
          };
        };
      });
      return eases;
    }();
    function parseEasings(easing, duration) {
      if (is.fnc(easing)) {
        return easing;
      }
      var name2 = easing.split("(")[0];
      var ease = penner[name2];
      var args = parseEasingParameters(easing);
      switch (name2) {
        case "spring":
          return spring(easing, duration);
        case "cubicBezier":
          return applyArguments(bezier, args);
        case "steps":
          return applyArguments(steps, args);
        default:
          return applyArguments(ease, args);
      }
    }
    function selectString(str) {
      try {
        var nodes = document.querySelectorAll(str);
        return nodes;
      } catch (e) {
        return;
      }
    }
    function filterArray(arr, callback) {
      var len = arr.length;
      var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
      var result2 = [];
      for (var i = 0; i < len; i++) {
        if (i in arr) {
          var val = arr[i];
          if (callback.call(thisArg, val, i, arr)) {
            result2.push(val);
          }
        }
      }
      return result2;
    }
    function flattenArray(arr) {
      return arr.reduce(function(a, b) {
        return a.concat(is.arr(b) ? flattenArray(b) : b);
      }, []);
    }
    function toArray$1(o) {
      if (is.arr(o)) {
        return o;
      }
      if (is.str(o)) {
        o = selectString(o) || o;
      }
      if (o instanceof NodeList || o instanceof HTMLCollection) {
        return [].slice.call(o);
      }
      return [o];
    }
    function arrayContains(arr, val) {
      return arr.some(function(a) {
        return a === val;
      });
    }
    function cloneObject(o) {
      var clone2 = {};
      for (var p2 in o) {
        clone2[p2] = o[p2];
      }
      return clone2;
    }
    function replaceObjectProps(o1, o2) {
      var o = cloneObject(o1);
      for (var p2 in o1) {
        o[p2] = o2.hasOwnProperty(p2) ? o2[p2] : o1[p2];
      }
      return o;
    }
    function mergeObjects(o1, o2) {
      var o = cloneObject(o1);
      for (var p2 in o2) {
        o[p2] = is.und(o1[p2]) ? o2[p2] : o1[p2];
      }
      return o;
    }
    function rgbToRgba(rgbValue) {
      var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
      return rgb ? "rgba(" + rgb[1] + ",1)" : rgbValue;
    }
    function hexToRgba(hexValue) {
      var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      var hex = hexValue.replace(rgx, function(m2, r3, g3, b2) {
        return r3 + r3 + g3 + g3 + b2 + b2;
      });
      var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      var r2 = parseInt(rgb[1], 16);
      var g2 = parseInt(rgb[2], 16);
      var b = parseInt(rgb[3], 16);
      return "rgba(" + r2 + "," + g2 + "," + b + ",1)";
    }
    function hslToRgba(hslValue) {
      var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
      var h2 = parseInt(hsl[1], 10) / 360;
      var s = parseInt(hsl[2], 10) / 100;
      var l2 = parseInt(hsl[3], 10) / 100;
      var a = hsl[4] || 1;
      function hue2rgb(p3, q3, t2) {
        if (t2 < 0) {
          t2 += 1;
        }
        if (t2 > 1) {
          t2 -= 1;
        }
        if (t2 < 1 / 6) {
          return p3 + (q3 - p3) * 6 * t2;
        }
        if (t2 < 1 / 2) {
          return q3;
        }
        if (t2 < 2 / 3) {
          return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
        }
        return p3;
      }
      var r2, g2, b;
      if (s == 0) {
        r2 = g2 = b = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
        var p2 = 2 * l2 - q2;
        r2 = hue2rgb(p2, q2, h2 + 1 / 3);
        g2 = hue2rgb(p2, q2, h2);
        b = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return "rgba(" + r2 * 255 + "," + g2 * 255 + "," + b * 255 + "," + a + ")";
    }
    function colorToRgb(val) {
      if (is.rgb(val)) {
        return rgbToRgba(val);
      }
      if (is.hex(val)) {
        return hexToRgba(val);
      }
      if (is.hsl(val)) {
        return hslToRgba(val);
      }
    }
    function getUnit(val) {
      var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
      if (split) {
        return split[1];
      }
    }
    function getTransformUnit(propName) {
      if (stringContains(propName, "translate") || propName === "perspective") {
        return "px";
      }
      if (stringContains(propName, "rotate") || stringContains(propName, "skew")) {
        return "deg";
      }
    }
    function getFunctionValue(val, animatable) {
      if (!is.fnc(val)) {
        return val;
      }
      return val(animatable.target, animatable.id, animatable.total);
    }
    function getAttribute(el, prop) {
      return el.getAttribute(prop);
    }
    function convertPxToUnit(el, value2, unit) {
      var valueUnit = getUnit(value2);
      if (arrayContains([unit, "deg", "rad", "turn"], valueUnit)) {
        return value2;
      }
      var cached = cache.CSS[value2 + unit];
      if (!is.und(cached)) {
        return cached;
      }
      var baseline = 100;
      var tempEl = document.createElement(el.tagName);
      var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;
      parentEl.appendChild(tempEl);
      tempEl.style.position = "absolute";
      tempEl.style.width = baseline + unit;
      var factor = baseline / tempEl.offsetWidth;
      parentEl.removeChild(tempEl);
      var convertedUnit = factor * parseFloat(value2);
      cache.CSS[value2 + unit] = convertedUnit;
      return convertedUnit;
    }
    function getCSSValue(el, prop, unit) {
      if (prop in el.style) {
        var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
        var value2 = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || "0";
        return unit ? convertPxToUnit(el, value2, unit) : value2;
      }
    }
    function getAnimationType(el, prop) {
      if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || is.svg(el) && el[prop])) {
        return "attribute";
      }
      if (is.dom(el) && arrayContains(validTransforms, prop)) {
        return "transform";
      }
      if (is.dom(el) && (prop !== "transform" && getCSSValue(el, prop))) {
        return "css";
      }
      if (el[prop] != null) {
        return "object";
      }
    }
    function getElementTransforms(el) {
      if (!is.dom(el)) {
        return;
      }
      var str = el.style.transform || "";
      var reg = /(\w+)\(([^)]*)\)/g;
      var transforms = /* @__PURE__ */ new Map();
      var m2;
      while (m2 = reg.exec(str)) {
        transforms.set(m2[1], m2[2]);
      }
      return transforms;
    }
    function getTransformValue(el, propName, animatable, unit) {
      var defaultVal = stringContains(propName, "scale") ? 1 : 0 + getTransformUnit(propName);
      var value2 = getElementTransforms(el).get(propName) || defaultVal;
      if (animatable) {
        animatable.transforms.list.set(propName, value2);
        animatable.transforms["last"] = propName;
      }
      return unit ? convertPxToUnit(el, value2, unit) : value2;
    }
    function getOriginalTargetValue(target, propName, unit, animatable) {
      switch (getAnimationType(target, propName)) {
        case "transform":
          return getTransformValue(target, propName, animatable, unit);
        case "css":
          return getCSSValue(target, propName, unit);
        case "attribute":
          return getAttribute(target, propName);
        default:
          return target[propName] || 0;
      }
    }
    function getRelativeValue(to2, from2) {
      var operator = /^(\*=|\+=|-=)/.exec(to2);
      if (!operator) {
        return to2;
      }
      var u2 = getUnit(to2) || 0;
      var x2 = parseFloat(from2);
      var y2 = parseFloat(to2.replace(operator[0], ""));
      switch (operator[0][0]) {
        case "+":
          return x2 + y2 + u2;
        case "-":
          return x2 - y2 + u2;
        case "*":
          return x2 * y2 + u2;
      }
    }
    function validateValue(val, unit) {
      if (is.col(val)) {
        return colorToRgb(val);
      }
      if (/\s/g.test(val)) {
        return val;
      }
      var originalUnit = getUnit(val);
      var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
      if (unit) {
        return unitLess + unit;
      }
      return unitLess;
    }
    function getDistance(p1, p2) {
      return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
    }
    function getCircleLength(el) {
      return Math.PI * 2 * getAttribute(el, "r");
    }
    function getRectLength(el) {
      return getAttribute(el, "width") * 2 + getAttribute(el, "height") * 2;
    }
    function getLineLength(el) {
      return getDistance(
        { x: getAttribute(el, "x1"), y: getAttribute(el, "y1") },
        { x: getAttribute(el, "x2"), y: getAttribute(el, "y2") }
      );
    }
    function getPolylineLength(el) {
      var points = el.points;
      var totalLength = 0;
      var previousPos;
      for (var i = 0; i < points.numberOfItems; i++) {
        var currentPos = points.getItem(i);
        if (i > 0) {
          totalLength += getDistance(previousPos, currentPos);
        }
        previousPos = currentPos;
      }
      return totalLength;
    }
    function getPolygonLength(el) {
      var points = el.points;
      return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
    }
    function getTotalLength(el) {
      if (el.getTotalLength) {
        return el.getTotalLength();
      }
      switch (el.tagName.toLowerCase()) {
        case "circle":
          return getCircleLength(el);
        case "rect":
          return getRectLength(el);
        case "line":
          return getLineLength(el);
        case "polyline":
          return getPolylineLength(el);
        case "polygon":
          return getPolygonLength(el);
      }
    }
    function setDashoffset(el) {
      var pathLength = getTotalLength(el);
      el.setAttribute("stroke-dasharray", pathLength);
      return pathLength;
    }
    function getParentSvgEl(el) {
      var parentEl = el.parentNode;
      while (is.svg(parentEl)) {
        if (!is.svg(parentEl.parentNode)) {
          break;
        }
        parentEl = parentEl.parentNode;
      }
      return parentEl;
    }
    function getParentSvg(pathEl, svgData) {
      var svg = svgData || {};
      var parentSvgEl = svg.el || getParentSvgEl(pathEl);
      var rect = parentSvgEl.getBoundingClientRect();
      var viewBoxAttr = getAttribute(parentSvgEl, "viewBox");
      var width2 = rect.width;
      var height2 = rect.height;
      var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(" ") : [0, 0, width2, height2]);
      return {
        el: parentSvgEl,
        viewBox,
        x: viewBox[0] / 1,
        y: viewBox[1] / 1,
        w: width2,
        h: height2,
        vW: viewBox[2],
        vH: viewBox[3]
      };
    }
    function getPath(path, percent) {
      var pathEl = is.str(path) ? selectString(path)[0] : path;
      var p2 = percent || 100;
      return function(property2) {
        return {
          property: property2,
          el: pathEl,
          svg: getParentSvg(pathEl),
          totalLength: getTotalLength(pathEl) * (p2 / 100)
        };
      };
    }
    function getPathProgress(path, progress, isPathTargetInsideSVG) {
      function point(offset2) {
        if (offset2 === void 0)
          offset2 = 0;
        var l2 = progress + offset2 >= 1 ? progress + offset2 : 0;
        return path.el.getPointAtLength(l2);
      }
      var svg = getParentSvg(path.el, path.svg);
      var p2 = point();
      var p0 = point(-1);
      var p1 = point(1);
      var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;
      var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;
      switch (path.property) {
        case "x":
          return (p2.x - svg.x) * scaleX;
        case "y":
          return (p2.y - svg.y) * scaleY;
        case "angle":
          return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
      }
    }
    function decomposeValue(val, unit) {
      var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g;
      var value2 = validateValue(is.pth(val) ? val.totalLength : val, unit) + "";
      return {
        original: value2,
        numbers: value2.match(rgx) ? value2.match(rgx).map(Number) : [0],
        strings: is.str(val) || unit ? value2.split(rgx) : []
      };
    }
    function parseTargets(targets) {
      var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray$1) : toArray$1(targets)) : [];
      return filterArray(targetsArray, function(item, pos, self2) {
        return self2.indexOf(item) === pos;
      });
    }
    function getAnimatables(targets) {
      var parsed = parseTargets(targets);
      return parsed.map(function(t2, i) {
        return { target: t2, id: i, total: parsed.length, transforms: { list: getElementTransforms(t2) } };
      });
    }
    function normalizePropertyTweens(prop, tweenSettings) {
      var settings2 = cloneObject(tweenSettings);
      if (/^spring/.test(settings2.easing)) {
        settings2.duration = spring(settings2.easing);
      }
      if (is.arr(prop)) {
        var l2 = prop.length;
        var isFromTo = l2 === 2 && !is.obj(prop[0]);
        if (!isFromTo) {
          if (!is.fnc(tweenSettings.duration)) {
            settings2.duration = tweenSettings.duration / l2;
          }
        } else {
          prop = { value: prop };
        }
      }
      var propArray = is.arr(prop) ? prop : [prop];
      return propArray.map(function(v2, i) {
        var obj = is.obj(v2) && !is.pth(v2) ? v2 : { value: v2 };
        if (is.und(obj.delay)) {
          obj.delay = !i ? tweenSettings.delay : 0;
        }
        if (is.und(obj.endDelay)) {
          obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;
        }
        return obj;
      }).map(function(k) {
        return mergeObjects(k, settings2);
      });
    }
    function flattenKeyframes(keyframes) {
      var propertyNames = filterArray(flattenArray(keyframes.map(function(key) {
        return Object.keys(key);
      })), function(p2) {
        return is.key(p2);
      }).reduce(function(a, b) {
        if (a.indexOf(b) < 0) {
          a.push(b);
        }
        return a;
      }, []);
      var properties = {};
      var loop = function(i2) {
        var propName = propertyNames[i2];
        properties[propName] = keyframes.map(function(key) {
          var newKey = {};
          for (var p2 in key) {
            if (is.key(p2)) {
              if (p2 == propName) {
                newKey.value = key[p2];
              }
            } else {
              newKey[p2] = key[p2];
            }
          }
          return newKey;
        });
      };
      for (var i = 0; i < propertyNames.length; i++)
        loop(i);
      return properties;
    }
    function getProperties(tweenSettings, params) {
      var properties = [];
      var keyframes = params.keyframes;
      if (keyframes) {
        params = mergeObjects(flattenKeyframes(keyframes), params);
      }
      for (var p2 in params) {
        if (is.key(p2)) {
          properties.push({
            name: p2,
            tweens: normalizePropertyTweens(params[p2], tweenSettings)
          });
        }
      }
      return properties;
    }
    function normalizeTweenValues(tween, animatable) {
      var t2 = {};
      for (var p2 in tween) {
        var value2 = getFunctionValue(tween[p2], animatable);
        if (is.arr(value2)) {
          value2 = value2.map(function(v2) {
            return getFunctionValue(v2, animatable);
          });
          if (value2.length === 1) {
            value2 = value2[0];
          }
        }
        t2[p2] = value2;
      }
      t2.duration = parseFloat(t2.duration);
      t2.delay = parseFloat(t2.delay);
      return t2;
    }
    function normalizeTweens(prop, animatable) {
      var previousTween;
      return prop.tweens.map(function(t2) {
        var tween = normalizeTweenValues(t2, animatable);
        var tweenValue = tween.value;
        var to2 = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
        var toUnit = getUnit(to2);
        var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
        var previousValue = previousTween ? previousTween.to.original : originalValue;
        var from2 = is.arr(tweenValue) ? tweenValue[0] : previousValue;
        var fromUnit = getUnit(from2) || getUnit(originalValue);
        var unit = toUnit || fromUnit;
        if (is.und(to2)) {
          to2 = previousValue;
        }
        tween.from = decomposeValue(from2, unit);
        tween.to = decomposeValue(getRelativeValue(to2, from2), unit);
        tween.start = previousTween ? previousTween.end : 0;
        tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
        tween.easing = parseEasings(tween.easing, tween.duration);
        tween.isPath = is.pth(tweenValue);
        tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);
        tween.isColor = is.col(tween.from.original);
        if (tween.isColor) {
          tween.round = 1;
        }
        previousTween = tween;
        return tween;
      });
    }
    var setProgressValue = {
      css: function(t2, p2, v2) {
        return t2.style[p2] = v2;
      },
      attribute: function(t2, p2, v2) {
        return t2.setAttribute(p2, v2);
      },
      object: function(t2, p2, v2) {
        return t2[p2] = v2;
      },
      transform: function(t2, p2, v2, transforms, manual) {
        transforms.list.set(p2, v2);
        if (p2 === transforms.last || manual) {
          var str = "";
          transforms.list.forEach(function(value2, prop) {
            str += prop + "(" + value2 + ") ";
          });
          t2.style.transform = str;
        }
      }
    };
    function setTargetsValue(targets, properties) {
      var animatables = getAnimatables(targets);
      animatables.forEach(function(animatable) {
        for (var property2 in properties) {
          var value2 = getFunctionValue(properties[property2], animatable);
          var target = animatable.target;
          var valueUnit = getUnit(value2);
          var originalValue = getOriginalTargetValue(target, property2, valueUnit, animatable);
          var unit = valueUnit || getUnit(originalValue);
          var to2 = getRelativeValue(validateValue(value2, unit), originalValue);
          var animType = getAnimationType(target, property2);
          setProgressValue[animType](target, property2, to2, animatable.transforms, true);
        }
      });
    }
    function createAnimation(animatable, prop) {
      var animType = getAnimationType(animatable.target, prop.name);
      if (animType) {
        var tweens = normalizeTweens(prop, animatable);
        var lastTween = tweens[tweens.length - 1];
        return {
          type: animType,
          property: prop.name,
          animatable,
          tweens,
          duration: lastTween.end,
          delay: tweens[0].delay,
          endDelay: lastTween.endDelay
        };
      }
    }
    function getAnimations(animatables, properties) {
      return filterArray(flattenArray(animatables.map(function(animatable) {
        return properties.map(function(prop) {
          return createAnimation(animatable, prop);
        });
      })), function(a) {
        return !is.und(a);
      });
    }
    function getInstanceTimings(animations, tweenSettings) {
      var animLength = animations.length;
      var getTlOffset = function(anim) {
        return anim.timelineOffset ? anim.timelineOffset : 0;
      };
      var timings = {};
      timings.duration = animLength ? Math.max.apply(Math, animations.map(function(anim) {
        return getTlOffset(anim) + anim.duration;
      })) : tweenSettings.duration;
      timings.delay = animLength ? Math.min.apply(Math, animations.map(function(anim) {
        return getTlOffset(anim) + anim.delay;
      })) : tweenSettings.delay;
      timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function(anim) {
        return getTlOffset(anim) + anim.duration - anim.endDelay;
      })) : tweenSettings.endDelay;
      return timings;
    }
    var instanceID = 0;
    function createNewInstance(params) {
      var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
      var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
      var properties = getProperties(tweenSettings, params);
      var animatables = getAnimatables(params.targets);
      var animations = getAnimations(animatables, properties);
      var timings = getInstanceTimings(animations, tweenSettings);
      var id2 = instanceID;
      instanceID++;
      return mergeObjects(instanceSettings, {
        id: id2,
        children: [],
        animatables,
        animations,
        duration: timings.duration,
        delay: timings.delay,
        endDelay: timings.endDelay
      });
    }
    var activeInstances = [];
    var engine = function() {
      var raf;
      function play() {
        if (!raf && (!isDocumentHidden() || !anime.suspendWhenDocumentHidden) && activeInstances.length > 0) {
          raf = requestAnimationFrame(step);
        }
      }
      function step(t2) {
        var activeInstancesLength = activeInstances.length;
        var i = 0;
        while (i < activeInstancesLength) {
          var activeInstance = activeInstances[i];
          if (!activeInstance.paused) {
            activeInstance.tick(t2);
            i++;
          } else {
            activeInstances.splice(i, 1);
            activeInstancesLength--;
          }
        }
        raf = i > 0 ? requestAnimationFrame(step) : void 0;
      }
      function handleVisibilityChange() {
        if (!anime.suspendWhenDocumentHidden) {
          return;
        }
        if (isDocumentHidden()) {
          raf = cancelAnimationFrame(raf);
        } else {
          activeInstances.forEach(
            function(instance) {
              return instance._onDocumentVisibility();
            }
          );
          engine();
        }
      }
      if (typeof document !== "undefined") {
        document.addEventListener("visibilitychange", handleVisibilityChange);
      }
      return play;
    }();
    function isDocumentHidden() {
      return !!document && document.hidden;
    }
    function anime(params) {
      if (params === void 0)
        params = {};
      var startTime = 0, lastTime2 = 0, now2 = 0;
      var children, childrenLength = 0;
      var resolve = null;
      function makePromise(instance2) {
        var promise2 = window.Promise && new Promise(function(_resolve) {
          return resolve = _resolve;
        });
        instance2.finished = promise2;
        return promise2;
      }
      var instance = createNewInstance(params);
      makePromise(instance);
      function toggleInstanceDirection() {
        var direction = instance.direction;
        if (direction !== "alternate") {
          instance.direction = direction !== "normal" ? "normal" : "reverse";
        }
        instance.reversed = !instance.reversed;
        children.forEach(function(child) {
          return child.reversed = instance.reversed;
        });
      }
      function adjustTime(time) {
        return instance.reversed ? instance.duration - time : time;
      }
      function resetTime() {
        startTime = 0;
        lastTime2 = adjustTime(instance.currentTime) * (1 / anime.speed);
      }
      function seekChild(time, child) {
        if (child) {
          child.seek(time - child.timelineOffset);
        }
      }
      function syncInstanceChildren(time) {
        if (!instance.reversePlayback) {
          for (var i = 0; i < childrenLength; i++) {
            seekChild(time, children[i]);
          }
        } else {
          for (var i$1 = childrenLength; i$1--; ) {
            seekChild(time, children[i$1]);
          }
        }
      }
      function setAnimationsProgress(insTime) {
        var i = 0;
        var animations = instance.animations;
        var animationsLength = animations.length;
        while (i < animationsLength) {
          var anim = animations[i];
          var animatable = anim.animatable;
          var tweens = anim.tweens;
          var tweenLength = tweens.length - 1;
          var tween = tweens[tweenLength];
          if (tweenLength) {
            tween = filterArray(tweens, function(t2) {
              return insTime < t2.end;
            })[0] || tween;
          }
          var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
          var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
          var strings = tween.to.strings;
          var round2 = tween.round;
          var numbers = [];
          var toNumbersLength = tween.to.numbers.length;
          var progress = void 0;
          for (var n2 = 0; n2 < toNumbersLength; n2++) {
            var value2 = void 0;
            var toNumber = tween.to.numbers[n2];
            var fromNumber = tween.from.numbers[n2] || 0;
            if (!tween.isPath) {
              value2 = fromNumber + eased * (toNumber - fromNumber);
            } else {
              value2 = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);
            }
            if (round2) {
              if (!(tween.isColor && n2 > 2)) {
                value2 = Math.round(value2 * round2) / round2;
              }
            }
            numbers.push(value2);
          }
          var stringsLength = strings.length;
          if (!stringsLength) {
            progress = numbers[0];
          } else {
            progress = strings[0];
            for (var s = 0; s < stringsLength; s++) {
              strings[s];
              var b = strings[s + 1];
              var n$12 = numbers[s];
              if (!isNaN(n$12)) {
                if (!b) {
                  progress += n$12 + " ";
                } else {
                  progress += n$12 + b;
                }
              }
            }
          }
          setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
          anim.currentValue = progress;
          i++;
        }
      }
      function setCallback(cb2) {
        if (instance[cb2] && !instance.passThrough) {
          instance[cb2](instance);
        }
      }
      function countIteration() {
        if (instance.remaining && instance.remaining !== true) {
          instance.remaining--;
        }
      }
      function setInstanceProgress(engineTime) {
        var insDuration = instance.duration;
        var insDelay = instance.delay;
        var insEndDelay = insDuration - instance.endDelay;
        var insTime = adjustTime(engineTime);
        instance.progress = minMax(insTime / insDuration * 100, 0, 100);
        instance.reversePlayback = insTime < instance.currentTime;
        if (children) {
          syncInstanceChildren(insTime);
        }
        if (!instance.began && instance.currentTime > 0) {
          instance.began = true;
          setCallback("begin");
        }
        if (!instance.loopBegan && instance.currentTime > 0) {
          instance.loopBegan = true;
          setCallback("loopBegin");
        }
        if (insTime <= insDelay && instance.currentTime !== 0) {
          setAnimationsProgress(0);
        }
        if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {
          setAnimationsProgress(insDuration);
        }
        if (insTime > insDelay && insTime < insEndDelay) {
          if (!instance.changeBegan) {
            instance.changeBegan = true;
            instance.changeCompleted = false;
            setCallback("changeBegin");
          }
          setCallback("change");
          setAnimationsProgress(insTime);
        } else {
          if (instance.changeBegan) {
            instance.changeCompleted = true;
            instance.changeBegan = false;
            setCallback("changeComplete");
          }
        }
        instance.currentTime = minMax(insTime, 0, insDuration);
        if (instance.began) {
          setCallback("update");
        }
        if (engineTime >= insDuration) {
          lastTime2 = 0;
          countIteration();
          if (!instance.remaining) {
            instance.paused = true;
            if (!instance.completed) {
              instance.completed = true;
              setCallback("loopComplete");
              setCallback("complete");
              if (!instance.passThrough && "Promise" in window) {
                resolve();
                makePromise(instance);
              }
            }
          } else {
            startTime = now2;
            setCallback("loopComplete");
            instance.loopBegan = false;
            if (instance.direction === "alternate") {
              toggleInstanceDirection();
            }
          }
        }
      }
      instance.reset = function() {
        var direction = instance.direction;
        instance.passThrough = false;
        instance.currentTime = 0;
        instance.progress = 0;
        instance.paused = true;
        instance.began = false;
        instance.loopBegan = false;
        instance.changeBegan = false;
        instance.completed = false;
        instance.changeCompleted = false;
        instance.reversePlayback = false;
        instance.reversed = direction === "reverse";
        instance.remaining = instance.loop;
        children = instance.children;
        childrenLength = children.length;
        for (var i = childrenLength; i--; ) {
          instance.children[i].reset();
        }
        if (instance.reversed && instance.loop !== true || direction === "alternate" && instance.loop === 1) {
          instance.remaining++;
        }
        setAnimationsProgress(instance.reversed ? instance.duration : 0);
      };
      instance._onDocumentVisibility = resetTime;
      instance.set = function(targets, properties) {
        setTargetsValue(targets, properties);
        return instance;
      };
      instance.tick = function(t2) {
        now2 = t2;
        if (!startTime) {
          startTime = now2;
        }
        setInstanceProgress((now2 + (lastTime2 - startTime)) * anime.speed);
      };
      instance.seek = function(time) {
        setInstanceProgress(adjustTime(time));
      };
      instance.pause = function() {
        instance.paused = true;
        resetTime();
      };
      instance.play = function() {
        if (!instance.paused) {
          return;
        }
        if (instance.completed) {
          instance.reset();
        }
        instance.paused = false;
        activeInstances.push(instance);
        resetTime();
        engine();
      };
      instance.reverse = function() {
        toggleInstanceDirection();
        instance.completed = instance.reversed ? false : true;
        resetTime();
      };
      instance.restart = function() {
        instance.reset();
        instance.play();
      };
      instance.remove = function(targets) {
        var targetsArray = parseTargets(targets);
        removeTargetsFromInstance(targetsArray, instance);
      };
      instance.reset();
      if (instance.autoplay) {
        instance.play();
      }
      return instance;
    }
    function removeTargetsFromAnimations(targetsArray, animations) {
      for (var a = animations.length; a--; ) {
        if (arrayContains(targetsArray, animations[a].animatable.target)) {
          animations.splice(a, 1);
        }
      }
    }
    function removeTargetsFromInstance(targetsArray, instance) {
      var animations = instance.animations;
      var children = instance.children;
      removeTargetsFromAnimations(targetsArray, animations);
      for (var c = children.length; c--; ) {
        var child = children[c];
        var childAnimations = child.animations;
        removeTargetsFromAnimations(targetsArray, childAnimations);
        if (!childAnimations.length && !child.children.length) {
          children.splice(c, 1);
        }
      }
      if (!animations.length && !children.length) {
        instance.pause();
      }
    }
    function removeTargetsFromActiveInstances(targets) {
      var targetsArray = parseTargets(targets);
      for (var i = activeInstances.length; i--; ) {
        var instance = activeInstances[i];
        removeTargetsFromInstance(targetsArray, instance);
      }
    }
    function stagger(val, params) {
      if (params === void 0)
        params = {};
      var direction = params.direction || "normal";
      var easing = params.easing ? parseEasings(params.easing) : null;
      var grid = params.grid;
      var axis = params.axis;
      var fromIndex = params.from || 0;
      var fromFirst = fromIndex === "first";
      var fromCenter = fromIndex === "center";
      var fromLast = fromIndex === "last";
      var isRange = is.arr(val);
      var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
      var val2 = isRange ? parseFloat(val[1]) : 0;
      var unit = getUnit(isRange ? val[1] : val) || 0;
      var start = params.start || 0 + (isRange ? val1 : 0);
      var values2 = [];
      var maxValue = 0;
      return function(el, i, t2) {
        if (fromFirst) {
          fromIndex = 0;
        }
        if (fromCenter) {
          fromIndex = (t2 - 1) / 2;
        }
        if (fromLast) {
          fromIndex = t2 - 1;
        }
        if (!values2.length) {
          for (var index2 = 0; index2 < t2; index2++) {
            if (!grid) {
              values2.push(Math.abs(fromIndex - index2));
            } else {
              var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
              var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
              var toX = index2 % grid[0];
              var toY = Math.floor(index2 / grid[0]);
              var distanceX = fromX - toX;
              var distanceY = fromY - toY;
              var value2 = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
              if (axis === "x") {
                value2 = -distanceX;
              }
              if (axis === "y") {
                value2 = -distanceY;
              }
              values2.push(value2);
            }
            maxValue = Math.max.apply(Math, values2);
          }
          if (easing) {
            values2 = values2.map(function(val3) {
              return easing(val3 / maxValue) * maxValue;
            });
          }
          if (direction === "reverse") {
            values2 = values2.map(function(val3) {
              return axis ? val3 < 0 ? val3 * -1 : -val3 : Math.abs(maxValue - val3);
            });
          }
        }
        var spacing = isRange ? (val2 - val1) / maxValue : val1;
        return start + spacing * (Math.round(values2[i] * 100) / 100) + unit;
      };
    }
    function timeline(params) {
      if (params === void 0)
        params = {};
      var tl = anime(params);
      tl.duration = 0;
      tl.add = function(instanceParams, timelineOffset) {
        var tlIndex = activeInstances.indexOf(tl);
        var children = tl.children;
        if (tlIndex > -1) {
          activeInstances.splice(tlIndex, 1);
        }
        function passThrough(ins2) {
          ins2.passThrough = true;
        }
        for (var i = 0; i < children.length; i++) {
          passThrough(children[i]);
        }
        var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
        insParams.targets = insParams.targets || params.targets;
        var tlDuration = tl.duration;
        insParams.autoplay = false;
        insParams.direction = tl.direction;
        insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
        passThrough(tl);
        tl.seek(insParams.timelineOffset);
        var ins = anime(insParams);
        passThrough(ins);
        children.push(ins);
        var timings = getInstanceTimings(children, params);
        tl.delay = timings.delay;
        tl.endDelay = timings.endDelay;
        tl.duration = timings.duration;
        tl.seek(0);
        tl.reset();
        if (tl.autoplay) {
          tl.play();
        }
        return tl;
      };
      return tl;
    }
    anime.version = "3.2.1";
    anime.speed = 1;
    anime.suspendWhenDocumentHidden = true;
    anime.running = activeInstances;
    anime.remove = removeTargetsFromActiveInstances;
    anime.get = getOriginalTargetValue;
    anime.set = setTargetsValue;
    anime.convertPx = convertPxToUnit;
    anime.path = getPath;
    anime.setDashoffset = setDashoffset;
    anime.stagger = stagger;
    anime.timeline = timeline;
    anime.easing = parseEasings;
    anime.penner = penner;
    anime.random = function(min2, max2) {
      return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
    };
    const anime_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: anime
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$1 = /* @__PURE__ */ getAugmentedNamespace(anime_es);
    var reactAnime = function(e) {
      var t2 = {};
      function r2(n2) {
        if (t2[n2])
          return t2[n2].exports;
        var o = t2[n2] = { i: n2, l: false, exports: {} };
        return e[n2].call(o.exports, o, o.exports, r2), o.l = true, o.exports;
      }
      return r2.m = e, r2.c = t2, r2.d = function(e2, t3, n2) {
        r2.o(e2, t3) || Object.defineProperty(e2, t3, { enumerable: true, get: n2 });
      }, r2.r = function(e2) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      }, r2.t = function(e2, t3) {
        if (1 & t3 && (e2 = r2(e2)), 8 & t3)
          return e2;
        if (4 & t3 && "object" == typeof e2 && e2 && e2.__esModule)
          return e2;
        var n2 = /* @__PURE__ */ Object.create(null);
        if (r2.r(n2), Object.defineProperty(n2, "default", { enumerable: true, value: e2 }), 2 & t3 && "string" != typeof e2)
          for (var o in e2)
            r2.d(n2, o, function(t4) {
              return e2[t4];
            }.bind(null, o));
        return n2;
      }, r2.n = function(e2) {
        var t3 = e2 && e2.__esModule ? function() {
          return e2.default;
        } : function() {
          return e2;
        };
        return r2.d(t3, "a", t3), t3;
      }, r2.o = function(e2, t3) {
        return Object.prototype.hasOwnProperty.call(e2, t3);
      }, r2.p = "", r2(r2.s = 0);
    }([function(e, t2, r2) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.anime = t2.default = t2.Anime = void 0;
      var n2 = function(e2) {
        if (e2 && e2.__esModule)
          return e2;
        if (null === e2 || "object" !== l2(e2) && "function" != typeof e2)
          return { default: e2 };
        var t3 = function() {
          if ("function" != typeof WeakMap)
            return null;
          var e3 = /* @__PURE__ */ new WeakMap();
          return e3;
        }();
        if (t3 && t3.has(e2))
          return t3.get(e2);
        var r3 = {}, n3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o2 in e2)
          if (Object.prototype.hasOwnProperty.call(e2, o2)) {
            var u3 = n3 ? Object.getOwnPropertyDescriptor(e2, o2) : null;
            u3 && (u3.get || u3.set) ? Object.defineProperty(r3, o2, u3) : r3[o2] = e2[o2];
          }
        return r3.default = e2, t3 && t3.set(e2, r3), r3;
      }(r2(1));
      function o(e2, t3) {
        var r3 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), r3.push.apply(r3, n3);
        }
        return r3;
      }
      function u2(e2, t3) {
        for (var r3 = 0; r3 < t3.length; r3++) {
          var n3 = t3[r3];
          n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e2, n3.key, n3);
        }
      }
      function i(e2) {
        return (i = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {
          return e3.__proto__ || Object.getPrototypeOf(e3);
        })(e2);
      }
      function a(e2) {
        if (void 0 === e2)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e2;
      }
      function c(e2, t3) {
        return (c = Object.setPrototypeOf || function(e3, t4) {
          return e3.__proto__ = t4, e3;
        })(e2, t3);
      }
      function f2(e2, t3, r3) {
        return t3 in e2 ? Object.defineProperty(e2, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e2[t3] = r3, e2;
      }
      function l2(e2) {
        return (l2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        })(e2);
      }
      var p2 = function(e2) {
        return e2;
      };
      if (t2.anime = p2, "undefined" != typeof window) {
        var s = r2(2);
        t2.anime = p2 = "object" === l2(s) ? s.default : s;
      }
      var y2 = function() {
        function e2(t4) {
          var r4, n3;
          return function(e3, t5) {
            if (!(e3 instanceof t5))
              throw new TypeError("Cannot call a class as a function");
          }(this, e2), n3 = i(e2).call(this, t4), r4 = !n3 || "object" !== l2(n3) && "function" != typeof n3 ? a(this) : n3, f2(a(r4), "createAnime", function() {
            var e3 = r4.props;
            0 < r4.targets.length && void 0 !== r4.anime && p2.remove(r4.targets);
            var t5 = true, n4 = !(r4.targets = []), u3 = void 0;
            try {
              for (var i2, a2 = r4.targetRefs[Symbol.iterator](); !(t5 = (i2 = a2.next()).done); t5 = true) {
                var c2 = i2.value;
                c2.current && r4.targets.push(c2.current);
              }
            } catch (e4) {
              n4 = true, u3 = e4;
            } finally {
              try {
                t5 || null == a2.return || a2.return();
              } finally {
                if (n4)
                  throw u3;
              }
            }
            var l3 = function(e4) {
              for (var t6 = 1; t6 < arguments.length; t6++) {
                var r5 = null != arguments[t6] ? arguments[t6] : {};
                t6 % 2 ? o(Object(r5), true).forEach(function(t7) {
                  f2(e4, t7, r5[t7]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(r5)) : o(Object(r5)).forEach(function(t7) {
                  Object.defineProperty(e4, t7, Object.getOwnPropertyDescriptor(r5, t7));
                });
              }
              return e4;
            }({}, e3, { targets: r4.targets });
            delete l3.children, delete l3.svg, r4.anime = p2(l3);
          }), r4.targets = [], r4.targetRefs = [], r4.anime = null, r4;
        }
        var t3, r3;
        return function(e3, t4) {
          if ("function" != typeof t4 && null !== t4)
            throw new TypeError("Super expression must either be null or a function");
          e3.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e3, writable: true, configurable: true } }), t4 && c(e3, t4);
        }(e2, n2.Component), t3 = e2, (r3 = [{ key: "componentDidMount", value: function() {
          this.createAnime();
        } }, { key: "componentDidUpdate", value: function() {
          this.createAnime();
        } }, { key: "render", value: function() {
          var e3 = this, t4 = this.props.children, r4 = this.targetRefs;
          return Array.isArray(t4) || (t4 = [t4]), n2.default.createElement(n2.Fragment, null, t4.map(function(t5, o2) {
            r4.push(n2.default.createRef());
            var u3 = e3.props.svg ? "g" : "div";
            return n2.default.createElement(u3, { ref: r4[r4.length - 1], key: "".concat("__anime__").concat(o2) }, t5);
          }));
        } }]) && u2(t3.prototype, r3), e2;
      }(), b = t2.Anime = y2;
      t2.default = b;
    }, function(e, t2) {
      e.exports = react.exports;
    }, function(e, t2) {
      e.exports = require$$1;
    }]);
    let defaultAnimation = {
      scale: [0.9, 1]
    };
    const animate = {
      default: (component) => {
        return /* @__PURE__ */ jsx(reactAnime, { ...defaultAnimation, children: component });
      }
    };
    class AnimatedComponent extends react.exports.Component {
      constructor(props) {
        super(props);
        __publicField(this, "smoothly", (component) => {
          return animate.default(component);
        });
        this.state = {};
      }
    }
    class PauseMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        __publicField(this, "unpauseGame", () => {
          events.emit("unpause");
        });
        __publicField(this, "restartGame", () => {
          events.emit("restartGame");
        });
      }
      render() {
        return this.smoothly(
          /* @__PURE__ */ jsxs("div", { className: "pauseMenu menu", children: [
            /* @__PURE__ */ jsx("h1", { className: "pauseHeader header", children: "Paused" }),
            /* @__PURE__ */ jsx(Button, { hint: "esc", text: "Continue", onClick: this.unpauseGame }),
            /* @__PURE__ */ jsx(Button, { danger: true, text: "Back to Menu", onClick: this.restartGame })
          ] })
        );
      }
    }
    class StartMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        __publicField(this, "startGame", () => {
          events.emit("gameStarted");
        });
        __publicField(this, "openSettings", () => {
          events.emit("settingsOpened");
        });
        __publicField(this, "openLeaderboard", () => {
          events.emit("leaderboardOpened");
        });
      }
      render() {
        const { playerName } = this.props;
        return this.smoothly(
          /* @__PURE__ */ jsxs("div", { className: "startMenu menu", children: [
            /* @__PURE__ */ jsxs("header", { children: [
              /* @__PURE__ */ jsx("h1", { className: "startHeader header", children: "XTYPE" }),
              /* @__PURE__ */ jsxs("div", { className: "username", children: [
                "Playing as ",
                playerName
              ] })
            ] }),
            /* @__PURE__ */ jsx(Button, { hint: "P", text: "Singleplayer", onClick: this.startGame }),
            /* @__PURE__ */ jsx(Button, { disabled: true, hint: "M", text: "Multiplayer", onClick: () => console.log("Multiplayer is WIP") }),
            /* @__PURE__ */ jsx("div", { className: "spacer" }),
            /* @__PURE__ */ jsx(Button, { mini: true, hint: "S", text: "Settings", onClick: this.openSettings }),
            /* @__PURE__ */ jsx(Button, { mini: true, hint: "L", text: "Leaderboard", onClick: this.openLeaderboard })
          ] })
        );
      }
    }
    class SettingsMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        __publicField(this, "handleFocus", (e) => e.target.select());
        __publicField(this, "handleChange", (e) => {
          e.stopPropagation();
          e.preventDefault();
          this.setState({
            playerName: e.target.value
          }, () => {
            this.updateShip();
          });
        });
        __publicField(this, "updateShip", () => {
          this.setState((old) => {
            return {
              playerShip: createIdenticon(old.playerName, { size: 200 })
            };
          });
        });
        __publicField(this, "saveSettings", () => {
          events.emit("settingsSaved", this.state.playerName);
        });
        this.state = {
          playerName: props.playerName,
          playerShip: ""
        };
        this.changed = false;
      }
      componentDidMount() {
        this.updateShip();
        this.changed = true;
      }
      render() {
        const { playerShip, playerName } = this.state;
        let content = /* @__PURE__ */ jsxs("div", { className: "settingsMenu menu", children: [
          /* @__PURE__ */ jsx("div", { className: "settingsHeader", children: /* @__PURE__ */ jsx("img", { src: playerShip, alt: "Visual representation of the player ship" }) }),
          /* @__PURE__ */ jsx(
            "input",
            {
              type: "text",
              defaultValue: playerName,
              onChange: this.handleChange,
              onFocus: this.handleFocus,
              required: true,
              autoFocus: true
            }
          ),
          /* @__PURE__ */ jsx(Button, { text: "Save", hint: "ret", onClick: this.saveSettings })
        ] });
        return this.changed ? content : this.smoothly(content);
      }
    }
    const localStorage = window.localStorage;
    const storage = {
      set: (key, value2) => {
        localStorage.setItem(key, value2);
      },
      get: (key) => {
        return localStorage.getItem(key);
      },
      del: (key) => {
        localStorage.removeItem(key);
      },
      push: (key, value2) => {
        let array = get(key);
        if (array) {
          array = JSON.parse(array);
        }
        if (typeof array !== "object") {
          array = [];
        }
        array.push(value2);
        set(key, JSON.stringify(array));
      },
      pop: (key) => {
        let array = get(key);
        if (array) {
          array = JSON.parse(array);
        }
        if (typeof array !== "object") {
          return null;
        }
        let val = array.pop();
        set(key, JSON.stringify(array));
        return val;
      },
      first: (key) => {
        let array = get(key);
        if (!array) {
          return null;
        }
        if (typeof array !== "object" && value.constructor !== Array) {
          return array;
        }
        return array[0];
      },
      last: (key) => {
        let array = get(key);
        if (!array) {
          return null;
        }
        if (typeof array !== "object" && value.constructor !== Array) {
          return array;
        }
        return array[array.length - 1];
      },
      exists: (key) => {
        let val = localStorage.getItem(key);
        if (val) {
          return true;
        }
        return false;
      }
    };
    const maxEntries = 15;
    let items = [];
    const sortEntry = (a, b) => {
      return b.totalWaves - a.totalWaves || b.score - a.score;
    };
    const addEntry = (who, accuracy, wpm, score, totalWaves) => {
      let entry = {
        playerName: who,
        playerAvatar: createIdenticon(who),
        accuracy,
        wpm,
        score,
        totalWaves
      };
      if (storage.exists("leaderboard")) {
        items = JSON.parse(storage.get("leaderboard"));
      }
      items.push(entry);
      items.sort(sortEntry);
      if (items.length > maxEntries) {
        items = items.slice(0, maxEntries);
      }
      storage.set("leaderboard", JSON.stringify(items));
      return items;
    };
    const allEntries = () => {
      let entries = storage.get("leaderboard");
      if (!entries) {
        return [];
      }
      return JSON.parse(entries);
    };
    class LeaderboardMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        __publicField(this, "closeLeaderboard", () => {
          events.emit("leaderboardClosed");
        });
        __publicField(this, "leaderboardEntry", (data, i) => {
          return /* @__PURE__ */ jsxs("div", { className: "leaderboardEntry", children: [
            /* @__PURE__ */ jsxs("div", { className: "playerInfo", children: [
              /* @__PURE__ */ jsx("img", { src: data.playerAvatar }),
              /* @__PURE__ */ jsx("div", { className: "playerName", children: truncate(data.playerName, 10) })
            ] }),
            /* @__PURE__ */ jsxs("div", { className: "playerData", children: [
              /* @__PURE__ */ jsxs("div", { className: "data accuracy", children: [
                data.accuracy,
                "%"
              ] }),
              /* @__PURE__ */ jsx("div", { className: "spacer" }),
              /* @__PURE__ */ jsx("div", { className: "data wpm", children: data.wpm }),
              /* @__PURE__ */ jsx("div", { className: "data score", children: data.score })
            ] })
          ] }, i);
        });
        __publicField(this, "leaderboardSeparator", (level, i) => {
          return /* @__PURE__ */ jsxs("div", { className: "levelDisplay", children: [
            "Wave ",
            level
          ] }, i * i);
        });
      }
      render() {
        let animeProps = {
          opacity: [0, 1],
          translateX: [-64, 0],
          delay: (el, i) => i * 200
        };
        let all = allEntries().sort((a, b) => {
          return b.totalWaves - a.totalWaves || b.score - a.score;
        });
        let entries = [];
        let lastLevel = all[0] ? all[0].totalWaves : 0;
        all.forEach((e, i) => {
          if (i === 0) {
            entries.push(this.leaderboardSeparator(lastLevel, i));
          }
          if (e.totalWaves !== lastLevel) {
            lastLevel = e.totalWaves;
            entries.push(this.leaderboardSeparator(lastLevel, i));
          }
          entries.push(this.leaderboardEntry(e, i));
        });
        return this.smoothly(
          /* @__PURE__ */ jsxs("div", { className: "leaderboardMenu menu", children: [
            entries.length === 0 && /* @__PURE__ */ jsx("div", { className: "nothingHere", children: "You haven't set any scores yet!" }),
            entries.length > 0 && /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx(reactAnime, { ...animeProps, children: entries }) }),
            /* @__PURE__ */ jsx(Button, { mini: true, hint: "esc", text: "Close", onClick: this.closeLeaderboard })
          ] })
        );
      }
    }
    var Chart$1 = { exports: {} };
    //! moment.js
    //! version : 2.29.2
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    var hookCallback;
    function hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;
        for (k in obj) {
          if (hasOwnProp(obj, k)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined(input) {
      return input === void 0;
    }
    function isNumber(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
      var res = [], i, arrLen = arr.length;
      for (i = 0; i < arrLen; ++i) {
        res.push(fn(arr[i], i));
      }
      return res;
    }
    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }
      if (hasOwnProp(b, "toString")) {
        a.toString = b.toString;
      }
      if (hasOwnProp(b, "valueOf")) {
        a.valueOf = b.valueOf;
      }
      return a;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m2) {
      if (m2._pf == null) {
        m2._pf = defaultParsingFlags();
      }
      return m2._pf;
    }
    var some;
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t2 = Object(this), len = t2.length >>> 0, i;
        for (i = 0; i < len; i++) {
          if (i in t2 && fun.call(this, t2[i], i, t2)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid(m2) {
      if (m2._isValid == null) {
        var flags = getParsingFlags(m2), parsedParts = some.call(flags.parsedDateParts, function(i) {
          return i != null;
        }), isNowValid = !isNaN(m2._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m2._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
        }
        if (Object.isFrozen == null || !Object.isFrozen(m2)) {
          m2._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }
      return m2._isValid;
    }
    function createInvalid(flags) {
      var m2 = createUTC(NaN);
      if (flags != null) {
        extend(getParsingFlags(m2), flags);
      } else {
        getParsingFlags(m2).userInvalidated = true;
      }
      return m2;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i, prop, val, momentPropertiesLen = momentProperties.length;
      if (!isUndefined(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentPropertiesLen > 0) {
        for (i = 0; i < momentPropertiesLen; i++) {
          prop = momentProperties[i];
          val = from2[prop];
          if (!isUndefined(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function() {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i, key, argLen = arguments.length;
          for (i = 0; i < argLen; i++) {
            arg = "";
            if (typeof arguments[i] === "object") {
              arg += "\n[" + i + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i];
            }
            args.push(arg);
          }
          warn(
            msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
          );
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name2, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name2, msg);
      }
      if (!deprecations[name2]) {
        warn(msg);
        deprecations[name2] = true;
      }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set$1(config) {
      var prop, i;
      for (i in config) {
        if (hasOwnProp(config, i)) {
          prop = config[i];
          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this["_" + i] = prop;
          }
        }
      }
      this._config = config;
      this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
      );
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          res[prop] = extend({}, res[prop]);
        }
      }
      return res;
    }
    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }
    var keys;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i, res = [];
        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }
        return res;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now2) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction(output) ? output.call(mom, now2) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback) {
      var func = callback;
      if (typeof callback === "string") {
        func = function() {
          return this[callback]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(
            func.apply(this, arguments),
            token2
          );
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array = format2.match(formattingTokens), i, length;
      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }
      return function(mom) {
        var output = "", i2;
        for (i2 = 0; i2 < length; i2++) {
          output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
        }
        return output;
      };
    }
    function formatMoment(m2, format2) {
      if (!m2.isValid()) {
        return m2.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m2.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m2);
    }
    function expandFormat(format2, locale2) {
      var i = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(
          localFormattingTokens,
          replaceLongDateFormatTokens
        );
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
      return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
      var units = [], u2;
      for (u2 in unitsObj) {
        if (hasOwnProp(unitsObj, u2)) {
          units.push({ unit: u2, priority: priorities[u2] });
        }
      }
      units.sort(function(a, b) {
        return a.priority - b.priority;
      });
      return units;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value2 = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value2 = absFloor(coercedNumber);
      }
      return value2;
    }
    function makeGetSet(unit, keepTime) {
      return function(value2) {
        if (value2 != null) {
          set$1$1(this, unit, value2);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get$1(this, unit);
        }
      };
    }
    function get$1(mom, unit) {
      return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
    }
    function set$1$1(mom, unit, value2) {
      if (mom.isValid() && !isNaN(value2)) {
        if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          value2 = toInt(value2);
          mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
            value2,
            mom.month(),
            daysInMonth(value2, mom.month())
          );
        } else {
          mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value2);
        }
      }
    }
    function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units]();
      }
      return this;
    }
    function stringSet(units, value2) {
      if (typeof units === "object") {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
        for (i = 0; i < prioritizedLen; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units](value2);
        }
      }
      return this;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
    regexes = {};
    function addRegexToken(token2, regex, strictRegex) {
      regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token2, config) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config._strict, config._locale);
    }
    function unescapeFormat(s) {
      return regexEscape(
        s.replace("\\", "").replace(
          /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
          function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }
        )
      );
    }
    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tokens = {};
    function addParseToken(token2, callback) {
      var i, func = callback, tokenLen;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber(callback)) {
        func = function(input, array) {
          array[callback] = toInt(input);
        };
      }
      tokenLen = token2.length;
      for (i = 0; i < tokenLen; i++) {
        tokens[token2[i]] = func;
      }
    }
    function addWeekParseToken(token2, callback) {
      addParseToken(token2, function(input, array, config, token3) {
        config._w = config._w || {};
        callback(input, config._w, config, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config._a, config, token2);
      }
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    function mod(n2, x2) {
      return (n2 % x2 + x2) % x2;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o) {
        var i;
        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addUnitAlias("month", "M");
    addUnitPriority("month", 8);
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
      var month = config._locale.monthsParse(input, token2, config._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m2, format2) {
      if (!m2) {
        return isArray(this._months) ? this._months : this._months["standalone"];
      }
      return isArray(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
    }
    function localeMonthsShort(m2, format2) {
      if (!m2) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i, ii2, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
          mom = createUTC([2e3, i]);
          this._shortMonthsParse[i] = this.monthsShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._longMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      } else {
        if (format2 === "MMM") {
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._longMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._longMonthsParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i, mom, regex;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp(
            "^" + this.months(mom, "").replace(".", "") + "$",
            "i"
          );
          this._shortMonthsParse[i] = new RegExp(
            "^" + this.monthsShort(mom, "").replace(".", "") + "$",
            "i"
          );
        }
        if (!strict && !this._monthsParse[i]) {
          regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    }
    function setMonth(mom, value2) {
      var dayOfMonth;
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value2 === "string") {
        if (/^\d+$/.test(value2)) {
          value2 = toInt(value2);
        } else {
          value2 = mom.localeData().monthsParse(value2);
          if (!isNumber(value2)) {
            return mom;
          }
        }
      }
      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value2));
      mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value2, dayOfMonth);
      return mom;
    }
    function getSetMonth(value2) {
      if (value2 != null) {
        setMonth(this, value2);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get$1(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        shortPieces.push(this.monthsShort(mom, ""));
        longPieces.push(this.months(mom, ""));
        mixedPieces.push(this.months(mom, ""));
        mixedPieces.push(this.monthsShort(mom, ""));
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
      }
      for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._monthsShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken("Y", 0, 0, function() {
      var y2 = this.year();
      return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addUnitAlias("year", "y");
    addUnitPriority("year", 1);
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function createDate(y2, m2, d, h2, M2, s, ms) {
      var date;
      if (y2 < 100 && y2 >= 0) {
        date = new Date(y2 + 400, m2, d, h2, M2, s, ms);
        if (isFinite(date.getFullYear())) {
          date.setFullYear(y2);
        }
      } else {
        date = new Date(y2, m2, d, h2, M2, s, ms);
      }
      return date;
    }
    function createUTCDate(y2) {
      var date, args;
      if (y2 < 100 && y2 >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y2 + 400;
        date = new Date(Date.UTC.apply(null, args));
        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y2);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }
      return date;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addUnitPriority("week", 5);
    addUnitPriority("isoWeek", 5);
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      }
    );
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      doy: 6
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addUnitPriority("day", 11);
    addUnitPriority("weekday", 11);
    addUnitPriority("isoWeekday", 11);
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
      var weekday = config._locale.weekdaysParse(input, token2, config._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
      week[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n2) {
      return ws.slice(n2, 7).concat(ws.slice(0, n2));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m2, format2) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
    }
    function localeWeekdaysShort(m2) {
      return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m2) {
      return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i, ii2, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i = 0; i < 7; ++i) {
          mom = createUTC([2e3, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(
            mom,
            ""
          ).toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii2 = indexOf.call(this._weekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else if (format2 === "ddd") {
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      } else {
        if (format2 === "dddd") {
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else if (format2 === "ddd") {
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i, mom, regex;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp(
            "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._shortWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._minWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
        }
        if (!this._weekdaysParse[i]) {
          regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._weekdaysShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
      this._weekdaysMinStrictRegex = new RegExp(
        "^(" + minPieces.join("|") + ")",
        "i"
      );
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(
          this.hours(),
          this.minutes(),
          lowercase
        );
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    addUnitPriority("hour", 13);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("k", match1to2);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i, minl = Math.min(arr1.length, arr2.length);
      for (i = 0; i < minl; i += 1) {
        if (arr1[i] !== arr2[i]) {
          return i;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
      var i = 0, j, next, locale2, split;
      while (i < names.length) {
        split = normalizeLocale(names[i]).split("-");
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split("-") : null;
        while (j > 0) {
          locale2 = loadLocale(split.slice(0, j).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
            break;
          }
          j--;
        }
        i++;
      }
      return globalLocale;
    }
    function isLocaleNameSane(name2) {
      return name2.match("^[^/\\\\]*$") != null;
    }
    function loadLocale(name2) {
      var oldLocale = null, aliasedRequire;
      if (locales[name2] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name2)) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = require;
          aliasedRequire("./locale/" + name2);
          getSetGlobalLocale(oldLocale);
        } catch (e) {
          locales[name2] = null;
        }
      }
      return locales[name2];
    }
    function getSetGlobalLocale(key, values2) {
      var data;
      if (key) {
        if (isUndefined(values2)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values2);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(
              "Locale " + key + " not found. Did you forget to load it?"
            );
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name2, config) {
      if (config !== null) {
        var locale2, parentConfig = baseConfig;
        config.abbr = name2;
        if (locales[name2] != null) {
          deprecateSimple(
            "defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
          );
          parentConfig = locales[name2]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale2 = loadLocale(config.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }
              localeFamilies[config.parentLocale].push({
                name: name2,
                config
              });
              return null;
            }
          }
        }
        locales[name2] = new Locale(mergeConfigs(parentConfig, config));
        if (localeFamilies[name2]) {
          localeFamilies[name2].forEach(function(x2) {
            defineLocale(x2.name, x2.config);
          });
        }
        getSetGlobalLocale(name2);
        return locales[name2];
      } else {
        delete locales[name2];
        return null;
      }
    }
    function updateLocale(name2, config) {
      if (config != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name2] != null && locales[name2].parentLocale != null) {
          locales[name2].set(mergeConfigs(locales[name2]._config, config));
        } else {
          tmpLocale = loadLocale(name2);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          if (tmpLocale == null) {
            config.abbr = name2;
          }
          locale2 = new Locale(config);
          locale2.parentLocale = locales[name2];
          locales[name2] = locale2;
        }
        getSetGlobalLocale(name2);
      } else {
        if (locales[name2] != null) {
          if (locales[name2].parentLocale != null) {
            locales[name2] = locales[name2].parentLocale;
            if (name2 === getSetGlobalLocale()) {
              getSetGlobalLocale(name2);
            }
          } else if (locales[name2] != null) {
            delete locales[name2];
          }
        }
      }
      return locales[name2];
    }
    function getLocale(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys(locales);
    }
    function checkOverflow(m2) {
      var overflow, a = m2._a;
      if (a && getParsingFlags(m2).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }
        if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }
        getParsingFlags(m2).overflow = overflow;
      }
      return m2;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config) {
      var i, l2, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
      if (match) {
        getParsingFlags(config).iso = true;
        for (i = 0, l2 = isoDatesLen; i < l2; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config._isValid = false;
          return;
        }
        if (match[3]) {
          for (i = 0, l2 = isoTimesLen; i < l2; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              timeFormat = (match[2] || " ") + isoTimes[i][0];
              break;
            }
          }
          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }
        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = "Z";
          } else {
            config._isValid = false;
            return;
          }
        }
        config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result2 = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result2.push(parseInt(secondStr, 10));
      }
      return result2;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2e3 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s) {
      return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
          parsedInput[0],
          parsedInput[1],
          parsedInput[2]
        ).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m2 = hm % 100, h2 = (hm - m2) / 100;
        return h2 * 60 + m2;
      }
    }
    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
      if (match) {
        parsedArray = extractFromRFC2822Strings(
          match[4],
          match[3],
          match[2],
          match[5],
          match[6],
          match[7]
        );
        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }
        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      configFromRFC2822(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      if (config._strict) {
        config._isValid = false;
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
      }
    );
    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }
      if (b != null) {
        return b;
      }
      return c;
    }
    function currentDateArray(config) {
      var nowValue = new Date(hooks.now());
      if (config._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
      var i, date, input = [], currentDate, expectedWeekday, yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      }
      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(
        null,
        input
      );
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
      if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w2, weekYear, week, weekday, dow, doy, temp2, weekdayOverflow, curWeek;
      w2 = config._w;
      if (w2.GG != null || w2.W != null || w2.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults(
          w2.GG,
          config._a[YEAR],
          weekOfYear(createLocal(), 1, 4).year
        );
        week = defaults(w2.W, 1);
        weekday = defaults(w2.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w2.gg, config._a[YEAR], curWeek.year);
        week = defaults(w2.w, curWeek.week);
        if (w2.d != null) {
          weekday = w2.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w2.e != null) {
          weekday = w2.e + dow;
          if (w2.e < 0 || w2.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp2 = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp2.year;
        config._dayOfYear = temp2.dayOfYear;
      }
    }
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config) {
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }
      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
      tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      tokenLen = tokens2.length;
      for (i = 0; i < tokenLen; i++) {
        token2 = tokens2[i];
        parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string = string.slice(
            string.indexOf(parsedInput) + parsedInput.length
          );
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      }
      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = void 0;
      }
      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem;
      config._a[HOUR] = meridiemFixWrap(
        config._locale,
        config._a[HOUR],
        config._meridiem
      );
      era = getParsingFlags(config).era;
      if (era !== null) {
        config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
      }
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
      if (configfLen === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }
      for (i = 0; i < configfLen; i++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
      config._a = map(
        [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
        function(obj) {
          return obj && parseInt(obj, 10);
        }
      );
      configFromArray(config);
    }
    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
        res.add(1, "d");
        res._nextDay = void 0;
      }
      return res;
    }
    function prepareConfig(config) {
      var input = config._i, format2 = config._f;
      config._locale = config._locale || getLocale(config._l);
      if (input === null || format2 === void 0 && input === "") {
        return createInvalid({ nullInput: true });
      }
      if (typeof input === "string") {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format2)) {
        configFromStringAndArray(config);
      } else if (format2) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }
      if (!isValid(config)) {
        config._d = null;
      }
      return config;
    }
    function configFromInput(config) {
      var input = config._i;
      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = void 0;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = void 0;
      }
      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = void 0;
      }
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale2;
      c._i = input;
      c._f = format2;
      c._strict = strict;
      return createFromConfig(c);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    ), prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    function pickBy(fn, moments) {
      var res, i;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }
      return res;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now = function() {
      return Date.now ? Date.now() : +new Date();
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m2) {
      var key, unitHasDecimal = false, i, orderLen = ordering.length;
      for (key in m2) {
        if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
          return false;
        }
      }
      for (i = 0; i < orderLen; ++i) {
        if (m2[ordering[i]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m2[ordering[i]]) !== toInt(m2[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher2, string) {
      var matches = (string || "").match(matcher2), chunk2, parts, minutes2;
      if (matches === null) {
        return null;
      }
      chunk2 = matches[matches.length - 1] || [];
      parts = (chunk2 + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res, diff2;
      if (model._isUTC) {
        res = model.clone();
        diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        res._d.setTime(res._d.valueOf() + diff2);
        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m2) {
      return -Math.round(m2._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(
              this,
              createDuration(input - offset2, "m"),
              1,
              false
            );
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c = {}, other;
      copyConfig(c, this);
      c = prepareConfig(c);
      if (c._a) {
        other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration = input, match = null, sign2, ret, diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input) || !isNaN(+input)) {
        duration = {};
        if (key) {
          duration[key] = +input;
        } else {
          duration.milliseconds = +input;
        }
      } else if (match = aspNetRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign2,
          h: toInt(match[HOUR]) * sign2,
          m: toInt(match[MINUTE]) * sign2,
          s: toInt(match[SECOND]) * sign2,
          ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
        };
      } else if (match = isoRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign2),
          M: parseIso(match[3], sign2),
          w: parseIso(match[4], sign2),
          d: parseIso(match[5], sign2),
          h: parseIso(match[6], sign2),
          m: parseIso(match[7], sign2),
          s: parseIso(match[8], sign2)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
        diffRes = momentsDifference(
          createLocal(duration.from),
          createLocal(duration.to)
        );
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret._isValid = input._isValid;
      }
      return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res) ? 0 : res) * sign2;
    }
    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, "M").isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +base.clone().add(res.months, "M");
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name2) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(
            name2,
            "moment()." + name2 + "(period, number) is deprecated. Please use moment()." + name2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
          );
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get$1(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$1$1(mom, "Date", get$1(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i, property2, propertyLen = properties.length;
      for (i = 0; i < propertyLen; i += 1) {
        property2 = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property2);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber(item) && isString(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i, property2;
      for (i = 0; i < properties.length; i += 1) {
        property2 = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property2);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now2) {
      var diff2 = myMoment.diff(now2, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats2) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = void 0;
          formats2 = void 0;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats2 = void 0;
        } else if (isCalendarSpec(arguments[0])) {
          formats2 = arguments[0];
          time = void 0;
        }
      }
      var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats2 && (isFunction(formats2[format2]) ? formats2[format2].call(this, now2) : formats2[format2]);
      return this.format(
        output || this.localeData().calendar(format2, this, createLocal(now2))
      );
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }
    function isBetween(from2, to2, units, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);
      switch (units) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1e3;
          break;
        case "minute":
          output = (this - that) / 6e4;
          break;
        case "hour":
          output = (this - that) / 36e5;
          break;
        case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;
        case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
      if (a.date() < b.date()) {
        return -monthDiff(b, a);
      }
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
      if (m2.year() < 0 || m2.year() > 9999) {
        return formatMoment(
          m2,
          utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      if (isFunction(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
        }
      }
      return formatMoment(
        m2,
        utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
      var newLocaleData;
      if (key === void 0) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y2, m2, d) {
      if (y2 < 100 && y2 >= 0) {
        return new Date(y2 + 400, m2, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y2, m2, d).valueOf();
      }
    }
    function utcStartOfDate(y2, m2, d) {
      if (y2 < 100 && y2 >= 0) {
        return Date.UTC(y2 + 400, m2, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y2, m2, d);
      }
    }
    function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3,
            1
          );
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday()
          );
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1)
          );
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          );
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3 + 3,
            1
          ) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday() + 7
          ) - 1;
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1) + 7
          ) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          ) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
      return new Date(this.valueOf());
    }
    function toArray() {
      var m2 = this;
      return [
        m2.year(),
        m2.month(),
        m2.date(),
        m2.hour(),
        m2.minute(),
        m2.second(),
        m2.millisecond()
      ];
    }
    function toObject() {
      var m2 = this;
      return {
        years: m2.year(),
        months: m2.month(),
        date: m2.date(),
        hours: m2.hours(),
        minutes: m2.minutes(),
        seconds: m2.seconds(),
        milliseconds: m2.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid(this);
    }
    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array, config, token2) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
        match = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
      } else {
        array[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m2, format2) {
      var i, l2, date, eras = this._eras || getLocale("en")._eras;
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        switch (typeof eras[i].since) {
          case "string":
            date = hooks(eras[i].since).startOf("day");
            eras[i].since = date.valueOf();
            break;
        }
        switch (typeof eras[i].until) {
          case "undefined":
            eras[i].until = Infinity;
            break;
          case "string":
            date = hooks(eras[i].until).startOf("day").valueOf();
            eras[i].until = date.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i, l2, eras = this.eras(), name2, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        name2 = eras[i].name.toUpperCase();
        abbr = eras[i].abbr.toUpperCase();
        narrow = eras[i].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i];
              }
              break;
            case "NNNN":
              if (name2 === eraName) {
                return eras[i];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i];
              }
              break;
          }
        } else if ([name2, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === void 0) {
        return hooks(era.since).year();
      } else {
        return hooks(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i, l2, val, eras = this.localeData().eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].name;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i, l2, val, eras = this.localeData().eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].narrow;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i, l2, val, eras = this.localeData().eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].abbr;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i, l2, dir, val, eras = this.localeData().eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        dir = eras[i].since <= eras[i].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
          return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l2, eras = this.eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        namePieces.push(regexEscape(eras[i].name));
        abbrPieces.push(regexEscape(eras[i].abbr));
        narrowPieces.push(regexEscape(eras[i].narrow));
        mixedPieces.push(regexEscape(eras[i].name));
        mixedPieces.push(regexEscape(eras[i].abbr));
        mixedPieces.push(regexEscape(eras[i].narrow));
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp(
        "^(" + narrowPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addUnitPriority("weekYear", 1);
    addUnitPriority("isoWeekYear", 1);
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.week(),
        this.weekday(),
        this.localeData()._week.dow,
        this.localeData()._week.doy
      );
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.isoWeek(),
        this.isoWeekday(),
        1,
        4
      );
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addUnitAlias("quarter", "Q");
    addUnitPriority("quarter", 7);
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addUnitAlias("date", "D");
    addUnitPriority("date", 9);
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addUnitPriority("dayOfYear", 4);
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array, config) {
      config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addUnitAlias("minute", "m");
    addUnitPriority("minute", 14);
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addUnitAlias("second", "s");
    addUnitPriority("second", 15);
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addUnitAlias("millisecond", "ms");
    addUnitPriority("millisecond", 16);
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
      array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    function createUnix(input) {
      return createLocal(input * 1e3);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
      return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set$1;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1$1(format2, index2, field, setter) {
      var locale2 = getLocale(), utc = createUTC().set(setter, index2);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index2, field) {
      if (isNumber(format2)) {
        index2 = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
      if (index2 != null) {
        return get$1$1(format2, index2, field, "month");
      }
      var i, out = [];
      for (i = 0; i < 12; i++) {
        out[i] = get$1$1(format2, i, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index2, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index2 = format2;
        localeSorted = false;
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
      if (index2 != null) {
        return get$1$1(format2, (index2 + shift) % 7, field, "day");
      }
      for (i = 0; i < 7; i++) {
        out[i] = get$1$1(format2, (i + shift) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index2) {
      return listMonthsImpl(format2, index2, "months");
    }
    function listMonthsShort(format2, index2) {
      return listMonthsImpl(format2, index2, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration, input, value2, direction) {
      var other = createDuration(input, value2);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function add$1(input, value2) {
      return addSubtract$1(this, input, value2, 1);
    }
    function subtract$1(input, value2) {
      return addSubtract$1(this, input, value2, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1e3;
      seconds2 = absFloor(milliseconds2 / 1e3);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units = normalizeUnits(units);
      if (units === "month" || units === "quarter" || units === "year") {
        days2 = this._days + milliseconds2 / 864e5;
        months2 = this._months + daysToMonths(days2);
        switch (units) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case "week":
            return days2 / 7 + milliseconds2 / 6048e5;
          case "day":
            return days2 + milliseconds2 / 864e5;
          case "hour":
            return days2 * 24 + milliseconds2 / 36e5;
          case "minute":
            return days2 * 1440 + milliseconds2 / 6e4;
          case "second":
            return days2 * 86400 + milliseconds2 / 1e3;
          case "millisecond":
            return Math.floor(days2 * 864e5) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units);
        }
      }
    }
    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }
      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
    function clone$1() {
      return createDuration(this);
    }
    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name2) {
      return function() {
        return this.isValid() ? this._data[name2] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
      ss: 44,
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      w: null,
      M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale2;
      return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === void 0) {
        return round;
      }
      if (typeof roundingFunction === "function") {
        round = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === void 0) {
        return false;
      }
      if (limit === void 0) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === "s") {
        thresholds.ss = limit - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th2 = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th2 = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th2.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th2, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x2) {
      return (x2 > 0) - (x2 < 0) || +x2;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
      config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
      config._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = "2.29.2";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      DATE: "YYYY-MM-DD",
      TIME: "HH:mm",
      TIME_SECONDS: "HH:mm:ss",
      TIME_MS: "HH:mm:ss.SSS",
      WEEK: "GGGG-[W]WW",
      MONTH: "YYYY-MM"
    };
    const moment = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: hooks
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$0 = /* @__PURE__ */ getAugmentedNamespace(moment);
    /*!
     * Chart.js v2.9.4
     * https://www.chartjs.org
     * (c) 2020 Chart.js Contributors
     * Released under the MIT License
     */
    (function(module2, exports2) {
      (function(global2, factory) {
        module2.exports = factory(function() {
          try {
            return require$$0;
          } catch (e) {
          }
        }());
      })(commonjsGlobal, function(moment2) {
        moment2 = moment2 && moment2.hasOwnProperty("default") ? moment2["default"] : moment2;
        function createCommonjsModule(fn, module3) {
          return module3 = { exports: {} }, fn(module3, module3.exports), module3.exports;
        }
        function getCjsExportFromNamespace(n2) {
          return n2 && n2["default"] || n2;
        }
        var colorName = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
        var conversions = createCommonjsModule(function(module3) {
          var reverseKeywords = {};
          for (var key in colorName) {
            if (colorName.hasOwnProperty(key)) {
              reverseKeywords[colorName[key]] = key;
            }
          }
          var convert2 = module3.exports = {
            rgb: { channels: 3, labels: "rgb" },
            hsl: { channels: 3, labels: "hsl" },
            hsv: { channels: 3, labels: "hsv" },
            hwb: { channels: 3, labels: "hwb" },
            cmyk: { channels: 4, labels: "cmyk" },
            xyz: { channels: 3, labels: "xyz" },
            lab: { channels: 3, labels: "lab" },
            lch: { channels: 3, labels: "lch" },
            hex: { channels: 1, labels: ["hex"] },
            keyword: { channels: 1, labels: ["keyword"] },
            ansi16: { channels: 1, labels: ["ansi16"] },
            ansi256: { channels: 1, labels: ["ansi256"] },
            hcg: { channels: 3, labels: ["h", "c", "g"] },
            apple: { channels: 3, labels: ["r16", "g16", "b16"] },
            gray: { channels: 1, labels: ["gray"] }
          };
          for (var model in convert2) {
            if (convert2.hasOwnProperty(model)) {
              if (!("channels" in convert2[model])) {
                throw new Error("missing channels property: " + model);
              }
              if (!("labels" in convert2[model])) {
                throw new Error("missing channel labels property: " + model);
              }
              if (convert2[model].labels.length !== convert2[model].channels) {
                throw new Error("channel and label counts mismatch: " + model);
              }
              var channels = convert2[model].channels;
              var labels = convert2[model].labels;
              delete convert2[model].channels;
              delete convert2[model].labels;
              Object.defineProperty(convert2[model], "channels", { value: channels });
              Object.defineProperty(convert2[model], "labels", { value: labels });
            }
          }
          convert2.rgb.hsl = function(rgb) {
            var r2 = rgb[0] / 255;
            var g2 = rgb[1] / 255;
            var b = rgb[2] / 255;
            var min2 = Math.min(r2, g2, b);
            var max2 = Math.max(r2, g2, b);
            var delta = max2 - min2;
            var h2;
            var s;
            var l2;
            if (max2 === min2) {
              h2 = 0;
            } else if (r2 === max2) {
              h2 = (g2 - b) / delta;
            } else if (g2 === max2) {
              h2 = 2 + (b - r2) / delta;
            } else if (b === max2) {
              h2 = 4 + (r2 - g2) / delta;
            }
            h2 = Math.min(h2 * 60, 360);
            if (h2 < 0) {
              h2 += 360;
            }
            l2 = (min2 + max2) / 2;
            if (max2 === min2) {
              s = 0;
            } else if (l2 <= 0.5) {
              s = delta / (max2 + min2);
            } else {
              s = delta / (2 - max2 - min2);
            }
            return [h2, s * 100, l2 * 100];
          };
          convert2.rgb.hsv = function(rgb) {
            var rdif;
            var gdif;
            var bdif;
            var h2;
            var s;
            var r2 = rgb[0] / 255;
            var g2 = rgb[1] / 255;
            var b = rgb[2] / 255;
            var v2 = Math.max(r2, g2, b);
            var diff2 = v2 - Math.min(r2, g2, b);
            var diffc = function(c) {
              return (v2 - c) / 6 / diff2 + 1 / 2;
            };
            if (diff2 === 0) {
              h2 = s = 0;
            } else {
              s = diff2 / v2;
              rdif = diffc(r2);
              gdif = diffc(g2);
              bdif = diffc(b);
              if (r2 === v2) {
                h2 = bdif - gdif;
              } else if (g2 === v2) {
                h2 = 1 / 3 + rdif - bdif;
              } else if (b === v2) {
                h2 = 2 / 3 + gdif - rdif;
              }
              if (h2 < 0) {
                h2 += 1;
              } else if (h2 > 1) {
                h2 -= 1;
              }
            }
            return [
              h2 * 360,
              s * 100,
              v2 * 100
            ];
          };
          convert2.rgb.hwb = function(rgb) {
            var r2 = rgb[0];
            var g2 = rgb[1];
            var b = rgb[2];
            var h2 = convert2.rgb.hsl(rgb)[0];
            var w2 = 1 / 255 * Math.min(r2, Math.min(g2, b));
            b = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b));
            return [h2, w2 * 100, b * 100];
          };
          convert2.rgb.cmyk = function(rgb) {
            var r2 = rgb[0] / 255;
            var g2 = rgb[1] / 255;
            var b = rgb[2] / 255;
            var c;
            var m2;
            var y2;
            var k2;
            k2 = Math.min(1 - r2, 1 - g2, 1 - b);
            c = (1 - r2 - k2) / (1 - k2) || 0;
            m2 = (1 - g2 - k2) / (1 - k2) || 0;
            y2 = (1 - b - k2) / (1 - k2) || 0;
            return [c * 100, m2 * 100, y2 * 100, k2 * 100];
          };
          function comparativeDistance(x2, y2) {
            return Math.pow(x2[0] - y2[0], 2) + Math.pow(x2[1] - y2[1], 2) + Math.pow(x2[2] - y2[2], 2);
          }
          convert2.rgb.keyword = function(rgb) {
            var reversed = reverseKeywords[rgb];
            if (reversed) {
              return reversed;
            }
            var currentClosestDistance = Infinity;
            var currentClosestKeyword;
            for (var keyword2 in colorName) {
              if (colorName.hasOwnProperty(keyword2)) {
                var value2 = colorName[keyword2];
                var distance = comparativeDistance(rgb, value2);
                if (distance < currentClosestDistance) {
                  currentClosestDistance = distance;
                  currentClosestKeyword = keyword2;
                }
              }
            }
            return currentClosestKeyword;
          };
          convert2.keyword.rgb = function(keyword2) {
            return colorName[keyword2];
          };
          convert2.rgb.xyz = function(rgb) {
            var r2 = rgb[0] / 255;
            var g2 = rgb[1] / 255;
            var b = rgb[2] / 255;
            r2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92;
            g2 = g2 > 0.04045 ? Math.pow((g2 + 0.055) / 1.055, 2.4) : g2 / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
            var x2 = r2 * 0.4124 + g2 * 0.3576 + b * 0.1805;
            var y2 = r2 * 0.2126 + g2 * 0.7152 + b * 0.0722;
            var z2 = r2 * 0.0193 + g2 * 0.1192 + b * 0.9505;
            return [x2 * 100, y2 * 100, z2 * 100];
          };
          convert2.rgb.lab = function(rgb) {
            var xyz = convert2.rgb.xyz(rgb);
            var x2 = xyz[0];
            var y2 = xyz[1];
            var z2 = xyz[2];
            var l2;
            var a;
            var b;
            x2 /= 95.047;
            y2 /= 100;
            z2 /= 108.883;
            x2 = x2 > 8856e-6 ? Math.pow(x2, 1 / 3) : 7.787 * x2 + 16 / 116;
            y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
            z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
            l2 = 116 * y2 - 16;
            a = 500 * (x2 - y2);
            b = 200 * (y2 - z2);
            return [l2, a, b];
          };
          convert2.hsl.rgb = function(hsl) {
            var h2 = hsl[0] / 360;
            var s = hsl[1] / 100;
            var l2 = hsl[2] / 100;
            var t1;
            var t2;
            var t3;
            var rgb;
            var val;
            if (s === 0) {
              val = l2 * 255;
              return [val, val, val];
            }
            if (l2 < 0.5) {
              t2 = l2 * (1 + s);
            } else {
              t2 = l2 + s - l2 * s;
            }
            t1 = 2 * l2 - t2;
            rgb = [0, 0, 0];
            for (var i = 0; i < 3; i++) {
              t3 = h2 + 1 / 3 * -(i - 1);
              if (t3 < 0) {
                t3++;
              }
              if (t3 > 1) {
                t3--;
              }
              if (6 * t3 < 1) {
                val = t1 + (t2 - t1) * 6 * t3;
              } else if (2 * t3 < 1) {
                val = t2;
              } else if (3 * t3 < 2) {
                val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
              } else {
                val = t1;
              }
              rgb[i] = val * 255;
            }
            return rgb;
          };
          convert2.hsl.hsv = function(hsl) {
            var h2 = hsl[0];
            var s = hsl[1] / 100;
            var l2 = hsl[2] / 100;
            var smin = s;
            var lmin = Math.max(l2, 0.01);
            var sv;
            var v2;
            l2 *= 2;
            s *= l2 <= 1 ? l2 : 2 - l2;
            smin *= lmin <= 1 ? lmin : 2 - lmin;
            v2 = (l2 + s) / 2;
            sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l2 + s);
            return [h2, sv * 100, v2 * 100];
          };
          convert2.hsv.rgb = function(hsv) {
            var h2 = hsv[0] / 60;
            var s = hsv[1] / 100;
            var v2 = hsv[2] / 100;
            var hi2 = Math.floor(h2) % 6;
            var f2 = h2 - Math.floor(h2);
            var p2 = 255 * v2 * (1 - s);
            var q2 = 255 * v2 * (1 - s * f2);
            var t2 = 255 * v2 * (1 - s * (1 - f2));
            v2 *= 255;
            switch (hi2) {
              case 0:
                return [v2, t2, p2];
              case 1:
                return [q2, v2, p2];
              case 2:
                return [p2, v2, t2];
              case 3:
                return [p2, q2, v2];
              case 4:
                return [t2, p2, v2];
              case 5:
                return [v2, p2, q2];
            }
          };
          convert2.hsv.hsl = function(hsv) {
            var h2 = hsv[0];
            var s = hsv[1] / 100;
            var v2 = hsv[2] / 100;
            var vmin = Math.max(v2, 0.01);
            var lmin;
            var sl;
            var l2;
            l2 = (2 - s) * v2;
            lmin = (2 - s) * vmin;
            sl = s * vmin;
            sl /= lmin <= 1 ? lmin : 2 - lmin;
            sl = sl || 0;
            l2 /= 2;
            return [h2, sl * 100, l2 * 100];
          };
          convert2.hwb.rgb = function(hwb) {
            var h2 = hwb[0] / 360;
            var wh2 = hwb[1] / 100;
            var bl = hwb[2] / 100;
            var ratio = wh2 + bl;
            var i;
            var v2;
            var f2;
            var n2;
            if (ratio > 1) {
              wh2 /= ratio;
              bl /= ratio;
            }
            i = Math.floor(6 * h2);
            v2 = 1 - bl;
            f2 = 6 * h2 - i;
            if ((i & 1) !== 0) {
              f2 = 1 - f2;
            }
            n2 = wh2 + f2 * (v2 - wh2);
            var r2;
            var g2;
            var b;
            switch (i) {
              default:
              case 6:
              case 0:
                r2 = v2;
                g2 = n2;
                b = wh2;
                break;
              case 1:
                r2 = n2;
                g2 = v2;
                b = wh2;
                break;
              case 2:
                r2 = wh2;
                g2 = v2;
                b = n2;
                break;
              case 3:
                r2 = wh2;
                g2 = n2;
                b = v2;
                break;
              case 4:
                r2 = n2;
                g2 = wh2;
                b = v2;
                break;
              case 5:
                r2 = v2;
                g2 = wh2;
                b = n2;
                break;
            }
            return [r2 * 255, g2 * 255, b * 255];
          };
          convert2.cmyk.rgb = function(cmyk) {
            var c = cmyk[0] / 100;
            var m2 = cmyk[1] / 100;
            var y2 = cmyk[2] / 100;
            var k2 = cmyk[3] / 100;
            var r2;
            var g2;
            var b;
            r2 = 1 - Math.min(1, c * (1 - k2) + k2);
            g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
            b = 1 - Math.min(1, y2 * (1 - k2) + k2);
            return [r2 * 255, g2 * 255, b * 255];
          };
          convert2.xyz.rgb = function(xyz) {
            var x2 = xyz[0] / 100;
            var y2 = xyz[1] / 100;
            var z2 = xyz[2] / 100;
            var r2;
            var g2;
            var b;
            r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
            g2 = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
            b = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
            r2 = r2 > 31308e-7 ? 1.055 * Math.pow(r2, 1 / 2.4) - 0.055 : r2 * 12.92;
            g2 = g2 > 31308e-7 ? 1.055 * Math.pow(g2, 1 / 2.4) - 0.055 : g2 * 12.92;
            b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
            r2 = Math.min(Math.max(0, r2), 1);
            g2 = Math.min(Math.max(0, g2), 1);
            b = Math.min(Math.max(0, b), 1);
            return [r2 * 255, g2 * 255, b * 255];
          };
          convert2.xyz.lab = function(xyz) {
            var x2 = xyz[0];
            var y2 = xyz[1];
            var z2 = xyz[2];
            var l2;
            var a;
            var b;
            x2 /= 95.047;
            y2 /= 100;
            z2 /= 108.883;
            x2 = x2 > 8856e-6 ? Math.pow(x2, 1 / 3) : 7.787 * x2 + 16 / 116;
            y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
            z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
            l2 = 116 * y2 - 16;
            a = 500 * (x2 - y2);
            b = 200 * (y2 - z2);
            return [l2, a, b];
          };
          convert2.lab.xyz = function(lab) {
            var l2 = lab[0];
            var a = lab[1];
            var b = lab[2];
            var x2;
            var y2;
            var z2;
            y2 = (l2 + 16) / 116;
            x2 = a / 500 + y2;
            z2 = y2 - b / 200;
            var y22 = Math.pow(y2, 3);
            var x22 = Math.pow(x2, 3);
            var z22 = Math.pow(z2, 3);
            y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
            x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
            z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
            x2 *= 95.047;
            y2 *= 100;
            z2 *= 108.883;
            return [x2, y2, z2];
          };
          convert2.lab.lch = function(lab) {
            var l2 = lab[0];
            var a = lab[1];
            var b = lab[2];
            var hr;
            var h2;
            var c;
            hr = Math.atan2(b, a);
            h2 = hr * 360 / 2 / Math.PI;
            if (h2 < 0) {
              h2 += 360;
            }
            c = Math.sqrt(a * a + b * b);
            return [l2, c, h2];
          };
          convert2.lch.lab = function(lch) {
            var l2 = lch[0];
            var c = lch[1];
            var h2 = lch[2];
            var a;
            var b;
            var hr;
            hr = h2 / 360 * 2 * Math.PI;
            a = c * Math.cos(hr);
            b = c * Math.sin(hr);
            return [l2, a, b];
          };
          convert2.rgb.ansi16 = function(args) {
            var r2 = args[0];
            var g2 = args[1];
            var b = args[2];
            var value2 = 1 in arguments ? arguments[1] : convert2.rgb.hsv(args)[2];
            value2 = Math.round(value2 / 50);
            if (value2 === 0) {
              return 30;
            }
            var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
            if (value2 === 2) {
              ansi += 60;
            }
            return ansi;
          };
          convert2.hsv.ansi16 = function(args) {
            return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
          };
          convert2.rgb.ansi256 = function(args) {
            var r2 = args[0];
            var g2 = args[1];
            var b = args[2];
            if (r2 === g2 && g2 === b) {
              if (r2 < 8) {
                return 16;
              }
              if (r2 > 248) {
                return 231;
              }
              return Math.round((r2 - 8) / 247 * 24) + 232;
            }
            var ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b / 255 * 5);
            return ansi;
          };
          convert2.ansi16.rgb = function(args) {
            var color = args % 10;
            if (color === 0 || color === 7) {
              if (args > 50) {
                color += 3.5;
              }
              color = color / 10.5 * 255;
              return [color, color, color];
            }
            var mult = (~~(args > 50) + 1) * 0.5;
            var r2 = (color & 1) * mult * 255;
            var g2 = (color >> 1 & 1) * mult * 255;
            var b = (color >> 2 & 1) * mult * 255;
            return [r2, g2, b];
          };
          convert2.ansi256.rgb = function(args) {
            if (args >= 232) {
              var c = (args - 232) * 10 + 8;
              return [c, c, c];
            }
            args -= 16;
            var rem;
            var r2 = Math.floor(args / 36) / 5 * 255;
            var g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
            var b = rem % 6 / 5 * 255;
            return [r2, g2, b];
          };
          convert2.rgb.hex = function(args) {
            var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
            var string = integer.toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          };
          convert2.hex.rgb = function(args) {
            var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
            if (!match) {
              return [0, 0, 0];
            }
            var colorString2 = match[0];
            if (match[0].length === 3) {
              colorString2 = colorString2.split("").map(function(char) {
                return char + char;
              }).join("");
            }
            var integer = parseInt(colorString2, 16);
            var r2 = integer >> 16 & 255;
            var g2 = integer >> 8 & 255;
            var b = integer & 255;
            return [r2, g2, b];
          };
          convert2.rgb.hcg = function(rgb) {
            var r2 = rgb[0] / 255;
            var g2 = rgb[1] / 255;
            var b = rgb[2] / 255;
            var max2 = Math.max(Math.max(r2, g2), b);
            var min2 = Math.min(Math.min(r2, g2), b);
            var chroma = max2 - min2;
            var grayscale;
            var hue;
            if (chroma < 1) {
              grayscale = min2 / (1 - chroma);
            } else {
              grayscale = 0;
            }
            if (chroma <= 0) {
              hue = 0;
            } else if (max2 === r2) {
              hue = (g2 - b) / chroma % 6;
            } else if (max2 === g2) {
              hue = 2 + (b - r2) / chroma;
            } else {
              hue = 4 + (r2 - g2) / chroma + 4;
            }
            hue /= 6;
            hue %= 1;
            return [hue * 360, chroma * 100, grayscale * 100];
          };
          convert2.hsl.hcg = function(hsl) {
            var s = hsl[1] / 100;
            var l2 = hsl[2] / 100;
            var c = 1;
            var f2 = 0;
            if (l2 < 0.5) {
              c = 2 * s * l2;
            } else {
              c = 2 * s * (1 - l2);
            }
            if (c < 1) {
              f2 = (l2 - 0.5 * c) / (1 - c);
            }
            return [hsl[0], c * 100, f2 * 100];
          };
          convert2.hsv.hcg = function(hsv) {
            var s = hsv[1] / 100;
            var v2 = hsv[2] / 100;
            var c = s * v2;
            var f2 = 0;
            if (c < 1) {
              f2 = (v2 - c) / (1 - c);
            }
            return [hsv[0], c * 100, f2 * 100];
          };
          convert2.hcg.rgb = function(hcg) {
            var h2 = hcg[0] / 360;
            var c = hcg[1] / 100;
            var g2 = hcg[2] / 100;
            if (c === 0) {
              return [g2 * 255, g2 * 255, g2 * 255];
            }
            var pure = [0, 0, 0];
            var hi2 = h2 % 1 * 6;
            var v2 = hi2 % 1;
            var w2 = 1 - v2;
            var mg2 = 0;
            switch (Math.floor(hi2)) {
              case 0:
                pure[0] = 1;
                pure[1] = v2;
                pure[2] = 0;
                break;
              case 1:
                pure[0] = w2;
                pure[1] = 1;
                pure[2] = 0;
                break;
              case 2:
                pure[0] = 0;
                pure[1] = 1;
                pure[2] = v2;
                break;
              case 3:
                pure[0] = 0;
                pure[1] = w2;
                pure[2] = 1;
                break;
              case 4:
                pure[0] = v2;
                pure[1] = 0;
                pure[2] = 1;
                break;
              default:
                pure[0] = 1;
                pure[1] = 0;
                pure[2] = w2;
            }
            mg2 = (1 - c) * g2;
            return [
              (c * pure[0] + mg2) * 255,
              (c * pure[1] + mg2) * 255,
              (c * pure[2] + mg2) * 255
            ];
          };
          convert2.hcg.hsv = function(hcg) {
            var c = hcg[1] / 100;
            var g2 = hcg[2] / 100;
            var v2 = c + g2 * (1 - c);
            var f2 = 0;
            if (v2 > 0) {
              f2 = c / v2;
            }
            return [hcg[0], f2 * 100, v2 * 100];
          };
          convert2.hcg.hsl = function(hcg) {
            var c = hcg[1] / 100;
            var g2 = hcg[2] / 100;
            var l2 = g2 * (1 - c) + 0.5 * c;
            var s = 0;
            if (l2 > 0 && l2 < 0.5) {
              s = c / (2 * l2);
            } else if (l2 >= 0.5 && l2 < 1) {
              s = c / (2 * (1 - l2));
            }
            return [hcg[0], s * 100, l2 * 100];
          };
          convert2.hcg.hwb = function(hcg) {
            var c = hcg[1] / 100;
            var g2 = hcg[2] / 100;
            var v2 = c + g2 * (1 - c);
            return [hcg[0], (v2 - c) * 100, (1 - v2) * 100];
          };
          convert2.hwb.hcg = function(hwb) {
            var w2 = hwb[1] / 100;
            var b = hwb[2] / 100;
            var v2 = 1 - b;
            var c = v2 - w2;
            var g2 = 0;
            if (c < 1) {
              g2 = (v2 - c) / (1 - c);
            }
            return [hwb[0], c * 100, g2 * 100];
          };
          convert2.apple.rgb = function(apple) {
            return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
          };
          convert2.rgb.apple = function(rgb) {
            return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
          };
          convert2.gray.rgb = function(args) {
            return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
          };
          convert2.gray.hsl = convert2.gray.hsv = function(args) {
            return [0, 0, args[0]];
          };
          convert2.gray.hwb = function(gray) {
            return [0, 100, gray[0]];
          };
          convert2.gray.cmyk = function(gray) {
            return [0, 0, 0, gray[0]];
          };
          convert2.gray.lab = function(gray) {
            return [gray[0], 0, 0];
          };
          convert2.gray.hex = function(gray) {
            var val = Math.round(gray[0] / 100 * 255) & 255;
            var integer = (val << 16) + (val << 8) + val;
            var string = integer.toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          };
          convert2.rgb.gray = function(rgb) {
            var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
            return [val / 255 * 100];
          };
        });
        conversions.rgb;
        conversions.hsl;
        conversions.hsv;
        conversions.hwb;
        conversions.cmyk;
        conversions.xyz;
        conversions.lab;
        conversions.lch;
        conversions.hex;
        conversions.keyword;
        conversions.ansi16;
        conversions.ansi256;
        conversions.hcg;
        conversions.apple;
        conversions.gray;
        function buildGraph() {
          var graph = {};
          var models2 = Object.keys(conversions);
          for (var len = models2.length, i = 0; i < len; i++) {
            graph[models2[i]] = {
              distance: -1,
              parent: null
            };
          }
          return graph;
        }
        function deriveBFS(fromModel) {
          var graph = buildGraph();
          var queue2 = [fromModel];
          graph[fromModel].distance = 0;
          while (queue2.length) {
            var current = queue2.pop();
            var adjacents = Object.keys(conversions[current]);
            for (var len = adjacents.length, i = 0; i < len; i++) {
              var adjacent = adjacents[i];
              var node = graph[adjacent];
              if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue2.unshift(adjacent);
              }
            }
          }
          return graph;
        }
        function link(from2, to2) {
          return function(args) {
            return to2(from2(args));
          };
        }
        function wrapConversion(toModel, graph) {
          var path = [graph[toModel].parent, toModel];
          var fn = conversions[graph[toModel].parent][toModel];
          var cur = graph[toModel].parent;
          while (graph[cur].parent) {
            path.unshift(graph[cur].parent);
            fn = link(conversions[graph[cur].parent][cur], fn);
            cur = graph[cur].parent;
          }
          fn.conversion = path;
          return fn;
        }
        var route = function(fromModel) {
          var graph = deriveBFS(fromModel);
          var conversion = {};
          var models2 = Object.keys(graph);
          for (var len = models2.length, i = 0; i < len; i++) {
            var toModel = models2[i];
            var node = graph[toModel];
            if (node.parent === null) {
              continue;
            }
            conversion[toModel] = wrapConversion(toModel, graph);
          }
          return conversion;
        };
        var convert = {};
        var models = Object.keys(conversions);
        function wrapRaw(fn) {
          var wrappedFn = function(args) {
            if (args === void 0 || args === null) {
              return args;
            }
            if (arguments.length > 1) {
              args = Array.prototype.slice.call(arguments);
            }
            return fn(args);
          };
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        function wrapRounded(fn) {
          var wrappedFn = function(args) {
            if (args === void 0 || args === null) {
              return args;
            }
            if (arguments.length > 1) {
              args = Array.prototype.slice.call(arguments);
            }
            var result2 = fn(args);
            if (typeof result2 === "object") {
              for (var len = result2.length, i = 0; i < len; i++) {
                result2[i] = Math.round(result2[i]);
              }
            }
            return result2;
          };
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        models.forEach(function(fromModel) {
          convert[fromModel] = {};
          Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
          Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
          var routes = route(fromModel);
          var routeModels = Object.keys(routes);
          routeModels.forEach(function(toModel) {
            var fn = routes[toModel];
            convert[fromModel][toModel] = wrapRounded(fn);
            convert[fromModel][toModel].raw = wrapRaw(fn);
          });
        });
        var colorConvert = convert;
        var colorName$1 = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
        var colorString = {
          getRgba,
          getHsla,
          getRgb,
          getHsl,
          getHwb,
          getAlpha,
          hexString,
          rgbString,
          rgbaString,
          percentString,
          percentaString,
          hslString,
          hslaString,
          hwbString,
          keyword
        };
        function getRgba(string) {
          if (!string) {
            return;
          }
          var abbr = /^#([a-fA-F0-9]{3,4})$/i, hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i, rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, keyword2 = /(\w+)/;
          var rgb = [0, 0, 0], a = 1, match = string.match(abbr), hexAlpha = "";
          if (match) {
            match = match[1];
            hexAlpha = match[3];
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = parseInt(match[i] + match[i], 16);
            }
            if (hexAlpha) {
              a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
            }
          } else if (match = string.match(hex)) {
            hexAlpha = match[2];
            match = match[1];
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
            }
            if (hexAlpha) {
              a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
            }
          } else if (match = string.match(rgba)) {
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = parseInt(match[i + 1]);
            }
            a = parseFloat(match[4]);
          } else if (match = string.match(per)) {
            for (var i = 0; i < rgb.length; i++) {
              rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
            }
            a = parseFloat(match[4]);
          } else if (match = string.match(keyword2)) {
            if (match[1] == "transparent") {
              return [0, 0, 0, 0];
            }
            rgb = colorName$1[match[1]];
            if (!rgb) {
              return;
            }
          }
          for (var i = 0; i < rgb.length; i++) {
            rgb[i] = scale(rgb[i], 0, 255);
          }
          if (!a && a != 0) {
            a = 1;
          } else {
            a = scale(a, 0, 1);
          }
          rgb[3] = a;
          return rgb;
        }
        function getHsla(string) {
          if (!string) {
            return;
          }
          var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
          var match = string.match(hsl);
          if (match) {
            var alpha = parseFloat(match[4]);
            var h2 = scale(parseInt(match[1]), 0, 360), s = scale(parseFloat(match[2]), 0, 100), l2 = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
            return [h2, s, l2, a];
          }
        }
        function getHwb(string) {
          if (!string) {
            return;
          }
          var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
          var match = string.match(hwb);
          if (match) {
            var alpha = parseFloat(match[4]);
            var h2 = scale(parseInt(match[1]), 0, 360), w2 = scale(parseFloat(match[2]), 0, 100), b = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
            return [h2, w2, b, a];
          }
        }
        function getRgb(string) {
          var rgba = getRgba(string);
          return rgba && rgba.slice(0, 3);
        }
        function getHsl(string) {
          var hsla = getHsla(string);
          return hsla && hsla.slice(0, 3);
        }
        function getAlpha(string) {
          var vals = getRgba(string);
          if (vals) {
            return vals[3];
          } else if (vals = getHsla(string)) {
            return vals[3];
          } else if (vals = getHwb(string)) {
            return vals[3];
          }
        }
        function hexString(rgba, a) {
          var a = a !== void 0 && rgba.length === 3 ? a : rgba[3];
          return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
        }
        function rgbString(rgba, alpha) {
          if (alpha < 1 || rgba[3] && rgba[3] < 1) {
            return rgbaString(rgba, alpha);
          }
          return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
        }
        function rgbaString(rgba, alpha) {
          if (alpha === void 0) {
            alpha = rgba[3] !== void 0 ? rgba[3] : 1;
          }
          return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
        }
        function percentString(rgba, alpha) {
          if (alpha < 1 || rgba[3] && rgba[3] < 1) {
            return percentaString(rgba, alpha);
          }
          var r2 = Math.round(rgba[0] / 255 * 100), g2 = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
          return "rgb(" + r2 + "%, " + g2 + "%, " + b + "%)";
        }
        function percentaString(rgba, alpha) {
          var r2 = Math.round(rgba[0] / 255 * 100), g2 = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
          return "rgba(" + r2 + "%, " + g2 + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
        }
        function hslString(hsla, alpha) {
          if (alpha < 1 || hsla[3] && hsla[3] < 1) {
            return hslaString(hsla, alpha);
          }
          return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
        }
        function hslaString(hsla, alpha) {
          if (alpha === void 0) {
            alpha = hsla[3] !== void 0 ? hsla[3] : 1;
          }
          return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
        }
        function hwbString(hwb, alpha) {
          if (alpha === void 0) {
            alpha = hwb[3] !== void 0 ? hwb[3] : 1;
          }
          return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== void 0 && alpha !== 1 ? ", " + alpha : "") + ")";
        }
        function keyword(rgb) {
          return reverseNames[rgb.slice(0, 3)];
        }
        function scale(num, min2, max2) {
          return Math.min(Math.max(min2, num), max2);
        }
        function hexDouble(num) {
          var str = num.toString(16).toUpperCase();
          return str.length < 2 ? "0" + str : str;
        }
        var reverseNames = {};
        for (var name2 in colorName$1) {
          reverseNames[colorName$1[name2]] = name2;
        }
        var Color = function(obj) {
          if (obj instanceof Color) {
            return obj;
          }
          if (!(this instanceof Color)) {
            return new Color(obj);
          }
          this.valid = false;
          this.values = {
            rgb: [0, 0, 0],
            hsl: [0, 0, 0],
            hsv: [0, 0, 0],
            hwb: [0, 0, 0],
            cmyk: [0, 0, 0, 0],
            alpha: 1
          };
          var vals;
          if (typeof obj === "string") {
            vals = colorString.getRgba(obj);
            if (vals) {
              this.setValues("rgb", vals);
            } else if (vals = colorString.getHsla(obj)) {
              this.setValues("hsl", vals);
            } else if (vals = colorString.getHwb(obj)) {
              this.setValues("hwb", vals);
            }
          } else if (typeof obj === "object") {
            vals = obj;
            if (vals.r !== void 0 || vals.red !== void 0) {
              this.setValues("rgb", vals);
            } else if (vals.l !== void 0 || vals.lightness !== void 0) {
              this.setValues("hsl", vals);
            } else if (vals.v !== void 0 || vals.value !== void 0) {
              this.setValues("hsv", vals);
            } else if (vals.w !== void 0 || vals.whiteness !== void 0) {
              this.setValues("hwb", vals);
            } else if (vals.c !== void 0 || vals.cyan !== void 0) {
              this.setValues("cmyk", vals);
            }
          }
        };
        Color.prototype = {
          isValid: function() {
            return this.valid;
          },
          rgb: function() {
            return this.setSpace("rgb", arguments);
          },
          hsl: function() {
            return this.setSpace("hsl", arguments);
          },
          hsv: function() {
            return this.setSpace("hsv", arguments);
          },
          hwb: function() {
            return this.setSpace("hwb", arguments);
          },
          cmyk: function() {
            return this.setSpace("cmyk", arguments);
          },
          rgbArray: function() {
            return this.values.rgb;
          },
          hslArray: function() {
            return this.values.hsl;
          },
          hsvArray: function() {
            return this.values.hsv;
          },
          hwbArray: function() {
            var values2 = this.values;
            if (values2.alpha !== 1) {
              return values2.hwb.concat([values2.alpha]);
            }
            return values2.hwb;
          },
          cmykArray: function() {
            return this.values.cmyk;
          },
          rgbaArray: function() {
            var values2 = this.values;
            return values2.rgb.concat([values2.alpha]);
          },
          hslaArray: function() {
            var values2 = this.values;
            return values2.hsl.concat([values2.alpha]);
          },
          alpha: function(val) {
            if (val === void 0) {
              return this.values.alpha;
            }
            this.setValues("alpha", val);
            return this;
          },
          red: function(val) {
            return this.setChannel("rgb", 0, val);
          },
          green: function(val) {
            return this.setChannel("rgb", 1, val);
          },
          blue: function(val) {
            return this.setChannel("rgb", 2, val);
          },
          hue: function(val) {
            if (val) {
              val %= 360;
              val = val < 0 ? 360 + val : val;
            }
            return this.setChannel("hsl", 0, val);
          },
          saturation: function(val) {
            return this.setChannel("hsl", 1, val);
          },
          lightness: function(val) {
            return this.setChannel("hsl", 2, val);
          },
          saturationv: function(val) {
            return this.setChannel("hsv", 1, val);
          },
          whiteness: function(val) {
            return this.setChannel("hwb", 1, val);
          },
          blackness: function(val) {
            return this.setChannel("hwb", 2, val);
          },
          value: function(val) {
            return this.setChannel("hsv", 2, val);
          },
          cyan: function(val) {
            return this.setChannel("cmyk", 0, val);
          },
          magenta: function(val) {
            return this.setChannel("cmyk", 1, val);
          },
          yellow: function(val) {
            return this.setChannel("cmyk", 2, val);
          },
          black: function(val) {
            return this.setChannel("cmyk", 3, val);
          },
          hexString: function() {
            return colorString.hexString(this.values.rgb);
          },
          rgbString: function() {
            return colorString.rgbString(this.values.rgb, this.values.alpha);
          },
          rgbaString: function() {
            return colorString.rgbaString(this.values.rgb, this.values.alpha);
          },
          percentString: function() {
            return colorString.percentString(this.values.rgb, this.values.alpha);
          },
          hslString: function() {
            return colorString.hslString(this.values.hsl, this.values.alpha);
          },
          hslaString: function() {
            return colorString.hslaString(this.values.hsl, this.values.alpha);
          },
          hwbString: function() {
            return colorString.hwbString(this.values.hwb, this.values.alpha);
          },
          keyword: function() {
            return colorString.keyword(this.values.rgb, this.values.alpha);
          },
          rgbNumber: function() {
            var rgb = this.values.rgb;
            return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
          },
          luminosity: function() {
            var rgb = this.values.rgb;
            var lum = [];
            for (var i = 0; i < rgb.length; i++) {
              var chan = rgb[i] / 255;
              lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
          },
          contrast: function(color2) {
            var lum1 = this.luminosity();
            var lum2 = color2.luminosity();
            if (lum1 > lum2) {
              return (lum1 + 0.05) / (lum2 + 0.05);
            }
            return (lum2 + 0.05) / (lum1 + 0.05);
          },
          level: function(color2) {
            var contrastRatio = this.contrast(color2);
            if (contrastRatio >= 7.1) {
              return "AAA";
            }
            return contrastRatio >= 4.5 ? "AA" : "";
          },
          dark: function() {
            var rgb = this.values.rgb;
            var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
            return yiq < 128;
          },
          light: function() {
            return !this.dark();
          },
          negate: function() {
            var rgb = [];
            for (var i = 0; i < 3; i++) {
              rgb[i] = 255 - this.values.rgb[i];
            }
            this.setValues("rgb", rgb);
            return this;
          },
          lighten: function(ratio) {
            var hsl = this.values.hsl;
            hsl[2] += hsl[2] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          darken: function(ratio) {
            var hsl = this.values.hsl;
            hsl[2] -= hsl[2] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          saturate: function(ratio) {
            var hsl = this.values.hsl;
            hsl[1] += hsl[1] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          desaturate: function(ratio) {
            var hsl = this.values.hsl;
            hsl[1] -= hsl[1] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          whiten: function(ratio) {
            var hwb = this.values.hwb;
            hwb[1] += hwb[1] * ratio;
            this.setValues("hwb", hwb);
            return this;
          },
          blacken: function(ratio) {
            var hwb = this.values.hwb;
            hwb[2] += hwb[2] * ratio;
            this.setValues("hwb", hwb);
            return this;
          },
          greyscale: function() {
            var rgb = this.values.rgb;
            var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
            this.setValues("rgb", [val, val, val]);
            return this;
          },
          clearer: function(ratio) {
            var alpha = this.values.alpha;
            this.setValues("alpha", alpha - alpha * ratio);
            return this;
          },
          opaquer: function(ratio) {
            var alpha = this.values.alpha;
            this.setValues("alpha", alpha + alpha * ratio);
            return this;
          },
          rotate: function(degrees) {
            var hsl = this.values.hsl;
            var hue = (hsl[0] + degrees) % 360;
            hsl[0] = hue < 0 ? 360 + hue : hue;
            this.setValues("hsl", hsl);
            return this;
          },
          mix: function(mixinColor, weight) {
            var color1 = this;
            var color2 = mixinColor;
            var p2 = weight === void 0 ? 0.5 : weight;
            var w2 = 2 * p2 - 1;
            var a = color1.alpha() - color2.alpha();
            var w1 = ((w2 * a === -1 ? w2 : (w2 + a) / (1 + w2 * a)) + 1) / 2;
            var w22 = 1 - w1;
            return this.rgb(
              w1 * color1.red() + w22 * color2.red(),
              w1 * color1.green() + w22 * color2.green(),
              w1 * color1.blue() + w22 * color2.blue()
            ).alpha(color1.alpha() * p2 + color2.alpha() * (1 - p2));
          },
          toJSON: function() {
            return this.rgb();
          },
          clone: function() {
            var result2 = new Color();
            var source = this.values;
            var target = result2.values;
            var value2, type;
            for (var prop in source) {
              if (source.hasOwnProperty(prop)) {
                value2 = source[prop];
                type = {}.toString.call(value2);
                if (type === "[object Array]") {
                  target[prop] = value2.slice(0);
                } else if (type === "[object Number]") {
                  target[prop] = value2;
                } else {
                  console.error("unexpected color value:", value2);
                }
              }
            }
            return result2;
          }
        };
        Color.prototype.spaces = {
          rgb: ["red", "green", "blue"],
          hsl: ["hue", "saturation", "lightness"],
          hsv: ["hue", "saturation", "value"],
          hwb: ["hue", "whiteness", "blackness"],
          cmyk: ["cyan", "magenta", "yellow", "black"]
        };
        Color.prototype.maxes = {
          rgb: [255, 255, 255],
          hsl: [360, 100, 100],
          hsv: [360, 100, 100],
          hwb: [360, 100, 100],
          cmyk: [100, 100, 100, 100]
        };
        Color.prototype.getValues = function(space) {
          var values2 = this.values;
          var vals = {};
          for (var i = 0; i < space.length; i++) {
            vals[space.charAt(i)] = values2[space][i];
          }
          if (values2.alpha !== 1) {
            vals.a = values2.alpha;
          }
          return vals;
        };
        Color.prototype.setValues = function(space, vals) {
          var values2 = this.values;
          var spaces = this.spaces;
          var maxes = this.maxes;
          var alpha = 1;
          var i;
          this.valid = true;
          if (space === "alpha") {
            alpha = vals;
          } else if (vals.length) {
            values2[space] = vals.slice(0, space.length);
            alpha = vals[space.length];
          } else if (vals[space.charAt(0)] !== void 0) {
            for (i = 0; i < space.length; i++) {
              values2[space][i] = vals[space.charAt(i)];
            }
            alpha = vals.a;
          } else if (vals[spaces[space][0]] !== void 0) {
            var chans = spaces[space];
            for (i = 0; i < space.length; i++) {
              values2[space][i] = vals[chans[i]];
            }
            alpha = vals.alpha;
          }
          values2.alpha = Math.max(0, Math.min(1, alpha === void 0 ? values2.alpha : alpha));
          if (space === "alpha") {
            return false;
          }
          var capped;
          for (i = 0; i < space.length; i++) {
            capped = Math.max(0, Math.min(maxes[space][i], values2[space][i]));
            values2[space][i] = Math.round(capped);
          }
          for (var sname in spaces) {
            if (sname !== space) {
              values2[sname] = colorConvert[space][sname](values2[space]);
            }
          }
          return true;
        };
        Color.prototype.setSpace = function(space, args) {
          var vals = args[0];
          if (vals === void 0) {
            return this.getValues(space);
          }
          if (typeof vals === "number") {
            vals = Array.prototype.slice.call(args);
          }
          this.setValues(space, vals);
          return this;
        };
        Color.prototype.setChannel = function(space, index2, val) {
          var svalues = this.values[space];
          if (val === void 0) {
            return svalues[index2];
          } else if (val === svalues[index2]) {
            return this;
          }
          svalues[index2] = val;
          this.setValues(space, svalues);
          return this;
        };
        if (typeof window !== "undefined") {
          window.Color = Color;
        }
        var chartjsColor = Color;
        function isValidKey(key) {
          return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
        }
        var helpers = {
          noop: function() {
          },
          uid: function() {
            var id2 = 0;
            return function() {
              return id2++;
            };
          }(),
          isNullOrUndef: function(value2) {
            return value2 === null || typeof value2 === "undefined";
          },
          isArray: function(value2) {
            if (Array.isArray && Array.isArray(value2)) {
              return true;
            }
            var type = Object.prototype.toString.call(value2);
            if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
              return true;
            }
            return false;
          },
          isObject: function(value2) {
            return value2 !== null && Object.prototype.toString.call(value2) === "[object Object]";
          },
          isFinite: function(value2) {
            return (typeof value2 === "number" || value2 instanceof Number) && isFinite(value2);
          },
          valueOrDefault: function(value2, defaultValue2) {
            return typeof value2 === "undefined" ? defaultValue2 : value2;
          },
          valueAtIndexOrDefault: function(value2, index2, defaultValue2) {
            return helpers.valueOrDefault(helpers.isArray(value2) ? value2[index2] : value2, defaultValue2);
          },
          callback: function(fn, args, thisArg) {
            if (fn && typeof fn.call === "function") {
              return fn.apply(thisArg, args);
            }
          },
          each: function(loopable, fn, thisArg, reverse) {
            var i, len, keys2;
            if (helpers.isArray(loopable)) {
              len = loopable.length;
              if (reverse) {
                for (i = len - 1; i >= 0; i--) {
                  fn.call(thisArg, loopable[i], i);
                }
              } else {
                for (i = 0; i < len; i++) {
                  fn.call(thisArg, loopable[i], i);
                }
              }
            } else if (helpers.isObject(loopable)) {
              keys2 = Object.keys(loopable);
              len = keys2.length;
              for (i = 0; i < len; i++) {
                fn.call(thisArg, loopable[keys2[i]], keys2[i]);
              }
            }
          },
          arrayEquals: function(a0, a1) {
            var i, ilen, v0, v1;
            if (!a0 || !a1 || a0.length !== a1.length) {
              return false;
            }
            for (i = 0, ilen = a0.length; i < ilen; ++i) {
              v0 = a0[i];
              v1 = a1[i];
              if (v0 instanceof Array && v1 instanceof Array) {
                if (!helpers.arrayEquals(v0, v1)) {
                  return false;
                }
              } else if (v0 !== v1) {
                return false;
              }
            }
            return true;
          },
          clone: function(source) {
            if (helpers.isArray(source)) {
              return source.map(helpers.clone);
            }
            if (helpers.isObject(source)) {
              var target = Object.create(source);
              var keys2 = Object.keys(source);
              var klen = keys2.length;
              var k2 = 0;
              for (; k2 < klen; ++k2) {
                target[keys2[k2]] = helpers.clone(source[keys2[k2]]);
              }
              return target;
            }
            return source;
          },
          _merger: function(key, target, source, options2) {
            if (!isValidKey(key)) {
              return;
            }
            var tval = target[key];
            var sval = source[key];
            if (helpers.isObject(tval) && helpers.isObject(sval)) {
              helpers.merge(tval, sval, options2);
            } else {
              target[key] = helpers.clone(sval);
            }
          },
          _mergerIf: function(key, target, source) {
            if (!isValidKey(key)) {
              return;
            }
            var tval = target[key];
            var sval = source[key];
            if (helpers.isObject(tval) && helpers.isObject(sval)) {
              helpers.mergeIf(tval, sval);
            } else if (!target.hasOwnProperty(key)) {
              target[key] = helpers.clone(sval);
            }
          },
          merge: function(target, source, options2) {
            var sources = helpers.isArray(source) ? source : [source];
            var ilen = sources.length;
            var merge2, i, keys2, klen, k2;
            if (!helpers.isObject(target)) {
              return target;
            }
            options2 = options2 || {};
            merge2 = options2.merger || helpers._merger;
            for (i = 0; i < ilen; ++i) {
              source = sources[i];
              if (!helpers.isObject(source)) {
                continue;
              }
              keys2 = Object.keys(source);
              for (k2 = 0, klen = keys2.length; k2 < klen; ++k2) {
                merge2(keys2[k2], target, source, options2);
              }
            }
            return target;
          },
          mergeIf: function(target, source) {
            return helpers.merge(target, source, { merger: helpers._mergerIf });
          },
          extend: Object.assign || function(target) {
            return helpers.merge(target, [].slice.call(arguments, 1), {
              merger: function(key, dst, src2) {
                dst[key] = src2[key];
              }
            });
          },
          inherits: function(extensions) {
            var me2 = this;
            var ChartElement = extensions && extensions.hasOwnProperty("constructor") ? extensions.constructor : function() {
              return me2.apply(this, arguments);
            };
            var Surrogate = function() {
              this.constructor = ChartElement;
            };
            Surrogate.prototype = me2.prototype;
            ChartElement.prototype = new Surrogate();
            ChartElement.extend = helpers.inherits;
            if (extensions) {
              helpers.extend(ChartElement.prototype, extensions);
            }
            ChartElement.__super__ = me2.prototype;
            return ChartElement;
          },
          _deprecated: function(scope, value2, previous, current) {
            if (value2 !== void 0) {
              console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
            }
          }
        };
        var helpers_core = helpers;
        helpers.callCallback = helpers.callback;
        helpers.indexOf = function(array, item, fromIndex) {
          return Array.prototype.indexOf.call(array, item, fromIndex);
        };
        helpers.getValueOrDefault = helpers.valueOrDefault;
        helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
        var effects = {
          linear: function(t2) {
            return t2;
          },
          easeInQuad: function(t2) {
            return t2 * t2;
          },
          easeOutQuad: function(t2) {
            return -t2 * (t2 - 2);
          },
          easeInOutQuad: function(t2) {
            if ((t2 /= 0.5) < 1) {
              return 0.5 * t2 * t2;
            }
            return -0.5 * (--t2 * (t2 - 2) - 1);
          },
          easeInCubic: function(t2) {
            return t2 * t2 * t2;
          },
          easeOutCubic: function(t2) {
            return (t2 = t2 - 1) * t2 * t2 + 1;
          },
          easeInOutCubic: function(t2) {
            if ((t2 /= 0.5) < 1) {
              return 0.5 * t2 * t2 * t2;
            }
            return 0.5 * ((t2 -= 2) * t2 * t2 + 2);
          },
          easeInQuart: function(t2) {
            return t2 * t2 * t2 * t2;
          },
          easeOutQuart: function(t2) {
            return -((t2 = t2 - 1) * t2 * t2 * t2 - 1);
          },
          easeInOutQuart: function(t2) {
            if ((t2 /= 0.5) < 1) {
              return 0.5 * t2 * t2 * t2 * t2;
            }
            return -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2);
          },
          easeInQuint: function(t2) {
            return t2 * t2 * t2 * t2 * t2;
          },
          easeOutQuint: function(t2) {
            return (t2 = t2 - 1) * t2 * t2 * t2 * t2 + 1;
          },
          easeInOutQuint: function(t2) {
            if ((t2 /= 0.5) < 1) {
              return 0.5 * t2 * t2 * t2 * t2 * t2;
            }
            return 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2);
          },
          easeInSine: function(t2) {
            return -Math.cos(t2 * (Math.PI / 2)) + 1;
          },
          easeOutSine: function(t2) {
            return Math.sin(t2 * (Math.PI / 2));
          },
          easeInOutSine: function(t2) {
            return -0.5 * (Math.cos(Math.PI * t2) - 1);
          },
          easeInExpo: function(t2) {
            return t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1));
          },
          easeOutExpo: function(t2) {
            return t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1;
          },
          easeInOutExpo: function(t2) {
            if (t2 === 0) {
              return 0;
            }
            if (t2 === 1) {
              return 1;
            }
            if ((t2 /= 0.5) < 1) {
              return 0.5 * Math.pow(2, 10 * (t2 - 1));
            }
            return 0.5 * (-Math.pow(2, -10 * --t2) + 2);
          },
          easeInCirc: function(t2) {
            if (t2 >= 1) {
              return t2;
            }
            return -(Math.sqrt(1 - t2 * t2) - 1);
          },
          easeOutCirc: function(t2) {
            return Math.sqrt(1 - (t2 = t2 - 1) * t2);
          },
          easeInOutCirc: function(t2) {
            if ((t2 /= 0.5) < 1) {
              return -0.5 * (Math.sqrt(1 - t2 * t2) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1);
          },
          easeInElastic: function(t2) {
            var s = 1.70158;
            var p2 = 0;
            var a = 1;
            if (t2 === 0) {
              return 0;
            }
            if (t2 === 1) {
              return 1;
            }
            if (!p2) {
              p2 = 0.3;
            }
            {
              s = p2 / (2 * Math.PI) * Math.asin(1 / a);
            }
            return -(a * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s) * (2 * Math.PI) / p2));
          },
          easeOutElastic: function(t2) {
            var s = 1.70158;
            var p2 = 0;
            var a = 1;
            if (t2 === 0) {
              return 0;
            }
            if (t2 === 1) {
              return 1;
            }
            if (!p2) {
              p2 = 0.3;
            }
            {
              s = p2 / (2 * Math.PI) * Math.asin(1 / a);
            }
            return a * Math.pow(2, -10 * t2) * Math.sin((t2 - s) * (2 * Math.PI) / p2) + 1;
          },
          easeInOutElastic: function(t2) {
            var s = 1.70158;
            var p2 = 0;
            var a = 1;
            if (t2 === 0) {
              return 0;
            }
            if ((t2 /= 0.5) === 2) {
              return 1;
            }
            if (!p2) {
              p2 = 0.45;
            }
            {
              s = p2 / (2 * Math.PI) * Math.asin(1 / a);
            }
            if (t2 < 1) {
              return -0.5 * (a * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s) * (2 * Math.PI) / p2));
            }
            return a * Math.pow(2, -10 * (t2 -= 1)) * Math.sin((t2 - s) * (2 * Math.PI) / p2) * 0.5 + 1;
          },
          easeInBack: function(t2) {
            var s = 1.70158;
            return t2 * t2 * ((s + 1) * t2 - s);
          },
          easeOutBack: function(t2) {
            var s = 1.70158;
            return (t2 = t2 - 1) * t2 * ((s + 1) * t2 + s) + 1;
          },
          easeInOutBack: function(t2) {
            var s = 1.70158;
            if ((t2 /= 0.5) < 1) {
              return 0.5 * (t2 * t2 * (((s *= 1.525) + 1) * t2 - s));
            }
            return 0.5 * ((t2 -= 2) * t2 * (((s *= 1.525) + 1) * t2 + s) + 2);
          },
          easeInBounce: function(t2) {
            return 1 - effects.easeOutBounce(1 - t2);
          },
          easeOutBounce: function(t2) {
            if (t2 < 1 / 2.75) {
              return 7.5625 * t2 * t2;
            }
            if (t2 < 2 / 2.75) {
              return 7.5625 * (t2 -= 1.5 / 2.75) * t2 + 0.75;
            }
            if (t2 < 2.5 / 2.75) {
              return 7.5625 * (t2 -= 2.25 / 2.75) * t2 + 0.9375;
            }
            return 7.5625 * (t2 -= 2.625 / 2.75) * t2 + 0.984375;
          },
          easeInOutBounce: function(t2) {
            if (t2 < 0.5) {
              return effects.easeInBounce(t2 * 2) * 0.5;
            }
            return effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5;
          }
        };
        var helpers_easing = {
          effects
        };
        helpers_core.easingEffects = effects;
        var PI = Math.PI;
        var RAD_PER_DEG = PI / 180;
        var DOUBLE_PI = PI * 2;
        var HALF_PI = PI / 2;
        var QUARTER_PI = PI / 4;
        var TWO_THIRDS_PI = PI * 2 / 3;
        var exports$1 = {
          clear: function(chart) {
            chart.ctx.clearRect(0, 0, chart.width, chart.height);
          },
          roundedRect: function(ctx, x2, y2, width2, height2, radius) {
            if (radius) {
              var r2 = Math.min(radius, height2 / 2, width2 / 2);
              var left = x2 + r2;
              var top = y2 + r2;
              var right = x2 + width2 - r2;
              var bottom = y2 + height2 - r2;
              ctx.moveTo(x2, top);
              if (left < right && top < bottom) {
                ctx.arc(left, top, r2, -PI, -HALF_PI);
                ctx.arc(right, top, r2, -HALF_PI, 0);
                ctx.arc(right, bottom, r2, 0, HALF_PI);
                ctx.arc(left, bottom, r2, HALF_PI, PI);
              } else if (left < right) {
                ctx.moveTo(left, y2);
                ctx.arc(right, top, r2, -HALF_PI, HALF_PI);
                ctx.arc(left, top, r2, HALF_PI, PI + HALF_PI);
              } else if (top < bottom) {
                ctx.arc(left, top, r2, -PI, 0);
                ctx.arc(left, bottom, r2, 0, PI);
              } else {
                ctx.arc(left, top, r2, -PI, PI);
              }
              ctx.closePath();
              ctx.moveTo(x2, y2);
            } else {
              ctx.rect(x2, y2, width2, height2);
            }
          },
          drawPoint: function(ctx, style, radius, x2, y2, rotation) {
            var type, xOffset, yOffset, size2, cornerRadius;
            var rad = (rotation || 0) * RAD_PER_DEG;
            if (style && typeof style === "object") {
              type = style.toString();
              if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
                ctx.save();
                ctx.translate(x2, y2);
                ctx.rotate(rad);
                ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
                ctx.restore();
                return;
              }
            }
            if (isNaN(radius) || radius <= 0) {
              return;
            }
            ctx.beginPath();
            switch (style) {
              default:
                ctx.arc(x2, y2, radius, 0, DOUBLE_PI);
                ctx.closePath();
                break;
              case "triangle":
                ctx.moveTo(x2 + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x2 + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x2 + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
                ctx.closePath();
                break;
              case "rectRounded":
                cornerRadius = radius * 0.516;
                size2 = radius - cornerRadius;
                xOffset = Math.cos(rad + QUARTER_PI) * size2;
                yOffset = Math.sin(rad + QUARTER_PI) * size2;
                ctx.arc(x2 - xOffset, y2 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
                ctx.arc(x2 + yOffset, y2 - xOffset, cornerRadius, rad - HALF_PI, rad);
                ctx.arc(x2 + xOffset, y2 + yOffset, cornerRadius, rad, rad + HALF_PI);
                ctx.arc(x2 - yOffset, y2 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
                ctx.closePath();
                break;
              case "rect":
                if (!rotation) {
                  size2 = Math.SQRT1_2 * radius;
                  ctx.rect(x2 - size2, y2 - size2, 2 * size2, 2 * size2);
                  break;
                }
                rad += QUARTER_PI;
              case "rectRot":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x2 - xOffset, y2 - yOffset);
                ctx.lineTo(x2 + yOffset, y2 - xOffset);
                ctx.lineTo(x2 + xOffset, y2 + yOffset);
                ctx.lineTo(x2 - yOffset, y2 + xOffset);
                ctx.closePath();
                break;
              case "crossRot":
                rad += QUARTER_PI;
              case "cross":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x2 - xOffset, y2 - yOffset);
                ctx.lineTo(x2 + xOffset, y2 + yOffset);
                ctx.moveTo(x2 + yOffset, y2 - xOffset);
                ctx.lineTo(x2 - yOffset, y2 + xOffset);
                break;
              case "star":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x2 - xOffset, y2 - yOffset);
                ctx.lineTo(x2 + xOffset, y2 + yOffset);
                ctx.moveTo(x2 + yOffset, y2 - xOffset);
                ctx.lineTo(x2 - yOffset, y2 + xOffset);
                rad += QUARTER_PI;
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x2 - xOffset, y2 - yOffset);
                ctx.lineTo(x2 + xOffset, y2 + yOffset);
                ctx.moveTo(x2 + yOffset, y2 - xOffset);
                ctx.lineTo(x2 - yOffset, y2 + xOffset);
                break;
              case "line":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x2 - xOffset, y2 - yOffset);
                ctx.lineTo(x2 + xOffset, y2 + yOffset);
                break;
              case "dash":
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 + Math.cos(rad) * radius, y2 + Math.sin(rad) * radius);
                break;
            }
            ctx.fill();
            ctx.stroke();
          },
          _isPointInArea: function(point, area2) {
            var epsilon = 1e-6;
            return point.x > area2.left - epsilon && point.x < area2.right + epsilon && point.y > area2.top - epsilon && point.y < area2.bottom + epsilon;
          },
          clipArea: function(ctx, area2) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(area2.left, area2.top, area2.right - area2.left, area2.bottom - area2.top);
            ctx.clip();
          },
          unclipArea: function(ctx) {
            ctx.restore();
          },
          lineTo: function(ctx, previous, target, flip) {
            var stepped = target.steppedLine;
            if (stepped) {
              if (stepped === "middle") {
                var midpoint = (previous.x + target.x) / 2;
                ctx.lineTo(midpoint, flip ? target.y : previous.y);
                ctx.lineTo(midpoint, flip ? previous.y : target.y);
              } else if (stepped === "after" && !flip || stepped !== "after" && flip) {
                ctx.lineTo(previous.x, target.y);
              } else {
                ctx.lineTo(target.x, previous.y);
              }
              ctx.lineTo(target.x, target.y);
              return;
            }
            if (!target.tension) {
              ctx.lineTo(target.x, target.y);
              return;
            }
            ctx.bezierCurveTo(
              flip ? previous.controlPointPreviousX : previous.controlPointNextX,
              flip ? previous.controlPointPreviousY : previous.controlPointNextY,
              flip ? target.controlPointNextX : target.controlPointPreviousX,
              flip ? target.controlPointNextY : target.controlPointPreviousY,
              target.x,
              target.y
            );
          }
        };
        var helpers_canvas = exports$1;
        helpers_core.clear = exports$1.clear;
        helpers_core.drawRoundedRectangle = function(ctx) {
          ctx.beginPath();
          exports$1.roundedRect.apply(exports$1, arguments);
        };
        var defaults2 = {
          _set: function(scope, values2) {
            return helpers_core.merge(this[scope] || (this[scope] = {}), values2);
          }
        };
        defaults2._set("global", {
          defaultColor: "rgba(0,0,0,0.1)",
          defaultFontColor: "#666",
          defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
          defaultFontSize: 12,
          defaultFontStyle: "normal",
          defaultLineHeight: 1.2,
          showLines: true
        });
        var core_defaults = defaults2;
        var valueOrDefault = helpers_core.valueOrDefault;
        function toFontString(font) {
          if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
            return null;
          }
          return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        }
        var helpers_options = {
          toLineHeight: function(value2, size2) {
            var matches = ("" + value2).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
            if (!matches || matches[1] === "normal") {
              return size2 * 1.2;
            }
            value2 = +matches[2];
            switch (matches[3]) {
              case "px":
                return value2;
              case "%":
                value2 /= 100;
                break;
            }
            return size2 * value2;
          },
          toPadding: function(value2) {
            var t2, r2, b, l2;
            if (helpers_core.isObject(value2)) {
              t2 = +value2.top || 0;
              r2 = +value2.right || 0;
              b = +value2.bottom || 0;
              l2 = +value2.left || 0;
            } else {
              t2 = r2 = b = l2 = +value2 || 0;
            }
            return {
              top: t2,
              right: r2,
              bottom: b,
              left: l2,
              height: t2 + b,
              width: l2 + r2
            };
          },
          _parseFont: function(options2) {
            var globalDefaults = core_defaults.global;
            var size2 = valueOrDefault(options2.fontSize, globalDefaults.defaultFontSize);
            var font = {
              family: valueOrDefault(options2.fontFamily, globalDefaults.defaultFontFamily),
              lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options2.lineHeight, globalDefaults.defaultLineHeight), size2),
              size: size2,
              style: valueOrDefault(options2.fontStyle, globalDefaults.defaultFontStyle),
              weight: null,
              string: ""
            };
            font.string = toFontString(font);
            return font;
          },
          resolve: function(inputs, context2, index2, info) {
            var cacheable = true;
            var i, ilen, value2;
            for (i = 0, ilen = inputs.length; i < ilen; ++i) {
              value2 = inputs[i];
              if (value2 === void 0) {
                continue;
              }
              if (context2 !== void 0 && typeof value2 === "function") {
                value2 = value2(context2);
                cacheable = false;
              }
              if (index2 !== void 0 && helpers_core.isArray(value2)) {
                value2 = value2[index2];
                cacheable = false;
              }
              if (value2 !== void 0) {
                if (info && !cacheable) {
                  info.cacheable = false;
                }
                return value2;
              }
            }
          }
        };
        var exports$2 = {
          _factorize: function(value2) {
            var result2 = [];
            var sqrt = Math.sqrt(value2);
            var i;
            for (i = 1; i < sqrt; i++) {
              if (value2 % i === 0) {
                result2.push(i);
                result2.push(value2 / i);
              }
            }
            if (sqrt === (sqrt | 0)) {
              result2.push(sqrt);
            }
            result2.sort(function(a, b) {
              return a - b;
            }).pop();
            return result2;
          },
          log10: Math.log10 || function(x2) {
            var exponent = Math.log(x2) * Math.LOG10E;
            var powerOf10 = Math.round(exponent);
            var isPowerOf10 = x2 === Math.pow(10, powerOf10);
            return isPowerOf10 ? powerOf10 : exponent;
          }
        };
        var helpers_math = exports$2;
        helpers_core.log10 = exports$2.log10;
        var getRtlAdapter = function(rectX, width2) {
          return {
            x: function(x2) {
              return rectX + rectX + width2 - x2;
            },
            setWidth: function(w2) {
              width2 = w2;
            },
            textAlign: function(align) {
              if (align === "center") {
                return align;
              }
              return align === "right" ? "left" : "right";
            },
            xPlus: function(x2, value2) {
              return x2 - value2;
            },
            leftForLtr: function(x2, itemWidth) {
              return x2 - itemWidth;
            }
          };
        };
        var getLtrAdapter = function() {
          return {
            x: function(x2) {
              return x2;
            },
            setWidth: function(w2) {
            },
            textAlign: function(align) {
              return align;
            },
            xPlus: function(x2, value2) {
              return x2 + value2;
            },
            leftForLtr: function(x2, _itemWidth) {
              return x2;
            }
          };
        };
        var getAdapter = function(rtl2, rectX, width2) {
          return rtl2 ? getRtlAdapter(rectX, width2) : getLtrAdapter();
        };
        var overrideTextDirection = function(ctx, direction) {
          var style, original;
          if (direction === "ltr" || direction === "rtl") {
            style = ctx.canvas.style;
            original = [
              style.getPropertyValue("direction"),
              style.getPropertyPriority("direction")
            ];
            style.setProperty("direction", direction, "important");
            ctx.prevTextDirection = original;
          }
        };
        var restoreTextDirection = function(ctx) {
          var original = ctx.prevTextDirection;
          if (original !== void 0) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty("direction", original[0], original[1]);
          }
        };
        var helpers_rtl = {
          getRtlAdapter: getAdapter,
          overrideTextDirection,
          restoreTextDirection
        };
        var helpers$1 = helpers_core;
        var easing = helpers_easing;
        var canvas2 = helpers_canvas;
        var options = helpers_options;
        var math = helpers_math;
        var rtl = helpers_rtl;
        helpers$1.easing = easing;
        helpers$1.canvas = canvas2;
        helpers$1.options = options;
        helpers$1.math = math;
        helpers$1.rtl = rtl;
        function interpolate(start, view, model, ease) {
          var keys2 = Object.keys(model);
          var i, ilen, key, actual, origin, target, type, c0, c1;
          for (i = 0, ilen = keys2.length; i < ilen; ++i) {
            key = keys2[i];
            target = model[key];
            if (!view.hasOwnProperty(key)) {
              view[key] = target;
            }
            actual = view[key];
            if (actual === target || key[0] === "_") {
              continue;
            }
            if (!start.hasOwnProperty(key)) {
              start[key] = actual;
            }
            origin = start[key];
            type = typeof target;
            if (type === typeof origin) {
              if (type === "string") {
                c0 = chartjsColor(origin);
                if (c0.valid) {
                  c1 = chartjsColor(target);
                  if (c1.valid) {
                    view[key] = c1.mix(c0, ease).rgbString();
                    continue;
                  }
                }
              } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
                view[key] = origin + (target - origin) * ease;
                continue;
              }
            }
            view[key] = target;
          }
        }
        var Element = function(configuration) {
          helpers$1.extend(this, configuration);
          this.initialize.apply(this, arguments);
        };
        helpers$1.extend(Element.prototype, {
          _type: void 0,
          initialize: function() {
            this.hidden = false;
          },
          pivot: function() {
            var me2 = this;
            if (!me2._view) {
              me2._view = helpers$1.extend({}, me2._model);
            }
            me2._start = {};
            return me2;
          },
          transition: function(ease) {
            var me2 = this;
            var model = me2._model;
            var start = me2._start;
            var view = me2._view;
            if (!model || ease === 1) {
              me2._view = helpers$1.extend({}, model);
              me2._start = null;
              return me2;
            }
            if (!view) {
              view = me2._view = {};
            }
            if (!start) {
              start = me2._start = {};
            }
            interpolate(start, view, model, ease);
            return me2;
          },
          tooltipPosition: function() {
            return {
              x: this._model.x,
              y: this._model.y
            };
          },
          hasValue: function() {
            return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
          }
        });
        Element.extend = helpers$1.inherits;
        var core_element = Element;
        var exports$3 = core_element.extend({
          chart: null,
          currentStep: 0,
          numSteps: 60,
          easing: "",
          render: null,
          onAnimationProgress: null,
          onAnimationComplete: null
        });
        var core_animation = exports$3;
        Object.defineProperty(exports$3.prototype, "animationObject", {
          get: function() {
            return this;
          }
        });
        Object.defineProperty(exports$3.prototype, "chartInstance", {
          get: function() {
            return this.chart;
          },
          set: function(value2) {
            this.chart = value2;
          }
        });
        core_defaults._set("global", {
          animation: {
            duration: 1e3,
            easing: "easeOutQuart",
            onProgress: helpers$1.noop,
            onComplete: helpers$1.noop
          }
        });
        var core_animations = {
          animations: [],
          request: null,
          addAnimation: function(chart, animation, duration, lazy) {
            var animations = this.animations;
            var i, ilen;
            animation.chart = chart;
            animation.startTime = Date.now();
            animation.duration = duration;
            if (!lazy) {
              chart.animating = true;
            }
            for (i = 0, ilen = animations.length; i < ilen; ++i) {
              if (animations[i].chart === chart) {
                animations[i] = animation;
                return;
              }
            }
            animations.push(animation);
            if (animations.length === 1) {
              this.requestAnimationFrame();
            }
          },
          cancelAnimation: function(chart) {
            var index2 = helpers$1.findIndex(this.animations, function(animation) {
              return animation.chart === chart;
            });
            if (index2 !== -1) {
              this.animations.splice(index2, 1);
              chart.animating = false;
            }
          },
          requestAnimationFrame: function() {
            var me2 = this;
            if (me2.request === null) {
              me2.request = helpers$1.requestAnimFrame.call(window, function() {
                me2.request = null;
                me2.startDigest();
              });
            }
          },
          startDigest: function() {
            var me2 = this;
            me2.advance();
            if (me2.animations.length > 0) {
              me2.requestAnimationFrame();
            }
          },
          advance: function() {
            var animations = this.animations;
            var animation, chart, numSteps, nextStep;
            var i = 0;
            while (i < animations.length) {
              animation = animations[i];
              chart = animation.chart;
              numSteps = animation.numSteps;
              nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
              animation.currentStep = Math.min(nextStep, numSteps);
              helpers$1.callback(animation.render, [chart, animation], chart);
              helpers$1.callback(animation.onAnimationProgress, [animation], chart);
              if (animation.currentStep >= numSteps) {
                helpers$1.callback(animation.onAnimationComplete, [animation], chart);
                chart.animating = false;
                animations.splice(i, 1);
              } else {
                ++i;
              }
            }
          }
        };
        var resolve = helpers$1.options.resolve;
        var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
        function listenArrayEvents(array, listener) {
          if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
          }
          Object.defineProperty(array, "_chartjs", {
            configurable: true,
            enumerable: false,
            value: {
              listeners: [listener]
            }
          });
          arrayEvents.forEach(function(key) {
            var method = "onData" + key.charAt(0).toUpperCase() + key.slice(1);
            var base = array[key];
            Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value: function() {
                var args = Array.prototype.slice.call(arguments);
                var res = base.apply(this, args);
                helpers$1.each(array._chartjs.listeners, function(object2) {
                  if (typeof object2[method] === "function") {
                    object2[method].apply(object2, args);
                  }
                });
                return res;
              }
            });
          });
        }
        function unlistenArrayEvents(array, listener) {
          var stub = array._chartjs;
          if (!stub) {
            return;
          }
          var listeners = stub.listeners;
          var index2 = listeners.indexOf(listener);
          if (index2 !== -1) {
            listeners.splice(index2, 1);
          }
          if (listeners.length > 0) {
            return;
          }
          arrayEvents.forEach(function(key) {
            delete array[key];
          });
          delete array._chartjs;
        }
        var DatasetController = function(chart, datasetIndex) {
          this.initialize(chart, datasetIndex);
        };
        helpers$1.extend(DatasetController.prototype, {
          datasetElementType: null,
          dataElementType: null,
          _datasetElementOptions: [
            "backgroundColor",
            "borderCapStyle",
            "borderColor",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "borderWidth"
          ],
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "pointStyle"
          ],
          initialize: function(chart, datasetIndex) {
            var me2 = this;
            me2.chart = chart;
            me2.index = datasetIndex;
            me2.linkScales();
            me2.addElements();
            me2._type = me2.getMeta().type;
          },
          updateIndex: function(datasetIndex) {
            this.index = datasetIndex;
          },
          linkScales: function() {
            var me2 = this;
            var meta = me2.getMeta();
            var chart = me2.chart;
            var scales2 = chart.scales;
            var dataset = me2.getDataset();
            var scalesOpts = chart.options.scales;
            if (meta.xAxisID === null || !(meta.xAxisID in scales2) || dataset.xAxisID) {
              meta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;
            }
            if (meta.yAxisID === null || !(meta.yAxisID in scales2) || dataset.yAxisID) {
              meta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;
            }
          },
          getDataset: function() {
            return this.chart.data.datasets[this.index];
          },
          getMeta: function() {
            return this.chart.getDatasetMeta(this.index);
          },
          getScaleForId: function(scaleID) {
            return this.chart.scales[scaleID];
          },
          _getValueScaleId: function() {
            return this.getMeta().yAxisID;
          },
          _getIndexScaleId: function() {
            return this.getMeta().xAxisID;
          },
          _getValueScale: function() {
            return this.getScaleForId(this._getValueScaleId());
          },
          _getIndexScale: function() {
            return this.getScaleForId(this._getIndexScaleId());
          },
          reset: function() {
            this._update(true);
          },
          destroy: function() {
            if (this._data) {
              unlistenArrayEvents(this._data, this);
            }
          },
          createMetaDataset: function() {
            var me2 = this;
            var type = me2.datasetElementType;
            return type && new type({
              _chart: me2.chart,
              _datasetIndex: me2.index
            });
          },
          createMetaData: function(index2) {
            var me2 = this;
            var type = me2.dataElementType;
            return type && new type({
              _chart: me2.chart,
              _datasetIndex: me2.index,
              _index: index2
            });
          },
          addElements: function() {
            var me2 = this;
            var meta = me2.getMeta();
            var data = me2.getDataset().data || [];
            var metaData = meta.data;
            var i, ilen;
            for (i = 0, ilen = data.length; i < ilen; ++i) {
              metaData[i] = metaData[i] || me2.createMetaData(i);
            }
            meta.dataset = meta.dataset || me2.createMetaDataset();
          },
          addElementAndReset: function(index2) {
            var element = this.createMetaData(index2);
            this.getMeta().data.splice(index2, 0, element);
            this.updateElement(element, index2, true);
          },
          buildOrUpdateElements: function() {
            var me2 = this;
            var dataset = me2.getDataset();
            var data = dataset.data || (dataset.data = []);
            if (me2._data !== data) {
              if (me2._data) {
                unlistenArrayEvents(me2._data, me2);
              }
              if (data && Object.isExtensible(data)) {
                listenArrayEvents(data, me2);
              }
              me2._data = data;
            }
            me2.resyncElements();
          },
          _configure: function() {
            var me2 = this;
            me2._config = helpers$1.merge(/* @__PURE__ */ Object.create(null), [
              me2.chart.options.datasets[me2._type],
              me2.getDataset()
            ], {
              merger: function(key, target, source) {
                if (key !== "_meta" && key !== "data") {
                  helpers$1._merger(key, target, source);
                }
              }
            });
          },
          _update: function(reset) {
            var me2 = this;
            me2._configure();
            me2._cachedDataOpts = null;
            me2.update(reset);
          },
          update: helpers$1.noop,
          transition: function(easingValue) {
            var meta = this.getMeta();
            var elements2 = meta.data || [];
            var ilen = elements2.length;
            var i = 0;
            for (; i < ilen; ++i) {
              elements2[i].transition(easingValue);
            }
            if (meta.dataset) {
              meta.dataset.transition(easingValue);
            }
          },
          draw: function() {
            var meta = this.getMeta();
            var elements2 = meta.data || [];
            var ilen = elements2.length;
            var i = 0;
            if (meta.dataset) {
              meta.dataset.draw();
            }
            for (; i < ilen; ++i) {
              elements2[i].draw();
            }
          },
          getStyle: function(index2) {
            var me2 = this;
            var meta = me2.getMeta();
            var dataset = meta.dataset;
            var style;
            me2._configure();
            if (dataset && index2 === void 0) {
              style = me2._resolveDatasetElementOptions(dataset || {});
            } else {
              index2 = index2 || 0;
              style = me2._resolveDataElementOptions(meta.data[index2] || {}, index2);
            }
            if (style.fill === false || style.fill === null) {
              style.backgroundColor = style.borderColor;
            }
            return style;
          },
          _resolveDatasetElementOptions: function(element, hover) {
            var me2 = this;
            var chart = me2.chart;
            var datasetOpts = me2._config;
            var custom = element.custom || {};
            var options2 = chart.options.elements[me2.datasetElementType.prototype._type] || {};
            var elementOptions = me2._datasetElementOptions;
            var values2 = {};
            var i, ilen, key, readKey;
            var context2 = {
              chart,
              dataset: me2.getDataset(),
              datasetIndex: me2.index,
              hover
            };
            for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
              key = elementOptions[i];
              readKey = hover ? "hover" + key.charAt(0).toUpperCase() + key.slice(1) : key;
              values2[key] = resolve([
                custom[readKey],
                datasetOpts[readKey],
                options2[readKey]
              ], context2);
            }
            return values2;
          },
          _resolveDataElementOptions: function(element, index2) {
            var me2 = this;
            var custom = element && element.custom;
            var cached = me2._cachedDataOpts;
            if (cached && !custom) {
              return cached;
            }
            var chart = me2.chart;
            var datasetOpts = me2._config;
            var options2 = chart.options.elements[me2.dataElementType.prototype._type] || {};
            var elementOptions = me2._dataElementOptions;
            var values2 = {};
            var context2 = {
              chart,
              dataIndex: index2,
              dataset: me2.getDataset(),
              datasetIndex: me2.index
            };
            var info = { cacheable: !custom };
            var keys2, i, ilen, key;
            custom = custom || {};
            if (helpers$1.isArray(elementOptions)) {
              for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
                key = elementOptions[i];
                values2[key] = resolve([
                  custom[key],
                  datasetOpts[key],
                  options2[key]
                ], context2, index2, info);
              }
            } else {
              keys2 = Object.keys(elementOptions);
              for (i = 0, ilen = keys2.length; i < ilen; ++i) {
                key = keys2[i];
                values2[key] = resolve([
                  custom[key],
                  datasetOpts[elementOptions[key]],
                  datasetOpts[key],
                  options2[key]
                ], context2, index2, info);
              }
            }
            if (info.cacheable) {
              me2._cachedDataOpts = Object.freeze(values2);
            }
            return values2;
          },
          removeHoverStyle: function(element) {
            helpers$1.merge(element._model, element.$previousStyle || {});
            delete element.$previousStyle;
          },
          setHoverStyle: function(element) {
            var dataset = this.chart.data.datasets[element._datasetIndex];
            var index2 = element._index;
            var custom = element.custom || {};
            var model = element._model;
            var getHoverColor = helpers$1.getHoverColor;
            element.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], void 0, index2);
            model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], void 0, index2);
            model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], void 0, index2);
          },
          _removeDatasetHoverStyle: function() {
            var element = this.getMeta().dataset;
            if (element) {
              this.removeHoverStyle(element);
            }
          },
          _setDatasetHoverStyle: function() {
            var element = this.getMeta().dataset;
            var prev = {};
            var i, ilen, key, keys2, hoverOptions, model;
            if (!element) {
              return;
            }
            model = element._model;
            hoverOptions = this._resolveDatasetElementOptions(element, true);
            keys2 = Object.keys(hoverOptions);
            for (i = 0, ilen = keys2.length; i < ilen; ++i) {
              key = keys2[i];
              prev[key] = model[key];
              model[key] = hoverOptions[key];
            }
            element.$previousStyle = prev;
          },
          resyncElements: function() {
            var me2 = this;
            var meta = me2.getMeta();
            var data = me2.getDataset().data;
            var numMeta = meta.data.length;
            var numData = data.length;
            if (numData < numMeta) {
              meta.data.splice(numData, numMeta - numData);
            } else if (numData > numMeta) {
              me2.insertElements(numMeta, numData - numMeta);
            }
          },
          insertElements: function(start, count) {
            for (var i = 0; i < count; ++i) {
              this.addElementAndReset(start + i);
            }
          },
          onDataPush: function() {
            var count = arguments.length;
            this.insertElements(this.getDataset().data.length - count, count);
          },
          onDataPop: function() {
            this.getMeta().data.pop();
          },
          onDataShift: function() {
            this.getMeta().data.shift();
          },
          onDataSplice: function(start, count) {
            this.getMeta().data.splice(start, count);
            this.insertElements(start, arguments.length - 2);
          },
          onDataUnshift: function() {
            this.insertElements(0, arguments.length);
          }
        });
        DatasetController.extend = helpers$1.inherits;
        var core_datasetController = DatasetController;
        var TAU = Math.PI * 2;
        core_defaults._set("global", {
          elements: {
            arc: {
              backgroundColor: core_defaults.global.defaultColor,
              borderColor: "#fff",
              borderWidth: 2,
              borderAlign: "center"
            }
          }
        });
        function clipArc(ctx, arc) {
          var startAngle = arc.startAngle;
          var endAngle = arc.endAngle;
          var pixelMargin = arc.pixelMargin;
          var angleMargin = pixelMargin / arc.outerRadius;
          var x2 = arc.x;
          var y2 = arc.y;
          ctx.beginPath();
          ctx.arc(x2, y2, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);
          if (arc.innerRadius > pixelMargin) {
            angleMargin = pixelMargin / arc.innerRadius;
            ctx.arc(x2, y2, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);
          } else {
            ctx.arc(x2, y2, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);
          }
          ctx.closePath();
          ctx.clip();
        }
        function drawFullCircleBorders(ctx, vm, arc, inner) {
          var endAngle = arc.endAngle;
          var i;
          if (inner) {
            arc.endAngle = arc.startAngle + TAU;
            clipArc(ctx, arc);
            arc.endAngle = endAngle;
            if (arc.endAngle === arc.startAngle && arc.fullCircles) {
              arc.endAngle += TAU;
              arc.fullCircles--;
            }
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);
          for (i = 0; i < arc.fullCircles; ++i) {
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);
          for (i = 0; i < arc.fullCircles; ++i) {
            ctx.stroke();
          }
        }
        function drawBorder(ctx, vm, arc) {
          var inner = vm.borderAlign === "inner";
          if (inner) {
            ctx.lineWidth = vm.borderWidth * 2;
            ctx.lineJoin = "round";
          } else {
            ctx.lineWidth = vm.borderWidth;
            ctx.lineJoin = "bevel";
          }
          if (arc.fullCircles) {
            drawFullCircleBorders(ctx, vm, arc, inner);
          }
          if (inner) {
            clipArc(ctx, arc);
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);
          ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
          ctx.closePath();
          ctx.stroke();
        }
        var element_arc = core_element.extend({
          _type: "arc",
          inLabelRange: function(mouseX) {
            var vm = this._view;
            if (vm) {
              return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
            }
            return false;
          },
          inRange: function(chartX, chartY) {
            var vm = this._view;
            if (vm) {
              var pointRelativePosition = helpers$1.getAngleFromPoint(vm, { x: chartX, y: chartY });
              var angle = pointRelativePosition.angle;
              var distance = pointRelativePosition.distance;
              var startAngle = vm.startAngle;
              var endAngle = vm.endAngle;
              while (endAngle < startAngle) {
                endAngle += TAU;
              }
              while (angle > endAngle) {
                angle -= TAU;
              }
              while (angle < startAngle) {
                angle += TAU;
              }
              var betweenAngles = angle >= startAngle && angle <= endAngle;
              var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
              return betweenAngles && withinRadius;
            }
            return false;
          },
          getCenterPoint: function() {
            var vm = this._view;
            var halfAngle = (vm.startAngle + vm.endAngle) / 2;
            var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
            return {
              x: vm.x + Math.cos(halfAngle) * halfRadius,
              y: vm.y + Math.sin(halfAngle) * halfRadius
            };
          },
          getArea: function() {
            var vm = this._view;
            return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
          },
          tooltipPosition: function() {
            var vm = this._view;
            var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
            var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
            return {
              x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
              y: vm.y + Math.sin(centreAngle) * rangeFromCentre
            };
          },
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var pixelMargin = vm.borderAlign === "inner" ? 0.33 : 0;
            var arc = {
              x: vm.x,
              y: vm.y,
              innerRadius: vm.innerRadius,
              outerRadius: Math.max(vm.outerRadius - pixelMargin, 0),
              pixelMargin,
              startAngle: vm.startAngle,
              endAngle: vm.endAngle,
              fullCircles: Math.floor(vm.circumference / TAU)
            };
            var i;
            ctx.save();
            ctx.fillStyle = vm.backgroundColor;
            ctx.strokeStyle = vm.borderColor;
            if (arc.fullCircles) {
              arc.endAngle = arc.startAngle + TAU;
              ctx.beginPath();
              ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
              ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
              ctx.closePath();
              for (i = 0; i < arc.fullCircles; ++i) {
                ctx.fill();
              }
              arc.endAngle = arc.startAngle + vm.circumference % TAU;
            }
            ctx.beginPath();
            ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
            ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
            ctx.closePath();
            ctx.fill();
            if (vm.borderWidth) {
              drawBorder(ctx, vm, arc);
            }
            ctx.restore();
          }
        });
        var valueOrDefault$1 = helpers$1.valueOrDefault;
        var defaultColor = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            line: {
              tension: 0.4,
              backgroundColor: defaultColor,
              borderWidth: 3,
              borderColor: defaultColor,
              borderCapStyle: "butt",
              borderDash: [],
              borderDashOffset: 0,
              borderJoinStyle: "miter",
              capBezierPoints: true,
              fill: true
            }
          }
        });
        var element_line = core_element.extend({
          _type: "line",
          draw: function() {
            var me2 = this;
            var vm = me2._view;
            var ctx = me2._chart.ctx;
            var spanGaps = vm.spanGaps;
            var points = me2._children.slice();
            var globalDefaults = core_defaults.global;
            var globalOptionLineElements = globalDefaults.elements.line;
            var lastDrawnIndex = -1;
            var closePath = me2._loop;
            var index2, previous, currentVM;
            if (!points.length) {
              return;
            }
            if (me2._loop) {
              for (index2 = 0; index2 < points.length; ++index2) {
                previous = helpers$1.previousItem(points, index2);
                if (!points[index2]._view.skip && previous._view.skip) {
                  points = points.slice(index2).concat(points.slice(0, index2));
                  closePath = spanGaps;
                  break;
                }
              }
              if (closePath) {
                points.push(points[0]);
              }
            }
            ctx.save();
            ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
            if (ctx.setLineDash) {
              ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
            }
            ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
            ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
            ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
            ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
            ctx.beginPath();
            currentVM = points[0]._view;
            if (!currentVM.skip) {
              ctx.moveTo(currentVM.x, currentVM.y);
              lastDrawnIndex = 0;
            }
            for (index2 = 1; index2 < points.length; ++index2) {
              currentVM = points[index2]._view;
              previous = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index2) : points[lastDrawnIndex];
              if (!currentVM.skip) {
                if (lastDrawnIndex !== index2 - 1 && !spanGaps || lastDrawnIndex === -1) {
                  ctx.moveTo(currentVM.x, currentVM.y);
                } else {
                  helpers$1.canvas.lineTo(ctx, previous._view, currentVM);
                }
                lastDrawnIndex = index2;
              }
            }
            if (closePath) {
              ctx.closePath();
            }
            ctx.stroke();
            ctx.restore();
          }
        });
        var valueOrDefault$2 = helpers$1.valueOrDefault;
        var defaultColor$1 = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            point: {
              radius: 3,
              pointStyle: "circle",
              backgroundColor: defaultColor$1,
              borderColor: defaultColor$1,
              borderWidth: 1,
              hitRadius: 1,
              hoverRadius: 4,
              hoverBorderWidth: 1
            }
          }
        });
        function xRange(mouseX) {
          var vm = this._view;
          return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
        }
        function yRange(mouseY) {
          var vm = this._view;
          return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
        }
        var element_point = core_element.extend({
          _type: "point",
          inRange: function(mouseX, mouseY) {
            var vm = this._view;
            return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
          },
          inLabelRange: xRange,
          inXRange: xRange,
          inYRange: yRange,
          getCenterPoint: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y
            };
          },
          getArea: function() {
            return Math.PI * Math.pow(this._view.radius, 2);
          },
          tooltipPosition: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y,
              padding: vm.radius + vm.borderWidth
            };
          },
          draw: function(chartArea) {
            var vm = this._view;
            var ctx = this._chart.ctx;
            var pointStyle = vm.pointStyle;
            var rotation = vm.rotation;
            var radius = vm.radius;
            var x2 = vm.x;
            var y2 = vm.y;
            var globalDefaults = core_defaults.global;
            var defaultColor2 = globalDefaults.defaultColor;
            if (vm.skip) {
              return;
            }
            if (chartArea === void 0 || helpers$1.canvas._isPointInArea(vm, chartArea)) {
              ctx.strokeStyle = vm.borderColor || defaultColor2;
              ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
              ctx.fillStyle = vm.backgroundColor || defaultColor2;
              helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x2, y2, rotation);
            }
          }
        });
        var defaultColor$2 = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            rectangle: {
              backgroundColor: defaultColor$2,
              borderColor: defaultColor$2,
              borderSkipped: "bottom",
              borderWidth: 0
            }
          }
        });
        function isVertical(vm) {
          return vm && vm.width !== void 0;
        }
        function getBarBounds(vm) {
          var x1, x2, y1, y2, half;
          if (isVertical(vm)) {
            half = vm.width / 2;
            x1 = vm.x - half;
            x2 = vm.x + half;
            y1 = Math.min(vm.y, vm.base);
            y2 = Math.max(vm.y, vm.base);
          } else {
            half = vm.height / 2;
            x1 = Math.min(vm.x, vm.base);
            x2 = Math.max(vm.x, vm.base);
            y1 = vm.y - half;
            y2 = vm.y + half;
          }
          return {
            left: x1,
            top: y1,
            right: x2,
            bottom: y2
          };
        }
        function swap(orig, v1, v2) {
          return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function parseBorderSkipped(vm) {
          var edge = vm.borderSkipped;
          var res = {};
          if (!edge) {
            return res;
          }
          if (vm.horizontal) {
            if (vm.base > vm.x) {
              edge = swap(edge, "left", "right");
            }
          } else if (vm.base < vm.y) {
            edge = swap(edge, "bottom", "top");
          }
          res[edge] = true;
          return res;
        }
        function parseBorderWidth(vm, maxW, maxH) {
          var value2 = vm.borderWidth;
          var skip2 = parseBorderSkipped(vm);
          var t2, r2, b, l2;
          if (helpers$1.isObject(value2)) {
            t2 = +value2.top || 0;
            r2 = +value2.right || 0;
            b = +value2.bottom || 0;
            l2 = +value2.left || 0;
          } else {
            t2 = r2 = b = l2 = +value2 || 0;
          }
          return {
            t: skip2.top || t2 < 0 ? 0 : t2 > maxH ? maxH : t2,
            r: skip2.right || r2 < 0 ? 0 : r2 > maxW ? maxW : r2,
            b: skip2.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
            l: skip2.left || l2 < 0 ? 0 : l2 > maxW ? maxW : l2
          };
        }
        function boundingRects(vm) {
          var bounds = getBarBounds(vm);
          var width2 = bounds.right - bounds.left;
          var height2 = bounds.bottom - bounds.top;
          var border = parseBorderWidth(vm, width2 / 2, height2 / 2);
          return {
            outer: {
              x: bounds.left,
              y: bounds.top,
              w: width2,
              h: height2
            },
            inner: {
              x: bounds.left + border.l,
              y: bounds.top + border.t,
              w: width2 - border.l - border.r,
              h: height2 - border.t - border.b
            }
          };
        }
        function inRange(vm, x2, y2) {
          var skipX = x2 === null;
          var skipY = y2 === null;
          var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
          return bounds && (skipX || x2 >= bounds.left && x2 <= bounds.right) && (skipY || y2 >= bounds.top && y2 <= bounds.bottom);
        }
        var element_rectangle = core_element.extend({
          _type: "rectangle",
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var rects = boundingRects(vm);
            var outer = rects.outer;
            var inner = rects.inner;
            ctx.fillStyle = vm.backgroundColor;
            ctx.fillRect(outer.x, outer.y, outer.w, outer.h);
            if (outer.w === inner.w && outer.h === inner.h) {
              return;
            }
            ctx.save();
            ctx.beginPath();
            ctx.rect(outer.x, outer.y, outer.w, outer.h);
            ctx.clip();
            ctx.fillStyle = vm.borderColor;
            ctx.rect(inner.x, inner.y, inner.w, inner.h);
            ctx.fill("evenodd");
            ctx.restore();
          },
          height: function() {
            var vm = this._view;
            return vm.base - vm.y;
          },
          inRange: function(mouseX, mouseY) {
            return inRange(this._view, mouseX, mouseY);
          },
          inLabelRange: function(mouseX, mouseY) {
            var vm = this._view;
            return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
          },
          inXRange: function(mouseX) {
            return inRange(this._view, mouseX, null);
          },
          inYRange: function(mouseY) {
            return inRange(this._view, null, mouseY);
          },
          getCenterPoint: function() {
            var vm = this._view;
            var x2, y2;
            if (isVertical(vm)) {
              x2 = vm.x;
              y2 = (vm.y + vm.base) / 2;
            } else {
              x2 = (vm.x + vm.base) / 2;
              y2 = vm.y;
            }
            return { x: x2, y: y2 };
          },
          getArea: function() {
            var vm = this._view;
            return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
          },
          tooltipPosition: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y
            };
          }
        });
        var elements = {};
        var Arc = element_arc;
        var Line = element_line;
        var Point2 = element_point;
        var Rectangle2 = element_rectangle;
        elements.Arc = Arc;
        elements.Line = Line;
        elements.Point = Point2;
        elements.Rectangle = Rectangle2;
        var deprecated = helpers$1._deprecated;
        var valueOrDefault$3 = helpers$1.valueOrDefault;
        core_defaults._set("bar", {
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "category",
              offset: true,
              gridLines: {
                offsetGridLines: true
              }
            }],
            yAxes: [{
              type: "linear"
            }]
          }
        });
        core_defaults._set("global", {
          datasets: {
            bar: {
              categoryPercentage: 0.8,
              barPercentage: 0.9
            }
          }
        });
        function computeMinSampleSize(scale2, pixels) {
          var min2 = scale2._length;
          var prev, curr, i, ilen;
          for (i = 1, ilen = pixels.length; i < ilen; ++i) {
            min2 = Math.min(min2, Math.abs(pixels[i] - pixels[i - 1]));
          }
          for (i = 0, ilen = scale2.getTicks().length; i < ilen; ++i) {
            curr = scale2.getPixelForTick(i);
            min2 = i > 0 ? Math.min(min2, Math.abs(curr - prev)) : min2;
            prev = curr;
          }
          return min2;
        }
        function computeFitCategoryTraits(index2, ruler, options2) {
          var thickness = options2.barThickness;
          var count = ruler.stackCount;
          var curr = ruler.pixels[index2];
          var min2 = helpers$1.isNullOrUndef(thickness) ? computeMinSampleSize(ruler.scale, ruler.pixels) : -1;
          var size2, ratio;
          if (helpers$1.isNullOrUndef(thickness)) {
            size2 = min2 * options2.categoryPercentage;
            ratio = options2.barPercentage;
          } else {
            size2 = thickness * count;
            ratio = 1;
          }
          return {
            chunk: size2 / count,
            ratio,
            start: curr - size2 / 2
          };
        }
        function computeFlexCategoryTraits(index2, ruler, options2) {
          var pixels = ruler.pixels;
          var curr = pixels[index2];
          var prev = index2 > 0 ? pixels[index2 - 1] : null;
          var next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
          var percent = options2.categoryPercentage;
          var start, size2;
          if (prev === null) {
            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
          }
          if (next === null) {
            next = curr + curr - prev;
          }
          start = curr - (curr - Math.min(prev, next)) / 2 * percent;
          size2 = Math.abs(next - prev) / 2 * percent;
          return {
            chunk: size2 / ruler.stackCount,
            ratio: options2.barPercentage,
            start
          };
        }
        var controller_bar = core_datasetController.extend({
          dataElementType: elements.Rectangle,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderSkipped",
            "borderWidth",
            "barPercentage",
            "barThickness",
            "categoryPercentage",
            "maxBarThickness",
            "minBarLength"
          ],
          initialize: function() {
            var me2 = this;
            var meta, scaleOpts;
            core_datasetController.prototype.initialize.apply(me2, arguments);
            meta = me2.getMeta();
            meta.stack = me2.getDataset().stack;
            meta.bar = true;
            scaleOpts = me2._getIndexScale().options;
            deprecated("bar chart", scaleOpts.barPercentage, "scales.[x/y]Axes.barPercentage", "dataset.barPercentage");
            deprecated("bar chart", scaleOpts.barThickness, "scales.[x/y]Axes.barThickness", "dataset.barThickness");
            deprecated("bar chart", scaleOpts.categoryPercentage, "scales.[x/y]Axes.categoryPercentage", "dataset.categoryPercentage");
            deprecated("bar chart", me2._getValueScale().options.minBarLength, "scales.[x/y]Axes.minBarLength", "dataset.minBarLength");
            deprecated("bar chart", scaleOpts.maxBarThickness, "scales.[x/y]Axes.maxBarThickness", "dataset.maxBarThickness");
          },
          update: function(reset) {
            var me2 = this;
            var rects = me2.getMeta().data;
            var i, ilen;
            me2._ruler = me2.getRuler();
            for (i = 0, ilen = rects.length; i < ilen; ++i) {
              me2.updateElement(rects[i], i, reset);
            }
          },
          updateElement: function(rectangle, index2, reset) {
            var me2 = this;
            var meta = me2.getMeta();
            var dataset = me2.getDataset();
            var options2 = me2._resolveDataElementOptions(rectangle, index2);
            rectangle._xScale = me2.getScaleForId(meta.xAxisID);
            rectangle._yScale = me2.getScaleForId(meta.yAxisID);
            rectangle._datasetIndex = me2.index;
            rectangle._index = index2;
            rectangle._model = {
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderSkipped: options2.borderSkipped,
              borderWidth: options2.borderWidth,
              datasetLabel: dataset.label,
              label: me2.chart.data.labels[index2]
            };
            if (helpers$1.isArray(dataset.data[index2])) {
              rectangle._model.borderSkipped = null;
            }
            me2._updateElementGeometry(rectangle, index2, reset, options2);
            rectangle.pivot();
          },
          _updateElementGeometry: function(rectangle, index2, reset, options2) {
            var me2 = this;
            var model = rectangle._model;
            var vscale = me2._getValueScale();
            var base = vscale.getBasePixel();
            var horizontal = vscale.isHorizontal();
            var ruler = me2._ruler || me2.getRuler();
            var vpixels = me2.calculateBarValuePixels(me2.index, index2, options2);
            var ipixels = me2.calculateBarIndexPixels(me2.index, index2, ruler, options2);
            model.horizontal = horizontal;
            model.base = reset ? base : vpixels.base;
            model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
            model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
            model.height = horizontal ? ipixels.size : void 0;
            model.width = horizontal ? void 0 : ipixels.size;
          },
          _getStacks: function(last2) {
            var me2 = this;
            var scale2 = me2._getIndexScale();
            var metasets = scale2._getMatchingVisibleMetas(me2._type);
            var stacked = scale2.options.stacked;
            var ilen = metasets.length;
            var stacks = [];
            var i, meta;
            for (i = 0; i < ilen; ++i) {
              meta = metasets[i];
              if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
                stacks.push(meta.stack);
              }
              if (meta.index === last2) {
                break;
              }
            }
            return stacks;
          },
          getStackCount: function() {
            return this._getStacks().length;
          },
          getStackIndex: function(datasetIndex, name3) {
            var stacks = this._getStacks(datasetIndex);
            var index2 = name3 !== void 0 ? stacks.indexOf(name3) : -1;
            return index2 === -1 ? stacks.length - 1 : index2;
          },
          getRuler: function() {
            var me2 = this;
            var scale2 = me2._getIndexScale();
            var pixels = [];
            var i, ilen;
            for (i = 0, ilen = me2.getMeta().data.length; i < ilen; ++i) {
              pixels.push(scale2.getPixelForValue(null, i, me2.index));
            }
            return {
              pixels,
              start: scale2._startPixel,
              end: scale2._endPixel,
              stackCount: me2.getStackCount(),
              scale: scale2
            };
          },
          calculateBarValuePixels: function(datasetIndex, index2, options2) {
            var me2 = this;
            var chart = me2.chart;
            var scale2 = me2._getValueScale();
            var isHorizontal = scale2.isHorizontal();
            var datasets = chart.data.datasets;
            var metasets = scale2._getMatchingVisibleMetas(me2._type);
            var value2 = scale2._parseValue(datasets[datasetIndex].data[index2]);
            var minBarLength = options2.minBarLength;
            var stacked = scale2.options.stacked;
            var stack = me2.getMeta().stack;
            var start = value2.start === void 0 ? 0 : value2.max >= 0 && value2.min >= 0 ? value2.min : value2.max;
            var length = value2.start === void 0 ? value2.end : value2.max >= 0 && value2.min >= 0 ? value2.max - value2.min : value2.min - value2.max;
            var ilen = metasets.length;
            var i, imeta, ivalue, base, head, size2, stackLength;
            if (stacked || stacked === void 0 && stack !== void 0) {
              for (i = 0; i < ilen; ++i) {
                imeta = metasets[i];
                if (imeta.index === datasetIndex) {
                  break;
                }
                if (imeta.stack === stack) {
                  stackLength = scale2._parseValue(datasets[imeta.index].data[index2]);
                  ivalue = stackLength.start === void 0 ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;
                  if (value2.min < 0 && ivalue < 0 || value2.max >= 0 && ivalue > 0) {
                    start += ivalue;
                  }
                }
              }
            }
            base = scale2.getPixelForValue(start);
            head = scale2.getPixelForValue(start + length);
            size2 = head - base;
            if (minBarLength !== void 0 && Math.abs(size2) < minBarLength) {
              size2 = minBarLength;
              if (length >= 0 && !isHorizontal || length < 0 && isHorizontal) {
                head = base - minBarLength;
              } else {
                head = base + minBarLength;
              }
            }
            return {
              size: size2,
              base,
              head,
              center: head + size2 / 2
            };
          },
          calculateBarIndexPixels: function(datasetIndex, index2, ruler, options2) {
            var me2 = this;
            var range2 = options2.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options2) : computeFitCategoryTraits(index2, ruler, options2);
            var stackIndex = me2.getStackIndex(datasetIndex, me2.getMeta().stack);
            var center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
            var size2 = Math.min(
              valueOrDefault$3(options2.maxBarThickness, Infinity),
              range2.chunk * range2.ratio
            );
            return {
              base: center - size2 / 2,
              head: center + size2 / 2,
              center,
              size: size2
            };
          },
          draw: function() {
            var me2 = this;
            var chart = me2.chart;
            var scale2 = me2._getValueScale();
            var rects = me2.getMeta().data;
            var dataset = me2.getDataset();
            var ilen = rects.length;
            var i = 0;
            helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);
            for (; i < ilen; ++i) {
              var val = scale2._parseValue(dataset.data[i]);
              if (!isNaN(val.min) && !isNaN(val.max)) {
                rects[i].draw();
              }
            }
            helpers$1.canvas.unclipArea(chart.ctx);
          },
          _resolveDataElementOptions: function() {
            var me2 = this;
            var values2 = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me2, arguments));
            var indexOpts = me2._getIndexScale().options;
            var valueOpts = me2._getValueScale().options;
            values2.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values2.barPercentage);
            values2.barThickness = valueOrDefault$3(indexOpts.barThickness, values2.barThickness);
            values2.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values2.categoryPercentage);
            values2.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values2.maxBarThickness);
            values2.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values2.minBarLength);
            return values2;
          }
        });
        var valueOrDefault$4 = helpers$1.valueOrDefault;
        var resolve$1 = helpers$1.options.resolve;
        core_defaults._set("bubble", {
          hover: {
            mode: "single"
          },
          scales: {
            xAxes: [{
              type: "linear",
              position: "bottom",
              id: "x-axis-0"
            }],
            yAxes: [{
              type: "linear",
              position: "left",
              id: "y-axis-0"
            }]
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item, data) {
                var datasetLabel = data.datasets[item.datasetIndex].label || "";
                var dataPoint = data.datasets[item.datasetIndex].data[item.index];
                return datasetLabel + ": (" + item.xLabel + ", " + item.yLabel + ", " + dataPoint.r + ")";
              }
            }
          }
        });
        var controller_bubble = core_datasetController.extend({
          dataElementType: elements.Point,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth",
            "hoverRadius",
            "hitRadius",
            "pointStyle",
            "rotation"
          ],
          update: function(reset) {
            var me2 = this;
            var meta = me2.getMeta();
            var points = meta.data;
            helpers$1.each(points, function(point, index2) {
              me2.updateElement(point, index2, reset);
            });
          },
          updateElement: function(point, index2, reset) {
            var me2 = this;
            var meta = me2.getMeta();
            var custom = point.custom || {};
            var xScale = me2.getScaleForId(meta.xAxisID);
            var yScale = me2.getScaleForId(meta.yAxisID);
            var options2 = me2._resolveDataElementOptions(point, index2);
            var data = me2.getDataset().data[index2];
            var dsIndex = me2.index;
            var x2 = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === "object" ? data : NaN, index2, dsIndex);
            var y2 = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index2, dsIndex);
            point._xScale = xScale;
            point._yScale = yScale;
            point._options = options2;
            point._datasetIndex = dsIndex;
            point._index = index2;
            point._model = {
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              hitRadius: options2.hitRadius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              radius: reset ? 0 : options2.radius,
              skip: custom.skip || isNaN(x2) || isNaN(y2),
              x: x2,
              y: y2
            };
            point.pivot();
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$4(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$4(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$4(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = options2.radius + options2.hoverRadius;
          },
          _resolveDataElementOptions: function(point, index2) {
            var me2 = this;
            var chart = me2.chart;
            var dataset = me2.getDataset();
            var custom = point.custom || {};
            var data = dataset.data[index2] || {};
            var values2 = core_datasetController.prototype._resolveDataElementOptions.apply(me2, arguments);
            var context2 = {
              chart,
              dataIndex: index2,
              dataset,
              datasetIndex: me2.index
            };
            if (me2._cachedDataOpts === values2) {
              values2 = helpers$1.extend({}, values2);
            }
            values2.radius = resolve$1([
              custom.radius,
              data.r,
              me2._config.radius,
              chart.options.elements.point.radius
            ], context2, index2);
            return values2;
          }
        });
        var valueOrDefault$5 = helpers$1.valueOrDefault;
        var PI$1 = Math.PI;
        var DOUBLE_PI$1 = PI$1 * 2;
        var HALF_PI$1 = PI$1 / 2;
        core_defaults._set("doughnut", {
          animation: {
            animateRotate: true,
            animateScale: false
          },
          hover: {
            mode: "single"
          },
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var data = chart.data;
            var datasets = data.datasets;
            var labels = data.labels;
            var i, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            if (datasets.length) {
              for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                listItem = list.appendChild(document.createElement("li"));
                listItemSpan = listItem.appendChild(document.createElement("span"));
                listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                if (labels[i]) {
                  listItem.appendChild(document.createTextNode(labels[i]));
                }
              }
            }
            return list.outerHTML;
          },
          legend: {
            labels: {
              generateLabels: function(chart) {
                var data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  return data.labels.map(function(label, i) {
                    var meta = chart.getDatasetMeta(0);
                    var style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick: function(e, legendItem) {
              var index2 = legendItem.index;
              var chart = this.chart;
              var i, ilen, meta;
              for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                meta = chart.getDatasetMeta(i);
                if (meta.data[index2]) {
                  meta.data[index2].hidden = !meta.data[index2].hidden;
                }
              }
              chart.update();
            }
          },
          cutoutPercentage: 50,
          rotation: -HALF_PI$1,
          circumference: DOUBLE_PI$1,
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(tooltipItem, data) {
                var dataLabel = data.labels[tooltipItem.index];
                var value2 = ": " + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                if (helpers$1.isArray(dataLabel)) {
                  dataLabel = dataLabel.slice();
                  dataLabel[0] += value2;
                } else {
                  dataLabel += value2;
                }
                return dataLabel;
              }
            }
          }
        });
        var controller_doughnut = core_datasetController.extend({
          dataElementType: elements.Arc,
          linkScales: helpers$1.noop,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "borderAlign",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth"
          ],
          getRingIndex: function(datasetIndex) {
            var ringIndex = 0;
            for (var j = 0; j < datasetIndex; ++j) {
              if (this.chart.isDatasetVisible(j)) {
                ++ringIndex;
              }
            }
            return ringIndex;
          },
          update: function(reset) {
            var me2 = this;
            var chart = me2.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var ratioX = 1;
            var ratioY = 1;
            var offsetX = 0;
            var offsetY = 0;
            var meta = me2.getMeta();
            var arcs = meta.data;
            var cutout = opts.cutoutPercentage / 100 || 0;
            var circumference = opts.circumference;
            var chartWeight = me2._getRingWeight(me2.index);
            var maxWidth, maxHeight, i, ilen;
            if (circumference < DOUBLE_PI$1) {
              var startAngle = opts.rotation % DOUBLE_PI$1;
              startAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;
              var endAngle = startAngle + circumference;
              var startX = Math.cos(startAngle);
              var startY = Math.sin(startAngle);
              var endX = Math.cos(endAngle);
              var endY = Math.sin(endAngle);
              var contains0 = startAngle <= 0 && endAngle >= 0 || endAngle >= DOUBLE_PI$1;
              var contains90 = startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1 || endAngle >= DOUBLE_PI$1 + HALF_PI$1;
              var contains180 = startAngle === -PI$1 || endAngle >= PI$1;
              var contains270 = startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1 || endAngle >= PI$1 + HALF_PI$1;
              var minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);
              var minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);
              var maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);
              var maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);
              ratioX = (maxX - minX) / 2;
              ratioY = (maxY - minY) / 2;
              offsetX = -(maxX + minX) / 2;
              offsetY = -(maxY + minY) / 2;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              arcs[i]._options = me2._resolveDataElementOptions(arcs[i], i);
            }
            chart.borderWidth = me2.getMaxBorderWidth();
            maxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;
            maxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;
            chart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            chart.innerRadius = Math.max(chart.outerRadius * cutout, 0);
            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me2._getVisibleDatasetWeightTotal() || 1);
            chart.offsetX = offsetX * chart.outerRadius;
            chart.offsetY = offsetY * chart.outerRadius;
            meta.total = me2.calculateTotal();
            me2.outerRadius = chart.outerRadius - chart.radiusLength * me2._getRingWeightOffset(me2.index);
            me2.innerRadius = Math.max(me2.outerRadius - chart.radiusLength * chartWeight, 0);
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              me2.updateElement(arcs[i], i, reset);
            }
          },
          updateElement: function(arc, index2, reset) {
            var me2 = this;
            var chart = me2.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var animationOpts = opts.animation;
            var centerX = (chartArea.left + chartArea.right) / 2;
            var centerY = (chartArea.top + chartArea.bottom) / 2;
            var startAngle = opts.rotation;
            var endAngle = opts.rotation;
            var dataset = me2.getDataset();
            var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me2.calculateCircumference(dataset.data[index2]) * (opts.circumference / DOUBLE_PI$1);
            var innerRadius = reset && animationOpts.animateScale ? 0 : me2.innerRadius;
            var outerRadius = reset && animationOpts.animateScale ? 0 : me2.outerRadius;
            var options2 = arc._options || {};
            helpers$1.extend(arc, {
              _datasetIndex: me2.index,
              _index: index2,
              _model: {
                backgroundColor: options2.backgroundColor,
                borderColor: options2.borderColor,
                borderWidth: options2.borderWidth,
                borderAlign: options2.borderAlign,
                x: centerX + chart.offsetX,
                y: centerY + chart.offsetY,
                startAngle,
                endAngle,
                circumference,
                outerRadius,
                innerRadius,
                label: helpers$1.valueAtIndexOrDefault(dataset.label, index2, chart.data.labels[index2])
              }
            });
            var model = arc._model;
            if (!reset || !animationOpts.animateRotate) {
              if (index2 === 0) {
                model.startAngle = opts.rotation;
              } else {
                model.startAngle = me2.getMeta().data[index2 - 1]._model.endAngle;
              }
              model.endAngle = model.startAngle + model.circumference;
            }
            arc.pivot();
          },
          calculateTotal: function() {
            var dataset = this.getDataset();
            var meta = this.getMeta();
            var total = 0;
            var value2;
            helpers$1.each(meta.data, function(element, index2) {
              value2 = dataset.data[index2];
              if (!isNaN(value2) && !element.hidden) {
                total += Math.abs(value2);
              }
            });
            return total;
          },
          calculateCircumference: function(value2) {
            var total = this.getMeta().total;
            if (total > 0 && !isNaN(value2)) {
              return DOUBLE_PI$1 * (Math.abs(value2) / total);
            }
            return 0;
          },
          getMaxBorderWidth: function(arcs) {
            var me2 = this;
            var max2 = 0;
            var chart = me2.chart;
            var i, ilen, meta, arc, controller, options2, borderWidth, hoverWidth;
            if (!arcs) {
              for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
                if (chart.isDatasetVisible(i)) {
                  meta = chart.getDatasetMeta(i);
                  arcs = meta.data;
                  if (i !== me2.index) {
                    controller = meta.controller;
                  }
                  break;
                }
              }
            }
            if (!arcs) {
              return 0;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              arc = arcs[i];
              if (controller) {
                controller._configure();
                options2 = controller._resolveDataElementOptions(arc, i);
              } else {
                options2 = arc._options;
              }
              if (options2.borderAlign !== "inner") {
                borderWidth = options2.borderWidth;
                hoverWidth = options2.hoverBorderWidth;
                max2 = borderWidth > max2 ? borderWidth : max2;
                max2 = hoverWidth > max2 ? hoverWidth : max2;
              }
            }
            return max2;
          },
          setHoverStyle: function(arc) {
            var model = arc._model;
            var options2 = arc._options;
            var getHoverColor = helpers$1.getHoverColor;
            arc.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = valueOrDefault$5(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$5(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$5(options2.hoverBorderWidth, options2.borderWidth);
          },
          _getRingWeightOffset: function(datasetIndex) {
            var ringWeightOffset = 0;
            for (var i = 0; i < datasetIndex; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
              }
            }
            return ringWeightOffset;
          },
          _getRingWeight: function(dataSetIndex) {
            return Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
          },
          _getVisibleDatasetWeightTotal: function() {
            return this._getRingWeightOffset(this.chart.data.datasets.length);
          }
        });
        core_defaults._set("horizontalBar", {
          hover: {
            mode: "index",
            axis: "y"
          },
          scales: {
            xAxes: [{
              type: "linear",
              position: "bottom"
            }],
            yAxes: [{
              type: "category",
              position: "left",
              offset: true,
              gridLines: {
                offsetGridLines: true
              }
            }]
          },
          elements: {
            rectangle: {
              borderSkipped: "left"
            }
          },
          tooltips: {
            mode: "index",
            axis: "y"
          }
        });
        core_defaults._set("global", {
          datasets: {
            horizontalBar: {
              categoryPercentage: 0.8,
              barPercentage: 0.9
            }
          }
        });
        var controller_horizontalBar = controller_bar.extend({
          _getValueScaleId: function() {
            return this.getMeta().xAxisID;
          },
          _getIndexScaleId: function() {
            return this.getMeta().yAxisID;
          }
        });
        var valueOrDefault$6 = helpers$1.valueOrDefault;
        var resolve$2 = helpers$1.options.resolve;
        var isPointInArea = helpers$1.canvas._isPointInArea;
        core_defaults._set("line", {
          showLines: true,
          spanGaps: false,
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "category",
              id: "x-axis-0"
            }],
            yAxes: [{
              type: "linear",
              id: "y-axis-0"
            }]
          }
        });
        function scaleClip(scale2, halfBorderWidth) {
          var tickOpts = scale2 && scale2.options.ticks || {};
          var reverse = tickOpts.reverse;
          var min2 = tickOpts.min === void 0 ? halfBorderWidth : 0;
          var max2 = tickOpts.max === void 0 ? halfBorderWidth : 0;
          return {
            start: reverse ? max2 : min2,
            end: reverse ? min2 : max2
          };
        }
        function defaultClip(xScale, yScale, borderWidth) {
          var halfBorderWidth = borderWidth / 2;
          var x2 = scaleClip(xScale, halfBorderWidth);
          var y2 = scaleClip(yScale, halfBorderWidth);
          return {
            top: y2.end,
            right: x2.end,
            bottom: y2.start,
            left: x2.start
          };
        }
        function toClip(value2) {
          var t2, r2, b, l2;
          if (helpers$1.isObject(value2)) {
            t2 = value2.top;
            r2 = value2.right;
            b = value2.bottom;
            l2 = value2.left;
          } else {
            t2 = r2 = b = l2 = value2;
          }
          return {
            top: t2,
            right: r2,
            bottom: b,
            left: l2
          };
        }
        var controller_line = core_datasetController.extend({
          datasetElementType: elements.Line,
          dataElementType: elements.Point,
          _datasetElementOptions: [
            "backgroundColor",
            "borderCapStyle",
            "borderColor",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "borderWidth",
            "cubicInterpolationMode",
            "fill"
          ],
          _dataElementOptions: {
            backgroundColor: "pointBackgroundColor",
            borderColor: "pointBorderColor",
            borderWidth: "pointBorderWidth",
            hitRadius: "pointHitRadius",
            hoverBackgroundColor: "pointHoverBackgroundColor",
            hoverBorderColor: "pointHoverBorderColor",
            hoverBorderWidth: "pointHoverBorderWidth",
            hoverRadius: "pointHoverRadius",
            pointStyle: "pointStyle",
            radius: "pointRadius",
            rotation: "pointRotation"
          },
          update: function(reset) {
            var me2 = this;
            var meta = me2.getMeta();
            var line = meta.dataset;
            var points = meta.data || [];
            var options2 = me2.chart.options;
            var config = me2._config;
            var showLine = me2._showLine = valueOrDefault$6(config.showLine, options2.showLines);
            var i, ilen;
            me2._xScale = me2.getScaleForId(meta.xAxisID);
            me2._yScale = me2.getScaleForId(meta.yAxisID);
            if (showLine) {
              if (config.tension !== void 0 && config.lineTension === void 0) {
                config.lineTension = config.tension;
              }
              line._scale = me2._yScale;
              line._datasetIndex = me2.index;
              line._children = points;
              line._model = me2._resolveDatasetElementOptions(line);
              line.pivot();
            }
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              me2.updateElement(points[i], i, reset);
            }
            if (showLine && line._model.tension !== 0) {
              me2.updateBezierControlPoints();
            }
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              points[i].pivot();
            }
          },
          updateElement: function(point, index2, reset) {
            var me2 = this;
            var meta = me2.getMeta();
            var custom = point.custom || {};
            var dataset = me2.getDataset();
            var datasetIndex = me2.index;
            var value2 = dataset.data[index2];
            var xScale = me2._xScale;
            var yScale = me2._yScale;
            var lineModel = meta.dataset._model;
            var x2, y2;
            var options2 = me2._resolveDataElementOptions(point, index2);
            x2 = xScale.getPixelForValue(typeof value2 === "object" ? value2 : NaN, index2, datasetIndex);
            y2 = reset ? yScale.getBasePixel() : me2.calculatePointY(value2, index2, datasetIndex);
            point._xScale = xScale;
            point._yScale = yScale;
            point._options = options2;
            point._datasetIndex = datasetIndex;
            point._index = index2;
            point._model = {
              x: x2,
              y: y2,
              skip: custom.skip || isNaN(x2) || isNaN(y2),
              radius: options2.radius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
              steppedLine: lineModel ? lineModel.steppedLine : false,
              hitRadius: options2.hitRadius
            };
          },
          _resolveDatasetElementOptions: function(element) {
            var me2 = this;
            var config = me2._config;
            var custom = element.custom || {};
            var options2 = me2.chart.options;
            var lineOptions = options2.elements.line;
            var values2 = core_datasetController.prototype._resolveDatasetElementOptions.apply(me2, arguments);
            values2.spanGaps = valueOrDefault$6(config.spanGaps, options2.spanGaps);
            values2.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);
            values2.steppedLine = resolve$2([custom.steppedLine, config.steppedLine, lineOptions.stepped]);
            values2.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me2._xScale, me2._yScale, values2.borderWidth)));
            return values2;
          },
          calculatePointY: function(value2, index2, datasetIndex) {
            var me2 = this;
            var chart = me2.chart;
            var yScale = me2._yScale;
            var sumPos = 0;
            var sumNeg = 0;
            var i, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;
            if (yScale.options.stacked) {
              rightValue = +yScale.getRightValue(value2);
              metasets = chart._getSortedVisibleDatasetMetas();
              ilen = metasets.length;
              for (i = 0; i < ilen; ++i) {
                dsMeta = metasets[i];
                if (dsMeta.index === datasetIndex) {
                  break;
                }
                ds = chart.data.datasets[dsMeta.index];
                if (dsMeta.type === "line" && dsMeta.yAxisID === yScale.id) {
                  stackedRightValue = +yScale.getRightValue(ds.data[index2]);
                  if (stackedRightValue < 0) {
                    sumNeg += stackedRightValue || 0;
                  } else {
                    sumPos += stackedRightValue || 0;
                  }
                }
              }
              if (rightValue < 0) {
                return yScale.getPixelForValue(sumNeg + rightValue);
              }
              return yScale.getPixelForValue(sumPos + rightValue);
            }
            return yScale.getPixelForValue(value2);
          },
          updateBezierControlPoints: function() {
            var me2 = this;
            var chart = me2.chart;
            var meta = me2.getMeta();
            var lineModel = meta.dataset._model;
            var area2 = chart.chartArea;
            var points = meta.data || [];
            var i, ilen, model, controlPoints;
            if (lineModel.spanGaps) {
              points = points.filter(function(pt) {
                return !pt._model.skip;
              });
            }
            function capControlPoint(pt, min2, max2) {
              return Math.max(Math.min(pt, max2), min2);
            }
            if (lineModel.cubicInterpolationMode === "monotone") {
              helpers$1.splineCurveMonotone(points);
            } else {
              for (i = 0, ilen = points.length; i < ilen; ++i) {
                model = points[i]._model;
                controlPoints = helpers$1.splineCurve(
                  helpers$1.previousItem(points, i)._model,
                  model,
                  helpers$1.nextItem(points, i)._model,
                  lineModel.tension
                );
                model.controlPointPreviousX = controlPoints.previous.x;
                model.controlPointPreviousY = controlPoints.previous.y;
                model.controlPointNextX = controlPoints.next.x;
                model.controlPointNextY = controlPoints.next.y;
              }
            }
            if (chart.options.elements.line.capBezierPoints) {
              for (i = 0, ilen = points.length; i < ilen; ++i) {
                model = points[i]._model;
                if (isPointInArea(model, area2)) {
                  if (i > 0 && isPointInArea(points[i - 1]._model, area2)) {
                    model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area2.left, area2.right);
                    model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area2.top, area2.bottom);
                  }
                  if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area2)) {
                    model.controlPointNextX = capControlPoint(model.controlPointNextX, area2.left, area2.right);
                    model.controlPointNextY = capControlPoint(model.controlPointNextY, area2.top, area2.bottom);
                  }
                }
              }
            }
          },
          draw: function() {
            var me2 = this;
            var chart = me2.chart;
            var meta = me2.getMeta();
            var points = meta.data || [];
            var area2 = chart.chartArea;
            var canvas3 = chart.canvas;
            var i = 0;
            var ilen = points.length;
            var clip;
            if (me2._showLine) {
              clip = meta.dataset._model.clip;
              helpers$1.canvas.clipArea(chart.ctx, {
                left: clip.left === false ? 0 : area2.left - clip.left,
                right: clip.right === false ? canvas3.width : area2.right + clip.right,
                top: clip.top === false ? 0 : area2.top - clip.top,
                bottom: clip.bottom === false ? canvas3.height : area2.bottom + clip.bottom
              });
              meta.dataset.draw();
              helpers$1.canvas.unclipArea(chart.ctx);
            }
            for (; i < ilen; ++i) {
              points[i].draw(area2);
            }
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$6(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$6(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$6(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = valueOrDefault$6(options2.hoverRadius, options2.radius);
          }
        });
        var resolve$3 = helpers$1.options.resolve;
        core_defaults._set("polarArea", {
          scale: {
            type: "radialLinear",
            angleLines: {
              display: false
            },
            gridLines: {
              circular: true
            },
            pointLabels: {
              display: false
            },
            ticks: {
              beginAtZero: true
            }
          },
          animation: {
            animateRotate: true,
            animateScale: true
          },
          startAngle: -0.5 * Math.PI,
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var data = chart.data;
            var datasets = data.datasets;
            var labels = data.labels;
            var i, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            if (datasets.length) {
              for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                listItem = list.appendChild(document.createElement("li"));
                listItemSpan = listItem.appendChild(document.createElement("span"));
                listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                if (labels[i]) {
                  listItem.appendChild(document.createTextNode(labels[i]));
                }
              }
            }
            return list.outerHTML;
          },
          legend: {
            labels: {
              generateLabels: function(chart) {
                var data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  return data.labels.map(function(label, i) {
                    var meta = chart.getDatasetMeta(0);
                    var style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick: function(e, legendItem) {
              var index2 = legendItem.index;
              var chart = this.chart;
              var i, ilen, meta;
              for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                meta = chart.getDatasetMeta(i);
                meta.data[index2].hidden = !meta.data[index2].hidden;
              }
              chart.update();
            }
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item, data) {
                return data.labels[item.index] + ": " + item.yLabel;
              }
            }
          }
        });
        var controller_polarArea = core_datasetController.extend({
          dataElementType: elements.Arc,
          linkScales: helpers$1.noop,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "borderAlign",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth"
          ],
          _getIndexScaleId: function() {
            return this.chart.scale.id;
          },
          _getValueScaleId: function() {
            return this.chart.scale.id;
          },
          update: function(reset) {
            var me2 = this;
            var dataset = me2.getDataset();
            var meta = me2.getMeta();
            var start = me2.chart.options.startAngle || 0;
            var starts = me2._starts = [];
            var angles = me2._angles = [];
            var arcs = meta.data;
            var i, ilen, angle;
            me2._updateRadius();
            meta.count = me2.countVisibleElements();
            for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
              starts[i] = start;
              angle = me2._computeAngle(i);
              angles[i] = angle;
              start += angle;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              arcs[i]._options = me2._resolveDataElementOptions(arcs[i], i);
              me2.updateElement(arcs[i], i, reset);
            }
          },
          _updateRadius: function() {
            var me2 = this;
            var chart = me2.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            chart.outerRadius = Math.max(minSize / 2, 0);
            chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
            me2.outerRadius = chart.outerRadius - chart.radiusLength * me2.index;
            me2.innerRadius = me2.outerRadius - chart.radiusLength;
          },
          updateElement: function(arc, index2, reset) {
            var me2 = this;
            var chart = me2.chart;
            var dataset = me2.getDataset();
            var opts = chart.options;
            var animationOpts = opts.animation;
            var scale2 = chart.scale;
            var labels = chart.data.labels;
            var centerX = scale2.xCenter;
            var centerY = scale2.yCenter;
            var datasetStartAngle = opts.startAngle;
            var distance = arc.hidden ? 0 : scale2.getDistanceFromCenterForValue(dataset.data[index2]);
            var startAngle = me2._starts[index2];
            var endAngle = startAngle + (arc.hidden ? 0 : me2._angles[index2]);
            var resetRadius = animationOpts.animateScale ? 0 : scale2.getDistanceFromCenterForValue(dataset.data[index2]);
            var options2 = arc._options || {};
            helpers$1.extend(arc, {
              _datasetIndex: me2.index,
              _index: index2,
              _scale: scale2,
              _model: {
                backgroundColor: options2.backgroundColor,
                borderColor: options2.borderColor,
                borderWidth: options2.borderWidth,
                borderAlign: options2.borderAlign,
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius: reset ? resetRadius : distance,
                startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
                endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
                label: helpers$1.valueAtIndexOrDefault(labels, index2, labels[index2])
              }
            });
            arc.pivot();
          },
          countVisibleElements: function() {
            var dataset = this.getDataset();
            var meta = this.getMeta();
            var count = 0;
            helpers$1.each(meta.data, function(element, index2) {
              if (!isNaN(dataset.data[index2]) && !element.hidden) {
                count++;
              }
            });
            return count;
          },
          setHoverStyle: function(arc) {
            var model = arc._model;
            var options2 = arc._options;
            var getHoverColor = helpers$1.getHoverColor;
            var valueOrDefault2 = helpers$1.valueOrDefault;
            arc.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = valueOrDefault2(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault2(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault2(options2.hoverBorderWidth, options2.borderWidth);
          },
          _computeAngle: function(index2) {
            var me2 = this;
            var count = this.getMeta().count;
            var dataset = me2.getDataset();
            var meta = me2.getMeta();
            if (isNaN(dataset.data[index2]) || meta.data[index2].hidden) {
              return 0;
            }
            var context2 = {
              chart: me2.chart,
              dataIndex: index2,
              dataset,
              datasetIndex: me2.index
            };
            return resolve$3([
              me2.chart.options.elements.arc.angle,
              2 * Math.PI / count
            ], context2, index2);
          }
        });
        core_defaults._set("pie", helpers$1.clone(core_defaults.doughnut));
        core_defaults._set("pie", {
          cutoutPercentage: 0
        });
        var controller_pie = controller_doughnut;
        var valueOrDefault$7 = helpers$1.valueOrDefault;
        core_defaults._set("radar", {
          spanGaps: false,
          scale: {
            type: "radialLinear"
          },
          elements: {
            line: {
              fill: "start",
              tension: 0
            }
          }
        });
        var controller_radar = core_datasetController.extend({
          datasetElementType: elements.Line,
          dataElementType: elements.Point,
          linkScales: helpers$1.noop,
          _datasetElementOptions: [
            "backgroundColor",
            "borderWidth",
            "borderColor",
            "borderCapStyle",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "fill"
          ],
          _dataElementOptions: {
            backgroundColor: "pointBackgroundColor",
            borderColor: "pointBorderColor",
            borderWidth: "pointBorderWidth",
            hitRadius: "pointHitRadius",
            hoverBackgroundColor: "pointHoverBackgroundColor",
            hoverBorderColor: "pointHoverBorderColor",
            hoverBorderWidth: "pointHoverBorderWidth",
            hoverRadius: "pointHoverRadius",
            pointStyle: "pointStyle",
            radius: "pointRadius",
            rotation: "pointRotation"
          },
          _getIndexScaleId: function() {
            return this.chart.scale.id;
          },
          _getValueScaleId: function() {
            return this.chart.scale.id;
          },
          update: function(reset) {
            var me2 = this;
            var meta = me2.getMeta();
            var line = meta.dataset;
            var points = meta.data || [];
            var scale2 = me2.chart.scale;
            var config = me2._config;
            var i, ilen;
            if (config.tension !== void 0 && config.lineTension === void 0) {
              config.lineTension = config.tension;
            }
            line._scale = scale2;
            line._datasetIndex = me2.index;
            line._children = points;
            line._loop = true;
            line._model = me2._resolveDatasetElementOptions(line);
            line.pivot();
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              me2.updateElement(points[i], i, reset);
            }
            me2.updateBezierControlPoints();
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              points[i].pivot();
            }
          },
          updateElement: function(point, index2, reset) {
            var me2 = this;
            var custom = point.custom || {};
            var dataset = me2.getDataset();
            var scale2 = me2.chart.scale;
            var pointPosition = scale2.getPointPositionForValue(index2, dataset.data[index2]);
            var options2 = me2._resolveDataElementOptions(point, index2);
            var lineModel = me2.getMeta().dataset._model;
            var x2 = reset ? scale2.xCenter : pointPosition.x;
            var y2 = reset ? scale2.yCenter : pointPosition.y;
            point._scale = scale2;
            point._options = options2;
            point._datasetIndex = me2.index;
            point._index = index2;
            point._model = {
              x: x2,
              y: y2,
              skip: custom.skip || isNaN(x2) || isNaN(y2),
              radius: options2.radius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              tension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),
              hitRadius: options2.hitRadius
            };
          },
          _resolveDatasetElementOptions: function() {
            var me2 = this;
            var config = me2._config;
            var options2 = me2.chart.options;
            var values2 = core_datasetController.prototype._resolveDatasetElementOptions.apply(me2, arguments);
            values2.spanGaps = valueOrDefault$7(config.spanGaps, options2.spanGaps);
            values2.tension = valueOrDefault$7(config.lineTension, options2.elements.line.tension);
            return values2;
          },
          updateBezierControlPoints: function() {
            var me2 = this;
            var meta = me2.getMeta();
            var area2 = me2.chart.chartArea;
            var points = meta.data || [];
            var i, ilen, model, controlPoints;
            if (meta.dataset._model.spanGaps) {
              points = points.filter(function(pt) {
                return !pt._model.skip;
              });
            }
            function capControlPoint(pt, min2, max2) {
              return Math.max(Math.min(pt, max2), min2);
            }
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              model = points[i]._model;
              controlPoints = helpers$1.splineCurve(
                helpers$1.previousItem(points, i, true)._model,
                model,
                helpers$1.nextItem(points, i, true)._model,
                model.tension
              );
              model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area2.left, area2.right);
              model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area2.top, area2.bottom);
              model.controlPointNextX = capControlPoint(controlPoints.next.x, area2.left, area2.right);
              model.controlPointNextY = capControlPoint(controlPoints.next.y, area2.top, area2.bottom);
            }
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$7(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$7(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$7(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = valueOrDefault$7(options2.hoverRadius, options2.radius);
          }
        });
        core_defaults._set("scatter", {
          hover: {
            mode: "single"
          },
          scales: {
            xAxes: [{
              id: "x-axis-1",
              type: "linear",
              position: "bottom"
            }],
            yAxes: [{
              id: "y-axis-1",
              type: "linear",
              position: "left"
            }]
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item) {
                return "(" + item.xLabel + ", " + item.yLabel + ")";
              }
            }
          }
        });
        core_defaults._set("global", {
          datasets: {
            scatter: {
              showLine: false
            }
          }
        });
        var controller_scatter = controller_line;
        var controllers = {
          bar: controller_bar,
          bubble: controller_bubble,
          doughnut: controller_doughnut,
          horizontalBar: controller_horizontalBar,
          line: controller_line,
          polarArea: controller_polarArea,
          pie: controller_pie,
          radar: controller_radar,
          scatter: controller_scatter
        };
        function getRelativePosition(e, chart) {
          if (e.native) {
            return {
              x: e.x,
              y: e.y
            };
          }
          return helpers$1.getRelativePosition(e, chart);
        }
        function parseVisibleItems(chart, handler) {
          var metasets = chart._getSortedVisibleDatasetMetas();
          var metadata, i, j, ilen, jlen, element;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            metadata = metasets[i].data;
            for (j = 0, jlen = metadata.length; j < jlen; ++j) {
              element = metadata[j];
              if (!element._view.skip) {
                handler(element);
              }
            }
          }
        }
        function getIntersectItems(chart, position) {
          var elements2 = [];
          parseVisibleItems(chart, function(element) {
            if (element.inRange(position.x, position.y)) {
              elements2.push(element);
            }
          });
          return elements2;
        }
        function getNearestItems(chart, position, intersect, distanceMetric) {
          var minDistance = Number.POSITIVE_INFINITY;
          var nearestItems = [];
          parseVisibleItems(chart, function(element) {
            if (intersect && !element.inRange(position.x, position.y)) {
              return;
            }
            var center = element.getCenterPoint();
            var distance = distanceMetric(position, center);
            if (distance < minDistance) {
              nearestItems = [element];
              minDistance = distance;
            } else if (distance === minDistance) {
              nearestItems.push(element);
            }
          });
          return nearestItems;
        }
        function getDistanceMetricForAxis(axis) {
          var useX = axis.indexOf("x") !== -1;
          var useY = axis.indexOf("y") !== -1;
          return function(pt1, pt2) {
            var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          };
        }
        function indexMode(chart, e, options2) {
          var position = getRelativePosition(e, chart);
          options2.axis = options2.axis || "x";
          var distanceMetric = getDistanceMetricForAxis(options2.axis);
          var items2 = options2.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
          var elements2 = [];
          if (!items2.length) {
            return [];
          }
          chart._getSortedVisibleDatasetMetas().forEach(function(meta) {
            var element = meta.data[items2[0]._index];
            if (element && !element._view.skip) {
              elements2.push(element);
            }
          });
          return elements2;
        }
        var core_interaction = {
          modes: {
            single: function(chart, e) {
              var position = getRelativePosition(e, chart);
              var elements2 = [];
              parseVisibleItems(chart, function(element) {
                if (element.inRange(position.x, position.y)) {
                  elements2.push(element);
                  return elements2;
                }
              });
              return elements2.slice(0, 1);
            },
            label: indexMode,
            index: indexMode,
            dataset: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              options2.axis = options2.axis || "xy";
              var distanceMetric = getDistanceMetricForAxis(options2.axis);
              var items2 = options2.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
              if (items2.length > 0) {
                items2 = chart.getDatasetMeta(items2[0]._datasetIndex).data;
              }
              return items2;
            },
            "x-axis": function(chart, e) {
              return indexMode(chart, e, { intersect: false });
            },
            point: function(chart, e) {
              var position = getRelativePosition(e, chart);
              return getIntersectItems(chart, position);
            },
            nearest: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              options2.axis = options2.axis || "xy";
              var distanceMetric = getDistanceMetricForAxis(options2.axis);
              return getNearestItems(chart, position, options2.intersect, distanceMetric);
            },
            x: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              var items2 = [];
              var intersectsItem = false;
              parseVisibleItems(chart, function(element) {
                if (element.inXRange(position.x)) {
                  items2.push(element);
                }
                if (element.inRange(position.x, position.y)) {
                  intersectsItem = true;
                }
              });
              if (options2.intersect && !intersectsItem) {
                items2 = [];
              }
              return items2;
            },
            y: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              var items2 = [];
              var intersectsItem = false;
              parseVisibleItems(chart, function(element) {
                if (element.inYRange(position.y)) {
                  items2.push(element);
                }
                if (element.inRange(position.x, position.y)) {
                  intersectsItem = true;
                }
              });
              if (options2.intersect && !intersectsItem) {
                items2 = [];
              }
              return items2;
            }
          }
        };
        var extend2 = helpers$1.extend;
        function filterByPosition(array, position) {
          return helpers$1.where(array, function(v2) {
            return v2.pos === position;
          });
        }
        function sortByWeight(array, reverse) {
          return array.sort(function(a, b) {
            var v0 = reverse ? b : a;
            var v1 = reverse ? a : b;
            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
          });
        }
        function wrapBoxes(boxes) {
          var layoutBoxes = [];
          var i, ilen, box;
          for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
            box = boxes[i];
            layoutBoxes.push({
              index: i,
              box,
              pos: box.position,
              horizontal: box.isHorizontal(),
              weight: box.weight
            });
          }
          return layoutBoxes;
        }
        function setLayoutDims(layouts, params) {
          var i, ilen, layout;
          for (i = 0, ilen = layouts.length; i < ilen; ++i) {
            layout = layouts[i];
            layout.width = layout.horizontal ? layout.box.fullWidth && params.availableWidth : params.vBoxMaxWidth;
            layout.height = layout.horizontal && params.hBoxMaxHeight;
          }
        }
        function buildLayoutBoxes(boxes) {
          var layoutBoxes = wrapBoxes(boxes);
          var left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
          var right = sortByWeight(filterByPosition(layoutBoxes, "right"));
          var top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
          var bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
          return {
            leftAndTop: left.concat(top),
            rightAndBottom: right.concat(bottom),
            chartArea: filterByPosition(layoutBoxes, "chartArea"),
            vertical: left.concat(right),
            horizontal: top.concat(bottom)
          };
        }
        function getCombinedMax(maxPadding, chartArea, a, b) {
          return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
        }
        function updateDims(chartArea, params, layout) {
          var box = layout.box;
          var maxPadding = chartArea.maxPadding;
          var newWidth, newHeight;
          if (layout.size) {
            chartArea[layout.pos] -= layout.size;
          }
          layout.size = layout.horizontal ? box.height : box.width;
          chartArea[layout.pos] += layout.size;
          if (box.getPadding) {
            var boxPadding = box.getPadding();
            maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
            maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
            maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
            maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
          }
          newWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right");
          newHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom");
          if (newWidth !== chartArea.w || newHeight !== chartArea.h) {
            chartArea.w = newWidth;
            chartArea.h = newHeight;
            var sizes = layout.horizontal ? [newWidth, chartArea.w] : [newHeight, chartArea.h];
            return sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));
          }
        }
        function handleMaxPadding(chartArea) {
          var maxPadding = chartArea.maxPadding;
          function updatePos(pos) {
            var change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
          }
          chartArea.y += updatePos("top");
          chartArea.x += updatePos("left");
          updatePos("right");
          updatePos("bottom");
        }
        function getMargins(horizontal, chartArea) {
          var maxPadding = chartArea.maxPadding;
          function marginForPositions(positions) {
            var margin = { left: 0, top: 0, right: 0, bottom: 0 };
            positions.forEach(function(pos) {
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
          }
          return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
        }
        function fitBoxes(boxes, chartArea, params) {
          var refitBoxes = [];
          var i, ilen, layout, box, refit, changed;
          for (i = 0, ilen = boxes.length; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            box.update(
              layout.width || chartArea.w,
              layout.height || chartArea.h,
              getMargins(layout.horizontal, chartArea)
            );
            if (updateDims(chartArea, params, layout)) {
              changed = true;
              if (refitBoxes.length) {
                refit = true;
              }
            }
            if (!box.fullWidth) {
              refitBoxes.push(layout);
            }
          }
          return refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;
        }
        function placeBoxes(boxes, chartArea, params) {
          var userPadding = params.padding;
          var x2 = chartArea.x;
          var y2 = chartArea.y;
          var i, ilen, layout, box;
          for (i = 0, ilen = boxes.length; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            if (layout.horizontal) {
              box.left = box.fullWidth ? userPadding.left : chartArea.left;
              box.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;
              box.top = y2;
              box.bottom = y2 + box.height;
              box.width = box.right - box.left;
              y2 = box.bottom;
            } else {
              box.left = x2;
              box.right = x2 + box.width;
              box.top = chartArea.top;
              box.bottom = chartArea.top + chartArea.h;
              box.height = box.bottom - box.top;
              x2 = box.right;
            }
          }
          chartArea.x = x2;
          chartArea.y = y2;
        }
        core_defaults._set("global", {
          layout: {
            padding: {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            }
          }
        });
        var core_layouts = {
          defaults: {},
          addBox: function(chart, item) {
            if (!chart.boxes) {
              chart.boxes = [];
            }
            item.fullWidth = item.fullWidth || false;
            item.position = item.position || "top";
            item.weight = item.weight || 0;
            item._layers = item._layers || function() {
              return [{
                z: 0,
                draw: function() {
                  item.draw.apply(item, arguments);
                }
              }];
            };
            chart.boxes.push(item);
          },
          removeBox: function(chart, layoutItem) {
            var index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
            if (index2 !== -1) {
              chart.boxes.splice(index2, 1);
            }
          },
          configure: function(chart, item, options2) {
            var props = ["fullWidth", "position", "weight"];
            var ilen = props.length;
            var i = 0;
            var prop;
            for (; i < ilen; ++i) {
              prop = props[i];
              if (options2.hasOwnProperty(prop)) {
                item[prop] = options2[prop];
              }
            }
          },
          update: function(chart, width2, height2) {
            if (!chart) {
              return;
            }
            var layoutOptions = chart.options.layout || {};
            var padding = helpers$1.options.toPadding(layoutOptions.padding);
            var availableWidth = width2 - padding.width;
            var availableHeight = height2 - padding.height;
            var boxes = buildLayoutBoxes(chart.boxes);
            var verticalBoxes = boxes.vertical;
            var horizontalBoxes = boxes.horizontal;
            var params = Object.freeze({
              outerWidth: width2,
              outerHeight: height2,
              padding,
              availableWidth,
              vBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,
              hBoxMaxHeight: availableHeight / 2
            });
            var chartArea = extend2({
              maxPadding: extend2({}, padding),
              w: availableWidth,
              h: availableHeight,
              x: padding.left,
              y: padding.top
            }, padding);
            setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
            fitBoxes(verticalBoxes, chartArea, params);
            if (fitBoxes(horizontalBoxes, chartArea, params)) {
              fitBoxes(verticalBoxes, chartArea, params);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params);
            chart.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h
            };
            helpers$1.each(boxes.chartArea, function(layout) {
              var box = layout.box;
              extend2(box, chart.chartArea);
              box.update(chartArea.w, chartArea.h);
            });
          }
        };
        var platform_basic = {
          acquireContext: function(item) {
            if (item && item.canvas) {
              item = item.canvas;
            }
            return item && item.getContext("2d") || null;
          }
        };
        var platform_dom = "/*\r\n * DOM element rendering detection\r\n * https://davidwalsh.name/detect-node-insertion\r\n */\r\n@keyframes chartjs-render-animation {\r\n	from { opacity: 0.99; }\r\n	to { opacity: 1; }\r\n}\r\n\r\n.chartjs-render-monitor {\r\n	animation: chartjs-render-animation 0.001s;\r\n}\r\n\r\n/*\r\n * DOM element resizing detection\r\n * https://github.com/marcj/css-element-queries\r\n */\r\n.chartjs-size-monitor,\r\n.chartjs-size-monitor-expand,\r\n.chartjs-size-monitor-shrink {\r\n	position: absolute;\r\n	direction: ltr;\r\n	left: 0;\r\n	top: 0;\r\n	right: 0;\r\n	bottom: 0;\r\n	overflow: hidden;\r\n	pointer-events: none;\r\n	visibility: hidden;\r\n	z-index: -1;\r\n}\r\n\r\n.chartjs-size-monitor-expand > div {\r\n	position: absolute;\r\n	width: 1000000px;\r\n	height: 1000000px;\r\n	left: 0;\r\n	top: 0;\r\n}\r\n\r\n.chartjs-size-monitor-shrink > div {\r\n	position: absolute;\r\n	width: 200%;\r\n	height: 200%;\r\n	left: 0;\r\n	top: 0;\r\n}\r\n";
        var platform_dom$1 = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          "default": platform_dom
        });
        var stylesheet = getCjsExportFromNamespace(platform_dom$1);
        var EXPANDO_KEY = "$chartjs";
        var CSS_PREFIX = "chartjs-";
        var CSS_SIZE_MONITOR = CSS_PREFIX + "size-monitor";
        var CSS_RENDER_MONITOR = CSS_PREFIX + "render-monitor";
        var CSS_RENDER_ANIMATION = CSS_PREFIX + "render-animation";
        var ANIMATION_START_EVENTS = ["animationstart", "webkitAnimationStart"];
        var EVENT_TYPES = {
          touchstart: "mousedown",
          touchmove: "mousemove",
          touchend: "mouseup",
          pointerenter: "mouseenter",
          pointerdown: "mousedown",
          pointermove: "mousemove",
          pointerup: "mouseup",
          pointerleave: "mouseout",
          pointerout: "mouseout"
        };
        function readUsedSize(element, property2) {
          var value2 = helpers$1.getStyle(element, property2);
          var matches = value2 && value2.match(/^(\d+)(\.\d+)?px$/);
          return matches ? Number(matches[1]) : void 0;
        }
        function initCanvas(canvas3, config) {
          var style = canvas3.style;
          var renderHeight = canvas3.getAttribute("height");
          var renderWidth = canvas3.getAttribute("width");
          canvas3[EXPANDO_KEY] = {
            initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                display: style.display,
                height: style.height,
                width: style.width
              }
            }
          };
          style.display = style.display || "block";
          if (renderWidth === null || renderWidth === "") {
            var displayWidth = readUsedSize(canvas3, "width");
            if (displayWidth !== void 0) {
              canvas3.width = displayWidth;
            }
          }
          if (renderHeight === null || renderHeight === "") {
            if (canvas3.style.height === "") {
              canvas3.height = canvas3.width / (config.options.aspectRatio || 2);
            } else {
              var displayHeight = readUsedSize(canvas3, "height");
              if (displayWidth !== void 0) {
                canvas3.height = displayHeight;
              }
            }
          }
          return canvas3;
        }
        var supportsEventListenerOptions = function() {
          var supports = false;
          try {
            var options2 = Object.defineProperty({}, "passive", {
              get: function() {
                supports = true;
              }
            });
            window.addEventListener("e", null, options2);
          } catch (e) {
          }
          return supports;
        }();
        var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
        function addListener(node, type, listener) {
          node.addEventListener(type, listener, eventListenerOptions);
        }
        function removeListener(node, type, listener) {
          node.removeEventListener(type, listener, eventListenerOptions);
        }
        function createEvent(type, chart, x2, y2, nativeEvent) {
          return {
            type,
            chart,
            native: nativeEvent || null,
            x: x2 !== void 0 ? x2 : null,
            y: y2 !== void 0 ? y2 : null
          };
        }
        function fromNativeEvent(event, chart) {
          var type = EVENT_TYPES[event.type] || event.type;
          var pos = helpers$1.getRelativePosition(event, chart);
          return createEvent(type, chart, pos.x, pos.y, event);
        }
        function throttled(fn, thisArg) {
          var ticking = false;
          var args = [];
          return function() {
            args = Array.prototype.slice.call(arguments);
            thisArg = thisArg || this;
            if (!ticking) {
              ticking = true;
              helpers$1.requestAnimFrame.call(window, function() {
                ticking = false;
                fn.apply(thisArg, args);
              });
            }
          };
        }
        function createDiv(cls) {
          var el = document.createElement("div");
          el.className = cls || "";
          return el;
        }
        function createResizer(handler) {
          var maxSize = 1e6;
          var resizer = createDiv(CSS_SIZE_MONITOR);
          var expand = createDiv(CSS_SIZE_MONITOR + "-expand");
          var shrink = createDiv(CSS_SIZE_MONITOR + "-shrink");
          expand.appendChild(createDiv());
          shrink.appendChild(createDiv());
          resizer.appendChild(expand);
          resizer.appendChild(shrink);
          resizer._reset = function() {
            expand.scrollLeft = maxSize;
            expand.scrollTop = maxSize;
            shrink.scrollLeft = maxSize;
            shrink.scrollTop = maxSize;
          };
          var onScroll = function() {
            resizer._reset();
            handler();
          };
          addListener(expand, "scroll", onScroll.bind(expand, "expand"));
          addListener(shrink, "scroll", onScroll.bind(shrink, "shrink"));
          return resizer;
        }
        function watchForRender(node, handler) {
          var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
          var proxy = expando.renderProxy = function(e) {
            if (e.animationName === CSS_RENDER_ANIMATION) {
              handler();
            }
          };
          helpers$1.each(ANIMATION_START_EVENTS, function(type) {
            addListener(node, type, proxy);
          });
          expando.reflow = !!node.offsetParent;
          node.classList.add(CSS_RENDER_MONITOR);
        }
        function unwatchForRender(node) {
          var expando = node[EXPANDO_KEY] || {};
          var proxy = expando.renderProxy;
          if (proxy) {
            helpers$1.each(ANIMATION_START_EVENTS, function(type) {
              removeListener(node, type, proxy);
            });
            delete expando.renderProxy;
          }
          node.classList.remove(CSS_RENDER_MONITOR);
        }
        function addResizeListener(node, listener, chart) {
          var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
          var resizer = expando.resizer = createResizer(throttled(function() {
            if (expando.resizer) {
              var container = chart.options.maintainAspectRatio && node.parentNode;
              var w2 = container ? container.clientWidth : 0;
              listener(createEvent("resize", chart));
              if (container && container.clientWidth < w2 && chart.canvas) {
                listener(createEvent("resize", chart));
              }
            }
          }));
          watchForRender(node, function() {
            if (expando.resizer) {
              var container = node.parentNode;
              if (container && container !== resizer.parentNode) {
                container.insertBefore(resizer, container.firstChild);
              }
              resizer._reset();
            }
          });
        }
        function removeResizeListener(node) {
          var expando = node[EXPANDO_KEY] || {};
          var resizer = expando.resizer;
          delete expando.resizer;
          unwatchForRender(node);
          if (resizer && resizer.parentNode) {
            resizer.parentNode.removeChild(resizer);
          }
        }
        function injectCSS(rootNode, css) {
          var expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});
          if (!expando.containsStyles) {
            expando.containsStyles = true;
            css = "/* Chart.js */\n" + css;
            var style = document.createElement("style");
            style.setAttribute("type", "text/css");
            style.appendChild(document.createTextNode(css));
            rootNode.appendChild(style);
          }
        }
        var platform_dom$2 = {
          disableCSSInjection: false,
          _enabled: typeof window !== "undefined" && typeof document !== "undefined",
          _ensureLoaded: function(canvas3) {
            if (!this.disableCSSInjection) {
              var root2 = canvas3.getRootNode ? canvas3.getRootNode() : document;
              var targetNode = root2.host ? root2 : document.head;
              injectCSS(targetNode, stylesheet);
            }
          },
          acquireContext: function(item, config) {
            if (typeof item === "string") {
              item = document.getElementById(item);
            } else if (item.length) {
              item = item[0];
            }
            if (item && item.canvas) {
              item = item.canvas;
            }
            var context2 = item && item.getContext && item.getContext("2d");
            if (context2 && context2.canvas === item) {
              this._ensureLoaded(item);
              initCanvas(item, config);
              return context2;
            }
            return null;
          },
          releaseContext: function(context2) {
            var canvas3 = context2.canvas;
            if (!canvas3[EXPANDO_KEY]) {
              return;
            }
            var initial2 = canvas3[EXPANDO_KEY].initial;
            ["height", "width"].forEach(function(prop) {
              var value2 = initial2[prop];
              if (helpers$1.isNullOrUndef(value2)) {
                canvas3.removeAttribute(prop);
              } else {
                canvas3.setAttribute(prop, value2);
              }
            });
            helpers$1.each(initial2.style || {}, function(value2, key) {
              canvas3.style[key] = value2;
            });
            canvas3.width = canvas3.width;
            delete canvas3[EXPANDO_KEY];
          },
          addEventListener: function(chart, type, listener) {
            var canvas3 = chart.canvas;
            if (type === "resize") {
              addResizeListener(canvas3, listener, chart);
              return;
            }
            var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
            var proxies = expando.proxies || (expando.proxies = {});
            var proxy = proxies[chart.id + "_" + type] = function(event) {
              listener(fromNativeEvent(event, chart));
            };
            addListener(canvas3, type, proxy);
          },
          removeEventListener: function(chart, type, listener) {
            var canvas3 = chart.canvas;
            if (type === "resize") {
              removeResizeListener(canvas3);
              return;
            }
            var expando = listener[EXPANDO_KEY] || {};
            var proxies = expando.proxies || {};
            var proxy = proxies[chart.id + "_" + type];
            if (!proxy) {
              return;
            }
            removeListener(canvas3, type, proxy);
          }
        };
        helpers$1.addEvent = addListener;
        helpers$1.removeEvent = removeListener;
        var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
        var platform = helpers$1.extend({
          initialize: function() {
          },
          acquireContext: function() {
          },
          releaseContext: function() {
          },
          addEventListener: function() {
          },
          removeEventListener: function() {
          }
        }, implementation);
        core_defaults._set("global", {
          plugins: {}
        });
        var core_plugins = {
          _plugins: [],
          _cacheId: 0,
          register: function(plugins2) {
            var p2 = this._plugins;
            [].concat(plugins2).forEach(function(plugin) {
              if (p2.indexOf(plugin) === -1) {
                p2.push(plugin);
              }
            });
            this._cacheId++;
          },
          unregister: function(plugins2) {
            var p2 = this._plugins;
            [].concat(plugins2).forEach(function(plugin) {
              var idx = p2.indexOf(plugin);
              if (idx !== -1) {
                p2.splice(idx, 1);
              }
            });
            this._cacheId++;
          },
          clear: function() {
            this._plugins = [];
            this._cacheId++;
          },
          count: function() {
            return this._plugins.length;
          },
          getAll: function() {
            return this._plugins;
          },
          notify: function(chart, hook, args) {
            var descriptors = this.descriptors(chart);
            var ilen = descriptors.length;
            var i, descriptor, plugin, params, method;
            for (i = 0; i < ilen; ++i) {
              descriptor = descriptors[i];
              plugin = descriptor.plugin;
              method = plugin[hook];
              if (typeof method === "function") {
                params = [chart].concat(args || []);
                params.push(descriptor.options);
                if (method.apply(plugin, params) === false) {
                  return false;
                }
              }
            }
            return true;
          },
          descriptors: function(chart) {
            var cache2 = chart.$plugins || (chart.$plugins = {});
            if (cache2.id === this._cacheId) {
              return cache2.descriptors;
            }
            var plugins2 = [];
            var descriptors = [];
            var config = chart && chart.config || {};
            var options2 = config.options && config.options.plugins || {};
            this._plugins.concat(config.plugins || []).forEach(function(plugin) {
              var idx = plugins2.indexOf(plugin);
              if (idx !== -1) {
                return;
              }
              var id2 = plugin.id;
              var opts = options2[id2];
              if (opts === false) {
                return;
              }
              if (opts === true) {
                opts = helpers$1.clone(core_defaults.global.plugins[id2]);
              }
              plugins2.push(plugin);
              descriptors.push({
                plugin,
                options: opts || {}
              });
            });
            cache2.descriptors = descriptors;
            cache2.id = this._cacheId;
            return descriptors;
          },
          _invalidate: function(chart) {
            delete chart.$plugins;
          }
        };
        var core_scaleService = {
          constructors: {},
          defaults: {},
          registerScaleType: function(type, scaleConstructor, scaleDefaults) {
            this.constructors[type] = scaleConstructor;
            this.defaults[type] = helpers$1.clone(scaleDefaults);
          },
          getScaleConstructor: function(type) {
            return this.constructors.hasOwnProperty(type) ? this.constructors[type] : void 0;
          },
          getScaleDefaults: function(type) {
            return this.defaults.hasOwnProperty(type) ? helpers$1.merge(/* @__PURE__ */ Object.create(null), [core_defaults.scale, this.defaults[type]]) : {};
          },
          updateScaleDefaults: function(type, additions) {
            var me2 = this;
            if (me2.defaults.hasOwnProperty(type)) {
              me2.defaults[type] = helpers$1.extend(me2.defaults[type], additions);
            }
          },
          addScalesToLayout: function(chart) {
            helpers$1.each(chart.scales, function(scale2) {
              scale2.fullWidth = scale2.options.fullWidth;
              scale2.position = scale2.options.position;
              scale2.weight = scale2.options.weight;
              core_layouts.addBox(chart, scale2);
            });
          }
        };
        var valueOrDefault$8 = helpers$1.valueOrDefault;
        var getRtlHelper = helpers$1.rtl.getRtlAdapter;
        core_defaults._set("global", {
          tooltips: {
            enabled: true,
            custom: null,
            mode: "nearest",
            position: "average",
            intersect: true,
            backgroundColor: "rgba(0,0,0,0.8)",
            titleFontStyle: "bold",
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleFontColor: "#fff",
            titleAlign: "left",
            bodySpacing: 2,
            bodyFontColor: "#fff",
            bodyAlign: "left",
            footerFontStyle: "bold",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFontColor: "#fff",
            footerAlign: "left",
            yPadding: 6,
            xPadding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            multiKeyBackground: "#fff",
            displayColors: true,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            callbacks: {
              beforeTitle: helpers$1.noop,
              title: function(tooltipItems, data) {
                var title2 = "";
                var labels = data.labels;
                var labelCount = labels ? labels.length : 0;
                if (tooltipItems.length > 0) {
                  var item = tooltipItems[0];
                  if (item.label) {
                    title2 = item.label;
                  } else if (item.xLabel) {
                    title2 = item.xLabel;
                  } else if (labelCount > 0 && item.index < labelCount) {
                    title2 = labels[item.index];
                  }
                }
                return title2;
              },
              afterTitle: helpers$1.noop,
              beforeBody: helpers$1.noop,
              beforeLabel: helpers$1.noop,
              label: function(tooltipItem, data) {
                var label = data.datasets[tooltipItem.datasetIndex].label || "";
                if (label) {
                  label += ": ";
                }
                if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
                  label += tooltipItem.value;
                } else {
                  label += tooltipItem.yLabel;
                }
                return label;
              },
              labelColor: function(tooltipItem, chart) {
                var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
                var activeElement = meta.data[tooltipItem.index];
                var view = activeElement._view;
                return {
                  borderColor: view.borderColor,
                  backgroundColor: view.backgroundColor
                };
              },
              labelTextColor: function() {
                return this._options.bodyFontColor;
              },
              afterLabel: helpers$1.noop,
              afterBody: helpers$1.noop,
              beforeFooter: helpers$1.noop,
              footer: helpers$1.noop,
              afterFooter: helpers$1.noop
            }
          }
        });
        var positioners = {
          average: function(elements2) {
            if (!elements2.length) {
              return false;
            }
            var i, len;
            var x2 = 0;
            var y2 = 0;
            var count = 0;
            for (i = 0, len = elements2.length; i < len; ++i) {
              var el = elements2[i];
              if (el && el.hasValue()) {
                var pos = el.tooltipPosition();
                x2 += pos.x;
                y2 += pos.y;
                ++count;
              }
            }
            return {
              x: x2 / count,
              y: y2 / count
            };
          },
          nearest: function(elements2, eventPosition) {
            var x2 = eventPosition.x;
            var y2 = eventPosition.y;
            var minDistance = Number.POSITIVE_INFINITY;
            var i, len, nearestElement;
            for (i = 0, len = elements2.length; i < len; ++i) {
              var el = elements2[i];
              if (el && el.hasValue()) {
                var center = el.getCenterPoint();
                var d = helpers$1.distanceBetweenPoints(eventPosition, center);
                if (d < minDistance) {
                  minDistance = d;
                  nearestElement = el;
                }
              }
            }
            if (nearestElement) {
              var tp = nearestElement.tooltipPosition();
              x2 = tp.x;
              y2 = tp.y;
            }
            return {
              x: x2,
              y: y2
            };
          }
        };
        function pushOrConcat(base, toPush) {
          if (toPush) {
            if (helpers$1.isArray(toPush)) {
              Array.prototype.push.apply(base, toPush);
            } else {
              base.push(toPush);
            }
          }
          return base;
        }
        function splitNewlines(str) {
          if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
            return str.split("\n");
          }
          return str;
        }
        function createTooltipItem(element) {
          var xScale = element._xScale;
          var yScale = element._yScale || element._scale;
          var index2 = element._index;
          var datasetIndex = element._datasetIndex;
          var controller = element._chart.getDatasetMeta(datasetIndex).controller;
          var indexScale = controller._getIndexScale();
          var valueScale = controller._getValueScale();
          return {
            xLabel: xScale ? xScale.getLabelForIndex(index2, datasetIndex) : "",
            yLabel: yScale ? yScale.getLabelForIndex(index2, datasetIndex) : "",
            label: indexScale ? "" + indexScale.getLabelForIndex(index2, datasetIndex) : "",
            value: valueScale ? "" + valueScale.getLabelForIndex(index2, datasetIndex) : "",
            index: index2,
            datasetIndex,
            x: element._model.x,
            y: element._model.y
          };
        }
        function getBaseModel(tooltipOpts) {
          var globalDefaults = core_defaults.global;
          return {
            xPadding: tooltipOpts.xPadding,
            yPadding: tooltipOpts.yPadding,
            xAlign: tooltipOpts.xAlign,
            yAlign: tooltipOpts.yAlign,
            rtl: tooltipOpts.rtl,
            textDirection: tooltipOpts.textDirection,
            bodyFontColor: tooltipOpts.bodyFontColor,
            _bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
            _bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
            _bodyAlign: tooltipOpts.bodyAlign,
            bodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
            bodySpacing: tooltipOpts.bodySpacing,
            titleFontColor: tooltipOpts.titleFontColor,
            _titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
            _titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
            titleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
            _titleAlign: tooltipOpts.titleAlign,
            titleSpacing: tooltipOpts.titleSpacing,
            titleMarginBottom: tooltipOpts.titleMarginBottom,
            footerFontColor: tooltipOpts.footerFontColor,
            _footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
            _footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
            footerFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
            _footerAlign: tooltipOpts.footerAlign,
            footerSpacing: tooltipOpts.footerSpacing,
            footerMarginTop: tooltipOpts.footerMarginTop,
            caretSize: tooltipOpts.caretSize,
            cornerRadius: tooltipOpts.cornerRadius,
            backgroundColor: tooltipOpts.backgroundColor,
            opacity: 0,
            legendColorBackground: tooltipOpts.multiKeyBackground,
            displayColors: tooltipOpts.displayColors,
            borderColor: tooltipOpts.borderColor,
            borderWidth: tooltipOpts.borderWidth
          };
        }
        function getTooltipSize(tooltip, model) {
          var ctx = tooltip._chart.ctx;
          var height2 = model.yPadding * 2;
          var width2 = 0;
          var body = model.body;
          var combinedBodyLength = body.reduce(function(count, bodyItem) {
            return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
          }, 0);
          combinedBodyLength += model.beforeBody.length + model.afterBody.length;
          var titleLineCount = model.title.length;
          var footerLineCount = model.footer.length;
          var titleFontSize = model.titleFontSize;
          var bodyFontSize = model.bodyFontSize;
          var footerFontSize = model.footerFontSize;
          height2 += titleLineCount * titleFontSize;
          height2 += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0;
          height2 += titleLineCount ? model.titleMarginBottom : 0;
          height2 += combinedBodyLength * bodyFontSize;
          height2 += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0;
          height2 += footerLineCount ? model.footerMarginTop : 0;
          height2 += footerLineCount * footerFontSize;
          height2 += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0;
          var widthPadding = 0;
          var maxLineWidth = function(line) {
            width2 = Math.max(width2, ctx.measureText(line).width + widthPadding);
          };
          ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
          helpers$1.each(model.title, maxLineWidth);
          ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
          helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
          widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
          helpers$1.each(body, function(bodyItem) {
            helpers$1.each(bodyItem.before, maxLineWidth);
            helpers$1.each(bodyItem.lines, maxLineWidth);
            helpers$1.each(bodyItem.after, maxLineWidth);
          });
          widthPadding = 0;
          ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
          helpers$1.each(model.footer, maxLineWidth);
          width2 += 2 * model.xPadding;
          return {
            width: width2,
            height: height2
          };
        }
        function determineAlignment(tooltip, size2) {
          var model = tooltip._model;
          var chart = tooltip._chart;
          var chartArea = tooltip._chart.chartArea;
          var xAlign = "center";
          var yAlign = "center";
          if (model.y < size2.height) {
            yAlign = "top";
          } else if (model.y > chart.height - size2.height) {
            yAlign = "bottom";
          }
          var lf2, rf2;
          var olf, orf;
          var yf2;
          var midX = (chartArea.left + chartArea.right) / 2;
          var midY = (chartArea.top + chartArea.bottom) / 2;
          if (yAlign === "center") {
            lf2 = function(x2) {
              return x2 <= midX;
            };
            rf2 = function(x2) {
              return x2 > midX;
            };
          } else {
            lf2 = function(x2) {
              return x2 <= size2.width / 2;
            };
            rf2 = function(x2) {
              return x2 >= chart.width - size2.width / 2;
            };
          }
          olf = function(x2) {
            return x2 + size2.width + model.caretSize + model.caretPadding > chart.width;
          };
          orf = function(x2) {
            return x2 - size2.width - model.caretSize - model.caretPadding < 0;
          };
          yf2 = function(y2) {
            return y2 <= midY ? "top" : "bottom";
          };
          if (lf2(model.x)) {
            xAlign = "left";
            if (olf(model.x)) {
              xAlign = "center";
              yAlign = yf2(model.y);
            }
          } else if (rf2(model.x)) {
            xAlign = "right";
            if (orf(model.x)) {
              xAlign = "center";
              yAlign = yf2(model.y);
            }
          }
          var opts = tooltip._options;
          return {
            xAlign: opts.xAlign ? opts.xAlign : xAlign,
            yAlign: opts.yAlign ? opts.yAlign : yAlign
          };
        }
        function getBackgroundPoint(vm, size2, alignment, chart) {
          var x2 = vm.x;
          var y2 = vm.y;
          var caretSize = vm.caretSize;
          var caretPadding = vm.caretPadding;
          var cornerRadius = vm.cornerRadius;
          var xAlign = alignment.xAlign;
          var yAlign = alignment.yAlign;
          var paddingAndSize = caretSize + caretPadding;
          var radiusAndPadding = cornerRadius + caretPadding;
          if (xAlign === "right") {
            x2 -= size2.width;
          } else if (xAlign === "center") {
            x2 -= size2.width / 2;
            if (x2 + size2.width > chart.width) {
              x2 = chart.width - size2.width;
            }
            if (x2 < 0) {
              x2 = 0;
            }
          }
          if (yAlign === "top") {
            y2 += paddingAndSize;
          } else if (yAlign === "bottom") {
            y2 -= size2.height + paddingAndSize;
          } else {
            y2 -= size2.height / 2;
          }
          if (yAlign === "center") {
            if (xAlign === "left") {
              x2 += paddingAndSize;
            } else if (xAlign === "right") {
              x2 -= paddingAndSize;
            }
          } else if (xAlign === "left") {
            x2 -= radiusAndPadding;
          } else if (xAlign === "right") {
            x2 += radiusAndPadding;
          }
          return {
            x: x2,
            y: y2
          };
        }
        function getAlignedX(vm, align) {
          return align === "center" ? vm.x + vm.width / 2 : align === "right" ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
        }
        function getBeforeAfterBodyLines(callback) {
          return pushOrConcat([], splitNewlines(callback));
        }
        var exports$4 = core_element.extend({
          initialize: function() {
            this._model = getBaseModel(this._options);
            this._lastActive = [];
          },
          getTitle: function() {
            var me2 = this;
            var opts = me2._options;
            var callbacks = opts.callbacks;
            var beforeTitle = callbacks.beforeTitle.apply(me2, arguments);
            var title2 = callbacks.title.apply(me2, arguments);
            var afterTitle = callbacks.afterTitle.apply(me2, arguments);
            var lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title2));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
          },
          getBeforeBody: function() {
            return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
          },
          getBody: function(tooltipItems, data) {
            var me2 = this;
            var callbacks = me2._options.callbacks;
            var bodyItems = [];
            helpers$1.each(tooltipItems, function(tooltipItem) {
              var bodyItem = {
                before: [],
                lines: [],
                after: []
              };
              pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me2, tooltipItem, data)));
              pushOrConcat(bodyItem.lines, callbacks.label.call(me2, tooltipItem, data));
              pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me2, tooltipItem, data)));
              bodyItems.push(bodyItem);
            });
            return bodyItems;
          },
          getAfterBody: function() {
            return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
          },
          getFooter: function() {
            var me2 = this;
            var callbacks = me2._options.callbacks;
            var beforeFooter = callbacks.beforeFooter.apply(me2, arguments);
            var footer = callbacks.footer.apply(me2, arguments);
            var afterFooter = callbacks.afterFooter.apply(me2, arguments);
            var lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
          },
          update: function(changed) {
            var me2 = this;
            var opts = me2._options;
            var existingModel = me2._model;
            var model = me2._model = getBaseModel(opts);
            var active = me2._active;
            var data = me2._data;
            var alignment = {
              xAlign: existingModel.xAlign,
              yAlign: existingModel.yAlign
            };
            var backgroundPoint = {
              x: existingModel.x,
              y: existingModel.y
            };
            var tooltipSize = {
              width: existingModel.width,
              height: existingModel.height
            };
            var tooltipPosition = {
              x: existingModel.caretX,
              y: existingModel.caretY
            };
            var i, len;
            if (active.length) {
              model.opacity = 1;
              var labelColors = [];
              var labelTextColors = [];
              tooltipPosition = positioners[opts.position].call(me2, active, me2._eventPosition);
              var tooltipItems = [];
              for (i = 0, len = active.length; i < len; ++i) {
                tooltipItems.push(createTooltipItem(active[i]));
              }
              if (opts.filter) {
                tooltipItems = tooltipItems.filter(function(a) {
                  return opts.filter(a, data);
                });
              }
              if (opts.itemSort) {
                tooltipItems = tooltipItems.sort(function(a, b) {
                  return opts.itemSort(a, b, data);
                });
              }
              helpers$1.each(tooltipItems, function(tooltipItem) {
                labelColors.push(opts.callbacks.labelColor.call(me2, tooltipItem, me2._chart));
                labelTextColors.push(opts.callbacks.labelTextColor.call(me2, tooltipItem, me2._chart));
              });
              model.title = me2.getTitle(tooltipItems, data);
              model.beforeBody = me2.getBeforeBody(tooltipItems, data);
              model.body = me2.getBody(tooltipItems, data);
              model.afterBody = me2.getAfterBody(tooltipItems, data);
              model.footer = me2.getFooter(tooltipItems, data);
              model.x = tooltipPosition.x;
              model.y = tooltipPosition.y;
              model.caretPadding = opts.caretPadding;
              model.labelColors = labelColors;
              model.labelTextColors = labelTextColors;
              model.dataPoints = tooltipItems;
              tooltipSize = getTooltipSize(this, model);
              alignment = determineAlignment(this, tooltipSize);
              backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me2._chart);
            } else {
              model.opacity = 0;
            }
            model.xAlign = alignment.xAlign;
            model.yAlign = alignment.yAlign;
            model.x = backgroundPoint.x;
            model.y = backgroundPoint.y;
            model.width = tooltipSize.width;
            model.height = tooltipSize.height;
            model.caretX = tooltipPosition.x;
            model.caretY = tooltipPosition.y;
            me2._model = model;
            if (changed && opts.custom) {
              opts.custom.call(me2, model);
            }
            return me2;
          },
          drawCaret: function(tooltipPoint, size2) {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var caretPosition = this.getCaretPosition(tooltipPoint, size2, vm);
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
          },
          getCaretPosition: function(tooltipPoint, size2, vm) {
            var x1, x2, x3, y1, y2, y3;
            var caretSize = vm.caretSize;
            var cornerRadius = vm.cornerRadius;
            var xAlign = vm.xAlign;
            var yAlign = vm.yAlign;
            var ptX = tooltipPoint.x;
            var ptY = tooltipPoint.y;
            var width2 = size2.width;
            var height2 = size2.height;
            if (yAlign === "center") {
              y2 = ptY + height2 / 2;
              if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                x3 = x1;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
              } else {
                x1 = ptX + width2;
                x2 = x1 + caretSize;
                x3 = x1;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
              }
            } else {
              if (xAlign === "left") {
                x2 = ptX + cornerRadius + caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else if (xAlign === "right") {
                x2 = ptX + width2 - cornerRadius - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else {
                x2 = vm.caretX;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              }
              if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                y3 = y1;
              } else {
                y1 = ptY + height2;
                y2 = y1 + caretSize;
                y3 = y1;
                var tmp = x3;
                x3 = x1;
                x1 = tmp;
              }
            }
            return { x1, x2, x3, y1, y2, y3 };
          },
          drawTitle: function(pt, vm, ctx) {
            var title2 = vm.title;
            var length = title2.length;
            var titleFontSize, titleSpacing, i;
            if (length) {
              var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
              pt.x = getAlignedX(vm, vm._titleAlign);
              ctx.textAlign = rtlHelper.textAlign(vm._titleAlign);
              ctx.textBaseline = "middle";
              titleFontSize = vm.titleFontSize;
              titleSpacing = vm.titleSpacing;
              ctx.fillStyle = vm.titleFontColor;
              ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
              for (i = 0; i < length; ++i) {
                ctx.fillText(title2[i], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);
                pt.y += titleFontSize + titleSpacing;
                if (i + 1 === length) {
                  pt.y += vm.titleMarginBottom - titleSpacing;
                }
              }
            }
          },
          drawBody: function(pt, vm, ctx) {
            var bodyFontSize = vm.bodyFontSize;
            var bodySpacing = vm.bodySpacing;
            var bodyAlign = vm._bodyAlign;
            var body = vm.body;
            var drawColorBoxes = vm.displayColors;
            var xLinePadding = 0;
            var colorX = drawColorBoxes ? getAlignedX(vm, "left") : 0;
            var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
            var fillLineOfText = function(line) {
              ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);
              pt.y += bodyFontSize + bodySpacing;
            };
            var bodyItem, textColor, labelColors, lines, i, j, ilen, jlen;
            var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = "middle";
            ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
            pt.x = getAlignedX(vm, bodyAlignForCalculation);
            ctx.fillStyle = vm.bodyFontColor;
            helpers$1.each(vm.beforeBody, fillLineOfText);
            xLinePadding = drawColorBoxes && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0;
            for (i = 0, ilen = body.length; i < ilen; ++i) {
              bodyItem = body[i];
              textColor = vm.labelTextColors[i];
              labelColors = vm.labelColors[i];
              ctx.fillStyle = textColor;
              helpers$1.each(bodyItem.before, fillLineOfText);
              lines = bodyItem.lines;
              for (j = 0, jlen = lines.length; j < jlen; ++j) {
                if (drawColorBoxes) {
                  var rtlColorX = rtlHelper.x(colorX);
                  ctx.fillStyle = vm.legendColorBackground;
                  ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                  ctx.lineWidth = 1;
                  ctx.strokeStyle = labelColors.borderColor;
                  ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                  ctx.fillStyle = labelColors.backgroundColor;
                  ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                  ctx.fillStyle = textColor;
                }
                fillLineOfText(lines[j]);
              }
              helpers$1.each(bodyItem.after, fillLineOfText);
            }
            xLinePadding = 0;
            helpers$1.each(vm.afterBody, fillLineOfText);
            pt.y -= bodySpacing;
          },
          drawFooter: function(pt, vm, ctx) {
            var footer = vm.footer;
            var length = footer.length;
            var footerFontSize, i;
            if (length) {
              var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
              pt.x = getAlignedX(vm, vm._footerAlign);
              pt.y += vm.footerMarginTop;
              ctx.textAlign = rtlHelper.textAlign(vm._footerAlign);
              ctx.textBaseline = "middle";
              footerFontSize = vm.footerFontSize;
              ctx.fillStyle = vm.footerFontColor;
              ctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
              for (i = 0; i < length; ++i) {
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);
                pt.y += footerFontSize + vm.footerSpacing;
              }
            }
          },
          drawBackground: function(pt, vm, ctx, tooltipSize) {
            ctx.fillStyle = vm.backgroundColor;
            ctx.strokeStyle = vm.borderColor;
            ctx.lineWidth = vm.borderWidth;
            var xAlign = vm.xAlign;
            var yAlign = vm.yAlign;
            var x2 = pt.x;
            var y2 = pt.y;
            var width2 = tooltipSize.width;
            var height2 = tooltipSize.height;
            var radius = vm.cornerRadius;
            ctx.beginPath();
            ctx.moveTo(x2 + radius, y2);
            if (yAlign === "top") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x2 + width2 - radius, y2);
            ctx.quadraticCurveTo(x2 + width2, y2, x2 + width2, y2 + radius);
            if (yAlign === "center" && xAlign === "right") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x2 + width2, y2 + height2 - radius);
            ctx.quadraticCurveTo(x2 + width2, y2 + height2, x2 + width2 - radius, y2 + height2);
            if (yAlign === "bottom") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x2 + radius, y2 + height2);
            ctx.quadraticCurveTo(x2, y2 + height2, x2, y2 + height2 - radius);
            if (yAlign === "center" && xAlign === "left") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x2, y2 + radius);
            ctx.quadraticCurveTo(x2, y2, x2 + radius, y2);
            ctx.closePath();
            ctx.fill();
            if (vm.borderWidth > 0) {
              ctx.stroke();
            }
          },
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            if (vm.opacity === 0) {
              return;
            }
            var tooltipSize = {
              width: vm.width,
              height: vm.height
            };
            var pt = {
              x: vm.x,
              y: vm.y
            };
            var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;
            var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
            if (this._options.enabled && hasTooltipContent) {
              ctx.save();
              ctx.globalAlpha = opacity;
              this.drawBackground(pt, vm, ctx, tooltipSize);
              pt.y += vm.yPadding;
              helpers$1.rtl.overrideTextDirection(ctx, vm.textDirection);
              this.drawTitle(pt, vm, ctx);
              this.drawBody(pt, vm, ctx);
              this.drawFooter(pt, vm, ctx);
              helpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);
              ctx.restore();
            }
          },
          handleEvent: function(e) {
            var me2 = this;
            var options2 = me2._options;
            var changed = false;
            me2._lastActive = me2._lastActive || [];
            if (e.type === "mouseout") {
              me2._active = [];
            } else {
              me2._active = me2._chart.getElementsAtEventForMode(e, options2.mode, options2);
              if (options2.reverse) {
                me2._active.reverse();
              }
            }
            changed = !helpers$1.arrayEquals(me2._active, me2._lastActive);
            if (changed) {
              me2._lastActive = me2._active;
              if (options2.enabled || options2.custom) {
                me2._eventPosition = {
                  x: e.x,
                  y: e.y
                };
                me2.update(true);
                me2.pivot();
              }
            }
            return changed;
          }
        });
        var positioners_1 = positioners;
        var core_tooltip = exports$4;
        core_tooltip.positioners = positioners_1;
        var valueOrDefault$9 = helpers$1.valueOrDefault;
        core_defaults._set("global", {
          elements: {},
          events: [
            "mousemove",
            "mouseout",
            "click",
            "touchstart",
            "touchmove"
          ],
          hover: {
            onHover: null,
            mode: "nearest",
            intersect: true,
            animationDuration: 400
          },
          onClick: null,
          maintainAspectRatio: true,
          responsive: true,
          responsiveAnimationDuration: 0
        });
        function mergeScaleConfig() {
          return helpers$1.merge(/* @__PURE__ */ Object.create(null), [].slice.call(arguments), {
            merger: function(key, target, source, options2) {
              if (key === "xAxes" || key === "yAxes") {
                var slen = source[key].length;
                var i, type, scale2;
                if (!target[key]) {
                  target[key] = [];
                }
                for (i = 0; i < slen; ++i) {
                  scale2 = source[key][i];
                  type = valueOrDefault$9(scale2.type, key === "xAxes" ? "category" : "linear");
                  if (i >= target[key].length) {
                    target[key].push({});
                  }
                  if (!target[key][i].type || scale2.type && scale2.type !== target[key][i].type) {
                    helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale2]);
                  } else {
                    helpers$1.merge(target[key][i], scale2);
                  }
                }
              } else {
                helpers$1._merger(key, target, source, options2);
              }
            }
          });
        }
        function mergeConfig2() {
          return helpers$1.merge(/* @__PURE__ */ Object.create(null), [].slice.call(arguments), {
            merger: function(key, target, source, options2) {
              var tval = target[key] || /* @__PURE__ */ Object.create(null);
              var sval = source[key];
              if (key === "scales") {
                target[key] = mergeScaleConfig(tval, sval);
              } else if (key === "scale") {
                target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
              } else {
                helpers$1._merger(key, target, source, options2);
              }
            }
          });
        }
        function initConfig(config) {
          config = config || /* @__PURE__ */ Object.create(null);
          var data = config.data = config.data || {};
          data.datasets = data.datasets || [];
          data.labels = data.labels || [];
          config.options = mergeConfig2(
            core_defaults.global,
            core_defaults[config.type],
            config.options || {}
          );
          return config;
        }
        function updateConfig(chart) {
          var newOptions = chart.options;
          helpers$1.each(chart.scales, function(scale2) {
            core_layouts.removeBox(chart, scale2);
          });
          newOptions = mergeConfig2(
            core_defaults.global,
            core_defaults[chart.config.type],
            newOptions
          );
          chart.options = chart.config.options = newOptions;
          chart.ensureScalesHaveIDs();
          chart.buildOrUpdateScales();
          chart.tooltip._options = newOptions.tooltips;
          chart.tooltip.initialize();
        }
        function nextAvailableScaleId(axesOpts, prefix, index2) {
          var id2;
          var hasId = function(obj) {
            return obj.id === id2;
          };
          do {
            id2 = prefix + index2++;
          } while (helpers$1.findIndex(axesOpts, hasId) >= 0);
          return id2;
        }
        function positionIsHorizontal(position) {
          return position === "top" || position === "bottom";
        }
        function compare2Level(l1, l2) {
          return function(a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
          };
        }
        var Chart2 = function(item, config) {
          this.construct(item, config);
          return this;
        };
        helpers$1.extend(Chart2.prototype, {
          construct: function(item, config) {
            var me2 = this;
            config = initConfig(config);
            var context2 = platform.acquireContext(item, config);
            var canvas3 = context2 && context2.canvas;
            var height2 = canvas3 && canvas3.height;
            var width2 = canvas3 && canvas3.width;
            me2.id = helpers$1.uid();
            me2.ctx = context2;
            me2.canvas = canvas3;
            me2.config = config;
            me2.width = width2;
            me2.height = height2;
            me2.aspectRatio = height2 ? width2 / height2 : null;
            me2.options = config.options;
            me2._bufferedRender = false;
            me2._layers = [];
            me2.chart = me2;
            me2.controller = me2;
            Chart2.instances[me2.id] = me2;
            Object.defineProperty(me2, "data", {
              get: function() {
                return me2.config.data;
              },
              set: function(value2) {
                me2.config.data = value2;
              }
            });
            if (!context2 || !canvas3) {
              console.error("Failed to create chart: can't acquire context from the given item");
              return;
            }
            me2.initialize();
            me2.update();
          },
          initialize: function() {
            var me2 = this;
            core_plugins.notify(me2, "beforeInit");
            helpers$1.retinaScale(me2, me2.options.devicePixelRatio);
            me2.bindEvents();
            if (me2.options.responsive) {
              me2.resize(true);
            }
            me2.initToolTip();
            core_plugins.notify(me2, "afterInit");
            return me2;
          },
          clear: function() {
            helpers$1.canvas.clear(this);
            return this;
          },
          stop: function() {
            core_animations.cancelAnimation(this);
            return this;
          },
          resize: function(silent) {
            var me2 = this;
            var options2 = me2.options;
            var canvas3 = me2.canvas;
            var aspectRatio = options2.maintainAspectRatio && me2.aspectRatio || null;
            var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas3)));
            var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas3)));
            if (me2.width === newWidth && me2.height === newHeight) {
              return;
            }
            canvas3.width = me2.width = newWidth;
            canvas3.height = me2.height = newHeight;
            canvas3.style.width = newWidth + "px";
            canvas3.style.height = newHeight + "px";
            helpers$1.retinaScale(me2, options2.devicePixelRatio);
            if (!silent) {
              var newSize = { width: newWidth, height: newHeight };
              core_plugins.notify(me2, "resize", [newSize]);
              if (options2.onResize) {
                options2.onResize(me2, newSize);
              }
              me2.stop();
              me2.update({
                duration: options2.responsiveAnimationDuration
              });
            }
          },
          ensureScalesHaveIDs: function() {
            var options2 = this.options;
            var scalesOptions = options2.scales || {};
            var scaleOptions = options2.scale;
            helpers$1.each(scalesOptions.xAxes, function(xAxisOptions, index2) {
              if (!xAxisOptions.id) {
                xAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, "x-axis-", index2);
              }
            });
            helpers$1.each(scalesOptions.yAxes, function(yAxisOptions, index2) {
              if (!yAxisOptions.id) {
                yAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, "y-axis-", index2);
              }
            });
            if (scaleOptions) {
              scaleOptions.id = scaleOptions.id || "scale";
            }
          },
          buildOrUpdateScales: function() {
            var me2 = this;
            var options2 = me2.options;
            var scales2 = me2.scales || {};
            var items2 = [];
            var updated = Object.keys(scales2).reduce(function(obj, id2) {
              obj[id2] = false;
              return obj;
            }, {});
            if (options2.scales) {
              items2 = items2.concat(
                (options2.scales.xAxes || []).map(function(xAxisOptions) {
                  return { options: xAxisOptions, dtype: "category", dposition: "bottom" };
                }),
                (options2.scales.yAxes || []).map(function(yAxisOptions) {
                  return { options: yAxisOptions, dtype: "linear", dposition: "left" };
                })
              );
            }
            if (options2.scale) {
              items2.push({
                options: options2.scale,
                dtype: "radialLinear",
                isDefault: true,
                dposition: "chartArea"
              });
            }
            helpers$1.each(items2, function(item) {
              var scaleOptions = item.options;
              var id2 = scaleOptions.id;
              var scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);
              if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
                scaleOptions.position = item.dposition;
              }
              updated[id2] = true;
              var scale2 = null;
              if (id2 in scales2 && scales2[id2].type === scaleType) {
                scale2 = scales2[id2];
                scale2.options = scaleOptions;
                scale2.ctx = me2.ctx;
                scale2.chart = me2;
              } else {
                var scaleClass = core_scaleService.getScaleConstructor(scaleType);
                if (!scaleClass) {
                  return;
                }
                scale2 = new scaleClass({
                  id: id2,
                  type: scaleType,
                  options: scaleOptions,
                  ctx: me2.ctx,
                  chart: me2
                });
                scales2[scale2.id] = scale2;
              }
              scale2.mergeTicksOptions();
              if (item.isDefault) {
                me2.scale = scale2;
              }
            });
            helpers$1.each(updated, function(hasUpdated, id2) {
              if (!hasUpdated) {
                delete scales2[id2];
              }
            });
            me2.scales = scales2;
            core_scaleService.addScalesToLayout(this);
          },
          buildOrUpdateControllers: function() {
            var me2 = this;
            var newControllers = [];
            var datasets = me2.data.datasets;
            var i, ilen;
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              var dataset = datasets[i];
              var meta = me2.getDatasetMeta(i);
              var type = dataset.type || me2.config.type;
              if (meta.type && meta.type !== type) {
                me2.destroyDatasetMeta(i);
                meta = me2.getDatasetMeta(i);
              }
              meta.type = type;
              meta.order = dataset.order || 0;
              meta.index = i;
              if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
              } else {
                var ControllerClass = controllers[meta.type];
                if (ControllerClass === void 0) {
                  throw new Error('"' + meta.type + '" is not a chart type.');
                }
                meta.controller = new ControllerClass(me2, i);
                newControllers.push(meta.controller);
              }
            }
            return newControllers;
          },
          resetElements: function() {
            var me2 = this;
            helpers$1.each(me2.data.datasets, function(dataset, datasetIndex) {
              me2.getDatasetMeta(datasetIndex).controller.reset();
            }, me2);
          },
          reset: function() {
            this.resetElements();
            this.tooltip.initialize();
          },
          update: function(config) {
            var me2 = this;
            var i, ilen;
            if (!config || typeof config !== "object") {
              config = {
                duration: config,
                lazy: arguments[1]
              };
            }
            updateConfig(me2);
            core_plugins._invalidate(me2);
            if (core_plugins.notify(me2, "beforeUpdate") === false) {
              return;
            }
            me2.tooltip._data = me2.data;
            var newControllers = me2.buildOrUpdateControllers();
            for (i = 0, ilen = me2.data.datasets.length; i < ilen; i++) {
              me2.getDatasetMeta(i).controller.buildOrUpdateElements();
            }
            me2.updateLayout();
            if (me2.options.animation && me2.options.animation.duration) {
              helpers$1.each(newControllers, function(controller) {
                controller.reset();
              });
            }
            me2.updateDatasets();
            me2.tooltip.initialize();
            me2.lastActive = [];
            core_plugins.notify(me2, "afterUpdate");
            me2._layers.sort(compare2Level("z", "_idx"));
            if (me2._bufferedRender) {
              me2._bufferedRequest = {
                duration: config.duration,
                easing: config.easing,
                lazy: config.lazy
              };
            } else {
              me2.render(config);
            }
          },
          updateLayout: function() {
            var me2 = this;
            if (core_plugins.notify(me2, "beforeLayout") === false) {
              return;
            }
            core_layouts.update(this, this.width, this.height);
            me2._layers = [];
            helpers$1.each(me2.boxes, function(box) {
              if (box._configure) {
                box._configure();
              }
              me2._layers.push.apply(me2._layers, box._layers());
            }, me2);
            me2._layers.forEach(function(item, index2) {
              item._idx = index2;
            });
            core_plugins.notify(me2, "afterScaleUpdate");
            core_plugins.notify(me2, "afterLayout");
          },
          updateDatasets: function() {
            var me2 = this;
            if (core_plugins.notify(me2, "beforeDatasetsUpdate") === false) {
              return;
            }
            for (var i = 0, ilen = me2.data.datasets.length; i < ilen; ++i) {
              me2.updateDataset(i);
            }
            core_plugins.notify(me2, "afterDatasetsUpdate");
          },
          updateDataset: function(index2) {
            var me2 = this;
            var meta = me2.getDatasetMeta(index2);
            var args = {
              meta,
              index: index2
            };
            if (core_plugins.notify(me2, "beforeDatasetUpdate", [args]) === false) {
              return;
            }
            meta.controller._update();
            core_plugins.notify(me2, "afterDatasetUpdate", [args]);
          },
          render: function(config) {
            var me2 = this;
            if (!config || typeof config !== "object") {
              config = {
                duration: config,
                lazy: arguments[1]
              };
            }
            var animationOptions = me2.options.animation;
            var duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);
            var lazy = config.lazy;
            if (core_plugins.notify(me2, "beforeRender") === false) {
              return;
            }
            var onComplete = function(animation2) {
              core_plugins.notify(me2, "afterRender");
              helpers$1.callback(animationOptions && animationOptions.onComplete, [animation2], me2);
            };
            if (animationOptions && duration) {
              var animation = new core_animation({
                numSteps: duration / 16.66,
                easing: config.easing || animationOptions.easing,
                render: function(chart, animationObject) {
                  var easingFunction = helpers$1.easing.effects[animationObject.easing];
                  var currentStep = animationObject.currentStep;
                  var stepDecimal = currentStep / animationObject.numSteps;
                  chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
                },
                onAnimationProgress: animationOptions.onProgress,
                onAnimationComplete: onComplete
              });
              core_animations.addAnimation(me2, animation, duration, lazy);
            } else {
              me2.draw();
              onComplete(new core_animation({ numSteps: 0, chart: me2 }));
            }
            return me2;
          },
          draw: function(easingValue) {
            var me2 = this;
            var i, layers;
            me2.clear();
            if (helpers$1.isNullOrUndef(easingValue)) {
              easingValue = 1;
            }
            me2.transition(easingValue);
            if (me2.width <= 0 || me2.height <= 0) {
              return;
            }
            if (core_plugins.notify(me2, "beforeDraw", [easingValue]) === false) {
              return;
            }
            layers = me2._layers;
            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
              layers[i].draw(me2.chartArea);
            }
            me2.drawDatasets(easingValue);
            for (; i < layers.length; ++i) {
              layers[i].draw(me2.chartArea);
            }
            me2._drawTooltip(easingValue);
            core_plugins.notify(me2, "afterDraw", [easingValue]);
          },
          transition: function(easingValue) {
            var me2 = this;
            for (var i = 0, ilen = (me2.data.datasets || []).length; i < ilen; ++i) {
              if (me2.isDatasetVisible(i)) {
                me2.getDatasetMeta(i).controller.transition(easingValue);
              }
            }
            me2.tooltip.transition(easingValue);
          },
          _getSortedDatasetMetas: function(filterVisible) {
            var me2 = this;
            var datasets = me2.data.datasets || [];
            var result2 = [];
            var i, ilen;
            for (i = 0, ilen = datasets.length; i < ilen; ++i) {
              if (!filterVisible || me2.isDatasetVisible(i)) {
                result2.push(me2.getDatasetMeta(i));
              }
            }
            result2.sort(compare2Level("order", "index"));
            return result2;
          },
          _getSortedVisibleDatasetMetas: function() {
            return this._getSortedDatasetMetas(true);
          },
          drawDatasets: function(easingValue) {
            var me2 = this;
            var metasets, i;
            if (core_plugins.notify(me2, "beforeDatasetsDraw", [easingValue]) === false) {
              return;
            }
            metasets = me2._getSortedVisibleDatasetMetas();
            for (i = metasets.length - 1; i >= 0; --i) {
              me2.drawDataset(metasets[i], easingValue);
            }
            core_plugins.notify(me2, "afterDatasetsDraw", [easingValue]);
          },
          drawDataset: function(meta, easingValue) {
            var me2 = this;
            var args = {
              meta,
              index: meta.index,
              easingValue
            };
            if (core_plugins.notify(me2, "beforeDatasetDraw", [args]) === false) {
              return;
            }
            meta.controller.draw(easingValue);
            core_plugins.notify(me2, "afterDatasetDraw", [args]);
          },
          _drawTooltip: function(easingValue) {
            var me2 = this;
            var tooltip = me2.tooltip;
            var args = {
              tooltip,
              easingValue
            };
            if (core_plugins.notify(me2, "beforeTooltipDraw", [args]) === false) {
              return;
            }
            tooltip.draw();
            core_plugins.notify(me2, "afterTooltipDraw", [args]);
          },
          getElementAtEvent: function(e) {
            return core_interaction.modes.single(this, e);
          },
          getElementsAtEvent: function(e) {
            return core_interaction.modes.label(this, e, { intersect: true });
          },
          getElementsAtXAxis: function(e) {
            return core_interaction.modes["x-axis"](this, e, { intersect: true });
          },
          getElementsAtEventForMode: function(e, mode, options2) {
            var method = core_interaction.modes[mode];
            if (typeof method === "function") {
              return method(this, e, options2);
            }
            return [];
          },
          getDatasetAtEvent: function(e) {
            return core_interaction.modes.dataset(this, e, { intersect: true });
          },
          getDatasetMeta: function(datasetIndex) {
            var me2 = this;
            var dataset = me2.data.datasets[datasetIndex];
            if (!dataset._meta) {
              dataset._meta = {};
            }
            var meta = dataset._meta[me2.id];
            if (!meta) {
              meta = dataset._meta[me2.id] = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset.order || 0,
                index: datasetIndex
              };
            }
            return meta;
          },
          getVisibleDatasetCount: function() {
            var count = 0;
            for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              if (this.isDatasetVisible(i)) {
                count++;
              }
            }
            return count;
          },
          isDatasetVisible: function(datasetIndex) {
            var meta = this.getDatasetMeta(datasetIndex);
            return typeof meta.hidden === "boolean" ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
          },
          generateLegend: function() {
            return this.options.legendCallback(this);
          },
          destroyDatasetMeta: function(datasetIndex) {
            var id2 = this.id;
            var dataset = this.data.datasets[datasetIndex];
            var meta = dataset._meta && dataset._meta[id2];
            if (meta) {
              meta.controller.destroy();
              delete dataset._meta[id2];
            }
          },
          destroy: function() {
            var me2 = this;
            var canvas3 = me2.canvas;
            var i, ilen;
            me2.stop();
            for (i = 0, ilen = me2.data.datasets.length; i < ilen; ++i) {
              me2.destroyDatasetMeta(i);
            }
            if (canvas3) {
              me2.unbindEvents();
              helpers$1.canvas.clear(me2);
              platform.releaseContext(me2.ctx);
              me2.canvas = null;
              me2.ctx = null;
            }
            core_plugins.notify(me2, "destroy");
            delete Chart2.instances[me2.id];
          },
          toBase64Image: function() {
            return this.canvas.toDataURL.apply(this.canvas, arguments);
          },
          initToolTip: function() {
            var me2 = this;
            me2.tooltip = new core_tooltip({
              _chart: me2,
              _chartInstance: me2,
              _data: me2.data,
              _options: me2.options.tooltips
            }, me2);
          },
          bindEvents: function() {
            var me2 = this;
            var listeners = me2._listeners = {};
            var listener = function() {
              me2.eventHandler.apply(me2, arguments);
            };
            helpers$1.each(me2.options.events, function(type) {
              platform.addEventListener(me2, type, listener);
              listeners[type] = listener;
            });
            if (me2.options.responsive) {
              listener = function() {
                me2.resize();
              };
              platform.addEventListener(me2, "resize", listener);
              listeners.resize = listener;
            }
          },
          unbindEvents: function() {
            var me2 = this;
            var listeners = me2._listeners;
            if (!listeners) {
              return;
            }
            delete me2._listeners;
            helpers$1.each(listeners, function(listener, type) {
              platform.removeEventListener(me2, type, listener);
            });
          },
          updateHoverStyle: function(elements2, mode, enabled) {
            var prefix = enabled ? "set" : "remove";
            var element, i, ilen;
            for (i = 0, ilen = elements2.length; i < ilen; ++i) {
              element = elements2[i];
              if (element) {
                this.getDatasetMeta(element._datasetIndex).controller[prefix + "HoverStyle"](element);
              }
            }
            if (mode === "dataset") {
              this.getDatasetMeta(elements2[0]._datasetIndex).controller["_" + prefix + "DatasetHoverStyle"]();
            }
          },
          eventHandler: function(e) {
            var me2 = this;
            var tooltip = me2.tooltip;
            if (core_plugins.notify(me2, "beforeEvent", [e]) === false) {
              return;
            }
            me2._bufferedRender = true;
            me2._bufferedRequest = null;
            var changed = me2.handleEvent(e);
            if (tooltip) {
              changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
            }
            core_plugins.notify(me2, "afterEvent", [e]);
            var bufferedRequest = me2._bufferedRequest;
            if (bufferedRequest) {
              me2.render(bufferedRequest);
            } else if (changed && !me2.animating) {
              me2.stop();
              me2.render({
                duration: me2.options.hover.animationDuration,
                lazy: true
              });
            }
            me2._bufferedRender = false;
            me2._bufferedRequest = null;
            return me2;
          },
          handleEvent: function(e) {
            var me2 = this;
            var options2 = me2.options || {};
            var hoverOptions = options2.hover;
            var changed = false;
            me2.lastActive = me2.lastActive || [];
            if (e.type === "mouseout") {
              me2.active = [];
            } else {
              me2.active = me2.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
            }
            helpers$1.callback(options2.onHover || options2.hover.onHover, [e.native, me2.active], me2);
            if (e.type === "mouseup" || e.type === "click") {
              if (options2.onClick) {
                options2.onClick.call(me2, e.native, me2.active);
              }
            }
            if (me2.lastActive.length) {
              me2.updateHoverStyle(me2.lastActive, hoverOptions.mode, false);
            }
            if (me2.active.length && hoverOptions.mode) {
              me2.updateHoverStyle(me2.active, hoverOptions.mode, true);
            }
            changed = !helpers$1.arrayEquals(me2.active, me2.lastActive);
            me2.lastActive = me2.active;
            return changed;
          }
        });
        Chart2.instances = {};
        var core_controller = Chart2;
        Chart2.Controller = Chart2;
        Chart2.types = {};
        helpers$1.configMerge = mergeConfig2;
        helpers$1.scaleMerge = mergeScaleConfig;
        var core_helpers = function() {
          helpers$1.where = function(collection, filterCallback) {
            if (helpers$1.isArray(collection) && Array.prototype.filter) {
              return collection.filter(filterCallback);
            }
            var filtered = [];
            helpers$1.each(collection, function(item) {
              if (filterCallback(item)) {
                filtered.push(item);
              }
            });
            return filtered;
          };
          helpers$1.findIndex = Array.prototype.findIndex ? function(array, callback, scope) {
            return array.findIndex(callback, scope);
          } : function(array, callback, scope) {
            scope = scope === void 0 ? array : scope;
            for (var i = 0, ilen = array.length; i < ilen; ++i) {
              if (callback.call(scope, array[i], i, array)) {
                return i;
              }
            }
            return -1;
          };
          helpers$1.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
            if (helpers$1.isNullOrUndef(startIndex)) {
              startIndex = -1;
            }
            for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
              var currentItem = arrayToSearch[i];
              if (filterCallback(currentItem)) {
                return currentItem;
              }
            }
          };
          helpers$1.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
            if (helpers$1.isNullOrUndef(startIndex)) {
              startIndex = arrayToSearch.length;
            }
            for (var i = startIndex - 1; i >= 0; i--) {
              var currentItem = arrayToSearch[i];
              if (filterCallback(currentItem)) {
                return currentItem;
              }
            }
          };
          helpers$1.isNumber = function(n2) {
            return !isNaN(parseFloat(n2)) && isFinite(n2);
          };
          helpers$1.almostEquals = function(x2, y2, epsilon) {
            return Math.abs(x2 - y2) < epsilon;
          };
          helpers$1.almostWhole = function(x2, epsilon) {
            var rounded = Math.round(x2);
            return rounded - epsilon <= x2 && rounded + epsilon >= x2;
          };
          helpers$1.max = function(array) {
            return array.reduce(function(max2, value2) {
              if (!isNaN(value2)) {
                return Math.max(max2, value2);
              }
              return max2;
            }, Number.NEGATIVE_INFINITY);
          };
          helpers$1.min = function(array) {
            return array.reduce(function(min2, value2) {
              if (!isNaN(value2)) {
                return Math.min(min2, value2);
              }
              return min2;
            }, Number.POSITIVE_INFINITY);
          };
          helpers$1.sign = Math.sign ? function(x2) {
            return Math.sign(x2);
          } : function(x2) {
            x2 = +x2;
            if (x2 === 0 || isNaN(x2)) {
              return x2;
            }
            return x2 > 0 ? 1 : -1;
          };
          helpers$1.toRadians = function(degrees) {
            return degrees * (Math.PI / 180);
          };
          helpers$1.toDegrees = function(radians) {
            return radians * (180 / Math.PI);
          };
          helpers$1._decimalPlaces = function(x2) {
            if (!helpers$1.isFinite(x2)) {
              return;
            }
            var e = 1;
            var p2 = 0;
            while (Math.round(x2 * e) / e !== x2) {
              e *= 10;
              p2++;
            }
            return p2;
          };
          helpers$1.getAngleFromPoint = function(centrePoint, anglePoint) {
            var distanceFromXCenter = anglePoint.x - centrePoint.x;
            var distanceFromYCenter = anglePoint.y - centrePoint.y;
            var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
            var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
            if (angle < -0.5 * Math.PI) {
              angle += 2 * Math.PI;
            }
            return {
              angle,
              distance: radialDistanceFromCenter
            };
          };
          helpers$1.distanceBetweenPoints = function(pt1, pt2) {
            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
          };
          helpers$1.aliasPixel = function(pixelWidth) {
            return pixelWidth % 2 === 0 ? 0 : 0.5;
          };
          helpers$1._alignPixel = function(chart, pixel, width2) {
            var devicePixelRatio = chart.currentDevicePixelRatio;
            var halfWidth = width2 / 2;
            return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
          };
          helpers$1.splineCurve = function(firstPoint, middlePoint, afterPoint, t2) {
            var previous = firstPoint.skip ? middlePoint : firstPoint;
            var current = middlePoint;
            var next = afterPoint.skip ? middlePoint : afterPoint;
            var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
            var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
            var s01 = d01 / (d01 + d12);
            var s12 = d12 / (d01 + d12);
            s01 = isNaN(s01) ? 0 : s01;
            s12 = isNaN(s12) ? 0 : s12;
            var fa2 = t2 * s01;
            var fb2 = t2 * s12;
            return {
              previous: {
                x: current.x - fa2 * (next.x - previous.x),
                y: current.y - fa2 * (next.y - previous.y)
              },
              next: {
                x: current.x + fb2 * (next.x - previous.x),
                y: current.y + fb2 * (next.y - previous.y)
              }
            };
          };
          helpers$1.EPSILON = Number.EPSILON || 1e-14;
          helpers$1.splineCurveMonotone = function(points) {
            var pointsWithTangents = (points || []).map(function(point) {
              return {
                model: point._model,
                deltaK: 0,
                mK: 0
              };
            });
            var pointsLen = pointsWithTangents.length;
            var i, pointBefore, pointCurrent, pointAfter;
            for (i = 0; i < pointsLen; ++i) {
              pointCurrent = pointsWithTangents[i];
              if (pointCurrent.model.skip) {
                continue;
              }
              pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
              pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
              if (pointAfter && !pointAfter.model.skip) {
                var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;
                pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
              }
              if (!pointBefore || pointBefore.model.skip) {
                pointCurrent.mK = pointCurrent.deltaK;
              } else if (!pointAfter || pointAfter.model.skip) {
                pointCurrent.mK = pointBefore.deltaK;
              } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
                pointCurrent.mK = 0;
              } else {
                pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
              }
            }
            var alphaK, betaK, tauK, squaredMagnitude;
            for (i = 0; i < pointsLen - 1; ++i) {
              pointCurrent = pointsWithTangents[i];
              pointAfter = pointsWithTangents[i + 1];
              if (pointCurrent.model.skip || pointAfter.model.skip) {
                continue;
              }
              if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
                pointCurrent.mK = pointAfter.mK = 0;
                continue;
              }
              alphaK = pointCurrent.mK / pointCurrent.deltaK;
              betaK = pointAfter.mK / pointCurrent.deltaK;
              squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
              if (squaredMagnitude <= 9) {
                continue;
              }
              tauK = 3 / Math.sqrt(squaredMagnitude);
              pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
              pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
            }
            var deltaX;
            for (i = 0; i < pointsLen; ++i) {
              pointCurrent = pointsWithTangents[i];
              if (pointCurrent.model.skip) {
                continue;
              }
              pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
              pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
              if (pointBefore && !pointBefore.model.skip) {
                deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
                pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
                pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
              }
              if (pointAfter && !pointAfter.model.skip) {
                deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
                pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
                pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
              }
            }
          };
          helpers$1.nextItem = function(collection, index2, loop) {
            if (loop) {
              return index2 >= collection.length - 1 ? collection[0] : collection[index2 + 1];
            }
            return index2 >= collection.length - 1 ? collection[collection.length - 1] : collection[index2 + 1];
          };
          helpers$1.previousItem = function(collection, index2, loop) {
            if (loop) {
              return index2 <= 0 ? collection[collection.length - 1] : collection[index2 - 1];
            }
            return index2 <= 0 ? collection[0] : collection[index2 - 1];
          };
          helpers$1.niceNum = function(range2, round2) {
            var exponent = Math.floor(helpers$1.log10(range2));
            var fraction = range2 / Math.pow(10, exponent);
            var niceFraction;
            if (round2) {
              if (fraction < 1.5) {
                niceFraction = 1;
              } else if (fraction < 3) {
                niceFraction = 2;
              } else if (fraction < 7) {
                niceFraction = 5;
              } else {
                niceFraction = 10;
              }
            } else if (fraction <= 1) {
              niceFraction = 1;
            } else if (fraction <= 2) {
              niceFraction = 2;
            } else if (fraction <= 5) {
              niceFraction = 5;
            } else {
              niceFraction = 10;
            }
            return niceFraction * Math.pow(10, exponent);
          };
          helpers$1.requestAnimFrame = function() {
            if (typeof window === "undefined") {
              return function(callback) {
                callback();
              };
            }
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
              return window.setTimeout(callback, 1e3 / 60);
            };
          }();
          helpers$1.getRelativePosition = function(evt, chart) {
            var mouseX, mouseY;
            var e = evt.originalEvent || evt;
            var canvas3 = evt.target || evt.srcElement;
            var boundingRect = canvas3.getBoundingClientRect();
            var touches = e.touches;
            if (touches && touches.length > 0) {
              mouseX = touches[0].clientX;
              mouseY = touches[0].clientY;
            } else {
              mouseX = e.clientX;
              mouseY = e.clientY;
            }
            var paddingLeft = parseFloat(helpers$1.getStyle(canvas3, "padding-left"));
            var paddingTop = parseFloat(helpers$1.getStyle(canvas3, "padding-top"));
            var paddingRight = parseFloat(helpers$1.getStyle(canvas3, "padding-right"));
            var paddingBottom = parseFloat(helpers$1.getStyle(canvas3, "padding-bottom"));
            var width2 = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
            var height2 = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
            mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width2 * canvas3.width / chart.currentDevicePixelRatio);
            mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height2 * canvas3.height / chart.currentDevicePixelRatio);
            return {
              x: mouseX,
              y: mouseY
            };
          };
          function parseMaxStyle(styleValue, node, parentProperty) {
            var valueInPixels;
            if (typeof styleValue === "string") {
              valueInPixels = parseInt(styleValue, 10);
              if (styleValue.indexOf("%") !== -1) {
                valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
              }
            } else {
              valueInPixels = styleValue;
            }
            return valueInPixels;
          }
          function isConstrainedValue(value2) {
            return value2 !== void 0 && value2 !== null && value2 !== "none";
          }
          function getConstraintDimension(domNode, maxStyle, percentageProperty) {
            var view = document.defaultView;
            var parentNode = helpers$1._getParentNode(domNode);
            var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
            var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
            var hasCNode = isConstrainedValue(constrainedNode);
            var hasCContainer = isConstrainedValue(constrainedContainer);
            var infinity = Number.POSITIVE_INFINITY;
            if (hasCNode || hasCContainer) {
              return Math.min(
                hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
                hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity
              );
            }
            return "none";
          }
          helpers$1.getConstraintWidth = function(domNode) {
            return getConstraintDimension(domNode, "max-width", "clientWidth");
          };
          helpers$1.getConstraintHeight = function(domNode) {
            return getConstraintDimension(domNode, "max-height", "clientHeight");
          };
          helpers$1._calculatePadding = function(container, padding, parentDimension) {
            padding = helpers$1.getStyle(container, padding);
            return padding.indexOf("%") > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
          };
          helpers$1._getParentNode = function(domNode) {
            var parent = domNode.parentNode;
            if (parent && parent.toString() === "[object ShadowRoot]") {
              parent = parent.host;
            }
            return parent;
          };
          helpers$1.getMaximumWidth = function(domNode) {
            var container = helpers$1._getParentNode(domNode);
            if (!container) {
              return domNode.clientWidth;
            }
            var clientWidth = container.clientWidth;
            var paddingLeft = helpers$1._calculatePadding(container, "padding-left", clientWidth);
            var paddingRight = helpers$1._calculatePadding(container, "padding-right", clientWidth);
            var w2 = clientWidth - paddingLeft - paddingRight;
            var cw = helpers$1.getConstraintWidth(domNode);
            return isNaN(cw) ? w2 : Math.min(w2, cw);
          };
          helpers$1.getMaximumHeight = function(domNode) {
            var container = helpers$1._getParentNode(domNode);
            if (!container) {
              return domNode.clientHeight;
            }
            var clientHeight = container.clientHeight;
            var paddingTop = helpers$1._calculatePadding(container, "padding-top", clientHeight);
            var paddingBottom = helpers$1._calculatePadding(container, "padding-bottom", clientHeight);
            var h2 = clientHeight - paddingTop - paddingBottom;
            var ch2 = helpers$1.getConstraintHeight(domNode);
            return isNaN(ch2) ? h2 : Math.min(h2, ch2);
          };
          helpers$1.getStyle = function(el, property2) {
            return el.currentStyle ? el.currentStyle[property2] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property2);
          };
          helpers$1.retinaScale = function(chart, forceRatio) {
            var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== "undefined" && window.devicePixelRatio || 1;
            if (pixelRatio === 1) {
              return;
            }
            var canvas3 = chart.canvas;
            var height2 = chart.height;
            var width2 = chart.width;
            canvas3.height = height2 * pixelRatio;
            canvas3.width = width2 * pixelRatio;
            chart.ctx.scale(pixelRatio, pixelRatio);
            if (!canvas3.style.height && !canvas3.style.width) {
              canvas3.style.height = height2 + "px";
              canvas3.style.width = width2 + "px";
            }
          };
          helpers$1.fontString = function(pixelSize, fontStyle, fontFamily) {
            return fontStyle + " " + pixelSize + "px " + fontFamily;
          };
          helpers$1.longestText = function(ctx, font, arrayOfThings, cache2) {
            cache2 = cache2 || {};
            var data = cache2.data = cache2.data || {};
            var gc2 = cache2.garbageCollect = cache2.garbageCollect || [];
            if (cache2.font !== font) {
              data = cache2.data = {};
              gc2 = cache2.garbageCollect = [];
              cache2.font = font;
            }
            ctx.font = font;
            var longest = 0;
            var ilen = arrayOfThings.length;
            var i, j, jlen, thing, nestedThing;
            for (i = 0; i < ilen; i++) {
              thing = arrayOfThings[i];
              if (thing !== void 0 && thing !== null && helpers$1.isArray(thing) !== true) {
                longest = helpers$1.measureText(ctx, data, gc2, longest, thing);
              } else if (helpers$1.isArray(thing)) {
                for (j = 0, jlen = thing.length; j < jlen; j++) {
                  nestedThing = thing[j];
                  if (nestedThing !== void 0 && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                    longest = helpers$1.measureText(ctx, data, gc2, longest, nestedThing);
                  }
                }
              }
            }
            var gcLen = gc2.length / 2;
            if (gcLen > arrayOfThings.length) {
              for (i = 0; i < gcLen; i++) {
                delete data[gc2[i]];
              }
              gc2.splice(0, gcLen);
            }
            return longest;
          };
          helpers$1.measureText = function(ctx, data, gc2, longest, string) {
            var textWidth = data[string];
            if (!textWidth) {
              textWidth = data[string] = ctx.measureText(string).width;
              gc2.push(string);
            }
            if (textWidth > longest) {
              longest = textWidth;
            }
            return longest;
          };
          helpers$1.numberOfLabelLines = function(arrayOfThings) {
            var numberOfLines = 1;
            helpers$1.each(arrayOfThings, function(thing) {
              if (helpers$1.isArray(thing)) {
                if (thing.length > numberOfLines) {
                  numberOfLines = thing.length;
                }
              }
            });
            return numberOfLines;
          };
          helpers$1.color = !chartjsColor ? function(value2) {
            console.error("Color.js not found!");
            return value2;
          } : function(value2) {
            if (value2 instanceof CanvasGradient) {
              value2 = core_defaults.global.defaultColor;
            }
            return chartjsColor(value2);
          };
          helpers$1.getHoverColor = function(colorValue) {
            return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
          };
        };
        function abstract() {
          throw new Error(
            "This method is not implemented: either no adapter can be found or an incomplete integration was provided."
          );
        }
        function DateAdapter(options2) {
          this.options = options2 || {};
        }
        helpers$1.extend(DateAdapter.prototype, {
          formats: abstract,
          parse: abstract,
          format: abstract,
          add: abstract,
          diff: abstract,
          startOf: abstract,
          endOf: abstract,
          _create: function(value2) {
            return value2;
          }
        });
        DateAdapter.override = function(members) {
          helpers$1.extend(DateAdapter.prototype, members);
        };
        var _date = DateAdapter;
        var core_adapters = {
          _date
        };
        var core_ticks = {
          formatters: {
            values: function(value2) {
              return helpers$1.isArray(value2) ? value2 : "" + value2;
            },
            linear: function(tickValue, index2, ticks) {
              var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
              if (Math.abs(delta) > 1) {
                if (tickValue !== Math.floor(tickValue)) {
                  delta = tickValue - Math.floor(tickValue);
                }
              }
              var logDelta = helpers$1.log10(Math.abs(delta));
              var tickString = "";
              if (tickValue !== 0) {
                var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
                if (maxTick < 1e-4) {
                  var logTick = helpers$1.log10(Math.abs(tickValue));
                  var numExponential = Math.floor(logTick) - Math.floor(logDelta);
                  numExponential = Math.max(Math.min(numExponential, 20), 0);
                  tickString = tickValue.toExponential(numExponential);
                } else {
                  var numDecimal = -1 * Math.floor(logDelta);
                  numDecimal = Math.max(Math.min(numDecimal, 20), 0);
                  tickString = tickValue.toFixed(numDecimal);
                }
              } else {
                tickString = "0";
              }
              return tickString;
            },
            logarithmic: function(tickValue, index2, ticks) {
              var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));
              if (tickValue === 0) {
                return "0";
              } else if (remain === 1 || remain === 2 || remain === 5 || index2 === 0 || index2 === ticks.length - 1) {
                return tickValue.toExponential();
              }
              return "";
            }
          }
        };
        var isArray2 = helpers$1.isArray;
        var isNullOrUndef = helpers$1.isNullOrUndef;
        var valueOrDefault$a = helpers$1.valueOrDefault;
        var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;
        core_defaults._set("scale", {
          display: true,
          position: "left",
          offset: false,
          gridLines: {
            display: true,
            color: "rgba(0,0,0,0.1)",
            lineWidth: 1,
            drawBorder: true,
            drawOnChartArea: true,
            drawTicks: true,
            tickMarkLength: 10,
            zeroLineWidth: 1,
            zeroLineColor: "rgba(0,0,0,0.25)",
            zeroLineBorderDash: [],
            zeroLineBorderDashOffset: 0,
            offsetGridLines: false,
            borderDash: [],
            borderDashOffset: 0
          },
          scaleLabel: {
            display: false,
            labelString: "",
            padding: {
              top: 4,
              bottom: 4
            }
          },
          ticks: {
            beginAtZero: false,
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            padding: 0,
            reverse: false,
            display: true,
            autoSkip: true,
            autoSkipPadding: 0,
            labelOffset: 0,
            callback: core_ticks.formatters.values,
            minor: {},
            major: {}
          }
        });
        function sample2(arr, numItems) {
          var result2 = [];
          var increment = arr.length / numItems;
          var i = 0;
          var len = arr.length;
          for (; i < len; i += increment) {
            result2.push(arr[Math.floor(i)]);
          }
          return result2;
        }
        function getPixelForGridLine(scale2, index2, offsetGridLines) {
          var length = scale2.getTicks().length;
          var validIndex = Math.min(index2, length - 1);
          var lineValue = scale2.getPixelForTick(validIndex);
          var start = scale2._startPixel;
          var end = scale2._endPixel;
          var epsilon = 1e-6;
          var offset2;
          if (offsetGridLines) {
            if (length === 1) {
              offset2 = Math.max(lineValue - start, end - lineValue);
            } else if (index2 === 0) {
              offset2 = (scale2.getPixelForTick(1) - lineValue) / 2;
            } else {
              offset2 = (lineValue - scale2.getPixelForTick(validIndex - 1)) / 2;
            }
            lineValue += validIndex < index2 ? offset2 : -offset2;
            if (lineValue < start - epsilon || lineValue > end + epsilon) {
              return;
            }
          }
          return lineValue;
        }
        function garbageCollect(caches, length) {
          helpers$1.each(caches, function(cache2) {
            var gc2 = cache2.gc;
            var gcLen = gc2.length / 2;
            var i;
            if (gcLen > length) {
              for (i = 0; i < gcLen; ++i) {
                delete cache2.data[gc2[i]];
              }
              gc2.splice(0, gcLen);
            }
          });
        }
        function computeLabelSizes(ctx, tickFonts, ticks, caches) {
          var length = ticks.length;
          var widths = [];
          var heights = [];
          var offsets = [];
          var widestLabelSize = 0;
          var highestLabelSize = 0;
          var i, j, jlen, label, tickFont, fontString, cache2, lineHeight, width2, height2, nestedLabel, widest, highest;
          for (i = 0; i < length; ++i) {
            label = ticks[i].label;
            tickFont = ticks[i].major ? tickFonts.major : tickFonts.minor;
            ctx.font = fontString = tickFont.string;
            cache2 = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
            lineHeight = tickFont.lineHeight;
            width2 = height2 = 0;
            if (!isNullOrUndef(label) && !isArray2(label)) {
              width2 = helpers$1.measureText(ctx, cache2.data, cache2.gc, width2, label);
              height2 = lineHeight;
            } else if (isArray2(label)) {
              for (j = 0, jlen = label.length; j < jlen; ++j) {
                nestedLabel = label[j];
                if (!isNullOrUndef(nestedLabel) && !isArray2(nestedLabel)) {
                  width2 = helpers$1.measureText(ctx, cache2.data, cache2.gc, width2, nestedLabel);
                  height2 += lineHeight;
                }
              }
            }
            widths.push(width2);
            heights.push(height2);
            offsets.push(lineHeight / 2);
            widestLabelSize = Math.max(width2, widestLabelSize);
            highestLabelSize = Math.max(height2, highestLabelSize);
          }
          garbageCollect(caches, length);
          widest = widths.indexOf(widestLabelSize);
          highest = heights.indexOf(highestLabelSize);
          function valueAt(idx) {
            return {
              width: widths[idx] || 0,
              height: heights[idx] || 0,
              offset: offsets[idx] || 0
            };
          }
          return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest)
          };
        }
        function getTickMarkLength(options2) {
          return options2.drawTicks ? options2.tickMarkLength : 0;
        }
        function getScaleLabelHeight(options2) {
          var font, padding;
          if (!options2.display) {
            return 0;
          }
          font = helpers$1.options._parseFont(options2);
          padding = helpers$1.options.toPadding(options2.padding);
          return font.lineHeight + padding.height;
        }
        function parseFontOptions(options2, nestedOpts) {
          return helpers$1.extend(helpers$1.options._parseFont({
            fontFamily: valueOrDefault$a(nestedOpts.fontFamily, options2.fontFamily),
            fontSize: valueOrDefault$a(nestedOpts.fontSize, options2.fontSize),
            fontStyle: valueOrDefault$a(nestedOpts.fontStyle, options2.fontStyle),
            lineHeight: valueOrDefault$a(nestedOpts.lineHeight, options2.lineHeight)
          }), {
            color: helpers$1.options.resolve([nestedOpts.fontColor, options2.fontColor, core_defaults.global.defaultFontColor])
          });
        }
        function parseTickFontOptions(options2) {
          var minor = parseFontOptions(options2, options2.minor);
          var major = options2.major.enabled ? parseFontOptions(options2, options2.major) : minor;
          return { minor, major };
        }
        function nonSkipped(ticksToFilter) {
          var filtered = [];
          var item, index2, len;
          for (index2 = 0, len = ticksToFilter.length; index2 < len; ++index2) {
            item = ticksToFilter[index2];
            if (typeof item._index !== "undefined") {
              filtered.push(item);
            }
          }
          return filtered;
        }
        function getEvenSpacing(arr) {
          var len = arr.length;
          var i, diff2;
          if (len < 2) {
            return false;
          }
          for (diff2 = arr[0], i = 1; i < len; ++i) {
            if (arr[i] - arr[i - 1] !== diff2) {
              return false;
            }
          }
          return diff2;
        }
        function calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {
          var evenMajorSpacing = getEvenSpacing(majorIndices);
          var spacing = (ticks.length - 1) / ticksLimit;
          var factors, factor, i, ilen;
          if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
          }
          factors = helpers$1.math._factorize(evenMajorSpacing);
          for (i = 0, ilen = factors.length - 1; i < ilen; i++) {
            factor = factors[i];
            if (factor > spacing) {
              return factor;
            }
          }
          return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
          var result2 = [];
          var i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (ticks[i].major) {
              result2.push(i);
            }
          }
          return result2;
        }
        function skipMajors(ticks, majorIndices, spacing) {
          var count = 0;
          var next = majorIndices[0];
          var i, tick;
          spacing = Math.ceil(spacing);
          for (i = 0; i < ticks.length; i++) {
            tick = ticks[i];
            if (i === next) {
              tick._index = i;
              count++;
              next = majorIndices[count * spacing];
            } else {
              delete tick.label;
            }
          }
        }
        function skip(ticks, spacing, majorStart, majorEnd) {
          var start = valueOrDefault$a(majorStart, 0);
          var end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);
          var count = 0;
          var length, i, tick, next;
          spacing = Math.ceil(spacing);
          if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
          }
          next = start;
          while (next < 0) {
            count++;
            next = Math.round(start + count * spacing);
          }
          for (i = Math.max(start, 0); i < end; i++) {
            tick = ticks[i];
            if (i === next) {
              tick._index = i;
              count++;
              next = Math.round(start + count * spacing);
            } else {
              delete tick.label;
            }
          }
        }
        var Scale = core_element.extend({
          zeroLineIndex: 0,
          getPadding: function() {
            var me2 = this;
            return {
              left: me2.paddingLeft || 0,
              top: me2.paddingTop || 0,
              right: me2.paddingRight || 0,
              bottom: me2.paddingBottom || 0
            };
          },
          getTicks: function() {
            return this._ticks;
          },
          _getLabels: function() {
            var data = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
          },
          mergeTicksOptions: function() {
          },
          beforeUpdate: function() {
            helpers$1.callback(this.options.beforeUpdate, [this]);
          },
          update: function(maxWidth, maxHeight, margins) {
            var me2 = this;
            var tickOpts = me2.options.ticks;
            var sampleSize = tickOpts.sampleSize;
            var i, ilen, labels, ticks, samplingEnabled;
            me2.beforeUpdate();
            me2.maxWidth = maxWidth;
            me2.maxHeight = maxHeight;
            me2.margins = helpers$1.extend({
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }, margins);
            me2._ticks = null;
            me2.ticks = null;
            me2._labelSizes = null;
            me2._maxLabelLines = 0;
            me2.longestLabelWidth = 0;
            me2.longestTextCache = me2.longestTextCache || {};
            me2._gridLineItems = null;
            me2._labelItems = null;
            me2.beforeSetDimensions();
            me2.setDimensions();
            me2.afterSetDimensions();
            me2.beforeDataLimits();
            me2.determineDataLimits();
            me2.afterDataLimits();
            me2.beforeBuildTicks();
            ticks = me2.buildTicks() || [];
            ticks = me2.afterBuildTicks(ticks) || ticks;
            if ((!ticks || !ticks.length) && me2.ticks) {
              ticks = [];
              for (i = 0, ilen = me2.ticks.length; i < ilen; ++i) {
                ticks.push({
                  value: me2.ticks[i],
                  major: false
                });
              }
            }
            me2._ticks = ticks;
            samplingEnabled = sampleSize < ticks.length;
            labels = me2._convertTicksToLabels(samplingEnabled ? sample2(ticks, sampleSize) : ticks);
            me2._configure();
            me2.beforeCalculateTickRotation();
            me2.calculateTickRotation();
            me2.afterCalculateTickRotation();
            me2.beforeFit();
            me2.fit();
            me2.afterFit();
            me2._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto") ? me2._autoSkip(ticks) : ticks;
            if (samplingEnabled) {
              labels = me2._convertTicksToLabels(me2._ticksToDraw);
            }
            me2.ticks = labels;
            me2.afterUpdate();
            return me2.minSize;
          },
          _configure: function() {
            var me2 = this;
            var reversePixels = me2.options.ticks.reverse;
            var startPixel, endPixel;
            if (me2.isHorizontal()) {
              startPixel = me2.left;
              endPixel = me2.right;
            } else {
              startPixel = me2.top;
              endPixel = me2.bottom;
              reversePixels = !reversePixels;
            }
            me2._startPixel = startPixel;
            me2._endPixel = endPixel;
            me2._reversePixels = reversePixels;
            me2._length = endPixel - startPixel;
          },
          afterUpdate: function() {
            helpers$1.callback(this.options.afterUpdate, [this]);
          },
          beforeSetDimensions: function() {
            helpers$1.callback(this.options.beforeSetDimensions, [this]);
          },
          setDimensions: function() {
            var me2 = this;
            if (me2.isHorizontal()) {
              me2.width = me2.maxWidth;
              me2.left = 0;
              me2.right = me2.width;
            } else {
              me2.height = me2.maxHeight;
              me2.top = 0;
              me2.bottom = me2.height;
            }
            me2.paddingLeft = 0;
            me2.paddingTop = 0;
            me2.paddingRight = 0;
            me2.paddingBottom = 0;
          },
          afterSetDimensions: function() {
            helpers$1.callback(this.options.afterSetDimensions, [this]);
          },
          beforeDataLimits: function() {
            helpers$1.callback(this.options.beforeDataLimits, [this]);
          },
          determineDataLimits: helpers$1.noop,
          afterDataLimits: function() {
            helpers$1.callback(this.options.afterDataLimits, [this]);
          },
          beforeBuildTicks: function() {
            helpers$1.callback(this.options.beforeBuildTicks, [this]);
          },
          buildTicks: helpers$1.noop,
          afterBuildTicks: function(ticks) {
            var me2 = this;
            if (isArray2(ticks) && ticks.length) {
              return helpers$1.callback(me2.options.afterBuildTicks, [me2, ticks]);
            }
            me2.ticks = helpers$1.callback(me2.options.afterBuildTicks, [me2, me2.ticks]) || me2.ticks;
            return ticks;
          },
          beforeTickToLabelConversion: function() {
            helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
          },
          convertTicksToLabels: function() {
            var me2 = this;
            var tickOpts = me2.options.ticks;
            me2.ticks = me2.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
          },
          afterTickToLabelConversion: function() {
            helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
          },
          beforeCalculateTickRotation: function() {
            helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
          },
          calculateTickRotation: function() {
            var me2 = this;
            var options2 = me2.options;
            var tickOpts = options2.ticks;
            var numTicks = me2.getTicks().length;
            var minRotation = tickOpts.minRotation || 0;
            var maxRotation = tickOpts.maxRotation;
            var labelRotation = minRotation;
            var labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;
            if (!me2._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me2.isHorizontal()) {
              me2.labelRotation = minRotation;
              return;
            }
            labelSizes = me2._getLabelSizes();
            maxLabelWidth = labelSizes.widest.width;
            maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset;
            maxWidth = Math.min(me2.maxWidth, me2.chart.width - maxLabelWidth);
            tickWidth = options2.offset ? me2.maxWidth / numTicks : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
              tickWidth = maxWidth / (numTicks - (options2.offset ? 0.5 : 1));
              maxHeight = me2.maxHeight - getTickMarkLength(options2.gridLines) - tickOpts.padding - getScaleLabelHeight(options2.scaleLabel);
              maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
              labelRotation = helpers$1.toDegrees(Math.min(
                Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)),
                Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)
              ));
              labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
            }
            me2.labelRotation = labelRotation;
          },
          afterCalculateTickRotation: function() {
            helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
          },
          beforeFit: function() {
            helpers$1.callback(this.options.beforeFit, [this]);
          },
          fit: function() {
            var me2 = this;
            var minSize = me2.minSize = {
              width: 0,
              height: 0
            };
            var chart = me2.chart;
            var opts = me2.options;
            var tickOpts = opts.ticks;
            var scaleLabelOpts = opts.scaleLabel;
            var gridLineOpts = opts.gridLines;
            var display = me2._isVisible();
            var isBottom = opts.position === "bottom";
            var isHorizontal = me2.isHorizontal();
            if (isHorizontal) {
              minSize.width = me2.maxWidth;
            } else if (display) {
              minSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
            }
            if (!isHorizontal) {
              minSize.height = me2.maxHeight;
            } else if (display) {
              minSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
            }
            if (tickOpts.display && display) {
              var tickFonts = parseTickFontOptions(tickOpts);
              var labelSizes = me2._getLabelSizes();
              var firstLabelSize = labelSizes.first;
              var lastLabelSize = labelSizes.last;
              var widestLabelSize = labelSizes.widest;
              var highestLabelSize = labelSizes.highest;
              var lineSpace = tickFonts.minor.lineHeight * 0.4;
              var tickPadding = tickOpts.padding;
              if (isHorizontal) {
                var isRotated = me2.labelRotation !== 0;
                var angleRadians = helpers$1.toRadians(me2.labelRotation);
                var cosRotation = Math.cos(angleRadians);
                var sinRotation = Math.sin(angleRadians);
                var labelHeight = sinRotation * widestLabelSize.width + cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0)) + (isRotated ? 0 : lineSpace);
                minSize.height = Math.min(me2.maxHeight, minSize.height + labelHeight + tickPadding);
                var offsetLeft = me2.getPixelForTick(0) - me2.left;
                var offsetRight = me2.right - me2.getPixelForTick(me2.getTicks().length - 1);
                var paddingLeft, paddingRight;
                if (isRotated) {
                  paddingLeft = isBottom ? cosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset : sinRotation * (firstLabelSize.height - firstLabelSize.offset);
                  paddingRight = isBottom ? sinRotation * (lastLabelSize.height - lastLabelSize.offset) : cosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;
                } else {
                  paddingLeft = firstLabelSize.width / 2;
                  paddingRight = lastLabelSize.width / 2;
                }
                me2.paddingLeft = Math.max((paddingLeft - offsetLeft) * me2.width / (me2.width - offsetLeft), 0) + 3;
                me2.paddingRight = Math.max((paddingRight - offsetRight) * me2.width / (me2.width - offsetRight), 0) + 3;
              } else {
                var labelWidth = tickOpts.mirror ? 0 : widestLabelSize.width + tickPadding + lineSpace;
                minSize.width = Math.min(me2.maxWidth, minSize.width + labelWidth);
                me2.paddingTop = firstLabelSize.height / 2;
                me2.paddingBottom = lastLabelSize.height / 2;
              }
            }
            me2.handleMargins();
            if (isHorizontal) {
              me2.width = me2._length = chart.width - me2.margins.left - me2.margins.right;
              me2.height = minSize.height;
            } else {
              me2.width = minSize.width;
              me2.height = me2._length = chart.height - me2.margins.top - me2.margins.bottom;
            }
          },
          handleMargins: function() {
            var me2 = this;
            if (me2.margins) {
              me2.margins.left = Math.max(me2.paddingLeft, me2.margins.left);
              me2.margins.top = Math.max(me2.paddingTop, me2.margins.top);
              me2.margins.right = Math.max(me2.paddingRight, me2.margins.right);
              me2.margins.bottom = Math.max(me2.paddingBottom, me2.margins.bottom);
            }
          },
          afterFit: function() {
            helpers$1.callback(this.options.afterFit, [this]);
          },
          isHorizontal: function() {
            var pos = this.options.position;
            return pos === "top" || pos === "bottom";
          },
          isFullWidth: function() {
            return this.options.fullWidth;
          },
          getRightValue: function(rawValue) {
            if (isNullOrUndef(rawValue)) {
              return NaN;
            }
            if ((typeof rawValue === "number" || rawValue instanceof Number) && !isFinite(rawValue)) {
              return NaN;
            }
            if (rawValue) {
              if (this.isHorizontal()) {
                if (rawValue.x !== void 0) {
                  return this.getRightValue(rawValue.x);
                }
              } else if (rawValue.y !== void 0) {
                return this.getRightValue(rawValue.y);
              }
            }
            return rawValue;
          },
          _convertTicksToLabels: function(ticks) {
            var me2 = this;
            var labels, i, ilen;
            me2.ticks = ticks.map(function(tick) {
              return tick.value;
            });
            me2.beforeTickToLabelConversion();
            labels = me2.convertTicksToLabels(ticks) || me2.ticks;
            me2.afterTickToLabelConversion();
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              ticks[i].label = labels[i];
            }
            return labels;
          },
          _getLabelSizes: function() {
            var me2 = this;
            var labelSizes = me2._labelSizes;
            if (!labelSizes) {
              me2._labelSizes = labelSizes = computeLabelSizes(me2.ctx, parseTickFontOptions(me2.options.ticks), me2.getTicks(), me2.longestTextCache);
              me2.longestLabelWidth = labelSizes.widest.width;
            }
            return labelSizes;
          },
          _parseValue: function(value2) {
            var start, end, min2, max2;
            if (isArray2(value2)) {
              start = +this.getRightValue(value2[0]);
              end = +this.getRightValue(value2[1]);
              min2 = Math.min(start, end);
              max2 = Math.max(start, end);
            } else {
              value2 = +this.getRightValue(value2);
              start = void 0;
              end = value2;
              min2 = value2;
              max2 = value2;
            }
            return {
              min: min2,
              max: max2,
              start,
              end
            };
          },
          _getScaleLabel: function(rawValue) {
            var v2 = this._parseValue(rawValue);
            if (v2.start !== void 0) {
              return "[" + v2.start + ", " + v2.end + "]";
            }
            return +this.getRightValue(rawValue);
          },
          getLabelForIndex: helpers$1.noop,
          getPixelForValue: helpers$1.noop,
          getValueForPixel: helpers$1.noop,
          getPixelForTick: function(index2) {
            var me2 = this;
            var offset2 = me2.options.offset;
            var numTicks = me2._ticks.length;
            var tickWidth = 1 / Math.max(numTicks - (offset2 ? 0 : 1), 1);
            return index2 < 0 || index2 > numTicks - 1 ? null : me2.getPixelForDecimal(index2 * tickWidth + (offset2 ? tickWidth / 2 : 0));
          },
          getPixelForDecimal: function(decimal) {
            var me2 = this;
            if (me2._reversePixels) {
              decimal = 1 - decimal;
            }
            return me2._startPixel + decimal * me2._length;
          },
          getDecimalForPixel: function(pixel) {
            var decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
          },
          getBasePixel: function() {
            return this.getPixelForValue(this.getBaseValue());
          },
          getBaseValue: function() {
            var me2 = this;
            var min2 = me2.min;
            var max2 = me2.max;
            return me2.beginAtZero ? 0 : min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0;
          },
          _autoSkip: function(ticks) {
            var me2 = this;
            var tickOpts = me2.options.ticks;
            var axisLength = me2._length;
            var ticksLimit = tickOpts.maxTicksLimit || axisLength / me2._tickSize() + 1;
            var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
            var numMajorIndices = majorIndices.length;
            var first2 = majorIndices[0];
            var last2 = majorIndices[numMajorIndices - 1];
            var i, ilen, spacing, avgMajorSpacing;
            if (numMajorIndices > ticksLimit) {
              skipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);
              return nonSkipped(ticks);
            }
            spacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);
            if (numMajorIndices > 0) {
              for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
                skip(ticks, spacing, majorIndices[i], majorIndices[i + 1]);
              }
              avgMajorSpacing = numMajorIndices > 1 ? (last2 - first2) / (numMajorIndices - 1) : null;
              skip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first2 - avgMajorSpacing, first2);
              skip(ticks, spacing, last2, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last2 + avgMajorSpacing);
              return nonSkipped(ticks);
            }
            skip(ticks, spacing);
            return nonSkipped(ticks);
          },
          _tickSize: function() {
            var me2 = this;
            var optionTicks = me2.options.ticks;
            var rot = helpers$1.toRadians(me2.labelRotation);
            var cos = Math.abs(Math.cos(rot));
            var sin = Math.abs(Math.sin(rot));
            var labelSizes = me2._getLabelSizes();
            var padding = optionTicks.autoSkipPadding || 0;
            var w2 = labelSizes ? labelSizes.widest.width + padding : 0;
            var h2 = labelSizes ? labelSizes.highest.height + padding : 0;
            return me2.isHorizontal() ? h2 * cos > w2 * sin ? w2 / cos : h2 / sin : h2 * sin < w2 * cos ? h2 / cos : w2 / sin;
          },
          _isVisible: function() {
            var me2 = this;
            var chart = me2.chart;
            var display = me2.options.display;
            var i, ilen, meta;
            if (display !== "auto") {
              return !!display;
            }
            for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                meta = chart.getDatasetMeta(i);
                if (meta.xAxisID === me2.id || meta.yAxisID === me2.id) {
                  return true;
                }
              }
            }
            return false;
          },
          _computeGridLineItems: function(chartArea) {
            var me2 = this;
            var chart = me2.chart;
            var options2 = me2.options;
            var gridLines = options2.gridLines;
            var position = options2.position;
            var offsetGridLines = gridLines.offsetGridLines;
            var isHorizontal = me2.isHorizontal();
            var ticks = me2._ticksToDraw;
            var ticksLength = ticks.length + (offsetGridLines ? 1 : 0);
            var tl = getTickMarkLength(gridLines);
            var items2 = [];
            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
            var axisHalfWidth = axisWidth / 2;
            var alignPixel = helpers$1._alignPixel;
            var alignBorderValue = function(pixel) {
              return alignPixel(chart, pixel, axisWidth);
            };
            var borderValue, i, tick, lineValue, alignedLineValue;
            var tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;
            if (position === "top") {
              borderValue = alignBorderValue(me2.bottom);
              ty1 = me2.bottom - tl;
              ty2 = borderValue - axisHalfWidth;
              y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
              y2 = chartArea.bottom;
            } else if (position === "bottom") {
              borderValue = alignBorderValue(me2.top);
              y1 = chartArea.top;
              y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
              ty1 = borderValue + axisHalfWidth;
              ty2 = me2.top + tl;
            } else if (position === "left") {
              borderValue = alignBorderValue(me2.right);
              tx1 = me2.right - tl;
              tx2 = borderValue - axisHalfWidth;
              x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
              x2 = chartArea.right;
            } else {
              borderValue = alignBorderValue(me2.left);
              x1 = chartArea.left;
              x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
              tx1 = borderValue + axisHalfWidth;
              tx2 = me2.left + tl;
            }
            for (i = 0; i < ticksLength; ++i) {
              tick = ticks[i] || {};
              if (isNullOrUndef(tick.label) && i < ticks.length) {
                continue;
              }
              if (i === me2.zeroLineIndex && options2.offset === offsetGridLines) {
                lineWidth = gridLines.zeroLineWidth;
                lineColor = gridLines.zeroLineColor;
                borderDash = gridLines.zeroLineBorderDash || [];
                borderDashOffset = gridLines.zeroLineBorderDashOffset || 0;
              } else {
                lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);
                lineColor = valueAtIndexOrDefault(gridLines.color, i, "rgba(0,0,0,0.1)");
                borderDash = gridLines.borderDash || [];
                borderDashOffset = gridLines.borderDashOffset || 0;
              }
              lineValue = getPixelForGridLine(me2, tick._index || i, offsetGridLines);
              if (lineValue === void 0) {
                continue;
              }
              alignedLineValue = alignPixel(chart, lineValue, lineWidth);
              if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
              } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
              }
              items2.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset
              });
            }
            items2.ticksLength = ticksLength;
            items2.borderValue = borderValue;
            return items2;
          },
          _computeLabelItems: function() {
            var me2 = this;
            var options2 = me2.options;
            var optionTicks = options2.ticks;
            var position = options2.position;
            var isMirrored = optionTicks.mirror;
            var isHorizontal = me2.isHorizontal();
            var ticks = me2._ticksToDraw;
            var fonts = parseTickFontOptions(optionTicks);
            var tickPadding = optionTicks.padding;
            var tl = getTickMarkLength(options2.gridLines);
            var rotation = -helpers$1.toRadians(me2.labelRotation);
            var items2 = [];
            var i, ilen, tick, label, x2, y2, textAlign, pixel, font, lineHeight, lineCount, textOffset;
            if (position === "top") {
              y2 = me2.bottom - tl - tickPadding;
              textAlign = !rotation ? "center" : "left";
            } else if (position === "bottom") {
              y2 = me2.top + tl + tickPadding;
              textAlign = !rotation ? "center" : "right";
            } else if (position === "left") {
              x2 = me2.right - (isMirrored ? 0 : tl) - tickPadding;
              textAlign = isMirrored ? "left" : "right";
            } else {
              x2 = me2.left + (isMirrored ? 0 : tl) + tickPadding;
              textAlign = isMirrored ? "right" : "left";
            }
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              label = tick.label;
              if (isNullOrUndef(label)) {
                continue;
              }
              pixel = me2.getPixelForTick(tick._index || i) + optionTicks.labelOffset;
              font = tick.major ? fonts.major : fonts.minor;
              lineHeight = font.lineHeight;
              lineCount = isArray2(label) ? label.length : 1;
              if (isHorizontal) {
                x2 = pixel;
                textOffset = position === "top" ? ((!rotation ? 0.5 : 1) - lineCount) * lineHeight : (!rotation ? 0.5 : 0) * lineHeight;
              } else {
                y2 = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
              }
              items2.push({
                x: x2,
                y: y2,
                rotation,
                label,
                font,
                textOffset,
                textAlign
              });
            }
            return items2;
          },
          _drawGrid: function(chartArea) {
            var me2 = this;
            var gridLines = me2.options.gridLines;
            if (!gridLines.display) {
              return;
            }
            var ctx = me2.ctx;
            var chart = me2.chart;
            var alignPixel = helpers$1._alignPixel;
            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
            var items2 = me2._gridLineItems || (me2._gridLineItems = me2._computeGridLineItems(chartArea));
            var width2, color, i, ilen, item;
            for (i = 0, ilen = items2.length; i < ilen; ++i) {
              item = items2[i];
              width2 = item.width;
              color = item.color;
              if (width2 && color) {
                ctx.save();
                ctx.lineWidth = width2;
                ctx.strokeStyle = color;
                if (ctx.setLineDash) {
                  ctx.setLineDash(item.borderDash);
                  ctx.lineDashOffset = item.borderDashOffset;
                }
                ctx.beginPath();
                if (gridLines.drawTicks) {
                  ctx.moveTo(item.tx1, item.ty1);
                  ctx.lineTo(item.tx2, item.ty2);
                }
                if (gridLines.drawOnChartArea) {
                  ctx.moveTo(item.x1, item.y1);
                  ctx.lineTo(item.x2, item.y2);
                }
                ctx.stroke();
                ctx.restore();
              }
            }
            if (axisWidth) {
              var firstLineWidth = axisWidth;
              var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items2.ticksLength - 1, 1);
              var borderValue = items2.borderValue;
              var x1, x2, y1, y2;
              if (me2.isHorizontal()) {
                x1 = alignPixel(chart, me2.left, firstLineWidth) - firstLineWidth / 2;
                x2 = alignPixel(chart, me2.right, lastLineWidth) + lastLineWidth / 2;
                y1 = y2 = borderValue;
              } else {
                y1 = alignPixel(chart, me2.top, firstLineWidth) - firstLineWidth / 2;
                y2 = alignPixel(chart, me2.bottom, lastLineWidth) + lastLineWidth / 2;
                x1 = x2 = borderValue;
              }
              ctx.lineWidth = axisWidth;
              ctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
            }
          },
          _drawLabels: function() {
            var me2 = this;
            var optionTicks = me2.options.ticks;
            if (!optionTicks.display) {
              return;
            }
            var ctx = me2.ctx;
            var items2 = me2._labelItems || (me2._labelItems = me2._computeLabelItems());
            var i, j, ilen, jlen, item, tickFont, label, y2;
            for (i = 0, ilen = items2.length; i < ilen; ++i) {
              item = items2[i];
              tickFont = item.font;
              ctx.save();
              ctx.translate(item.x, item.y);
              ctx.rotate(item.rotation);
              ctx.font = tickFont.string;
              ctx.fillStyle = tickFont.color;
              ctx.textBaseline = "middle";
              ctx.textAlign = item.textAlign;
              label = item.label;
              y2 = item.textOffset;
              if (isArray2(label)) {
                for (j = 0, jlen = label.length; j < jlen; ++j) {
                  ctx.fillText("" + label[j], 0, y2);
                  y2 += tickFont.lineHeight;
                }
              } else {
                ctx.fillText(label, 0, y2);
              }
              ctx.restore();
            }
          },
          _drawTitle: function() {
            var me2 = this;
            var ctx = me2.ctx;
            var options2 = me2.options;
            var scaleLabel = options2.scaleLabel;
            if (!scaleLabel.display) {
              return;
            }
            var scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);
            var scaleLabelFont = helpers$1.options._parseFont(scaleLabel);
            var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
            var halfLineHeight = scaleLabelFont.lineHeight / 2;
            var position = options2.position;
            var rotation = 0;
            var scaleLabelX, scaleLabelY;
            if (me2.isHorizontal()) {
              scaleLabelX = me2.left + me2.width / 2;
              scaleLabelY = position === "bottom" ? me2.bottom - halfLineHeight - scaleLabelPadding.bottom : me2.top + halfLineHeight + scaleLabelPadding.top;
            } else {
              var isLeft = position === "left";
              scaleLabelX = isLeft ? me2.left + halfLineHeight + scaleLabelPadding.top : me2.right - halfLineHeight - scaleLabelPadding.top;
              scaleLabelY = me2.top + me2.height / 2;
              rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
            }
            ctx.save();
            ctx.translate(scaleLabelX, scaleLabelY);
            ctx.rotate(rotation);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = scaleLabelFontColor;
            ctx.font = scaleLabelFont.string;
            ctx.fillText(scaleLabel.labelString, 0, 0);
            ctx.restore();
          },
          draw: function(chartArea) {
            var me2 = this;
            if (!me2._isVisible()) {
              return;
            }
            me2._drawGrid(chartArea);
            me2._drawTitle();
            me2._drawLabels();
          },
          _layers: function() {
            var me2 = this;
            var opts = me2.options;
            var tz = opts.ticks && opts.ticks.z || 0;
            var gz = opts.gridLines && opts.gridLines.z || 0;
            if (!me2._isVisible() || tz === gz || me2.draw !== me2._draw) {
              return [{
                z: tz,
                draw: function() {
                  me2.draw.apply(me2, arguments);
                }
              }];
            }
            return [{
              z: gz,
              draw: function() {
                me2._drawGrid.apply(me2, arguments);
                me2._drawTitle.apply(me2, arguments);
              }
            }, {
              z: tz,
              draw: function() {
                me2._drawLabels.apply(me2, arguments);
              }
            }];
          },
          _getMatchingVisibleMetas: function(type) {
            var me2 = this;
            var isHorizontal = me2.isHorizontal();
            return me2.chart._getSortedVisibleDatasetMetas().filter(function(meta) {
              return (!type || meta.type === type) && (isHorizontal ? meta.xAxisID === me2.id : meta.yAxisID === me2.id);
            });
          }
        });
        Scale.prototype._draw = Scale.prototype.draw;
        var core_scale = Scale;
        var isNullOrUndef$1 = helpers$1.isNullOrUndef;
        var defaultConfig = {
          position: "bottom"
        };
        var scale_category = core_scale.extend({
          determineDataLimits: function() {
            var me2 = this;
            var labels = me2._getLabels();
            var ticksOpts = me2.options.ticks;
            var min2 = ticksOpts.min;
            var max2 = ticksOpts.max;
            var minIndex = 0;
            var maxIndex = labels.length - 1;
            var findIndex2;
            if (min2 !== void 0) {
              findIndex2 = labels.indexOf(min2);
              if (findIndex2 >= 0) {
                minIndex = findIndex2;
              }
            }
            if (max2 !== void 0) {
              findIndex2 = labels.indexOf(max2);
              if (findIndex2 >= 0) {
                maxIndex = findIndex2;
              }
            }
            me2.minIndex = minIndex;
            me2.maxIndex = maxIndex;
            me2.min = labels[minIndex];
            me2.max = labels[maxIndex];
          },
          buildTicks: function() {
            var me2 = this;
            var labels = me2._getLabels();
            var minIndex = me2.minIndex;
            var maxIndex = me2.maxIndex;
            me2.ticks = minIndex === 0 && maxIndex === labels.length - 1 ? labels : labels.slice(minIndex, maxIndex + 1);
          },
          getLabelForIndex: function(index2, datasetIndex) {
            var me2 = this;
            var chart = me2.chart;
            if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me2.id) {
              return me2.getRightValue(chart.data.datasets[datasetIndex].data[index2]);
            }
            return me2._getLabels()[index2];
          },
          _configure: function() {
            var me2 = this;
            var offset2 = me2.options.offset;
            var ticks = me2.ticks;
            core_scale.prototype._configure.call(me2);
            if (!me2.isHorizontal()) {
              me2._reversePixels = !me2._reversePixels;
            }
            if (!ticks) {
              return;
            }
            me2._startValue = me2.minIndex - (offset2 ? 0.5 : 0);
            me2._valueRange = Math.max(ticks.length - (offset2 ? 0 : 1), 1);
          },
          getPixelForValue: function(value2, index2, datasetIndex) {
            var me2 = this;
            var valueCategory, labels, idx;
            if (!isNullOrUndef$1(index2) && !isNullOrUndef$1(datasetIndex)) {
              value2 = me2.chart.data.datasets[datasetIndex].data[index2];
            }
            if (!isNullOrUndef$1(value2)) {
              valueCategory = me2.isHorizontal() ? value2.x : value2.y;
            }
            if (valueCategory !== void 0 || value2 !== void 0 && isNaN(index2)) {
              labels = me2._getLabels();
              value2 = helpers$1.valueOrDefault(valueCategory, value2);
              idx = labels.indexOf(value2);
              index2 = idx !== -1 ? idx : index2;
              if (isNaN(index2)) {
                index2 = value2;
              }
            }
            return me2.getPixelForDecimal((index2 - me2._startValue) / me2._valueRange);
          },
          getPixelForTick: function(index2) {
            var ticks = this.ticks;
            return index2 < 0 || index2 > ticks.length - 1 ? null : this.getPixelForValue(ticks[index2], index2 + this.minIndex);
          },
          getValueForPixel: function(pixel) {
            var me2 = this;
            var value2 = Math.round(me2._startValue + me2.getDecimalForPixel(pixel) * me2._valueRange);
            return Math.min(Math.max(value2, 0), me2.ticks.length - 1);
          },
          getBasePixel: function() {
            return this.bottom;
          }
        });
        var _defaults = defaultConfig;
        scale_category._defaults = _defaults;
        var noop2 = helpers$1.noop;
        var isNullOrUndef$2 = helpers$1.isNullOrUndef;
        function generateTicks(generationOptions, dataRange) {
          var ticks = [];
          var MIN_SPACING = 1e-14;
          var stepSize = generationOptions.stepSize;
          var unit = stepSize || 1;
          var maxNumSpaces = generationOptions.maxTicks - 1;
          var min2 = generationOptions.min;
          var max2 = generationOptions.max;
          var precision = generationOptions.precision;
          var rmin = dataRange.min;
          var rmax = dataRange.max;
          var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
          var factor, niceMin, niceMax, numSpaces;
          if (spacing < MIN_SPACING && isNullOrUndef$2(min2) && isNullOrUndef$2(max2)) {
            return [rmin, rmax];
          }
          numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
          if (numSpaces > maxNumSpaces) {
            spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
          }
          if (stepSize || isNullOrUndef$2(precision)) {
            factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
          } else {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
          }
          niceMin = Math.floor(rmin / spacing) * spacing;
          niceMax = Math.ceil(rmax / spacing) * spacing;
          if (stepSize) {
            if (!isNullOrUndef$2(min2) && helpers$1.almostWhole(min2 / spacing, spacing / 1e3)) {
              niceMin = min2;
            }
            if (!isNullOrUndef$2(max2) && helpers$1.almostWhole(max2 / spacing, spacing / 1e3)) {
              niceMax = max2;
            }
          }
          numSpaces = (niceMax - niceMin) / spacing;
          if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
            numSpaces = Math.round(numSpaces);
          } else {
            numSpaces = Math.ceil(numSpaces);
          }
          niceMin = Math.round(niceMin * factor) / factor;
          niceMax = Math.round(niceMax * factor) / factor;
          ticks.push(isNullOrUndef$2(min2) ? niceMin : min2);
          for (var j = 1; j < numSpaces; ++j) {
            ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
          }
          ticks.push(isNullOrUndef$2(max2) ? niceMax : max2);
          return ticks;
        }
        var scale_linearbase = core_scale.extend({
          getRightValue: function(value2) {
            if (typeof value2 === "string") {
              return +value2;
            }
            return core_scale.prototype.getRightValue.call(this, value2);
          },
          handleTickRangeOptions: function() {
            var me2 = this;
            var opts = me2.options;
            var tickOpts = opts.ticks;
            if (tickOpts.beginAtZero) {
              var minSign = helpers$1.sign(me2.min);
              var maxSign = helpers$1.sign(me2.max);
              if (minSign < 0 && maxSign < 0) {
                me2.max = 0;
              } else if (minSign > 0 && maxSign > 0) {
                me2.min = 0;
              }
            }
            var setMin = tickOpts.min !== void 0 || tickOpts.suggestedMin !== void 0;
            var setMax = tickOpts.max !== void 0 || tickOpts.suggestedMax !== void 0;
            if (tickOpts.min !== void 0) {
              me2.min = tickOpts.min;
            } else if (tickOpts.suggestedMin !== void 0) {
              if (me2.min === null) {
                me2.min = tickOpts.suggestedMin;
              } else {
                me2.min = Math.min(me2.min, tickOpts.suggestedMin);
              }
            }
            if (tickOpts.max !== void 0) {
              me2.max = tickOpts.max;
            } else if (tickOpts.suggestedMax !== void 0) {
              if (me2.max === null) {
                me2.max = tickOpts.suggestedMax;
              } else {
                me2.max = Math.max(me2.max, tickOpts.suggestedMax);
              }
            }
            if (setMin !== setMax) {
              if (me2.min >= me2.max) {
                if (setMin) {
                  me2.max = me2.min + 1;
                } else {
                  me2.min = me2.max - 1;
                }
              }
            }
            if (me2.min === me2.max) {
              me2.max++;
              if (!tickOpts.beginAtZero) {
                me2.min--;
              }
            }
          },
          getTickLimit: function() {
            var me2 = this;
            var tickOpts = me2.options.ticks;
            var stepSize = tickOpts.stepSize;
            var maxTicksLimit = tickOpts.maxTicksLimit;
            var maxTicks;
            if (stepSize) {
              maxTicks = Math.ceil(me2.max / stepSize) - Math.floor(me2.min / stepSize) + 1;
            } else {
              maxTicks = me2._computeTickLimit();
              maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
              maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
          },
          _computeTickLimit: function() {
            return Number.POSITIVE_INFINITY;
          },
          handleDirectionalChanges: noop2,
          buildTicks: function() {
            var me2 = this;
            var opts = me2.options;
            var tickOpts = opts.ticks;
            var maxTicks = me2.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            var numericGeneratorOptions = {
              maxTicks,
              min: tickOpts.min,
              max: tickOpts.max,
              precision: tickOpts.precision,
              stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
            };
            var ticks = me2.ticks = generateTicks(numericGeneratorOptions, me2);
            me2.handleDirectionalChanges();
            me2.max = helpers$1.max(ticks);
            me2.min = helpers$1.min(ticks);
            if (tickOpts.reverse) {
              ticks.reverse();
              me2.start = me2.max;
              me2.end = me2.min;
            } else {
              me2.start = me2.min;
              me2.end = me2.max;
            }
          },
          convertTicksToLabels: function() {
            var me2 = this;
            me2.ticksAsNumbers = me2.ticks.slice();
            me2.zeroLineIndex = me2.ticks.indexOf(0);
            core_scale.prototype.convertTicksToLabels.call(me2);
          },
          _configure: function() {
            var me2 = this;
            var ticks = me2.getTicks();
            var start = me2.min;
            var end = me2.max;
            var offset2;
            core_scale.prototype._configure.call(me2);
            if (me2.options.offset && ticks.length) {
              offset2 = (end - start) / Math.max(ticks.length - 1, 1) / 2;
              start -= offset2;
              end += offset2;
            }
            me2._startValue = start;
            me2._endValue = end;
            me2._valueRange = end - start;
          }
        });
        var defaultConfig$1 = {
          position: "left",
          ticks: {
            callback: core_ticks.formatters.linear
          }
        };
        var DEFAULT_MIN = 0;
        var DEFAULT_MAX = 1;
        function getOrCreateStack(stacks, stacked, meta) {
          var key = [
            meta.type,
            stacked === void 0 && meta.stack === void 0 ? meta.index : "",
            meta.stack
          ].join(".");
          if (stacks[key] === void 0) {
            stacks[key] = {
              pos: [],
              neg: []
            };
          }
          return stacks[key];
        }
        function stackData(scale2, stacks, meta, data) {
          var opts = scale2.options;
          var stacked = opts.stacked;
          var stack = getOrCreateStack(stacks, stacked, meta);
          var pos = stack.pos;
          var neg = stack.neg;
          var ilen = data.length;
          var i, value2;
          for (i = 0; i < ilen; ++i) {
            value2 = scale2._parseValue(data[i]);
            if (isNaN(value2.min) || isNaN(value2.max) || meta.data[i].hidden) {
              continue;
            }
            pos[i] = pos[i] || 0;
            neg[i] = neg[i] || 0;
            if (opts.relativePoints) {
              pos[i] = 100;
            } else if (value2.min < 0 || value2.max < 0) {
              neg[i] += value2.min;
            } else {
              pos[i] += value2.max;
            }
          }
        }
        function updateMinMax(scale2, meta, data) {
          var ilen = data.length;
          var i, value2;
          for (i = 0; i < ilen; ++i) {
            value2 = scale2._parseValue(data[i]);
            if (isNaN(value2.min) || isNaN(value2.max) || meta.data[i].hidden) {
              continue;
            }
            scale2.min = Math.min(scale2.min, value2.min);
            scale2.max = Math.max(scale2.max, value2.max);
          }
        }
        var scale_linear = scale_linearbase.extend({
          determineDataLimits: function() {
            var me2 = this;
            var opts = me2.options;
            var chart = me2.chart;
            var datasets = chart.data.datasets;
            var metasets = me2._getMatchingVisibleMetas();
            var hasStacks = opts.stacked;
            var stacks = {};
            var ilen = metasets.length;
            var i, meta, data, values2;
            me2.min = Number.POSITIVE_INFINITY;
            me2.max = Number.NEGATIVE_INFINITY;
            if (hasStacks === void 0) {
              for (i = 0; !hasStacks && i < ilen; ++i) {
                meta = metasets[i];
                hasStacks = meta.stack !== void 0;
              }
            }
            for (i = 0; i < ilen; ++i) {
              meta = metasets[i];
              data = datasets[meta.index].data;
              if (hasStacks) {
                stackData(me2, stacks, meta, data);
              } else {
                updateMinMax(me2, meta, data);
              }
            }
            helpers$1.each(stacks, function(stackValues) {
              values2 = stackValues.pos.concat(stackValues.neg);
              me2.min = Math.min(me2.min, helpers$1.min(values2));
              me2.max = Math.max(me2.max, helpers$1.max(values2));
            });
            me2.min = helpers$1.isFinite(me2.min) && !isNaN(me2.min) ? me2.min : DEFAULT_MIN;
            me2.max = helpers$1.isFinite(me2.max) && !isNaN(me2.max) ? me2.max : DEFAULT_MAX;
            me2.handleTickRangeOptions();
          },
          _computeTickLimit: function() {
            var me2 = this;
            var tickFont;
            if (me2.isHorizontal()) {
              return Math.ceil(me2.width / 40);
            }
            tickFont = helpers$1.options._parseFont(me2.options.ticks);
            return Math.ceil(me2.height / tickFont.lineHeight);
          },
          handleDirectionalChanges: function() {
            if (!this.isHorizontal()) {
              this.ticks.reverse();
            }
          },
          getLabelForIndex: function(index2, datasetIndex) {
            return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index2]);
          },
          getPixelForValue: function(value2) {
            var me2 = this;
            return me2.getPixelForDecimal((+me2.getRightValue(value2) - me2._startValue) / me2._valueRange);
          },
          getValueForPixel: function(pixel) {
            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
          },
          getPixelForTick: function(index2) {
            var ticks = this.ticksAsNumbers;
            if (index2 < 0 || index2 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index2]);
          }
        });
        var _defaults$1 = defaultConfig$1;
        scale_linear._defaults = _defaults$1;
        var valueOrDefault$b = helpers$1.valueOrDefault;
        var log10 = helpers$1.math.log10;
        function generateTicks$1(generationOptions, dataRange) {
          var ticks = [];
          var tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
          var endExp = Math.floor(log10(dataRange.max));
          var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
          var exp, significand;
          if (tickVal === 0) {
            exp = Math.floor(log10(dataRange.minNotZero));
            significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
            ticks.push(tickVal);
            tickVal = significand * Math.pow(10, exp);
          } else {
            exp = Math.floor(log10(tickVal));
            significand = Math.floor(tickVal / Math.pow(10, exp));
          }
          var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
          do {
            ticks.push(tickVal);
            ++significand;
            if (significand === 10) {
              significand = 1;
              ++exp;
              precision = exp >= 0 ? 1 : precision;
            }
            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
          } while (exp < endExp || exp === endExp && significand < endSignificand);
          var lastTick = valueOrDefault$b(generationOptions.max, tickVal);
          ticks.push(lastTick);
          return ticks;
        }
        var defaultConfig$2 = {
          position: "left",
          ticks: {
            callback: core_ticks.formatters.logarithmic
          }
        };
        function nonNegativeOrDefault(value2, defaultValue2) {
          return helpers$1.isFinite(value2) && value2 >= 0 ? value2 : defaultValue2;
        }
        var scale_logarithmic = core_scale.extend({
          determineDataLimits: function() {
            var me2 = this;
            var opts = me2.options;
            var chart = me2.chart;
            var datasets = chart.data.datasets;
            var isHorizontal = me2.isHorizontal();
            function IDMatches(meta2) {
              return isHorizontal ? meta2.xAxisID === me2.id : meta2.yAxisID === me2.id;
            }
            var datasetIndex, meta, value2, data, i, ilen;
            me2.min = Number.POSITIVE_INFINITY;
            me2.max = Number.NEGATIVE_INFINITY;
            me2.minNotZero = Number.POSITIVE_INFINITY;
            var hasStacks = opts.stacked;
            if (hasStacks === void 0) {
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== void 0) {
                  hasStacks = true;
                  break;
                }
              }
            }
            if (opts.stacked || hasStacks) {
              var valuesPerStack = {};
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                var key = [
                  meta.type,
                  opts.stacked === void 0 && meta.stack === void 0 ? datasetIndex : "",
                  meta.stack
                ].join(".");
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  if (valuesPerStack[key] === void 0) {
                    valuesPerStack[key] = [];
                  }
                  data = datasets[datasetIndex].data;
                  for (i = 0, ilen = data.length; i < ilen; i++) {
                    var values2 = valuesPerStack[key];
                    value2 = me2._parseValue(data[i]);
                    if (isNaN(value2.min) || isNaN(value2.max) || meta.data[i].hidden || value2.min < 0 || value2.max < 0) {
                      continue;
                    }
                    values2[i] = values2[i] || 0;
                    values2[i] += value2.max;
                  }
                }
              }
              helpers$1.each(valuesPerStack, function(valuesForType) {
                if (valuesForType.length > 0) {
                  var minVal = helpers$1.min(valuesForType);
                  var maxVal = helpers$1.max(valuesForType);
                  me2.min = Math.min(me2.min, minVal);
                  me2.max = Math.max(me2.max, maxVal);
                }
              });
            } else {
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  data = datasets[datasetIndex].data;
                  for (i = 0, ilen = data.length; i < ilen; i++) {
                    value2 = me2._parseValue(data[i]);
                    if (isNaN(value2.min) || isNaN(value2.max) || meta.data[i].hidden || value2.min < 0 || value2.max < 0) {
                      continue;
                    }
                    me2.min = Math.min(value2.min, me2.min);
                    me2.max = Math.max(value2.max, me2.max);
                    if (value2.min !== 0) {
                      me2.minNotZero = Math.min(value2.min, me2.minNotZero);
                    }
                  }
                }
              }
            }
            me2.min = helpers$1.isFinite(me2.min) ? me2.min : null;
            me2.max = helpers$1.isFinite(me2.max) ? me2.max : null;
            me2.minNotZero = helpers$1.isFinite(me2.minNotZero) ? me2.minNotZero : null;
            this.handleTickRangeOptions();
          },
          handleTickRangeOptions: function() {
            var me2 = this;
            var tickOpts = me2.options.ticks;
            var DEFAULT_MIN2 = 1;
            var DEFAULT_MAX2 = 10;
            me2.min = nonNegativeOrDefault(tickOpts.min, me2.min);
            me2.max = nonNegativeOrDefault(tickOpts.max, me2.max);
            if (me2.min === me2.max) {
              if (me2.min !== 0 && me2.min !== null) {
                me2.min = Math.pow(10, Math.floor(log10(me2.min)) - 1);
                me2.max = Math.pow(10, Math.floor(log10(me2.max)) + 1);
              } else {
                me2.min = DEFAULT_MIN2;
                me2.max = DEFAULT_MAX2;
              }
            }
            if (me2.min === null) {
              me2.min = Math.pow(10, Math.floor(log10(me2.max)) - 1);
            }
            if (me2.max === null) {
              me2.max = me2.min !== 0 ? Math.pow(10, Math.floor(log10(me2.min)) + 1) : DEFAULT_MAX2;
            }
            if (me2.minNotZero === null) {
              if (me2.min > 0) {
                me2.minNotZero = me2.min;
              } else if (me2.max < 1) {
                me2.minNotZero = Math.pow(10, Math.floor(log10(me2.max)));
              } else {
                me2.minNotZero = DEFAULT_MIN2;
              }
            }
          },
          buildTicks: function() {
            var me2 = this;
            var tickOpts = me2.options.ticks;
            var reverse = !me2.isHorizontal();
            var generationOptions = {
              min: nonNegativeOrDefault(tickOpts.min),
              max: nonNegativeOrDefault(tickOpts.max)
            };
            var ticks = me2.ticks = generateTicks$1(generationOptions, me2);
            me2.max = helpers$1.max(ticks);
            me2.min = helpers$1.min(ticks);
            if (tickOpts.reverse) {
              reverse = !reverse;
              me2.start = me2.max;
              me2.end = me2.min;
            } else {
              me2.start = me2.min;
              me2.end = me2.max;
            }
            if (reverse) {
              ticks.reverse();
            }
          },
          convertTicksToLabels: function() {
            this.tickValues = this.ticks.slice();
            core_scale.prototype.convertTicksToLabels.call(this);
          },
          getLabelForIndex: function(index2, datasetIndex) {
            return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index2]);
          },
          getPixelForTick: function(index2) {
            var ticks = this.tickValues;
            if (index2 < 0 || index2 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index2]);
          },
          _getFirstTickValue: function(value2) {
            var exp = Math.floor(log10(value2));
            var significand = Math.floor(value2 / Math.pow(10, exp));
            return significand * Math.pow(10, exp);
          },
          _configure: function() {
            var me2 = this;
            var start = me2.min;
            var offset2 = 0;
            core_scale.prototype._configure.call(me2);
            if (start === 0) {
              start = me2._getFirstTickValue(me2.minNotZero);
              offset2 = valueOrDefault$b(me2.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me2._length;
            }
            me2._startValue = log10(start);
            me2._valueOffset = offset2;
            me2._valueRange = (log10(me2.max) - log10(start)) / (1 - offset2);
          },
          getPixelForValue: function(value2) {
            var me2 = this;
            var decimal = 0;
            value2 = +me2.getRightValue(value2);
            if (value2 > me2.min && value2 > 0) {
              decimal = (log10(value2) - me2._startValue) / me2._valueRange + me2._valueOffset;
            }
            return me2.getPixelForDecimal(decimal);
          },
          getValueForPixel: function(pixel) {
            var me2 = this;
            var decimal = me2.getDecimalForPixel(pixel);
            return decimal === 0 && me2.min === 0 ? 0 : Math.pow(10, me2._startValue + (decimal - me2._valueOffset) * me2._valueRange);
          }
        });
        var _defaults$2 = defaultConfig$2;
        scale_logarithmic._defaults = _defaults$2;
        var valueOrDefault$c = helpers$1.valueOrDefault;
        var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
        var resolve$4 = helpers$1.options.resolve;
        var defaultConfig$3 = {
          display: true,
          animate: true,
          position: "chartArea",
          angleLines: {
            display: true,
            color: "rgba(0,0,0,0.1)",
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
          },
          gridLines: {
            circular: false
          },
          ticks: {
            showLabelBackdrop: true,
            backdropColor: "rgba(255,255,255,0.75)",
            backdropPaddingY: 2,
            backdropPaddingX: 2,
            callback: core_ticks.formatters.linear
          },
          pointLabels: {
            display: true,
            fontSize: 10,
            callback: function(label) {
              return label;
            }
          }
        };
        function getTickBackdropHeight(opts) {
          var tickOpts = opts.ticks;
          if (tickOpts.display && opts.display) {
            return valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
          }
          return 0;
        }
        function measureLabelSize(ctx, lineHeight, label) {
          if (helpers$1.isArray(label)) {
            return {
              w: helpers$1.longestText(ctx, ctx.font, label),
              h: label.length * lineHeight
            };
          }
          return {
            w: ctx.measureText(label).width,
            h: lineHeight
          };
        }
        function determineLimits(angle, pos, size2, min2, max2) {
          if (angle === min2 || angle === max2) {
            return {
              start: pos - size2 / 2,
              end: pos + size2 / 2
            };
          } else if (angle < min2 || angle > max2) {
            return {
              start: pos - size2,
              end: pos
            };
          }
          return {
            start: pos,
            end: pos + size2
          };
        }
        function fitWithPointLabels(scale2) {
          var plFont = helpers$1.options._parseFont(scale2.options.pointLabels);
          var furthestLimits = {
            l: 0,
            r: scale2.width,
            t: 0,
            b: scale2.height - scale2.paddingTop
          };
          var furthestAngles = {};
          var i, textSize, pointPosition;
          scale2.ctx.font = plFont.string;
          scale2._pointLabelSizes = [];
          var valueCount = scale2.chart.data.labels.length;
          for (i = 0; i < valueCount; i++) {
            pointPosition = scale2.getPointPosition(i, scale2.drawingArea + 5);
            textSize = measureLabelSize(scale2.ctx, plFont.lineHeight, scale2.pointLabels[i]);
            scale2._pointLabelSizes[i] = textSize;
            var angleRadians = scale2.getIndexAngle(i);
            var angle = helpers$1.toDegrees(angleRadians) % 360;
            var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
            var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            if (hLimits.start < furthestLimits.l) {
              furthestLimits.l = hLimits.start;
              furthestAngles.l = angleRadians;
            }
            if (hLimits.end > furthestLimits.r) {
              furthestLimits.r = hLimits.end;
              furthestAngles.r = angleRadians;
            }
            if (vLimits.start < furthestLimits.t) {
              furthestLimits.t = vLimits.start;
              furthestAngles.t = angleRadians;
            }
            if (vLimits.end > furthestLimits.b) {
              furthestLimits.b = vLimits.end;
              furthestAngles.b = angleRadians;
            }
          }
          scale2.setReductions(scale2.drawingArea, furthestLimits, furthestAngles);
        }
        function getTextAlignForAngle(angle) {
          if (angle === 0 || angle === 180) {
            return "center";
          } else if (angle < 180) {
            return "left";
          }
          return "right";
        }
        function fillText(ctx, text, position, lineHeight) {
          var y2 = position.y + lineHeight / 2;
          var i, ilen;
          if (helpers$1.isArray(text)) {
            for (i = 0, ilen = text.length; i < ilen; ++i) {
              ctx.fillText(text[i], position.x, y2);
              y2 += lineHeight;
            }
          } else {
            ctx.fillText(text, position.x, y2);
          }
        }
        function adjustPointPositionForLabelHeight(angle, textSize, position) {
          if (angle === 90 || angle === 270) {
            position.y -= textSize.h / 2;
          } else if (angle > 270 || angle < 90) {
            position.y -= textSize.h;
          }
        }
        function drawPointLabels(scale2) {
          var ctx = scale2.ctx;
          var opts = scale2.options;
          var pointLabelOpts = opts.pointLabels;
          var tickBackdropHeight = getTickBackdropHeight(opts);
          var outerDistance = scale2.getDistanceFromCenterForValue(opts.ticks.reverse ? scale2.min : scale2.max);
          var plFont = helpers$1.options._parseFont(pointLabelOpts);
          ctx.save();
          ctx.font = plFont.string;
          ctx.textBaseline = "middle";
          for (var i = scale2.chart.data.labels.length - 1; i >= 0; i--) {
            var extra = i === 0 ? tickBackdropHeight / 2 : 0;
            var pointLabelPosition = scale2.getPointPosition(i, outerDistance + extra + 5);
            var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
            ctx.fillStyle = pointLabelFontColor;
            var angleRadians = scale2.getIndexAngle(i);
            var angle = helpers$1.toDegrees(angleRadians);
            ctx.textAlign = getTextAlignForAngle(angle);
            adjustPointPositionForLabelHeight(angle, scale2._pointLabelSizes[i], pointLabelPosition);
            fillText(ctx, scale2.pointLabels[i], pointLabelPosition, plFont.lineHeight);
          }
          ctx.restore();
        }
        function drawRadiusLine(scale2, gridLineOpts, radius, index2) {
          var ctx = scale2.ctx;
          var circular = gridLineOpts.circular;
          var valueCount = scale2.chart.data.labels.length;
          var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index2 - 1);
          var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index2 - 1);
          var pointPosition;
          if (!circular && !valueCount || !lineColor || !lineWidth) {
            return;
          }
          ctx.save();
          ctx.strokeStyle = lineColor;
          ctx.lineWidth = lineWidth;
          if (ctx.setLineDash) {
            ctx.setLineDash(gridLineOpts.borderDash || []);
            ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0;
          }
          ctx.beginPath();
          if (circular) {
            ctx.arc(scale2.xCenter, scale2.yCenter, radius, 0, Math.PI * 2);
          } else {
            pointPosition = scale2.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (var i = 1; i < valueCount; i++) {
              pointPosition = scale2.getPointPosition(i, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
            }
          }
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
        function numberOrZero(param) {
          return helpers$1.isNumber(param) ? param : 0;
        }
        var scale_radialLinear = scale_linearbase.extend({
          setDimensions: function() {
            var me2 = this;
            me2.width = me2.maxWidth;
            me2.height = me2.maxHeight;
            me2.paddingTop = getTickBackdropHeight(me2.options) / 2;
            me2.xCenter = Math.floor(me2.width / 2);
            me2.yCenter = Math.floor((me2.height - me2.paddingTop) / 2);
            me2.drawingArea = Math.min(me2.height - me2.paddingTop, me2.width) / 2;
          },
          determineDataLimits: function() {
            var me2 = this;
            var chart = me2.chart;
            var min2 = Number.POSITIVE_INFINITY;
            var max2 = Number.NEGATIVE_INFINITY;
            helpers$1.each(chart.data.datasets, function(dataset, datasetIndex) {
              if (chart.isDatasetVisible(datasetIndex)) {
                var meta = chart.getDatasetMeta(datasetIndex);
                helpers$1.each(dataset.data, function(rawValue, index2) {
                  var value2 = +me2.getRightValue(rawValue);
                  if (isNaN(value2) || meta.data[index2].hidden) {
                    return;
                  }
                  min2 = Math.min(value2, min2);
                  max2 = Math.max(value2, max2);
                });
              }
            });
            me2.min = min2 === Number.POSITIVE_INFINITY ? 0 : min2;
            me2.max = max2 === Number.NEGATIVE_INFINITY ? 0 : max2;
            me2.handleTickRangeOptions();
          },
          _computeTickLimit: function() {
            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
          },
          convertTicksToLabels: function() {
            var me2 = this;
            scale_linearbase.prototype.convertTicksToLabels.call(me2);
            me2.pointLabels = me2.chart.data.labels.map(function() {
              var label = helpers$1.callback(me2.options.pointLabels.callback, arguments, me2);
              return label || label === 0 ? label : "";
            });
          },
          getLabelForIndex: function(index2, datasetIndex) {
            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index2]);
          },
          fit: function() {
            var me2 = this;
            var opts = me2.options;
            if (opts.display && opts.pointLabels.display) {
              fitWithPointLabels(me2);
            } else {
              me2.setCenterPoint(0, 0, 0, 0);
            }
          },
          setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
            var me2 = this;
            var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
            var radiusReductionRight = Math.max(furthestLimits.r - me2.width, 0) / Math.sin(furthestAngles.r);
            var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
            var radiusReductionBottom = -Math.max(furthestLimits.b - (me2.height - me2.paddingTop), 0) / Math.cos(furthestAngles.b);
            radiusReductionLeft = numberOrZero(radiusReductionLeft);
            radiusReductionRight = numberOrZero(radiusReductionRight);
            radiusReductionTop = numberOrZero(radiusReductionTop);
            radiusReductionBottom = numberOrZero(radiusReductionBottom);
            me2.drawingArea = Math.min(
              Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
              Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)
            );
            me2.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
          },
          setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
            var me2 = this;
            var maxRight = me2.width - rightMovement - me2.drawingArea;
            var maxLeft = leftMovement + me2.drawingArea;
            var maxTop = topMovement + me2.drawingArea;
            var maxBottom = me2.height - me2.paddingTop - bottomMovement - me2.drawingArea;
            me2.xCenter = Math.floor((maxLeft + maxRight) / 2 + me2.left);
            me2.yCenter = Math.floor((maxTop + maxBottom) / 2 + me2.top + me2.paddingTop);
          },
          getIndexAngle: function(index2) {
            var chart = this.chart;
            var angleMultiplier = 360 / chart.data.labels.length;
            var options2 = chart.options || {};
            var startAngle = options2.startAngle || 0;
            var angle = (index2 * angleMultiplier + startAngle) % 360;
            return (angle < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;
          },
          getDistanceFromCenterForValue: function(value2) {
            var me2 = this;
            if (helpers$1.isNullOrUndef(value2)) {
              return NaN;
            }
            var scalingFactor = me2.drawingArea / (me2.max - me2.min);
            if (me2.options.ticks.reverse) {
              return (me2.max - value2) * scalingFactor;
            }
            return (value2 - me2.min) * scalingFactor;
          },
          getPointPosition: function(index2, distanceFromCenter) {
            var me2 = this;
            var thisAngle = me2.getIndexAngle(index2) - Math.PI / 2;
            return {
              x: Math.cos(thisAngle) * distanceFromCenter + me2.xCenter,
              y: Math.sin(thisAngle) * distanceFromCenter + me2.yCenter
            };
          },
          getPointPositionForValue: function(index2, value2) {
            return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value2));
          },
          getBasePosition: function(index2) {
            var me2 = this;
            var min2 = me2.min;
            var max2 = me2.max;
            return me2.getPointPositionForValue(
              index2 || 0,
              me2.beginAtZero ? 0 : min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0
            );
          },
          _drawGrid: function() {
            var me2 = this;
            var ctx = me2.ctx;
            var opts = me2.options;
            var gridLineOpts = opts.gridLines;
            var angleLineOpts = opts.angleLines;
            var lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
            var lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);
            var i, offset2, position;
            if (opts.pointLabels.display) {
              drawPointLabels(me2);
            }
            if (gridLineOpts.display) {
              helpers$1.each(me2.ticks, function(label, index2) {
                if (index2 !== 0) {
                  offset2 = me2.getDistanceFromCenterForValue(me2.ticksAsNumbers[index2]);
                  drawRadiusLine(me2, gridLineOpts, offset2, index2);
                }
              });
            }
            if (angleLineOpts.display && lineWidth && lineColor) {
              ctx.save();
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = lineColor;
              if (ctx.setLineDash) {
                ctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
                ctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0]);
              }
              for (i = me2.chart.data.labels.length - 1; i >= 0; i--) {
                offset2 = me2.getDistanceFromCenterForValue(opts.ticks.reverse ? me2.min : me2.max);
                position = me2.getPointPosition(i, offset2);
                ctx.beginPath();
                ctx.moveTo(me2.xCenter, me2.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
              }
              ctx.restore();
            }
          },
          _drawLabels: function() {
            var me2 = this;
            var ctx = me2.ctx;
            var opts = me2.options;
            var tickOpts = opts.ticks;
            if (!tickOpts.display) {
              return;
            }
            var startAngle = me2.getIndexAngle(0);
            var tickFont = helpers$1.options._parseFont(tickOpts);
            var tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);
            var offset2, width2;
            ctx.save();
            ctx.font = tickFont.string;
            ctx.translate(me2.xCenter, me2.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            helpers$1.each(me2.ticks, function(label, index2) {
              if (index2 === 0 && !tickOpts.reverse) {
                return;
              }
              offset2 = me2.getDistanceFromCenterForValue(me2.ticksAsNumbers[index2]);
              if (tickOpts.showLabelBackdrop) {
                width2 = ctx.measureText(label).width;
                ctx.fillStyle = tickOpts.backdropColor;
                ctx.fillRect(
                  -width2 / 2 - tickOpts.backdropPaddingX,
                  -offset2 - tickFont.size / 2 - tickOpts.backdropPaddingY,
                  width2 + tickOpts.backdropPaddingX * 2,
                  tickFont.size + tickOpts.backdropPaddingY * 2
                );
              }
              ctx.fillStyle = tickFontColor;
              ctx.fillText(label, 0, -offset2);
            });
            ctx.restore();
          },
          _drawTitle: helpers$1.noop
        });
        var _defaults$3 = defaultConfig$3;
        scale_radialLinear._defaults = _defaults$3;
        var deprecated$1 = helpers$1._deprecated;
        var resolve$5 = helpers$1.options.resolve;
        var valueOrDefault$d = helpers$1.valueOrDefault;
        var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
        var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        var INTERVALS = {
          millisecond: {
            common: true,
            size: 1,
            steps: 1e3
          },
          second: {
            common: true,
            size: 1e3,
            steps: 60
          },
          minute: {
            common: true,
            size: 6e4,
            steps: 60
          },
          hour: {
            common: true,
            size: 36e5,
            steps: 24
          },
          day: {
            common: true,
            size: 864e5,
            steps: 30
          },
          week: {
            common: false,
            size: 6048e5,
            steps: 4
          },
          month: {
            common: true,
            size: 2628e6,
            steps: 12
          },
          quarter: {
            common: false,
            size: 7884e6,
            steps: 4
          },
          year: {
            common: true,
            size: 3154e7
          }
        };
        var UNITS = Object.keys(INTERVALS);
        function sorter(a, b) {
          return a - b;
        }
        function arrayUnique(items2) {
          var hash = {};
          var out = [];
          var i, ilen, item;
          for (i = 0, ilen = items2.length; i < ilen; ++i) {
            item = items2[i];
            if (!hash[item]) {
              hash[item] = true;
              out.push(item);
            }
          }
          return out;
        }
        function getMin(options2) {
          return helpers$1.valueOrDefault(options2.time.min, options2.ticks.min);
        }
        function getMax(options2) {
          return helpers$1.valueOrDefault(options2.time.max, options2.ticks.max);
        }
        function buildLookupTable(timestamps, min2, max2, distribution) {
          if (distribution === "linear" || !timestamps.length) {
            return [
              { time: min2, pos: 0 },
              { time: max2, pos: 1 }
            ];
          }
          var table = [];
          var items2 = [min2];
          var i, ilen, prev, curr, next;
          for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
            curr = timestamps[i];
            if (curr > min2 && curr < max2) {
              items2.push(curr);
            }
          }
          items2.push(max2);
          for (i = 0, ilen = items2.length; i < ilen; ++i) {
            next = items2[i + 1];
            prev = items2[i - 1];
            curr = items2[i];
            if (prev === void 0 || next === void 0 || Math.round((next + prev) / 2) !== curr) {
              table.push({ time: curr, pos: i / (ilen - 1) });
            }
          }
          return table;
        }
        function lookup(table, key, value2) {
          var lo = 0;
          var hi2 = table.length - 1;
          var mid, i0, i1;
          while (lo >= 0 && lo <= hi2) {
            mid = lo + hi2 >> 1;
            i0 = table[mid - 1] || null;
            i1 = table[mid];
            if (!i0) {
              return { lo: null, hi: i1 };
            } else if (i1[key] < value2) {
              lo = mid + 1;
            } else if (i0[key] > value2) {
              hi2 = mid - 1;
            } else {
              return { lo: i0, hi: i1 };
            }
          }
          return { lo: i1, hi: null };
        }
        function interpolate$1(table, skey, sval, tkey) {
          var range2 = lookup(table, skey, sval);
          var prev = !range2.lo ? table[0] : !range2.hi ? table[table.length - 2] : range2.lo;
          var next = !range2.lo ? table[1] : !range2.hi ? table[table.length - 1] : range2.hi;
          var span = next[skey] - prev[skey];
          var ratio = span ? (sval - prev[skey]) / span : 0;
          var offset2 = (next[tkey] - prev[tkey]) * ratio;
          return prev[tkey] + offset2;
        }
        function toTimestamp(scale2, input) {
          var adapter = scale2._adapter;
          var options2 = scale2.options.time;
          var parser = options2.parser;
          var format2 = parser || options2.format;
          var value2 = input;
          if (typeof parser === "function") {
            value2 = parser(value2);
          }
          if (!helpers$1.isFinite(value2)) {
            value2 = typeof format2 === "string" ? adapter.parse(value2, format2) : adapter.parse(value2);
          }
          if (value2 !== null) {
            return +value2;
          }
          if (!parser && typeof format2 === "function") {
            value2 = format2(input);
            if (!helpers$1.isFinite(value2)) {
              value2 = adapter.parse(value2);
            }
          }
          return value2;
        }
        function parse2(scale2, input) {
          if (helpers$1.isNullOrUndef(input)) {
            return null;
          }
          var options2 = scale2.options.time;
          var value2 = toTimestamp(scale2, scale2.getRightValue(input));
          if (value2 === null) {
            return value2;
          }
          if (options2.round) {
            value2 = +scale2._adapter.startOf(value2, options2.round);
          }
          return value2;
        }
        function determineUnitForAutoTicks(minUnit, min2, max2, capacity) {
          var ilen = UNITS.length;
          var i, interval, factor;
          for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
            interval = INTERVALS[UNITS[i]];
            factor = interval.steps ? interval.steps : MAX_INTEGER;
            if (interval.common && Math.ceil((max2 - min2) / (factor * interval.size)) <= capacity) {
              return UNITS[i];
            }
          }
          return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(scale2, numTicks, minUnit, min2, max2) {
          var i, unit;
          for (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
            unit = UNITS[i];
            if (INTERVALS[unit].common && scale2._adapter.diff(max2, min2, unit) >= numTicks - 1) {
              return unit;
            }
          }
          return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
          for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
            if (INTERVALS[UNITS[i]].common) {
              return UNITS[i];
            }
          }
        }
        function generate(scale2, min2, max2, capacity) {
          var adapter = scale2._adapter;
          var options2 = scale2.options;
          var timeOpts = options2.time;
          var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min2, max2, capacity);
          var stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize, 1]);
          var weekday = minor === "week" ? timeOpts.isoWeekday : false;
          var first2 = min2;
          var ticks = [];
          var time;
          if (weekday) {
            first2 = +adapter.startOf(first2, "isoWeek", weekday);
          }
          first2 = +adapter.startOf(first2, weekday ? "day" : minor);
          if (adapter.diff(max2, min2, minor) > 1e5 * stepSize) {
            throw min2 + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor;
          }
          for (time = first2; time < max2; time = +adapter.add(time, stepSize, minor)) {
            ticks.push(time);
          }
          if (time === max2 || options2.bounds === "ticks") {
            ticks.push(time);
          }
          return ticks;
        }
        function computeOffsets(table, ticks, min2, max2, options2) {
          var start = 0;
          var end = 0;
          var first2, last2;
          if (options2.offset && ticks.length) {
            first2 = interpolate$1(table, "time", ticks[0], "pos");
            if (ticks.length === 1) {
              start = 1 - first2;
            } else {
              start = (interpolate$1(table, "time", ticks[1], "pos") - first2) / 2;
            }
            last2 = interpolate$1(table, "time", ticks[ticks.length - 1], "pos");
            if (ticks.length === 1) {
              end = last2;
            } else {
              end = (last2 - interpolate$1(table, "time", ticks[ticks.length - 2], "pos")) / 2;
            }
          }
          return { start, end, factor: 1 / (start + 1 + end) };
        }
        function setMajorTicks(scale2, ticks, map2, majorUnit) {
          var adapter = scale2._adapter;
          var first2 = +adapter.startOf(ticks[0].value, majorUnit);
          var last2 = ticks[ticks.length - 1].value;
          var major, index2;
          for (major = first2; major <= last2; major = +adapter.add(major, 1, majorUnit)) {
            index2 = map2[major];
            if (index2 >= 0) {
              ticks[index2].major = true;
            }
          }
          return ticks;
        }
        function ticksFromTimestamps(scale2, values2, majorUnit) {
          var ticks = [];
          var map2 = {};
          var ilen = values2.length;
          var i, value2;
          for (i = 0; i < ilen; ++i) {
            value2 = values2[i];
            map2[value2] = i;
            ticks.push({
              value: value2,
              major: false
            });
          }
          return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale2, ticks, map2, majorUnit);
        }
        var defaultConfig$4 = {
          position: "bottom",
          distribution: "linear",
          bounds: "data",
          adapters: {},
          time: {
            parser: false,
            unit: false,
            round: false,
            displayFormat: false,
            isoWeekday: false,
            minUnit: "millisecond",
            displayFormats: {}
          },
          ticks: {
            autoSkip: false,
            source: "auto",
            major: {
              enabled: false
            }
          }
        };
        var scale_time = core_scale.extend({
          initialize: function() {
            this.mergeTicksOptions();
            core_scale.prototype.initialize.call(this);
          },
          update: function() {
            var me2 = this;
            var options2 = me2.options;
            var time = options2.time || (options2.time = {});
            var adapter = me2._adapter = new core_adapters._date(options2.adapters.date);
            deprecated$1("time scale", time.format, "time.format", "time.parser");
            deprecated$1("time scale", time.min, "time.min", "ticks.min");
            deprecated$1("time scale", time.max, "time.max", "ticks.max");
            helpers$1.mergeIf(time.displayFormats, adapter.formats());
            return core_scale.prototype.update.apply(me2, arguments);
          },
          getRightValue: function(rawValue) {
            if (rawValue && rawValue.t !== void 0) {
              rawValue = rawValue.t;
            }
            return core_scale.prototype.getRightValue.call(this, rawValue);
          },
          determineDataLimits: function() {
            var me2 = this;
            var chart = me2.chart;
            var adapter = me2._adapter;
            var options2 = me2.options;
            var unit = options2.time.unit || "day";
            var min2 = MAX_INTEGER;
            var max2 = MIN_INTEGER;
            var timestamps = [];
            var datasets = [];
            var labels = [];
            var i, j, ilen, jlen, data, timestamp, labelsAdded;
            var dataLabels = me2._getLabels();
            for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
              labels.push(parse2(me2, dataLabels[i]));
            }
            for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                data = chart.data.datasets[i].data;
                if (helpers$1.isObject(data[0])) {
                  datasets[i] = [];
                  for (j = 0, jlen = data.length; j < jlen; ++j) {
                    timestamp = parse2(me2, data[j]);
                    timestamps.push(timestamp);
                    datasets[i][j] = timestamp;
                  }
                } else {
                  datasets[i] = labels.slice(0);
                  if (!labelsAdded) {
                    timestamps = timestamps.concat(labels);
                    labelsAdded = true;
                  }
                }
              } else {
                datasets[i] = [];
              }
            }
            if (labels.length) {
              min2 = Math.min(min2, labels[0]);
              max2 = Math.max(max2, labels[labels.length - 1]);
            }
            if (timestamps.length) {
              timestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);
              min2 = Math.min(min2, timestamps[0]);
              max2 = Math.max(max2, timestamps[timestamps.length - 1]);
            }
            min2 = parse2(me2, getMin(options2)) || min2;
            max2 = parse2(me2, getMax(options2)) || max2;
            min2 = min2 === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min2;
            max2 = max2 === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max2;
            me2.min = Math.min(min2, max2);
            me2.max = Math.max(min2 + 1, max2);
            me2._table = [];
            me2._timestamps = {
              data: timestamps,
              datasets,
              labels
            };
          },
          buildTicks: function() {
            var me2 = this;
            var min2 = me2.min;
            var max2 = me2.max;
            var options2 = me2.options;
            var tickOpts = options2.ticks;
            var timeOpts = options2.time;
            var timestamps = me2._timestamps;
            var ticks = [];
            var capacity = me2.getLabelCapacity(min2);
            var source = tickOpts.source;
            var distribution = options2.distribution;
            var i, ilen, timestamp;
            if (source === "data" || source === "auto" && distribution === "series") {
              timestamps = timestamps.data;
            } else if (source === "labels") {
              timestamps = timestamps.labels;
            } else {
              timestamps = generate(me2, min2, max2, capacity);
            }
            if (options2.bounds === "ticks" && timestamps.length) {
              min2 = timestamps[0];
              max2 = timestamps[timestamps.length - 1];
            }
            min2 = parse2(me2, getMin(options2)) || min2;
            max2 = parse2(me2, getMax(options2)) || max2;
            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
              timestamp = timestamps[i];
              if (timestamp >= min2 && timestamp <= max2) {
                ticks.push(timestamp);
              }
            }
            me2.min = min2;
            me2.max = max2;
            me2._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me2.min, me2.max, capacity) : determineUnitForFormatting(me2, ticks.length, timeOpts.minUnit, me2.min, me2.max));
            me2._majorUnit = !tickOpts.major.enabled || me2._unit === "year" ? void 0 : determineMajorUnit(me2._unit);
            me2._table = buildLookupTable(me2._timestamps.data, min2, max2, distribution);
            me2._offsets = computeOffsets(me2._table, ticks, min2, max2, options2);
            if (tickOpts.reverse) {
              ticks.reverse();
            }
            return ticksFromTimestamps(me2, ticks, me2._majorUnit);
          },
          getLabelForIndex: function(index2, datasetIndex) {
            var me2 = this;
            var adapter = me2._adapter;
            var data = me2.chart.data;
            var timeOpts = me2.options.time;
            var label = data.labels && index2 < data.labels.length ? data.labels[index2] : "";
            var value2 = data.datasets[datasetIndex].data[index2];
            if (helpers$1.isObject(value2)) {
              label = me2.getRightValue(value2);
            }
            if (timeOpts.tooltipFormat) {
              return adapter.format(toTimestamp(me2, label), timeOpts.tooltipFormat);
            }
            if (typeof label === "string") {
              return label;
            }
            return adapter.format(toTimestamp(me2, label), timeOpts.displayFormats.datetime);
          },
          tickFormatFunction: function(time, index2, ticks, format2) {
            var me2 = this;
            var adapter = me2._adapter;
            var options2 = me2.options;
            var formats2 = options2.time.displayFormats;
            var minorFormat = formats2[me2._unit];
            var majorUnit = me2._majorUnit;
            var majorFormat = formats2[majorUnit];
            var tick = ticks[index2];
            var tickOpts = options2.ticks;
            var major = majorUnit && majorFormat && tick && tick.major;
            var label = adapter.format(time, format2 ? format2 : major ? majorFormat : minorFormat);
            var nestedTickOpts = major ? tickOpts.major : tickOpts.minor;
            var formatter = resolve$5([
              nestedTickOpts.callback,
              nestedTickOpts.userCallback,
              tickOpts.callback,
              tickOpts.userCallback
            ]);
            return formatter ? formatter(label, index2, ticks) : label;
          },
          convertTicksToLabels: function(ticks) {
            var labels = [];
            var i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
            }
            return labels;
          },
          getPixelForOffset: function(time) {
            var me2 = this;
            var offsets = me2._offsets;
            var pos = interpolate$1(me2._table, "time", time, "pos");
            return me2.getPixelForDecimal((offsets.start + pos) * offsets.factor);
          },
          getPixelForValue: function(value2, index2, datasetIndex) {
            var me2 = this;
            var time = null;
            if (index2 !== void 0 && datasetIndex !== void 0) {
              time = me2._timestamps.datasets[datasetIndex][index2];
            }
            if (time === null) {
              time = parse2(me2, value2);
            }
            if (time !== null) {
              return me2.getPixelForOffset(time);
            }
          },
          getPixelForTick: function(index2) {
            var ticks = this.getTicks();
            return index2 >= 0 && index2 < ticks.length ? this.getPixelForOffset(ticks[index2].value) : null;
          },
          getValueForPixel: function(pixel) {
            var me2 = this;
            var offsets = me2._offsets;
            var pos = me2.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            var time = interpolate$1(me2._table, "pos", pos, "time");
            return me2._adapter._create(time);
          },
          _getLabelSize: function(label) {
            var me2 = this;
            var ticksOpts = me2.options.ticks;
            var tickLabelWidth = me2.ctx.measureText(label).width;
            var angle = helpers$1.toRadians(me2.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
            var cosRotation = Math.cos(angle);
            var sinRotation = Math.sin(angle);
            var tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
            return {
              w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
              h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
            };
          },
          getLabelWidth: function(label) {
            return this._getLabelSize(label).w;
          },
          getLabelCapacity: function(exampleTime) {
            var me2 = this;
            var timeOpts = me2.options.time;
            var displayFormats = timeOpts.displayFormats;
            var format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
            var exampleLabel = me2.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me2, [exampleTime], me2._majorUnit), format2);
            var size2 = me2._getLabelSize(exampleLabel);
            var capacity = Math.floor(me2.isHorizontal() ? me2.width / size2.w : me2.height / size2.h);
            if (me2.options.offset) {
              capacity--;
            }
            return capacity > 0 ? capacity : 1;
          }
        });
        var _defaults$4 = defaultConfig$4;
        scale_time._defaults = _defaults$4;
        var scales = {
          category: scale_category,
          linear: scale_linear,
          logarithmic: scale_logarithmic,
          radialLinear: scale_radialLinear,
          time: scale_time
        };
        var FORMATS2 = {
          datetime: "MMM D, YYYY, h:mm:ss a",
          millisecond: "h:mm:ss.SSS a",
          second: "h:mm:ss a",
          minute: "h:mm a",
          hour: "hA",
          day: "MMM D",
          week: "ll",
          month: "MMM YYYY",
          quarter: "[Q]Q - YYYY",
          year: "YYYY"
        };
        core_adapters._date.override(typeof moment2 === "function" ? {
          _id: "moment",
          formats: function() {
            return FORMATS2;
          },
          parse: function(value2, format2) {
            if (typeof value2 === "string" && typeof format2 === "string") {
              value2 = moment2(value2, format2);
            } else if (!(value2 instanceof moment2)) {
              value2 = moment2(value2);
            }
            return value2.isValid() ? value2.valueOf() : null;
          },
          format: function(time, format2) {
            return moment2(time).format(format2);
          },
          add: function(time, amount, unit) {
            return moment2(time).add(amount, unit).valueOf();
          },
          diff: function(max2, min2, unit) {
            return moment2(max2).diff(moment2(min2), unit);
          },
          startOf: function(time, unit, weekday) {
            time = moment2(time);
            if (unit === "isoWeek") {
              return time.isoWeekday(weekday).valueOf();
            }
            return time.startOf(unit).valueOf();
          },
          endOf: function(time, unit) {
            return moment2(time).endOf(unit).valueOf();
          },
          _create: function(time) {
            return moment2(time);
          }
        } : {});
        core_defaults._set("global", {
          plugins: {
            filler: {
              propagate: true
            }
          }
        });
        var mappers = {
          dataset: function(source) {
            var index2 = source.fill;
            var chart = source.chart;
            var meta = chart.getDatasetMeta(index2);
            var visible = meta && chart.isDatasetVisible(index2);
            var points = visible && meta.dataset._children || [];
            var length = points.length || 0;
            return !length ? null : function(point, i) {
              return i < length && points[i]._view || null;
            };
          },
          boundary: function(source) {
            var boundary = source.boundary;
            var x2 = boundary ? boundary.x : null;
            var y2 = boundary ? boundary.y : null;
            if (helpers$1.isArray(boundary)) {
              return function(point, i) {
                return boundary[i];
              };
            }
            return function(point) {
              return {
                x: x2 === null ? point.x : x2,
                y: y2 === null ? point.y : y2
              };
            };
          }
        };
        function decodeFill(el, index2, count) {
          var model = el._model || {};
          var fill = model.fill;
          var target;
          if (fill === void 0) {
            fill = !!model.backgroundColor;
          }
          if (fill === false || fill === null) {
            return false;
          }
          if (fill === true) {
            return "origin";
          }
          target = parseFloat(fill, 10);
          if (isFinite(target) && Math.floor(target) === target) {
            if (fill[0] === "-" || fill[0] === "+") {
              target = index2 + target;
            }
            if (target === index2 || target < 0 || target >= count) {
              return false;
            }
            return target;
          }
          switch (fill) {
            case "bottom":
              return "start";
            case "top":
              return "end";
            case "zero":
              return "origin";
            case "origin":
            case "start":
            case "end":
              return fill;
            default:
              return false;
          }
        }
        function computeLinearBoundary(source) {
          var model = source.el._model || {};
          var scale2 = source.el._scale || {};
          var fill = source.fill;
          var target = null;
          var horizontal;
          if (isFinite(fill)) {
            return null;
          }
          if (fill === "start") {
            target = model.scaleBottom === void 0 ? scale2.bottom : model.scaleBottom;
          } else if (fill === "end") {
            target = model.scaleTop === void 0 ? scale2.top : model.scaleTop;
          } else if (model.scaleZero !== void 0) {
            target = model.scaleZero;
          } else if (scale2.getBasePixel) {
            target = scale2.getBasePixel();
          }
          if (target !== void 0 && target !== null) {
            if (target.x !== void 0 && target.y !== void 0) {
              return target;
            }
            if (helpers$1.isFinite(target)) {
              horizontal = scale2.isHorizontal();
              return {
                x: horizontal ? target : null,
                y: horizontal ? null : target
              };
            }
          }
          return null;
        }
        function computeCircularBoundary(source) {
          var scale2 = source.el._scale;
          var options2 = scale2.options;
          var length = scale2.chart.data.labels.length;
          var fill = source.fill;
          var target = [];
          var start, end, center, i, point;
          if (!length) {
            return null;
          }
          start = options2.ticks.reverse ? scale2.max : scale2.min;
          end = options2.ticks.reverse ? scale2.min : scale2.max;
          center = scale2.getPointPositionForValue(0, start);
          for (i = 0; i < length; ++i) {
            point = fill === "start" || fill === "end" ? scale2.getPointPositionForValue(i, fill === "start" ? start : end) : scale2.getBasePosition(i);
            if (options2.gridLines.circular) {
              point.cx = center.x;
              point.cy = center.y;
              point.angle = scale2.getIndexAngle(i) - Math.PI / 2;
            }
            target.push(point);
          }
          return target;
        }
        function computeBoundary(source) {
          var scale2 = source.el._scale || {};
          if (scale2.getPointPositionForValue) {
            return computeCircularBoundary(source);
          }
          return computeLinearBoundary(source);
        }
        function resolveTarget(sources, index2, propagate) {
          var source = sources[index2];
          var fill = source.fill;
          var visited = [index2];
          var target;
          if (!propagate) {
            return fill;
          }
          while (fill !== false && visited.indexOf(fill) === -1) {
            if (!isFinite(fill)) {
              return fill;
            }
            target = sources[fill];
            if (!target) {
              return false;
            }
            if (target.visible) {
              return fill;
            }
            visited.push(fill);
            fill = target.fill;
          }
          return false;
        }
        function createMapper(source) {
          var fill = source.fill;
          var type = "dataset";
          if (fill === false) {
            return null;
          }
          if (!isFinite(fill)) {
            type = "boundary";
          }
          return mappers[type](source);
        }
        function isDrawable(point) {
          return point && !point.skip;
        }
        function drawArea(ctx, curve0, curve1, len0, len1) {
          var i, cx, cy, r2;
          if (!len0 || !len1) {
            return;
          }
          ctx.moveTo(curve0[0].x, curve0[0].y);
          for (i = 1; i < len0; ++i) {
            helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
          }
          if (curve1[0].angle !== void 0) {
            cx = curve1[0].cx;
            cy = curve1[0].cy;
            r2 = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));
            for (i = len1 - 1; i > 0; --i) {
              ctx.arc(cx, cy, r2, curve1[i].angle, curve1[i - 1].angle, true);
            }
            return;
          }
          ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
          for (i = len1 - 1; i > 0; --i) {
            helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
          }
        }
        function doFill(ctx, points, mapper, view, color, loop) {
          var count = points.length;
          var span = view.spanGaps;
          var curve0 = [];
          var curve1 = [];
          var len0 = 0;
          var len1 = 0;
          var i, ilen, index2, p0, p1, d0, d1, loopOffset;
          ctx.beginPath();
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i % count;
            p0 = points[index2]._view;
            p1 = mapper(p0, index2, view);
            d0 = isDrawable(p0);
            d1 = isDrawable(p1);
            if (loop && loopOffset === void 0 && d0) {
              loopOffset = i + 1;
              ilen = count + loopOffset;
            }
            if (d0 && d1) {
              len0 = curve0.push(p0);
              len1 = curve1.push(p1);
            } else if (len0 && len1) {
              if (!span) {
                drawArea(ctx, curve0, curve1, len0, len1);
                len0 = len1 = 0;
                curve0 = [];
                curve1 = [];
              } else {
                if (d0) {
                  curve0.push(p0);
                }
                if (d1) {
                  curve1.push(p1);
                }
              }
            }
          }
          drawArea(ctx, curve0, curve1, len0, len1);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
        }
        var plugin_filler = {
          id: "filler",
          afterDatasetsUpdate: function(chart, options2) {
            var count = (chart.data.datasets || []).length;
            var propagate = options2.propagate;
            var sources = [];
            var meta, i, el, source;
            for (i = 0; i < count; ++i) {
              meta = chart.getDatasetMeta(i);
              el = meta.dataset;
              source = null;
              if (el && el._model && el instanceof elements.Line) {
                source = {
                  visible: chart.isDatasetVisible(i),
                  fill: decodeFill(el, i, count),
                  chart,
                  el
                };
              }
              meta.$filler = source;
              sources.push(source);
            }
            for (i = 0; i < count; ++i) {
              source = sources[i];
              if (!source) {
                continue;
              }
              source.fill = resolveTarget(sources, i, propagate);
              source.boundary = computeBoundary(source);
              source.mapper = createMapper(source);
            }
          },
          beforeDatasetsDraw: function(chart) {
            var metasets = chart._getSortedVisibleDatasetMetas();
            var ctx = chart.ctx;
            var meta, i, el, view, points, mapper, color;
            for (i = metasets.length - 1; i >= 0; --i) {
              meta = metasets[i].$filler;
              if (!meta || !meta.visible) {
                continue;
              }
              el = meta.el;
              view = el._view;
              points = el._children || [];
              mapper = meta.mapper;
              color = view.backgroundColor || core_defaults.global.defaultColor;
              if (mapper && color && points.length) {
                helpers$1.canvas.clipArea(ctx, chart.chartArea);
                doFill(ctx, points, mapper, view, color, el._loop);
                helpers$1.canvas.unclipArea(ctx);
              }
            }
          }
        };
        var getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;
        var noop$1 = helpers$1.noop;
        var valueOrDefault$e = helpers$1.valueOrDefault;
        core_defaults._set("global", {
          legend: {
            display: true,
            position: "top",
            align: "center",
            fullWidth: true,
            reverse: false,
            weight: 1e3,
            onClick: function(e, legendItem) {
              var index2 = legendItem.datasetIndex;
              var ci2 = this.chart;
              var meta = ci2.getDatasetMeta(index2);
              meta.hidden = meta.hidden === null ? !ci2.data.datasets[index2].hidden : null;
              ci2.update();
            },
            onHover: null,
            onLeave: null,
            labels: {
              boxWidth: 40,
              padding: 10,
              generateLabels: function(chart) {
                var datasets = chart.data.datasets;
                var options2 = chart.options.legend || {};
                var usePointStyle = options2.labels && options2.labels.usePointStyle;
                return chart._getSortedDatasetMetas().map(function(meta) {
                  var style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                  return {
                    text: datasets[meta.index].label,
                    fillStyle: style.backgroundColor,
                    hidden: !chart.isDatasetVisible(meta.index),
                    lineCap: style.borderCapStyle,
                    lineDash: style.borderDash,
                    lineDashOffset: style.borderDashOffset,
                    lineJoin: style.borderJoinStyle,
                    lineWidth: style.borderWidth,
                    strokeStyle: style.borderColor,
                    pointStyle: style.pointStyle,
                    rotation: style.rotation,
                    datasetIndex: meta.index
                  };
                }, this);
              }
            }
          },
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var datasets = chart.data.datasets;
            var i, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              listItem = list.appendChild(document.createElement("li"));
              listItemSpan = listItem.appendChild(document.createElement("span"));
              listItemSpan.style.backgroundColor = datasets[i].backgroundColor;
              if (datasets[i].label) {
                listItem.appendChild(document.createTextNode(datasets[i].label));
              }
            }
            return list.outerHTML;
          }
        });
        function getBoxWidth(labelOpts, fontSize) {
          return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
        }
        var Legend = core_element.extend({
          initialize: function(config) {
            var me2 = this;
            helpers$1.extend(me2, config);
            me2.legendHitBoxes = [];
            me2._hoveredItem = null;
            me2.doughnutMode = false;
          },
          beforeUpdate: noop$1,
          update: function(maxWidth, maxHeight, margins) {
            var me2 = this;
            me2.beforeUpdate();
            me2.maxWidth = maxWidth;
            me2.maxHeight = maxHeight;
            me2.margins = margins;
            me2.beforeSetDimensions();
            me2.setDimensions();
            me2.afterSetDimensions();
            me2.beforeBuildLabels();
            me2.buildLabels();
            me2.afterBuildLabels();
            me2.beforeFit();
            me2.fit();
            me2.afterFit();
            me2.afterUpdate();
            return me2.minSize;
          },
          afterUpdate: noop$1,
          beforeSetDimensions: noop$1,
          setDimensions: function() {
            var me2 = this;
            if (me2.isHorizontal()) {
              me2.width = me2.maxWidth;
              me2.left = 0;
              me2.right = me2.width;
            } else {
              me2.height = me2.maxHeight;
              me2.top = 0;
              me2.bottom = me2.height;
            }
            me2.paddingLeft = 0;
            me2.paddingTop = 0;
            me2.paddingRight = 0;
            me2.paddingBottom = 0;
            me2.minSize = {
              width: 0,
              height: 0
            };
          },
          afterSetDimensions: noop$1,
          beforeBuildLabels: noop$1,
          buildLabels: function() {
            var me2 = this;
            var labelOpts = me2.options.labels || {};
            var legendItems = helpers$1.callback(labelOpts.generateLabels, [me2.chart], me2) || [];
            if (labelOpts.filter) {
              legendItems = legendItems.filter(function(item) {
                return labelOpts.filter(item, me2.chart.data);
              });
            }
            if (me2.options.reverse) {
              legendItems.reverse();
            }
            me2.legendItems = legendItems;
          },
          afterBuildLabels: noop$1,
          beforeFit: noop$1,
          fit: function() {
            var me2 = this;
            var opts = me2.options;
            var labelOpts = opts.labels;
            var display = opts.display;
            var ctx = me2.ctx;
            var labelFont = helpers$1.options._parseFont(labelOpts);
            var fontSize = labelFont.size;
            var hitboxes = me2.legendHitBoxes = [];
            var minSize = me2.minSize;
            var isHorizontal = me2.isHorizontal();
            if (isHorizontal) {
              minSize.width = me2.maxWidth;
              minSize.height = display ? 10 : 0;
            } else {
              minSize.width = display ? 10 : 0;
              minSize.height = me2.maxHeight;
            }
            if (!display) {
              me2.width = minSize.width = me2.height = minSize.height = 0;
              return;
            }
            ctx.font = labelFont.string;
            if (isHorizontal) {
              var lineWidths = me2.lineWidths = [0];
              var totalHeight = 0;
              ctx.textAlign = "left";
              ctx.textBaseline = "middle";
              helpers$1.each(me2.legendItems, function(legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var width2 = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                if (i === 0 || lineWidths[lineWidths.length - 1] + width2 + 2 * labelOpts.padding > minSize.width) {
                  totalHeight += fontSize + labelOpts.padding;
                  lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                }
                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width: width2,
                  height: fontSize
                };
                lineWidths[lineWidths.length - 1] += width2 + labelOpts.padding;
              });
              minSize.height += totalHeight;
            } else {
              var vPadding = labelOpts.padding;
              var columnWidths = me2.columnWidths = [];
              var columnHeights = me2.columnHeights = [];
              var totalWidth = labelOpts.padding;
              var currentColWidth = 0;
              var currentColHeight = 0;
              helpers$1.each(me2.legendItems, function(legendItem, i) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                if (i > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {
                  totalWidth += currentColWidth + labelOpts.padding;
                  columnWidths.push(currentColWidth);
                  columnHeights.push(currentColHeight);
                  currentColWidth = 0;
                  currentColHeight = 0;
                }
                currentColWidth = Math.max(currentColWidth, itemWidth);
                currentColHeight += fontSize + vPadding;
                hitboxes[i] = {
                  left: 0,
                  top: 0,
                  width: itemWidth,
                  height: fontSize
                };
              });
              totalWidth += currentColWidth;
              columnWidths.push(currentColWidth);
              columnHeights.push(currentColHeight);
              minSize.width += totalWidth;
            }
            me2.width = minSize.width;
            me2.height = minSize.height;
          },
          afterFit: noop$1,
          isHorizontal: function() {
            return this.options.position === "top" || this.options.position === "bottom";
          },
          draw: function() {
            var me2 = this;
            var opts = me2.options;
            var labelOpts = opts.labels;
            var globalDefaults = core_defaults.global;
            var defaultColor2 = globalDefaults.defaultColor;
            var lineDefault = globalDefaults.elements.line;
            var legendHeight = me2.height;
            var columnHeights = me2.columnHeights;
            var legendWidth = me2.width;
            var lineWidths = me2.lineWidths;
            if (!opts.display) {
              return;
            }
            var rtlHelper = getRtlHelper$1(opts.rtl, me2.left, me2.minSize.width);
            var ctx = me2.ctx;
            var fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);
            var labelFont = helpers$1.options._parseFont(labelOpts);
            var fontSize = labelFont.size;
            var cursor;
            ctx.textAlign = rtlHelper.textAlign("left");
            ctx.textBaseline = "middle";
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = fontColor;
            ctx.fillStyle = fontColor;
            ctx.font = labelFont.string;
            var boxWidth = getBoxWidth(labelOpts, fontSize);
            var hitboxes = me2.legendHitBoxes;
            var drawLegendBox = function(x2, y2, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0) {
                return;
              }
              ctx.save();
              var lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);
              ctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor2);
              ctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);
              ctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);
              ctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor2);
              if (ctx.setLineDash) {
                ctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));
              }
              if (labelOpts && labelOpts.usePointStyle) {
                var radius = boxWidth * Math.SQRT2 / 2;
                var centerX = rtlHelper.xPlus(x2, boxWidth / 2);
                var centerY = y2 + fontSize / 2;
                helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);
              } else {
                ctx.fillRect(rtlHelper.leftForLtr(x2, boxWidth), y2, boxWidth, fontSize);
                if (lineWidth !== 0) {
                  ctx.strokeRect(rtlHelper.leftForLtr(x2, boxWidth), y2, boxWidth, fontSize);
                }
              }
              ctx.restore();
            };
            var fillText2 = function(x2, y2, legendItem, textWidth) {
              var halfFontSize = fontSize / 2;
              var xLeft = rtlHelper.xPlus(x2, boxWidth + halfFontSize);
              var yMiddle = y2 + halfFontSize;
              ctx.fillText(legendItem.text, xLeft, yMiddle);
              if (legendItem.hidden) {
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(xLeft, yMiddle);
                ctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);
                ctx.stroke();
              }
            };
            var alignmentOffset = function(dimension, blockSize) {
              switch (opts.align) {
                case "start":
                  return labelOpts.padding;
                case "end":
                  return dimension - blockSize;
                default:
                  return (dimension - blockSize + labelOpts.padding) / 2;
              }
            };
            var isHorizontal = me2.isHorizontal();
            if (isHorizontal) {
              cursor = {
                x: me2.left + alignmentOffset(legendWidth, lineWidths[0]),
                y: me2.top + labelOpts.padding,
                line: 0
              };
            } else {
              cursor = {
                x: me2.left + labelOpts.padding,
                y: me2.top + alignmentOffset(legendHeight, columnHeights[0]),
                line: 0
              };
            }
            helpers$1.rtl.overrideTextDirection(me2.ctx, opts.textDirection);
            var itemHeight = fontSize + labelOpts.padding;
            helpers$1.each(me2.legendItems, function(legendItem, i) {
              var textWidth = ctx.measureText(legendItem.text).width;
              var width2 = boxWidth + fontSize / 2 + textWidth;
              var x2 = cursor.x;
              var y2 = cursor.y;
              rtlHelper.setWidth(me2.minSize.width);
              if (isHorizontal) {
                if (i > 0 && x2 + width2 + labelOpts.padding > me2.left + me2.minSize.width) {
                  y2 = cursor.y += itemHeight;
                  cursor.line++;
                  x2 = cursor.x = me2.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);
                }
              } else if (i > 0 && y2 + itemHeight > me2.top + me2.minSize.height) {
                x2 = cursor.x = x2 + me2.columnWidths[cursor.line] + labelOpts.padding;
                cursor.line++;
                y2 = cursor.y = me2.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);
              }
              var realX = rtlHelper.x(x2);
              drawLegendBox(realX, y2, legendItem);
              hitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);
              hitboxes[i].top = y2;
              fillText2(realX, y2, legendItem, textWidth);
              if (isHorizontal) {
                cursor.x += width2 + labelOpts.padding;
              } else {
                cursor.y += itemHeight;
              }
            });
            helpers$1.rtl.restoreTextDirection(me2.ctx, opts.textDirection);
          },
          _getLegendItemAt: function(x2, y2) {
            var me2 = this;
            var i, hitBox, lh2;
            if (x2 >= me2.left && x2 <= me2.right && y2 >= me2.top && y2 <= me2.bottom) {
              lh2 = me2.legendHitBoxes;
              for (i = 0; i < lh2.length; ++i) {
                hitBox = lh2[i];
                if (x2 >= hitBox.left && x2 <= hitBox.left + hitBox.width && y2 >= hitBox.top && y2 <= hitBox.top + hitBox.height) {
                  return me2.legendItems[i];
                }
              }
            }
            return null;
          },
          handleEvent: function(e) {
            var me2 = this;
            var opts = me2.options;
            var type = e.type === "mouseup" ? "click" : e.type;
            var hoveredItem;
            if (type === "mousemove") {
              if (!opts.onHover && !opts.onLeave) {
                return;
              }
            } else if (type === "click") {
              if (!opts.onClick) {
                return;
              }
            } else {
              return;
            }
            hoveredItem = me2._getLegendItemAt(e.x, e.y);
            if (type === "click") {
              if (hoveredItem && opts.onClick) {
                opts.onClick.call(me2, e.native, hoveredItem);
              }
            } else {
              if (opts.onLeave && hoveredItem !== me2._hoveredItem) {
                if (me2._hoveredItem) {
                  opts.onLeave.call(me2, e.native, me2._hoveredItem);
                }
                me2._hoveredItem = hoveredItem;
              }
              if (opts.onHover && hoveredItem) {
                opts.onHover.call(me2, e.native, hoveredItem);
              }
            }
          }
        });
        function createNewLegendAndAttach(chart, legendOpts) {
          var legend2 = new Legend({
            ctx: chart.ctx,
            options: legendOpts,
            chart
          });
          core_layouts.configure(chart, legend2, legendOpts);
          core_layouts.addBox(chart, legend2);
          chart.legend = legend2;
        }
        var plugin_legend = {
          id: "legend",
          _element: Legend,
          beforeInit: function(chart) {
            var legendOpts = chart.options.legend;
            if (legendOpts) {
              createNewLegendAndAttach(chart, legendOpts);
            }
          },
          beforeUpdate: function(chart) {
            var legendOpts = chart.options.legend;
            var legend2 = chart.legend;
            if (legendOpts) {
              helpers$1.mergeIf(legendOpts, core_defaults.global.legend);
              if (legend2) {
                core_layouts.configure(chart, legend2, legendOpts);
                legend2.options = legendOpts;
              } else {
                createNewLegendAndAttach(chart, legendOpts);
              }
            } else if (legend2) {
              core_layouts.removeBox(chart, legend2);
              delete chart.legend;
            }
          },
          afterEvent: function(chart, e) {
            var legend2 = chart.legend;
            if (legend2) {
              legend2.handleEvent(e);
            }
          }
        };
        var noop$2 = helpers$1.noop;
        core_defaults._set("global", {
          title: {
            display: false,
            fontStyle: "bold",
            fullWidth: true,
            padding: 10,
            position: "top",
            text: "",
            weight: 2e3
          }
        });
        var Title = core_element.extend({
          initialize: function(config) {
            var me2 = this;
            helpers$1.extend(me2, config);
            me2.legendHitBoxes = [];
          },
          beforeUpdate: noop$2,
          update: function(maxWidth, maxHeight, margins) {
            var me2 = this;
            me2.beforeUpdate();
            me2.maxWidth = maxWidth;
            me2.maxHeight = maxHeight;
            me2.margins = margins;
            me2.beforeSetDimensions();
            me2.setDimensions();
            me2.afterSetDimensions();
            me2.beforeBuildLabels();
            me2.buildLabels();
            me2.afterBuildLabels();
            me2.beforeFit();
            me2.fit();
            me2.afterFit();
            me2.afterUpdate();
            return me2.minSize;
          },
          afterUpdate: noop$2,
          beforeSetDimensions: noop$2,
          setDimensions: function() {
            var me2 = this;
            if (me2.isHorizontal()) {
              me2.width = me2.maxWidth;
              me2.left = 0;
              me2.right = me2.width;
            } else {
              me2.height = me2.maxHeight;
              me2.top = 0;
              me2.bottom = me2.height;
            }
            me2.paddingLeft = 0;
            me2.paddingTop = 0;
            me2.paddingRight = 0;
            me2.paddingBottom = 0;
            me2.minSize = {
              width: 0,
              height: 0
            };
          },
          afterSetDimensions: noop$2,
          beforeBuildLabels: noop$2,
          buildLabels: noop$2,
          afterBuildLabels: noop$2,
          beforeFit: noop$2,
          fit: function() {
            var me2 = this;
            var opts = me2.options;
            var minSize = me2.minSize = {};
            var isHorizontal = me2.isHorizontal();
            var lineCount, textSize;
            if (!opts.display) {
              me2.width = minSize.width = me2.height = minSize.height = 0;
              return;
            }
            lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;
            textSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + opts.padding * 2;
            me2.width = minSize.width = isHorizontal ? me2.maxWidth : textSize;
            me2.height = minSize.height = isHorizontal ? textSize : me2.maxHeight;
          },
          afterFit: noop$2,
          isHorizontal: function() {
            var pos = this.options.position;
            return pos === "top" || pos === "bottom";
          },
          draw: function() {
            var me2 = this;
            var ctx = me2.ctx;
            var opts = me2.options;
            if (!opts.display) {
              return;
            }
            var fontOpts = helpers$1.options._parseFont(opts);
            var lineHeight = fontOpts.lineHeight;
            var offset2 = lineHeight / 2 + opts.padding;
            var rotation = 0;
            var top = me2.top;
            var left = me2.left;
            var bottom = me2.bottom;
            var right = me2.right;
            var maxWidth, titleX, titleY;
            ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor);
            ctx.font = fontOpts.string;
            if (me2.isHorizontal()) {
              titleX = left + (right - left) / 2;
              titleY = top + offset2;
              maxWidth = right - left;
            } else {
              titleX = opts.position === "left" ? left + offset2 : right - offset2;
              titleY = top + (bottom - top) / 2;
              maxWidth = bottom - top;
              rotation = Math.PI * (opts.position === "left" ? -0.5 : 0.5);
            }
            ctx.save();
            ctx.translate(titleX, titleY);
            ctx.rotate(rotation);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            var text = opts.text;
            if (helpers$1.isArray(text)) {
              var y2 = 0;
              for (var i = 0; i < text.length; ++i) {
                ctx.fillText(text[i], 0, y2, maxWidth);
                y2 += lineHeight;
              }
            } else {
              ctx.fillText(text, 0, 0, maxWidth);
            }
            ctx.restore();
          }
        });
        function createNewTitleBlockAndAttach(chart, titleOpts) {
          var title2 = new Title({
            ctx: chart.ctx,
            options: titleOpts,
            chart
          });
          core_layouts.configure(chart, title2, titleOpts);
          core_layouts.addBox(chart, title2);
          chart.titleBlock = title2;
        }
        var plugin_title = {
          id: "title",
          _element: Title,
          beforeInit: function(chart) {
            var titleOpts = chart.options.title;
            if (titleOpts) {
              createNewTitleBlockAndAttach(chart, titleOpts);
            }
          },
          beforeUpdate: function(chart) {
            var titleOpts = chart.options.title;
            var titleBlock = chart.titleBlock;
            if (titleOpts) {
              helpers$1.mergeIf(titleOpts, core_defaults.global.title);
              if (titleBlock) {
                core_layouts.configure(chart, titleBlock, titleOpts);
                titleBlock.options = titleOpts;
              } else {
                createNewTitleBlockAndAttach(chart, titleOpts);
              }
            } else if (titleBlock) {
              core_layouts.removeBox(chart, titleBlock);
              delete chart.titleBlock;
            }
          }
        };
        var plugins = {};
        var filler = plugin_filler;
        var legend = plugin_legend;
        var title = plugin_title;
        plugins.filler = filler;
        plugins.legend = legend;
        plugins.title = title;
        core_controller.helpers = helpers$1;
        core_helpers();
        core_controller._adapters = core_adapters;
        core_controller.Animation = core_animation;
        core_controller.animationService = core_animations;
        core_controller.controllers = controllers;
        core_controller.DatasetController = core_datasetController;
        core_controller.defaults = core_defaults;
        core_controller.Element = core_element;
        core_controller.elements = elements;
        core_controller.Interaction = core_interaction;
        core_controller.layouts = core_layouts;
        core_controller.platform = platform;
        core_controller.plugins = core_plugins;
        core_controller.Scale = core_scale;
        core_controller.scaleService = core_scaleService;
        core_controller.Ticks = core_ticks;
        core_controller.Tooltip = core_tooltip;
        core_controller.helpers.each(scales, function(scale2, type) {
          core_controller.scaleService.registerScaleType(type, scale2, scale2._defaults);
        });
        for (var k in plugins) {
          if (plugins.hasOwnProperty(k)) {
            core_controller.plugins.register(plugins[k]);
          }
        }
        core_controller.platform.initialize();
        var src = core_controller;
        if (typeof window !== "undefined") {
          window.Chart = core_controller;
        }
        core_controller.Chart = core_controller;
        core_controller.Legend = plugins.legend._element;
        core_controller.Title = plugins.title._element;
        core_controller.pluginService = core_controller.plugins;
        core_controller.PluginBase = core_controller.Element.extend({});
        core_controller.canvasHelpers = core_controller.helpers.canvas;
        core_controller.layoutService = core_controller.layouts;
        core_controller.LinearScaleBase = scale_linearbase;
        core_controller.helpers.each(
          [
            "Bar",
            "Bubble",
            "Doughnut",
            "Line",
            "PolarArea",
            "Radar",
            "Scatter"
          ],
          function(klass) {
            core_controller[klass] = function(ctx, cfg) {
              return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
                type: klass.charAt(0).toLowerCase() + klass.slice(1)
              }));
            };
          }
        );
        return src;
      });
    })(Chart$1);
    const Chart = Chart$1.exports;
    let WaveMenu$1 = class WaveMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        this.state = {
          counter: this.props.from,
          interval: this.props.interval ?? 1e3
        };
        this.interval;
      }
      componentDidMount() {
        this.interval = setInterval(() => {
          const { counter } = this.state;
          if (counter === 0) {
            this.props.whenDone();
            clearInterval(this.interval);
            return;
          }
          this.setState({ counter: counter - 1 });
        }, this.state.interval);
      }
      componentWillUnmount() {
        clearInterval(this.interval);
      }
      render() {
        return this.smoothly(
          /* @__PURE__ */ jsx("div", { children: this.state.counter })
        );
      }
    };
    const calculateAccuracy = (wave) => {
      return (1 - wave.shotsMissed / wave.shotsFired) * 100;
    };
    const calculateWpm = (wave) => {
      let shotsHit = wave.shotsFired - wave.shotsMissed;
      let waveTime = (wave.waveEnd - wave.waveStart) / 1e3 / 60;
      return shotsHit / 5 / waveTime;
    };
    class WaveMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        __publicField(this, "handleNextWave", () => {
          events.emit("nextWave");
        });
        this.chart = React.createRef();
        this.graph;
      }
      componentDidMount() {
        let waves = this.props.waveData;
        this.graph = new Chart(this.chart.current, {
          type: "line",
          data: {
            labels: waves.map((_2, idx) => idx + 1),
            datasets: [
              {
                data: waves.map((wave) => calculateAccuracy(wave)),
                label: "Accuracy",
                borderColor: "#3e95cd",
                fill: false
              },
              {
                data: waves.map((wave) => calculateWpm(wave)),
                label: "Wpm",
                borderColor: "#78ebcc",
                fill: false
              }
            ]
          },
          options: {
            legend: {
              display: false
            },
            scales: {
              xAxes: [{
                display: false,
                gridLines: {
                  color: "rgba(0, 0, 0, 0)"
                }
              }],
              yAxes: [{
                display: false,
                gridLines: {
                  color: "rgba(0, 0, 0, 0)"
                }
              }]
            },
            layout: {
              padding: {
                left: 10,
                right: 10,
                top: 10,
                bottom: 10
              }
            }
          }
        });
      }
      render() {
        const { waveData, score } = this.props;
        const finishedWave = waveData.length;
        const wave = _.last(waveData);
        const accuracy = calculateAccuracy(wave).toFixed(2);
        const wpm = calculateWpm(wave).toFixed(2);
        const abbreviatedScore = abbreviateNumber(score);
        return this.smoothly(
          /* @__PURE__ */ jsxs("div", { className: "hud", children: [
            /* @__PURE__ */ jsxs("div", { className: "wave", children: [
              /* @__PURE__ */ jsxs("div", { className: "waveNumber", children: [
                "wave",
                /* @__PURE__ */ jsx("br", {}),
                finishedWave
              ] }),
              /* @__PURE__ */ jsx("div", { className: "score", children: abbreviatedScore })
            ] }),
            /* @__PURE__ */ jsxs("div", { className: "waveStats", children: [
              /* @__PURE__ */ jsxs("div", { className: "stat", children: [
                /* @__PURE__ */ jsx("div", { className: "marker accuracy" }),
                /* @__PURE__ */ jsx("span", { className: "faded", children: "accuracy" }),
                "",
                accuracy,
                "%"
              ] }),
              /* @__PURE__ */ jsxs("div", { className: "stat", children: [
                /* @__PURE__ */ jsx("div", { className: "marker wpm" }),
                /* @__PURE__ */ jsx("span", { className: "faded", children: "wpm " }),
                "",
                wpm
              ] })
            ] }),
            /* @__PURE__ */ jsx("div", { className: "chartContainer", children: /* @__PURE__ */ jsx("canvas", { width: "300", height: "150", ref: this.chart }) }),
            /* @__PURE__ */ jsxs("div", { className: "timer", children: [
              /* @__PURE__ */ jsx("header", { children: "next wave in" }),
              /* @__PURE__ */ jsx(WaveMenu$1, { from: 5, whenDone: this.handleNextWave })
            ] })
          ] })
        );
      }
    }
    class GameOverMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        __publicField(this, "restartGame", () => {
          events.emit("restartGame");
        });
      }
      render() {
        return this.smoothly(
          /* @__PURE__ */ jsxs("div", { className: "gameOverMenu menu", children: [
            /* @__PURE__ */ jsx("h1", { className: "gameOverHeader header", children: "Game Over" }),
            /* @__PURE__ */ jsx(Button, { danger: true, hint: "ret", text: "Back to Menu", onClick: this.restartGame })
          ] })
        );
      }
    }
    class App extends react.exports.Component {
      constructor(props) {
        super(props);
        __publicField(this, "_handleKeyDown", (e) => {
          if (!this.state.started) {
            return;
          }
          switch (e.key) {
            case "Escape":
              this.handlePause();
              break;
          }
        });
        __publicField(this, "handlePause", () => {
          if (this.state.intermission) {
            return;
          }
          this.toggleMenu();
          this.setState((old) => {
            this.game.pause(!old.paused);
            return {
              paused: !old.paused
            };
          });
        });
        __publicField(this, "toggleMenu", () => {
          this.setState((old) => {
            return {
              inMenu: !old.inMenu
            };
          });
        });
        __publicField(this, "nextWave", () => {
          this.setState((old) => {
            return {
              wave: old.wave + 1,
              intermission: false
            };
          });
          this.game.nextWave(this.state.wave);
          this.handlePause();
        });
        this.game = Game$1;
        this.state = {
          inMenu: true,
          paused: false,
          started: false,
          inSettings: false,
          inLeaderboard: false,
          intermission: false,
          gameOver: false,
          playerName: storage.get("playerName") || "0x20F",
          wave: 1
        };
        this.score = 0;
        this.waveData = [];
      }
      componentDidMount() {
        document.addEventListener("keydown", this._handleKeyDown, false);
        events.on("shotFired", (missed) => {
          if (this.score >= 10 && missed) {
            this.score -= 10;
          } else {
            this.score += 1;
          }
        });
        events.on("enemyDeath", () => {
          this.score += 100;
        });
        events.on("nextWave", this.nextWave);
        events.on("waveEnd", (data) => {
          this.waveData.push(data);
          this.handlePause();
          this.setState({
            intermission: true
          });
        });
        events.on("settingsOpened", () => this.setState({ inSettings: true }));
        events.on("settingsSaved", (playerName) => {
          this.setState({
            playerName,
            inSettings: false
          });
          storage.set("playerName", playerName);
        });
        events.on("leaderboardOpened", () => this.setState({ inLeaderboard: true }));
        events.on("leaderboardClosed", () => this.setState({ inLeaderboard: false }));
        events.on("gameStarted", async () => {
          const { wave, playerName } = this.state;
          await this.game.start(playerName, this.emitter);
          this.game.nextWave(wave);
          this.toggleMenu();
          this.setState((old) => {
            return {
              started: !old.started
            };
          });
        });
        events.on("unpause", this.handlePause);
        events.on("gameOver", (lastWave) => {
          this.waveData.push(lastWave);
          let totalWaves = this.waveData.length;
          let accuracy = this.waveData.map((w2) => calculateAccuracy(w2)).reduce((a, b) => a + b, 0);
          let wpm = this.waveData.map((w2) => calculateWpm(w2)).reduce((a, b) => a + b, 0);
          let score = this.score;
          addEntry(
            this.state.playerName,
            (accuracy / totalWaves).toFixed(2),
            (wpm / totalWaves).toFixed(2),
            abbreviateNumber(score),
            totalWaves
          );
          this.setState({
            gameOver: true,
            inMenu: true
          });
        });
        events.on("restartGame", () => {
          this.setState({
            started: false,
            inMenu: true,
            paused: false,
            inSettings: false,
            intermission: false,
            gameOver: false,
            inLeaderboard: false,
            wave: 1
          });
          this.waveData = [];
          this.score = 0;
          Game$1.reset();
        });
      }
      componentWillUnmount() {
        document.removeEventListener("keydown", this._handleKeyDown, false);
      }
      render() {
        const { inMenu, paused: paused2, started, inSettings, inLeaderboard, gameOver, playerName, intermission } = this.state;
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          gameOver && /* @__PURE__ */ jsx(GameOverMenu, {}),
          !started && inLeaderboard && /* @__PURE__ */ jsx(LeaderboardMenu, {}),
          !started && !inSettings && !inLeaderboard && /* @__PURE__ */ jsx(StartMenu, { playerName }),
          paused2 && !intermission && /* @__PURE__ */ jsx(PauseMenu, {}),
          inSettings && /* @__PURE__ */ jsx(SettingsMenu, { playerName }),
          intermission && paused2 && /* @__PURE__ */ jsx(WaveMenu, { waveData: this.waveData, score: this.score }),
          /* @__PURE__ */ jsx(Background, { hidden: !inMenu })
        ] });
      }
    }
    const app = "";
    ReactDOM.render(/* @__PURE__ */ jsx(App, {}), document.getElementById("root"));
  }
});
export default require_index_001();
