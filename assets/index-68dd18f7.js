var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var require_index_001 = __commonJS({
  "assets/index-68dd18f7.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(script) {
        const fetchOpts = {};
        if (script.integrity)
          fetchOpts.integrity = script.integrity;
        if (script.referrerpolicy)
          fetchOpts.referrerPolicy = script.referrerpolicy;
        if (script.crossorigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (script.crossorigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    function getAugmentedNamespace(n2) {
      var f2 = n2.default;
      if (typeof f2 == "function") {
        var a2 = function a3() {
          if (this instanceof a3) {
            var args = [null];
            args.push.apply(args, arguments);
            var Ctor = Function.bind.apply(f2, args);
            return new Ctor();
          }
          return f2.apply(this, arguments);
        };
        a2.prototype = f2.prototype;
      } else
        a2 = {};
      Object.defineProperty(a2, "__esModule", { value: true });
      Object.keys(n2).forEach(function(k) {
        var d = Object.getOwnPropertyDescriptor(n2, k);
        Object.defineProperty(a2, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return n2[k];
          }
        });
      });
      return a2;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production_min = {};
    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject$1(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to2 = toObject$1(target);
      var symbols;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from2 = Object(arguments[s2]);
        for (var key in from2) {
          if (hasOwnProperty$3.call(from2, key)) {
            to2[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from2, symbols[i2])) {
              to2[symbols[i2]] = from2[symbols[i2]];
            }
          }
        }
      }
      return to2;
    };
    var react = { exports: {} };
    var react_production_min = {};
    /** @license React v17.0.2
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l$1 = objectAssign, n$1 = 60103, p$2 = 60106;
    react_production_min.Fragment = 60107;
    react_production_min.StrictMode = 60108;
    react_production_min.Profiler = 60114;
    var q$1 = 60109, r$1 = 60110, t = 60112;
    react_production_min.Suspense = 60113;
    var u = 60115, v = 60116;
    if ("function" === typeof Symbol && Symbol.for) {
      var w = Symbol.for;
      n$1 = w("react.element");
      p$2 = w("react.portal");
      react_production_min.Fragment = w("react.fragment");
      react_production_min.StrictMode = w("react.strict_mode");
      react_production_min.Profiler = w("react.profiler");
      q$1 = w("react.provider");
      r$1 = w("react.context");
      t = w("react.forward_ref");
      react_production_min.Suspense = w("react.suspense");
      u = w("react.memo");
      v = w("react.lazy");
    }
    var x$1 = "function" === typeof Symbol && Symbol.iterator;
    function y$1(a2) {
      if (null === a2 || "object" !== typeof a2)
        return null;
      a2 = x$1 && a2[x$1] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    function z(a2) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a2 + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var A = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, B$1 = {};
    function C(a2, b, c) {
      this.props = a2;
      this.context = b;
      this.refs = B$1;
      this.updater = c || A;
    }
    C.prototype.isReactComponent = {};
    C.prototype.setState = function(a2, b) {
      if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
        throw Error(z(85));
      this.updater.enqueueSetState(this, a2, b, "setState");
    };
    C.prototype.forceUpdate = function(a2) {
      this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
    };
    function D$1() {
    }
    D$1.prototype = C.prototype;
    function E$1(a2, b, c) {
      this.props = a2;
      this.context = b;
      this.refs = B$1;
      this.updater = c || A;
    }
    var F$1 = E$1.prototype = new D$1();
    F$1.constructor = E$1;
    l$1(F$1, C.prototype);
    F$1.isPureReactComponent = true;
    var G$1 = { current: null }, H$1 = Object.prototype.hasOwnProperty, I$1 = { key: true, ref: true, __self: true, __source: true };
    function J(a2, b, c) {
      var e, d = {}, k = null, h2 = null;
      if (null != b)
        for (e in void 0 !== b.ref && (h2 = b.ref), void 0 !== b.key && (k = "" + b.key), b)
          H$1.call(b, e) && !I$1.hasOwnProperty(e) && (d[e] = b[e]);
      var g2 = arguments.length - 2;
      if (1 === g2)
        d.children = c;
      else if (1 < g2) {
        for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
          f2[m2] = arguments[m2 + 2];
        d.children = f2;
      }
      if (a2 && a2.defaultProps)
        for (e in g2 = a2.defaultProps, g2)
          void 0 === d[e] && (d[e] = g2[e]);
      return { $$typeof: n$1, type: a2, key: k, ref: h2, props: d, _owner: G$1.current };
    }
    function K(a2, b) {
      return { $$typeof: n$1, type: a2.type, key: b, ref: a2.ref, props: a2.props, _owner: a2._owner };
    }
    function L(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === n$1;
    }
    function escape$2(a2) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a2.replace(/[=:]/g, function(a3) {
        return b[a3];
      });
    }
    var M$1 = /\/+/g;
    function N$1(a2, b) {
      return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$2("" + a2.key) : b.toString(36);
    }
    function O$1(a2, b, c, e, d) {
      var k = typeof a2;
      if ("undefined" === k || "boolean" === k)
        a2 = null;
      var h2 = false;
      if (null === a2)
        h2 = true;
      else
        switch (k) {
          case "string":
          case "number":
            h2 = true;
            break;
          case "object":
            switch (a2.$$typeof) {
              case n$1:
              case p$2:
                h2 = true;
            }
        }
      if (h2)
        return h2 = a2, d = d(h2), a2 = "" === e ? "." + N$1(h2, 0) : e, Array.isArray(d) ? (c = "", null != a2 && (c = a2.replace(M$1, "$&/") + "/"), O$1(d, b, c, "", function(a3) {
          return a3;
        })) : null != d && (L(d) && (d = K(d, c + (!d.key || h2 && h2.key === d.key ? "" : ("" + d.key).replace(M$1, "$&/") + "/") + a2)), b.push(d)), 1;
      h2 = 0;
      e = "" === e ? "." : e + ":";
      if (Array.isArray(a2))
        for (var g2 = 0; g2 < a2.length; g2++) {
          k = a2[g2];
          var f2 = e + N$1(k, g2);
          h2 += O$1(k, b, c, f2, d);
        }
      else if (f2 = y$1(a2), "function" === typeof f2)
        for (a2 = f2.call(a2), g2 = 0; !(k = a2.next()).done; )
          k = k.value, f2 = e + N$1(k, g2++), h2 += O$1(k, b, c, f2, d);
      else if ("object" === k)
        throw b = "" + a2, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b));
      return h2;
    }
    function P$1(a2, b, c) {
      if (null == a2)
        return a2;
      var e = [], d = 0;
      O$1(a2, e, "", "", function(a3) {
        return b.call(c, a3, d++);
      });
      return e;
    }
    function Q(a2) {
      if (-1 === a2._status) {
        var b = a2._result;
        b = b();
        a2._status = 0;
        a2._result = b;
        b.then(function(b2) {
          0 === a2._status && (b2 = b2.default, a2._status = 1, a2._result = b2);
        }, function(b2) {
          0 === a2._status && (a2._status = 2, a2._result = b2);
        });
      }
      if (1 === a2._status)
        return a2._result;
      throw a2._result;
    }
    var R$1 = { current: null };
    function S$1() {
      var a2 = R$1.current;
      if (null === a2)
        throw Error(z(321));
      return a2;
    }
    var T$1 = { ReactCurrentDispatcher: R$1, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$1, IsSomeRendererActing: { current: false }, assign: l$1 };
    react_production_min.Children = { map: P$1, forEach: function(a2, b, c) {
      P$1(a2, function() {
        b.apply(this, arguments);
      }, c);
    }, count: function(a2) {
      var b = 0;
      P$1(a2, function() {
        b++;
      });
      return b;
    }, toArray: function(a2) {
      return P$1(a2, function(a3) {
        return a3;
      }) || [];
    }, only: function(a2) {
      if (!L(a2))
        throw Error(z(143));
      return a2;
    } };
    react_production_min.Component = C;
    react_production_min.PureComponent = E$1;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$1;
    react_production_min.cloneElement = function(a2, b, c) {
      if (null === a2 || void 0 === a2)
        throw Error(z(267, a2));
      var e = l$1({}, a2.props), d = a2.key, k = a2.ref, h2 = a2._owner;
      if (null != b) {
        void 0 !== b.ref && (k = b.ref, h2 = G$1.current);
        void 0 !== b.key && (d = "" + b.key);
        if (a2.type && a2.type.defaultProps)
          var g2 = a2.type.defaultProps;
        for (f2 in b)
          H$1.call(b, f2) && !I$1.hasOwnProperty(f2) && (e[f2] = void 0 === b[f2] && void 0 !== g2 ? g2[f2] : b[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2)
        e.children = c;
      else if (1 < f2) {
        g2 = Array(f2);
        for (var m2 = 0; m2 < f2; m2++)
          g2[m2] = arguments[m2 + 2];
        e.children = g2;
      }
      return {
        $$typeof: n$1,
        type: a2.type,
        key: d,
        ref: k,
        props: e,
        _owner: h2
      };
    };
    react_production_min.createContext = function(a2, b) {
      void 0 === b && (b = null);
      a2 = { $$typeof: r$1, _calculateChangedBits: b, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null };
      a2.Provider = { $$typeof: q$1, _context: a2 };
      return a2.Consumer = a2;
    };
    react_production_min.createElement = J;
    react_production_min.createFactory = function(a2) {
      var b = J.bind(null, a2);
      b.type = a2;
      return b;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a2) {
      return { $$typeof: t, render: a2 };
    };
    react_production_min.isValidElement = L;
    react_production_min.lazy = function(a2) {
      return { $$typeof: v, _payload: { _status: -1, _result: a2 }, _init: Q };
    };
    react_production_min.memo = function(a2, b) {
      return { $$typeof: u, type: a2, compare: void 0 === b ? null : b };
    };
    react_production_min.useCallback = function(a2, b) {
      return S$1().useCallback(a2, b);
    };
    react_production_min.useContext = function(a2, b) {
      return S$1().useContext(a2, b);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useEffect = function(a2, b) {
      return S$1().useEffect(a2, b);
    };
    react_production_min.useImperativeHandle = function(a2, b, c) {
      return S$1().useImperativeHandle(a2, b, c);
    };
    react_production_min.useLayoutEffect = function(a2, b) {
      return S$1().useLayoutEffect(a2, b);
    };
    react_production_min.useMemo = function(a2, b) {
      return S$1().useMemo(a2, b);
    };
    react_production_min.useReducer = function(a2, b, c) {
      return S$1().useReducer(a2, b, c);
    };
    react_production_min.useRef = function(a2) {
      return S$1().useRef(a2);
    };
    react_production_min.useState = function(a2) {
      return S$1().useState(a2);
    };
    react_production_min.version = "17.0.2";
    (function(module2) {
      {
        module2.exports = react_production_min;
      }
    })(react);
    const React = /* @__PURE__ */ getDefaultExportFromCjs(react.exports);
    /** @license React v17.0.2
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f = react.exports, g = 60103;
    reactJsxRuntime_production_min.Fragment = 60107;
    if ("function" === typeof Symbol && Symbol.for) {
      var h = Symbol.for;
      g = h("react.element");
      reactJsxRuntime_production_min.Fragment = h("react.fragment");
    }
    var m$1 = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n = Object.prototype.hasOwnProperty, p$1 = { key: true, ref: true, __self: true, __source: true };
    function q(c, a2, k) {
      var b, d = {}, e = null, l2 = null;
      void 0 !== k && (e = "" + k);
      void 0 !== a2.key && (e = "" + a2.key);
      void 0 !== a2.ref && (l2 = a2.ref);
      for (b in a2)
        n.call(a2, b) && !p$1.hasOwnProperty(b) && (d[b] = a2[b]);
      if (c && c.defaultProps)
        for (b in a2 = c.defaultProps, a2)
          void 0 === d[b] && (d[b] = a2[b]);
      return { $$typeof: g, type: c, key: e, ref: l2, props: d, _owner: m$1.current };
    }
    reactJsxRuntime_production_min.jsx = q;
    reactJsxRuntime_production_min.jsxs = q;
    (function(module2) {
      {
        module2.exports = reactJsxRuntime_production_min;
      }
    })(jsxRuntime);
    const Fragment = jsxRuntime.exports.Fragment;
    const jsx = jsxRuntime.exports.jsx;
    const jsxs = jsxRuntime.exports.jsxs;
    var reactDom = { exports: {} };
    var reactDom_production_min = {};
    var scheduler = { exports: {} };
    var scheduler_production_min = {};
    /** @license React v0.20.2
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      var f2, g2, h2, k;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l2 = performance;
        exports2.unstable_now = function() {
          return l2.now();
        };
      } else {
        var p2 = Date, q2 = p2.now();
        exports2.unstable_now = function() {
          return p2.now() - q2;
        };
      }
      if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
        var t2 = null, u2 = null, w2 = function() {
          if (null !== t2)
            try {
              var a2 = exports2.unstable_now();
              t2(true, a2);
              t2 = null;
            } catch (b) {
              throw setTimeout(w2, 0), b;
            }
        };
        f2 = function(a2) {
          null !== t2 ? setTimeout(f2, 0, a2) : (t2 = a2, setTimeout(w2, 0));
        };
        g2 = function(a2, b) {
          u2 = setTimeout(a2, b);
        };
        h2 = function() {
          clearTimeout(u2);
        };
        exports2.unstable_shouldYield = function() {
          return false;
        };
        k = exports2.unstable_forceFrameRate = function() {
        };
      } else {
        var x2 = window.setTimeout, y2 = window.clearTimeout;
        if ("undefined" !== typeof console) {
          var z2 = window.cancelAnimationFrame;
          "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
          "function" !== typeof z2 && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        }
        var A2 = false, B2 = null, C2 = -1, D2 = 5, E2 = 0;
        exports2.unstable_shouldYield = function() {
          return exports2.unstable_now() >= E2;
        };
        k = function() {
        };
        exports2.unstable_forceFrameRate = function(a2) {
          0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
        };
        var F2 = new MessageChannel(), G2 = F2.port2;
        F2.port1.onmessage = function() {
          if (null !== B2) {
            var a2 = exports2.unstable_now();
            E2 = a2 + D2;
            try {
              B2(true, a2) ? G2.postMessage(null) : (A2 = false, B2 = null);
            } catch (b) {
              throw G2.postMessage(null), b;
            }
          } else
            A2 = false;
        };
        f2 = function(a2) {
          B2 = a2;
          A2 || (A2 = true, G2.postMessage(null));
        };
        g2 = function(a2, b) {
          C2 = x2(function() {
            a2(exports2.unstable_now());
          }, b);
        };
        h2 = function() {
          y2(C2);
          C2 = -1;
        };
      }
      function H2(a2, b) {
        var c = a2.length;
        a2.push(b);
        a:
          for (; ; ) {
            var d = c - 1 >>> 1, e = a2[d];
            if (void 0 !== e && 0 < I2(e, b))
              a2[d] = b, a2[c] = e, c = d;
            else
              break a;
          }
      }
      function J2(a2) {
        a2 = a2[0];
        return void 0 === a2 ? null : a2;
      }
      function K2(a2) {
        var b = a2[0];
        if (void 0 !== b) {
          var c = a2.pop();
          if (c !== b) {
            a2[0] = c;
            a:
              for (var d = 0, e = a2.length; d < e; ) {
                var m2 = 2 * (d + 1) - 1, n2 = a2[m2], v2 = m2 + 1, r2 = a2[v2];
                if (void 0 !== n2 && 0 > I2(n2, c))
                  void 0 !== r2 && 0 > I2(r2, n2) ? (a2[d] = r2, a2[v2] = c, d = v2) : (a2[d] = n2, a2[m2] = c, d = m2);
                else if (void 0 !== r2 && 0 > I2(r2, c))
                  a2[d] = r2, a2[v2] = c, d = v2;
                else
                  break a;
              }
          }
          return b;
        }
        return null;
      }
      function I2(a2, b) {
        var c = a2.sortIndex - b.sortIndex;
        return 0 !== c ? c : a2.id - b.id;
      }
      var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;
      function T2(a2) {
        for (var b = J2(M2); null !== b; ) {
          if (null === b.callback)
            K2(M2);
          else if (b.startTime <= a2)
            K2(M2), b.sortIndex = b.expirationTime, H2(L2, b);
          else
            break;
          b = J2(M2);
        }
      }
      function U2(a2) {
        S2 = false;
        T2(a2);
        if (!R2)
          if (null !== J2(L2))
            R2 = true, f2(V2);
          else {
            var b = J2(M2);
            null !== b && g2(U2, b.startTime - a2);
          }
      }
      function V2(a2, b) {
        R2 = false;
        S2 && (S2 = false, h2());
        Q2 = true;
        var c = P2;
        try {
          T2(b);
          for (O2 = J2(L2); null !== O2 && (!(O2.expirationTime > b) || a2 && !exports2.unstable_shouldYield()); ) {
            var d = O2.callback;
            if ("function" === typeof d) {
              O2.callback = null;
              P2 = O2.priorityLevel;
              var e = d(O2.expirationTime <= b);
              b = exports2.unstable_now();
              "function" === typeof e ? O2.callback = e : O2 === J2(L2) && K2(L2);
              T2(b);
            } else
              K2(L2);
            O2 = J2(L2);
          }
          if (null !== O2)
            var m2 = true;
          else {
            var n2 = J2(M2);
            null !== n2 && g2(U2, n2.startTime - b);
            m2 = false;
          }
          return m2;
        } finally {
          O2 = null, P2 = c, Q2 = false;
        }
      }
      var W2 = k;
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a2) {
        a2.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        R2 || Q2 || (R2 = true, f2(V2));
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return P2;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return J2(L2);
      };
      exports2.unstable_next = function(a2) {
        switch (P2) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = P2;
        }
        var c = P2;
        P2 = b;
        try {
          return a2();
        } finally {
          P2 = c;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = W2;
      exports2.unstable_runWithPriority = function(a2, b) {
        switch (a2) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a2 = 3;
        }
        var c = P2;
        P2 = a2;
        try {
          return b();
        } finally {
          P2 = c;
        }
      };
      exports2.unstable_scheduleCallback = function(a2, b, c) {
        var d = exports2.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a2) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a2 = { id: N2++, callback: b, priorityLevel: a2, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a2.sortIndex = c, H2(M2, a2), null === J2(L2) && a2 === J2(M2) && (S2 ? h2() : S2 = true, g2(U2, c - d))) : (a2.sortIndex = e, H2(L2, a2), R2 || Q2 || (R2 = true, f2(V2)));
        return a2;
      };
      exports2.unstable_wrapCallback = function(a2) {
        var b = P2;
        return function() {
          var c = P2;
          P2 = b;
          try {
            return a2.apply(this, arguments);
          } finally {
            P2 = c;
          }
        };
      };
    })(scheduler_production_min);
    (function(module2) {
      {
        module2.exports = scheduler_production_min;
      }
    })(scheduler);
    /** @license React v17.0.2
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = react.exports, m = objectAssign, r = scheduler.exports;
    function y(a2) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a2 + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    if (!aa)
      throw Error(y(227));
    var ba = /* @__PURE__ */ new Set(), ca = {};
    function da(a2, b) {
      ea(a2, b);
      ea(a2 + "Capture", b);
    }
    function ea(a2, b) {
      ca[a2] = b;
      for (a2 = 0; a2 < b.length; a2++)
        ba.add(b[a2]);
    }
    var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = Object.prototype.hasOwnProperty, ja = {}, ka = {};
    function la(a2) {
      if (ia.call(ka, a2))
        return true;
      if (ia.call(ja, a2))
        return false;
      if (ha.test(a2))
        return ka[a2] = true;
      ja[a2] = true;
      return false;
    }
    function ma(a2, b, c, d) {
      if (null !== c && 0 === c.type)
        return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d)
            return false;
          if (null !== c)
            return !c.acceptsBooleans;
          a2 = a2.toLowerCase().slice(0, 5);
          return "data-" !== a2 && "aria-" !== a2;
        default:
          return false;
      }
    }
    function na(a2, b, c, d) {
      if (null === b || "undefined" === typeof b || ma(a2, b, c, d))
        return true;
      if (d)
        return false;
      if (null !== c)
        switch (c.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
      return false;
    }
    function B(a2, b, c, d, e, f2, g2) {
      this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
      this.attributeName = d;
      this.attributeNamespace = e;
      this.mustUseProperty = c;
      this.propertyName = a2;
      this.type = b;
      this.sanitizeURL = f2;
      this.removeEmptyString = g2;
    }
    var D = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
      D[a2] = new B(a2, 0, false, a2, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
      var b = a2[0];
      D[b] = new B(b, 1, false, a2[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
      D[a2] = new B(a2, 2, false, a2.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
      D[a2] = new B(a2, 2, false, a2, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
      D[a2] = new B(a2, 3, false, a2.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
      D[a2] = new B(a2, 3, true, a2, null, false, false);
    });
    ["capture", "download"].forEach(function(a2) {
      D[a2] = new B(a2, 4, false, a2, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a2) {
      D[a2] = new B(a2, 6, false, a2, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a2) {
      D[a2] = new B(a2, 5, false, a2.toLowerCase(), null, false, false);
    });
    var oa = /[\-:]([a-z])/g;
    function pa(a2) {
      return a2[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
      var b = a2.replace(
        oa,
        pa
      );
      D[b] = new B(b, 1, false, a2, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
      var b = a2.replace(oa, pa);
      D[b] = new B(b, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
      var b = a2.replace(oa, pa);
      D[b] = new B(b, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a2) {
      D[a2] = new B(a2, 1, false, a2.toLowerCase(), null, false, false);
    });
    D.xlinkHref = new B("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a2) {
      D[a2] = new B(a2, 1, false, a2.toLowerCase(), null, true, true);
    });
    function qa(a2, b, c, d) {
      var e = D.hasOwnProperty(b) ? D[b] : null;
      var f2 = null !== e ? 0 === e.type : d ? false : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? false : true;
      f2 || (na(b, c, e, d) && (c = null), d || null === e ? la(b) && (null === c ? a2.removeAttribute(b) : a2.setAttribute(b, "" + c)) : e.mustUseProperty ? a2[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a2.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a2.setAttributeNS(d, b, c) : a2.setAttribute(b, c))));
    }
    var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = 60103, ta = 60106, ua = 60107, wa = 60108, xa = 60114, ya = 60109, za = 60110, Aa = 60112, Ba = 60113, Ca = 60120, Da = 60115, Ea = 60116, Fa = 60121, Ga = 60128, Ha = 60129, Ia = 60130, Ja = 60131;
    if ("function" === typeof Symbol && Symbol.for) {
      var E = Symbol.for;
      sa = E("react.element");
      ta = E("react.portal");
      ua = E("react.fragment");
      wa = E("react.strict_mode");
      xa = E("react.profiler");
      ya = E("react.provider");
      za = E("react.context");
      Aa = E("react.forward_ref");
      Ba = E("react.suspense");
      Ca = E("react.suspense_list");
      Da = E("react.memo");
      Ea = E("react.lazy");
      Fa = E("react.block");
      E("react.scope");
      Ga = E("react.opaque.id");
      Ha = E("react.debug_trace_mode");
      Ia = E("react.offscreen");
      Ja = E("react.legacy_hidden");
    }
    var Ka = "function" === typeof Symbol && Symbol.iterator;
    function La(a2) {
      if (null === a2 || "object" !== typeof a2)
        return null;
      a2 = Ka && a2[Ka] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    var Ma;
    function Na(a2) {
      if (void 0 === Ma)
        try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          Ma = b && b[1] || "";
        }
      return "\n" + Ma + a2;
    }
    var Oa = false;
    function Pa(a2, b) {
      if (!a2 || Oa)
        return "";
      Oa = true;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b)
          if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (k) {
              var d = k;
            }
            Reflect.construct(a2, [], b);
          } else {
            try {
              b.call();
            } catch (k) {
              d = k;
            }
            a2.call(b.prototype);
          }
        else {
          try {
            throw Error();
          } catch (k) {
            d = k;
          }
          a2();
        }
      } catch (k) {
        if (k && d && "string" === typeof k.stack) {
          for (var e = k.stack.split("\n"), f2 = d.stack.split("\n"), g2 = e.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e[g2] !== f2[h2]; )
            h2--;
          for (; 1 <= g2 && 0 <= h2; g2--, h2--)
            if (e[g2] !== f2[h2]) {
              if (1 !== g2 || 1 !== h2) {
                do
                  if (g2--, h2--, 0 > h2 || e[g2] !== f2[h2])
                    return "\n" + e[g2].replace(" at new ", " at ");
                while (1 <= g2 && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Oa = false, Error.prepareStackTrace = c;
      }
      return (a2 = a2 ? a2.displayName || a2.name : "") ? Na(a2) : "";
    }
    function Qa(a2) {
      switch (a2.tag) {
        case 5:
          return Na(a2.type);
        case 16:
          return Na("Lazy");
        case 13:
          return Na("Suspense");
        case 19:
          return Na("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a2 = Pa(a2.type, false), a2;
        case 11:
          return a2 = Pa(a2.type.render, false), a2;
        case 22:
          return a2 = Pa(a2.type._render, false), a2;
        case 1:
          return a2 = Pa(a2.type, true), a2;
        default:
          return "";
      }
    }
    function Ra(a2) {
      if (null == a2)
        return null;
      if ("function" === typeof a2)
        return a2.displayName || a2.name || null;
      if ("string" === typeof a2)
        return a2;
      switch (a2) {
        case ua:
          return "Fragment";
        case ta:
          return "Portal";
        case xa:
          return "Profiler";
        case wa:
          return "StrictMode";
        case Ba:
          return "Suspense";
        case Ca:
          return "SuspenseList";
      }
      if ("object" === typeof a2)
        switch (a2.$$typeof) {
          case za:
            return (a2.displayName || "Context") + ".Consumer";
          case ya:
            return (a2._context.displayName || "Context") + ".Provider";
          case Aa:
            var b = a2.render;
            b = b.displayName || b.name || "";
            return a2.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");
          case Da:
            return Ra(a2.type);
          case Fa:
            return Ra(a2._render);
          case Ea:
            b = a2._payload;
            a2 = a2._init;
            try {
              return Ra(a2(b));
            } catch (c) {
            }
        }
      return null;
    }
    function Sa(a2) {
      switch (typeof a2) {
        case "boolean":
        case "number":
        case "object":
        case "string":
        case "undefined":
          return a2;
        default:
          return "";
      }
    }
    function Ta(a2) {
      var b = a2.type;
      return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b || "radio" === b);
    }
    function Ua(a2) {
      var b = Ta(a2) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b), d = "" + a2[b];
      if (!a2.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
        var e = c.get, f2 = c.set;
        Object.defineProperty(a2, b, { configurable: true, get: function() {
          return e.call(this);
        }, set: function(a3) {
          d = "" + a3;
          f2.call(this, a3);
        } });
        Object.defineProperty(a2, b, { enumerable: c.enumerable });
        return { getValue: function() {
          return d;
        }, setValue: function(a3) {
          d = "" + a3;
        }, stopTracking: function() {
          a2._valueTracker = null;
          delete a2[b];
        } };
      }
    }
    function Va(a2) {
      a2._valueTracker || (a2._valueTracker = Ua(a2));
    }
    function Wa(a2) {
      if (!a2)
        return false;
      var b = a2._valueTracker;
      if (!b)
        return true;
      var c = b.getValue();
      var d = "";
      a2 && (d = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
      a2 = d;
      return a2 !== c ? (b.setValue(a2), true) : false;
    }
    function Xa(a2) {
      a2 = a2 || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a2)
        return null;
      try {
        return a2.activeElement || a2.body;
      } catch (b) {
        return a2.body;
      }
    }
    function Ya(a2, b) {
      var c = b.checked;
      return m({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a2._wrapperState.initialChecked });
    }
    function Za(a2, b) {
      var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
      c = Sa(null != b.value ? b.value : c);
      a2._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
    }
    function $a(a2, b) {
      b = b.checked;
      null != b && qa(a2, "checked", b, false);
    }
    function ab(a2, b) {
      $a(a2, b);
      var c = Sa(b.value), d = b.type;
      if (null != c)
        if ("number" === d) {
          if (0 === c && "" === a2.value || a2.value != c)
            a2.value = "" + c;
        } else
          a2.value !== "" + c && (a2.value = "" + c);
      else if ("submit" === d || "reset" === d) {
        a2.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? bb(a2, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a2, b.type, Sa(b.defaultValue));
      null == b.checked && null != b.defaultChecked && (a2.defaultChecked = !!b.defaultChecked);
    }
    function cb$1(a2, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value))
          return;
        b = "" + a2._wrapperState.initialValue;
        c || b === a2.value || (a2.value = b);
        a2.defaultValue = b;
      }
      c = a2.name;
      "" !== c && (a2.name = "");
      a2.defaultChecked = !!a2._wrapperState.initialChecked;
      "" !== c && (a2.name = c);
    }
    function bb(a2, b, c) {
      if ("number" !== b || Xa(a2.ownerDocument) !== a2)
        null == c ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c && (a2.defaultValue = "" + c);
    }
    function db(a2) {
      var b = "";
      aa.Children.forEach(a2, function(a3) {
        null != a3 && (b += a3);
      });
      return b;
    }
    function eb(a2, b) {
      a2 = m({ children: void 0 }, b);
      if (b = db(b.children))
        a2.children = b;
      return a2;
    }
    function fb(a2, b, c, d) {
      a2 = a2.options;
      if (b) {
        b = {};
        for (var e = 0; e < c.length; e++)
          b["$" + c[e]] = true;
        for (c = 0; c < a2.length; c++)
          e = b.hasOwnProperty("$" + a2[c].value), a2[c].selected !== e && (a2[c].selected = e), e && d && (a2[c].defaultSelected = true);
      } else {
        c = "" + Sa(c);
        b = null;
        for (e = 0; e < a2.length; e++) {
          if (a2[e].value === c) {
            a2[e].selected = true;
            d && (a2[e].defaultSelected = true);
            return;
          }
          null !== b || a2[e].disabled || (b = a2[e]);
        }
        null !== b && (b.selected = true);
      }
    }
    function gb(a2, b) {
      if (null != b.dangerouslySetInnerHTML)
        throw Error(y(91));
      return m({}, b, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
    }
    function hb(a2, b) {
      var c = b.value;
      if (null == c) {
        c = b.children;
        b = b.defaultValue;
        if (null != c) {
          if (null != b)
            throw Error(y(92));
          if (Array.isArray(c)) {
            if (!(1 >= c.length))
              throw Error(y(93));
            c = c[0];
          }
          b = c;
        }
        null == b && (b = "");
        c = b;
      }
      a2._wrapperState = { initialValue: Sa(c) };
    }
    function ib(a2, b) {
      var c = Sa(b.value), d = Sa(b.defaultValue);
      null != c && (c = "" + c, c !== a2.value && (a2.value = c), null == b.defaultValue && a2.defaultValue !== c && (a2.defaultValue = c));
      null != d && (a2.defaultValue = "" + d);
    }
    function jb(a2) {
      var b = a2.textContent;
      b === a2._wrapperState.initialValue && "" !== b && null !== b && (a2.value = b);
    }
    var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
    function lb(a2) {
      switch (a2) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function mb(a2, b) {
      return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? lb(b) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a2;
    }
    var nb, ob = function(a2) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a2(b, c, d, e);
        });
      } : a2;
    }(function(a2, b) {
      if (a2.namespaceURI !== kb.svg || "innerHTML" in a2)
        a2.innerHTML = b;
      else {
        nb = nb || document.createElement("div");
        nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = nb.firstChild; a2.firstChild; )
          a2.removeChild(a2.firstChild);
        for (; b.firstChild; )
          a2.appendChild(b.firstChild);
      }
    });
    function pb(a2, b) {
      if (b) {
        var c = a2.firstChild;
        if (c && c === a2.lastChild && 3 === c.nodeType) {
          c.nodeValue = b;
          return;
        }
      }
      a2.textContent = b;
    }
    var qb = {
      animationIterationCount: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, rb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(qb).forEach(function(a2) {
      rb.forEach(function(b) {
        b = b + a2.charAt(0).toUpperCase() + a2.substring(1);
        qb[b] = qb[a2];
      });
    });
    function sb(a2, b, c) {
      return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || qb.hasOwnProperty(a2) && qb[a2] ? ("" + b).trim() : b + "px";
    }
    function tb(a2, b) {
      a2 = a2.style;
      for (var c in b)
        if (b.hasOwnProperty(c)) {
          var d = 0 === c.indexOf("--"), e = sb(c, b[c], d);
          "float" === c && (c = "cssFloat");
          d ? a2.setProperty(c, e) : a2[c] = e;
        }
    }
    var ub = m({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function vb(a2, b) {
      if (b) {
        if (ub[a2] && (null != b.children || null != b.dangerouslySetInnerHTML))
          throw Error(y(137, a2));
        if (null != b.dangerouslySetInnerHTML) {
          if (null != b.children)
            throw Error(y(60));
          if (!("object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML))
            throw Error(y(61));
        }
        if (null != b.style && "object" !== typeof b.style)
          throw Error(y(62));
      }
    }
    function wb(a2, b) {
      if (-1 === a2.indexOf("-"))
        return "string" === typeof b.is;
      switch (a2) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    function xb(a2) {
      a2 = a2.target || a2.srcElement || window;
      a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
      return 3 === a2.nodeType ? a2.parentNode : a2;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a2) {
      if (a2 = Cb(a2)) {
        if ("function" !== typeof yb)
          throw Error(y(280));
        var b = a2.stateNode;
        b && (b = Db(b), yb(a2.stateNode, a2.type, b));
      }
    }
    function Eb(a2) {
      zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
    }
    function Fb() {
      if (zb) {
        var a2 = zb, b = Ab;
        Ab = zb = null;
        Bb(a2);
        if (b)
          for (a2 = 0; a2 < b.length; a2++)
            Bb(b[a2]);
      }
    }
    function Gb(a2, b) {
      return a2(b);
    }
    function Hb(a2, b, c, d, e) {
      return a2(b, c, d, e);
    }
    function Ib() {
    }
    var Jb = Gb, Kb = false, Lb = false;
    function Mb() {
      if (null !== zb || null !== Ab)
        Ib(), Fb();
    }
    function Nb(a2, b, c) {
      if (Lb)
        return a2(b, c);
      Lb = true;
      try {
        return Jb(a2, b, c);
      } finally {
        Lb = false, Mb();
      }
    }
    function Ob(a2, b) {
      var c = a2.stateNode;
      if (null === c)
        return null;
      var d = Db(c);
      if (null === d)
        return null;
      c = d[b];
      a:
        switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a2 = a2.type, d = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
            a2 = !d;
            break a;
          default:
            a2 = false;
        }
      if (a2)
        return null;
      if (c && "function" !== typeof c)
        throw Error(y(231, b, typeof c));
      return c;
    }
    var Pb = false;
    if (fa)
      try {
        var Qb = {};
        Object.defineProperty(Qb, "passive", { get: function() {
          Pb = true;
        } });
        window.addEventListener("test", Qb, Qb);
        window.removeEventListener("test", Qb, Qb);
      } catch (a2) {
        Pb = false;
      }
    function Rb(a2, b, c, d, e, f2, g2, h2, k) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l2);
      } catch (n2) {
        this.onError(n2);
      }
    }
    var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a2) {
      Sb = true;
      Tb = a2;
    } };
    function Xb(a2, b, c, d, e, f2, g2, h2, k) {
      Sb = false;
      Tb = null;
      Rb.apply(Wb, arguments);
    }
    function Yb(a2, b, c, d, e, f2, g2, h2, k) {
      Xb.apply(this, arguments);
      if (Sb) {
        if (Sb) {
          var l2 = Tb;
          Sb = false;
          Tb = null;
        } else
          throw Error(y(198));
        Ub || (Ub = true, Vb = l2);
      }
    }
    function Zb(a2) {
      var b = a2, c = a2;
      if (a2.alternate)
        for (; b.return; )
          b = b.return;
      else {
        a2 = b;
        do
          b = a2, 0 !== (b.flags & 1026) && (c = b.return), a2 = b.return;
        while (a2);
      }
      return 3 === b.tag ? c : null;
    }
    function $b(a2) {
      if (13 === a2.tag) {
        var b = a2.memoizedState;
        null === b && (a2 = a2.alternate, null !== a2 && (b = a2.memoizedState));
        if (null !== b)
          return b.dehydrated;
      }
      return null;
    }
    function ac(a2) {
      if (Zb(a2) !== a2)
        throw Error(y(188));
    }
    function bc(a2) {
      var b = a2.alternate;
      if (!b) {
        b = Zb(a2);
        if (null === b)
          throw Error(y(188));
        return b !== a2 ? null : a2;
      }
      for (var c = a2, d = b; ; ) {
        var e = c.return;
        if (null === e)
          break;
        var f2 = e.alternate;
        if (null === f2) {
          d = e.return;
          if (null !== d) {
            c = d;
            continue;
          }
          break;
        }
        if (e.child === f2.child) {
          for (f2 = e.child; f2; ) {
            if (f2 === c)
              return ac(e), a2;
            if (f2 === d)
              return ac(e), b;
            f2 = f2.sibling;
          }
          throw Error(y(188));
        }
        if (c.return !== d.return)
          c = e, d = f2;
        else {
          for (var g2 = false, h2 = e.child; h2; ) {
            if (h2 === c) {
              g2 = true;
              c = e;
              d = f2;
              break;
            }
            if (h2 === d) {
              g2 = true;
              d = e;
              c = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c) {
                g2 = true;
                c = f2;
                d = e;
                break;
              }
              if (h2 === d) {
                g2 = true;
                d = f2;
                c = e;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2)
              throw Error(y(189));
          }
        }
        if (c.alternate !== d)
          throw Error(y(190));
      }
      if (3 !== c.tag)
        throw Error(y(188));
      return c.stateNode.current === c ? a2 : b;
    }
    function cc(a2) {
      a2 = bc(a2);
      if (!a2)
        return null;
      for (var b = a2; ; ) {
        if (5 === b.tag || 6 === b.tag)
          return b;
        if (b.child)
          b.child.return = b, b = b.child;
        else {
          if (b === a2)
            break;
          for (; !b.sibling; ) {
            if (!b.return || b.return === a2)
              return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return null;
    }
    function dc(a2, b) {
      for (var c = a2.alternate; null !== b; ) {
        if (b === a2 || b === c)
          return true;
        b = b.return;
      }
      return false;
    }
    var ec, fc, gc, hc, ic = false, jc = [], kc = null, lc = null, mc = null, nc = /* @__PURE__ */ new Map(), oc = /* @__PURE__ */ new Map(), pc = [], qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function rc(a2, b, c, d, e) {
      return { blockedOn: a2, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e, targetContainers: [d] };
    }
    function sc(a2, b) {
      switch (a2) {
        case "focusin":
        case "focusout":
          kc = null;
          break;
        case "dragenter":
        case "dragleave":
          lc = null;
          break;
        case "mouseover":
        case "mouseout":
          mc = null;
          break;
        case "pointerover":
        case "pointerout":
          nc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          oc.delete(b.pointerId);
      }
    }
    function tc(a2, b, c, d, e, f2) {
      if (null === a2 || a2.nativeEvent !== f2)
        return a2 = rc(b, c, d, e, f2), null !== b && (b = Cb(b), null !== b && fc(b)), a2;
      a2.eventSystemFlags |= d;
      b = a2.targetContainers;
      null !== e && -1 === b.indexOf(e) && b.push(e);
      return a2;
    }
    function uc(a2, b, c, d, e) {
      switch (b) {
        case "focusin":
          return kc = tc(kc, a2, b, c, d, e), true;
        case "dragenter":
          return lc = tc(lc, a2, b, c, d, e), true;
        case "mouseover":
          return mc = tc(mc, a2, b, c, d, e), true;
        case "pointerover":
          var f2 = e.pointerId;
          nc.set(f2, tc(nc.get(f2) || null, a2, b, c, d, e));
          return true;
        case "gotpointercapture":
          return f2 = e.pointerId, oc.set(f2, tc(oc.get(f2) || null, a2, b, c, d, e)), true;
      }
      return false;
    }
    function vc(a2) {
      var b = wc(a2.target);
      if (null !== b) {
        var c = Zb(b);
        if (null !== c) {
          if (b = c.tag, 13 === b) {
            if (b = $b(c), null !== b) {
              a2.blockedOn = b;
              hc(a2.lanePriority, function() {
                r.unstable_runWithPriority(a2.priority, function() {
                  gc(c);
                });
              });
              return;
            }
          } else if (3 === b && c.stateNode.hydrate) {
            a2.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a2.blockedOn = null;
    }
    function xc(a2) {
      if (null !== a2.blockedOn)
        return false;
      for (var b = a2.targetContainers; 0 < b.length; ) {
        var c = yc(a2.domEventName, a2.eventSystemFlags, b[0], a2.nativeEvent);
        if (null !== c)
          return b = Cb(c), null !== b && fc(b), a2.blockedOn = c, false;
        b.shift();
      }
      return true;
    }
    function zc(a2, b, c) {
      xc(a2) && c.delete(b);
    }
    function Ac() {
      for (ic = false; 0 < jc.length; ) {
        var a2 = jc[0];
        if (null !== a2.blockedOn) {
          a2 = Cb(a2.blockedOn);
          null !== a2 && ec(a2);
          break;
        }
        for (var b = a2.targetContainers; 0 < b.length; ) {
          var c = yc(a2.domEventName, a2.eventSystemFlags, b[0], a2.nativeEvent);
          if (null !== c) {
            a2.blockedOn = c;
            break;
          }
          b.shift();
        }
        null === a2.blockedOn && jc.shift();
      }
      null !== kc && xc(kc) && (kc = null);
      null !== lc && xc(lc) && (lc = null);
      null !== mc && xc(mc) && (mc = null);
      nc.forEach(zc);
      oc.forEach(zc);
    }
    function Bc(a2, b) {
      a2.blockedOn === b && (a2.blockedOn = null, ic || (ic = true, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ac)));
    }
    function Cc(a2) {
      function b(b2) {
        return Bc(b2, a2);
      }
      if (0 < jc.length) {
        Bc(jc[0], a2);
        for (var c = 1; c < jc.length; c++) {
          var d = jc[c];
          d.blockedOn === a2 && (d.blockedOn = null);
        }
      }
      null !== kc && Bc(kc, a2);
      null !== lc && Bc(lc, a2);
      null !== mc && Bc(mc, a2);
      nc.forEach(b);
      oc.forEach(b);
      for (c = 0; c < pc.length; c++)
        d = pc[c], d.blockedOn === a2 && (d.blockedOn = null);
      for (; 0 < pc.length && (c = pc[0], null === c.blockedOn); )
        vc(c), null === c.blockedOn && pc.shift();
    }
    function Dc(a2, b) {
      var c = {};
      c[a2.toLowerCase()] = b.toLowerCase();
      c["Webkit" + a2] = "webkit" + b;
      c["Moz" + a2] = "moz" + b;
      return c;
    }
    var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") }, Fc = {}, Gc = {};
    fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
    function Hc(a2) {
      if (Fc[a2])
        return Fc[a2];
      if (!Ec[a2])
        return a2;
      var b = Ec[a2], c;
      for (c in b)
        if (b.hasOwnProperty(c) && c in Gc)
          return Fc[a2] = b[c];
      return a2;
    }
    var Ic = Hc("animationend"), Jc = Hc("animationiteration"), Kc = Hc("animationstart"), Lc = Hc("transitionend"), Mc = /* @__PURE__ */ new Map(), Nc = /* @__PURE__ */ new Map(), Oc = [
      "abort",
      "abort",
      Ic,
      "animationEnd",
      Jc,
      "animationIteration",
      Kc,
      "animationStart",
      "canplay",
      "canPlay",
      "canplaythrough",
      "canPlayThrough",
      "durationchange",
      "durationChange",
      "emptied",
      "emptied",
      "encrypted",
      "encrypted",
      "ended",
      "ended",
      "error",
      "error",
      "gotpointercapture",
      "gotPointerCapture",
      "load",
      "load",
      "loadeddata",
      "loadedData",
      "loadedmetadata",
      "loadedMetadata",
      "loadstart",
      "loadStart",
      "lostpointercapture",
      "lostPointerCapture",
      "playing",
      "playing",
      "progress",
      "progress",
      "seeking",
      "seeking",
      "stalled",
      "stalled",
      "suspend",
      "suspend",
      "timeupdate",
      "timeUpdate",
      Lc,
      "transitionEnd",
      "waiting",
      "waiting"
    ];
    function Pc(a2, b) {
      for (var c = 0; c < a2.length; c += 2) {
        var d = a2[c], e = a2[c + 1];
        e = "on" + (e[0].toUpperCase() + e.slice(1));
        Nc.set(d, b);
        Mc.set(d, e);
        da(e, [d]);
      }
    }
    var Qc = r.unstable_now;
    Qc();
    var F = 8;
    function Rc(a2) {
      if (0 !== (1 & a2))
        return F = 15, 1;
      if (0 !== (2 & a2))
        return F = 14, 2;
      if (0 !== (4 & a2))
        return F = 13, 4;
      var b = 24 & a2;
      if (0 !== b)
        return F = 12, b;
      if (0 !== (a2 & 32))
        return F = 11, 32;
      b = 192 & a2;
      if (0 !== b)
        return F = 10, b;
      if (0 !== (a2 & 256))
        return F = 9, 256;
      b = 3584 & a2;
      if (0 !== b)
        return F = 8, b;
      if (0 !== (a2 & 4096))
        return F = 7, 4096;
      b = 4186112 & a2;
      if (0 !== b)
        return F = 6, b;
      b = 62914560 & a2;
      if (0 !== b)
        return F = 5, b;
      if (a2 & 67108864)
        return F = 4, 67108864;
      if (0 !== (a2 & 134217728))
        return F = 3, 134217728;
      b = 805306368 & a2;
      if (0 !== b)
        return F = 2, b;
      if (0 !== (1073741824 & a2))
        return F = 1, 1073741824;
      F = 8;
      return a2;
    }
    function Sc(a2) {
      switch (a2) {
        case 99:
          return 15;
        case 98:
          return 10;
        case 97:
        case 96:
          return 8;
        case 95:
          return 2;
        default:
          return 0;
      }
    }
    function Tc(a2) {
      switch (a2) {
        case 15:
        case 14:
          return 99;
        case 13:
        case 12:
        case 11:
        case 10:
          return 98;
        case 9:
        case 8:
        case 7:
        case 6:
        case 4:
        case 5:
          return 97;
        case 3:
        case 2:
        case 1:
          return 95;
        case 0:
          return 90;
        default:
          throw Error(y(358, a2));
      }
    }
    function Uc(a2, b) {
      var c = a2.pendingLanes;
      if (0 === c)
        return F = 0;
      var d = 0, e = 0, f2 = a2.expiredLanes, g2 = a2.suspendedLanes, h2 = a2.pingedLanes;
      if (0 !== f2)
        d = f2, e = F = 15;
      else if (f2 = c & 134217727, 0 !== f2) {
        var k = f2 & ~g2;
        0 !== k ? (d = Rc(k), e = F) : (h2 &= f2, 0 !== h2 && (d = Rc(h2), e = F));
      } else
        f2 = c & ~g2, 0 !== f2 ? (d = Rc(f2), e = F) : 0 !== h2 && (d = Rc(h2), e = F);
      if (0 === d)
        return 0;
      d = 31 - Vc(d);
      d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;
      if (0 !== b && b !== d && 0 === (b & g2)) {
        Rc(b);
        if (e <= F)
          return b;
        F = e;
      }
      b = a2.entangledLanes;
      if (0 !== b)
        for (a2 = a2.entanglements, b &= d; 0 < b; )
          c = 31 - Vc(b), e = 1 << c, d |= a2[c], b &= ~e;
      return d;
    }
    function Wc(a2) {
      a2 = a2.pendingLanes & -1073741825;
      return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
    }
    function Xc(a2, b) {
      switch (a2) {
        case 15:
          return 1;
        case 14:
          return 2;
        case 12:
          return a2 = Yc(24 & ~b), 0 === a2 ? Xc(10, b) : a2;
        case 10:
          return a2 = Yc(192 & ~b), 0 === a2 ? Xc(8, b) : a2;
        case 8:
          return a2 = Yc(3584 & ~b), 0 === a2 && (a2 = Yc(4186112 & ~b), 0 === a2 && (a2 = 512)), a2;
        case 2:
          return b = Yc(805306368 & ~b), 0 === b && (b = 268435456), b;
      }
      throw Error(y(358, a2));
    }
    function Yc(a2) {
      return a2 & -a2;
    }
    function Zc(a2) {
      for (var b = [], c = 0; 31 > c; c++)
        b.push(a2);
      return b;
    }
    function $c(a2, b, c) {
      a2.pendingLanes |= b;
      var d = b - 1;
      a2.suspendedLanes &= d;
      a2.pingedLanes &= d;
      a2 = a2.eventTimes;
      b = 31 - Vc(b);
      a2[b] = c;
    }
    var Vc = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
    function ad(a2) {
      return 0 === a2 ? 32 : 31 - (bd(a2) / cd | 0) | 0;
    }
    var dd = r.unstable_UserBlockingPriority, ed = r.unstable_runWithPriority, fd = true;
    function gd(a2, b, c, d) {
      Kb || Ib();
      var e = hd, f2 = Kb;
      Kb = true;
      try {
        Hb(e, a2, b, c, d);
      } finally {
        (Kb = f2) || Mb();
      }
    }
    function id(a2, b, c, d) {
      ed(dd, hd.bind(null, a2, b, c, d));
    }
    function hd(a2, b, c, d) {
      if (fd) {
        var e;
        if ((e = 0 === (b & 4)) && 0 < jc.length && -1 < qc.indexOf(a2))
          a2 = rc(null, a2, b, c, d), jc.push(a2);
        else {
          var f2 = yc(a2, b, c, d);
          if (null === f2)
            e && sc(a2, d);
          else {
            if (e) {
              if (-1 < qc.indexOf(a2)) {
                a2 = rc(f2, a2, b, c, d);
                jc.push(a2);
                return;
              }
              if (uc(f2, a2, b, c, d))
                return;
              sc(a2, d);
            }
            jd(a2, b, d, null, c);
          }
        }
      }
    }
    function yc(a2, b, c, d) {
      var e = xb(d);
      e = wc(e);
      if (null !== e) {
        var f2 = Zb(e);
        if (null === f2)
          e = null;
        else {
          var g2 = f2.tag;
          if (13 === g2) {
            e = $b(f2);
            if (null !== e)
              return e;
            e = null;
          } else if (3 === g2) {
            if (f2.stateNode.hydrate)
              return 3 === f2.tag ? f2.stateNode.containerInfo : null;
            e = null;
          } else
            f2 !== e && (e = null);
        }
      }
      jd(a2, b, d, e, c);
      return null;
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a2, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f2 = e.length;
      for (a2 = 0; a2 < c && b[a2] === e[a2]; a2++)
        ;
      var g2 = c - a2;
      for (d = 1; d <= g2 && b[c - d] === e[f2 - d]; d++)
        ;
      return md = e.slice(a2, 1 < d ? 1 - d : void 0);
    }
    function od(a2) {
      var b = a2.keyCode;
      "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b && (a2 = 13)) : a2 = b;
      10 === a2 && (a2 = 13);
      return 32 <= a2 || 13 === a2 ? a2 : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a2) {
      function b(b2, d, e, f2, g2) {
        this._reactName = b2;
        this._targetInst = e;
        this.type = d;
        this.nativeEvent = f2;
        this.target = g2;
        this.currentTarget = null;
        for (var c in a2)
          a2.hasOwnProperty(c) && (b2 = a2[c], this[c] = b2 ? b2(f2) : f2[c]);
        this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      m(b.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a3 = this.nativeEvent;
        a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a3 = this.nativeEvent;
        a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
      return a2.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = m({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
      return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
    }, movementX: function(a2) {
      if ("movementX" in a2)
        return a2.movementX;
      a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
      return wd;
    }, movementY: function(a2) {
      return "movementY" in a2 ? a2.movementY : xd;
    } }), Bd = rd(Ad), Cd = m({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = m({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = m({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m({}, sd, { clipboardData: function(a2) {
      return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = m({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a2) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a2) : (a2 = Od[a2]) ? !!b[a2] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = m({}, ud, { key: function(a2) {
      if (a2.key) {
        var b = Md[a2.key] || a2.key;
        if ("Unidentified" !== b)
          return b;
      }
      return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
      return "keypress" === a2.type ? od(a2) : 0;
    }, keyCode: function(a2) {
      return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    }, which: function(a2) {
      return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    } }), Rd = rd(Qd), Sd = m({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = m({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = m({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = m({}, Ad, {
      deltaX: function(a2) {
        return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
      },
      deltaY: function(a2) {
        return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = fa && "CompositionEvent" in window, be = null;
    fa && "documentMode" in document && (be = document.documentMode);
    var ce = fa && "TextEvent" in window && !be, de = fa && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
    function ge(a2, b) {
      switch (a2) {
        case "keyup":
          return -1 !== $d.indexOf(b.keyCode);
        case "keydown":
          return 229 !== b.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a2) {
      a2 = a2.detail;
      return "object" === typeof a2 && "data" in a2 ? a2.data : null;
    }
    var ie = false;
    function je(a2, b) {
      switch (a2) {
        case "compositionend":
          return he(b);
        case "keypress":
          if (32 !== b.which)
            return null;
          fe = true;
          return ee;
        case "textInput":
          return a2 = b.data, a2 === ee && fe ? null : a2;
        default:
          return null;
      }
    }
    function ke(a2, b) {
      if (ie)
        return "compositionend" === a2 || !ae && ge(a2, b) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
      switch (a2) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length)
              return b.char;
            if (b.which)
              return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b.locale ? null : b.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a2) {
      var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
      return "input" === b ? !!le[a2.type] : "textarea" === b ? true : false;
    }
    function ne(a2, b, c, d) {
      Eb(d);
      b = oe(b, "onChange");
      0 < b.length && (c = new td("onChange", "change", null, c, d), a2.push({ event: c, listeners: b }));
    }
    var pe = null, qe = null;
    function re(a2) {
      se(a2, 0);
    }
    function te(a2) {
      var b = ue(a2);
      if (Wa(b))
        return a2;
    }
    function ve(a2, b) {
      if ("change" === a2)
        return b;
    }
    var we = false;
    if (fa) {
      var xe;
      if (fa) {
        var ye = "oninput" in document;
        if (!ye) {
          var ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a2) {
      if ("value" === a2.propertyName && te(qe)) {
        var b = [];
        ne(b, qe, a2, xb(a2));
        a2 = re;
        if (Kb)
          a2(b);
        else {
          Kb = true;
          try {
            Gb(a2, b);
          } finally {
            Kb = false, Mb();
          }
        }
      }
    }
    function Ce(a2, b, c) {
      "focusin" === a2 ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
    }
    function De(a2) {
      if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
        return te(qe);
    }
    function Ee(a2, b) {
      if ("click" === a2)
        return te(b);
    }
    function Fe(a2, b) {
      if ("input" === a2 || "change" === a2)
        return te(b);
    }
    function Ge(a2, b) {
      return a2 === b && (0 !== a2 || 1 / a2 === 1 / b) || a2 !== a2 && b !== b;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge, Ie = Object.prototype.hasOwnProperty;
    function Je(a2, b) {
      if (He(a2, b))
        return true;
      if ("object" !== typeof a2 || null === a2 || "object" !== typeof b || null === b)
        return false;
      var c = Object.keys(a2), d = Object.keys(b);
      if (c.length !== d.length)
        return false;
      for (d = 0; d < c.length; d++)
        if (!Ie.call(b, c[d]) || !He(a2[c[d]], b[c[d]]))
          return false;
      return true;
    }
    function Ke(a2) {
      for (; a2 && a2.firstChild; )
        a2 = a2.firstChild;
      return a2;
    }
    function Le(a2, b) {
      var c = Ke(a2);
      a2 = 0;
      for (var d; c; ) {
        if (3 === c.nodeType) {
          d = a2 + c.textContent.length;
          if (a2 <= b && d >= b)
            return { node: c, offset: b - a2 };
          a2 = d;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Ke(c);
      }
    }
    function Me(a2, b) {
      return a2 && b ? a2 === b ? true : a2 && 3 === a2.nodeType ? false : b && 3 === b.nodeType ? Me(a2, b.parentNode) : "contains" in a2 ? a2.contains(b) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b) & 16) : false : false;
    }
    function Ne() {
      for (var a2 = window, b = Xa(); b instanceof a2.HTMLIFrameElement; ) {
        try {
          var c = "string" === typeof b.contentWindow.location.href;
        } catch (d) {
          c = false;
        }
        if (c)
          a2 = b.contentWindow;
        else
          break;
        b = Xa(a2.document);
      }
      return b;
    }
    function Oe(a2) {
      var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
      return b && ("input" === b && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b || "true" === a2.contentEditable);
    }
    var Pe = fa && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
    function Ue(a2, b, c) {
      var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
      Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a2.push({ event: b, listeners: d }), b.target = Qe)));
    }
    Pc(
      "cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
      0
    );
    Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
    Pc(Oc, 2);
    for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
      Nc.set(Ve[We], 0);
    ea("onMouseEnter", ["mouseout", "mouseover"]);
    ea("onMouseLeave", ["mouseout", "mouseover"]);
    ea("onPointerEnter", ["pointerout", "pointerover"]);
    ea("onPointerLeave", ["pointerout", "pointerover"]);
    da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
    function Ze(a2, b, c) {
      var d = a2.type || "unknown-event";
      a2.currentTarget = c;
      Yb(d, b, void 0, a2);
      a2.currentTarget = null;
    }
    function se(a2, b) {
      b = 0 !== (b & 4);
      for (var c = 0; c < a2.length; c++) {
        var d = a2[c], e = d.event;
        d = d.listeners;
        a: {
          var f2 = void 0;
          if (b)
            for (var g2 = d.length - 1; 0 <= g2; g2--) {
              var h2 = d[g2], k = h2.instance, l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k !== f2 && e.isPropagationStopped())
                break a;
              Ze(e, h2, l2);
              f2 = k;
            }
          else
            for (g2 = 0; g2 < d.length; g2++) {
              h2 = d[g2];
              k = h2.instance;
              l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k !== f2 && e.isPropagationStopped())
                break a;
              Ze(e, h2, l2);
              f2 = k;
            }
        }
      }
      if (Ub)
        throw a2 = Vb, Ub = false, Vb = null, a2;
    }
    function G(a2, b) {
      var c = $e(b), d = a2 + "__bubble";
      c.has(d) || (af(b, a2, 2, false), c.add(d));
    }
    var bf = "_reactListening" + Math.random().toString(36).slice(2);
    function cf(a2) {
      a2[bf] || (a2[bf] = true, ba.forEach(function(b) {
        Ye.has(b) || df(b, false, a2, null);
        df(b, true, a2, null);
      }));
    }
    function df(a2, b, c, d) {
      var e = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, f2 = c;
      "selectionchange" === a2 && 9 !== c.nodeType && (f2 = c.ownerDocument);
      if (null !== d && !b && Ye.has(a2)) {
        if ("scroll" !== a2)
          return;
        e |= 2;
        f2 = d;
      }
      var g2 = $e(f2), h2 = a2 + "__" + (b ? "capture" : "bubble");
      g2.has(h2) || (b && (e |= 4), af(f2, a2, e, b), g2.add(h2));
    }
    function af(a2, b, c, d) {
      var e = Nc.get(b);
      switch (void 0 === e ? 2 : e) {
        case 0:
          e = gd;
          break;
        case 1:
          e = id;
          break;
        default:
          e = hd;
      }
      c = e.bind(null, b, c, a2);
      e = void 0;
      !Pb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
      d ? void 0 !== e ? a2.addEventListener(b, c, { capture: true, passive: e }) : a2.addEventListener(b, c, true) : void 0 !== e ? a2.addEventListener(b, c, { passive: e }) : a2.addEventListener(b, c, false);
    }
    function jd(a2, b, c, d, e) {
      var f2 = d;
      if (0 === (b & 1) && 0 === (b & 2) && null !== d)
        a:
          for (; ; ) {
            if (null === d)
              return;
            var g2 = d.tag;
            if (3 === g2 || 4 === g2) {
              var h2 = d.stateNode.containerInfo;
              if (h2 === e || 8 === h2.nodeType && h2.parentNode === e)
                break;
              if (4 === g2)
                for (g2 = d.return; null !== g2; ) {
                  var k = g2.tag;
                  if (3 === k || 4 === k) {
                    if (k = g2.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e)
                      return;
                  }
                  g2 = g2.return;
                }
              for (; null !== h2; ) {
                g2 = wc(h2);
                if (null === g2)
                  return;
                k = g2.tag;
                if (5 === k || 6 === k) {
                  d = f2 = g2;
                  continue a;
                }
                h2 = h2.parentNode;
              }
            }
            d = d.return;
          }
      Nb(function() {
        var d2 = f2, e2 = xb(c), g3 = [];
        a: {
          var h3 = Mc.get(a2);
          if (void 0 !== h3) {
            var k2 = td, x2 = a2;
            switch (a2) {
              case "keypress":
                if (0 === od(c))
                  break a;
              case "keydown":
              case "keyup":
                k2 = Rd;
                break;
              case "focusin":
                x2 = "focus";
                k2 = Fd;
                break;
              case "focusout":
                x2 = "blur";
                k2 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k2 = Fd;
                break;
              case "click":
                if (2 === c.button)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k2 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k2 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k2 = Vd;
                break;
              case Ic:
              case Jc:
              case Kc:
                k2 = Hd;
                break;
              case Lc:
                k2 = Xd;
                break;
              case "scroll":
                k2 = vd;
                break;
              case "wheel":
                k2 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k2 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k2 = Td;
            }
            var w2 = 0 !== (b & 4), z2 = !w2 && "scroll" === a2, u2 = w2 ? null !== h3 ? h3 + "Capture" : null : h3;
            w2 = [];
            for (var t2 = d2, q2; null !== t2; ) {
              q2 = t2;
              var v2 = q2.stateNode;
              5 === q2.tag && null !== v2 && (q2 = v2, null !== u2 && (v2 = Ob(t2, u2), null != v2 && w2.push(ef(t2, v2, q2))));
              if (z2)
                break;
              t2 = t2.return;
            }
            0 < w2.length && (h3 = new k2(h3, x2, null, c, e2), g3.push({ event: h3, listeners: w2 }));
          }
        }
        if (0 === (b & 7)) {
          a: {
            h3 = "mouseover" === a2 || "pointerover" === a2;
            k2 = "mouseout" === a2 || "pointerout" === a2;
            if (h3 && 0 === (b & 16) && (x2 = c.relatedTarget || c.fromElement) && (wc(x2) || x2[ff]))
              break a;
            if (k2 || h3) {
              h3 = e2.window === e2 ? e2 : (h3 = e2.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
              if (k2) {
                if (x2 = c.relatedTarget || c.toElement, k2 = d2, x2 = x2 ? wc(x2) : null, null !== x2 && (z2 = Zb(x2), x2 !== z2 || 5 !== x2.tag && 6 !== x2.tag))
                  x2 = null;
              } else
                k2 = null, x2 = d2;
              if (k2 !== x2) {
                w2 = Bd;
                v2 = "onMouseLeave";
                u2 = "onMouseEnter";
                t2 = "mouse";
                if ("pointerout" === a2 || "pointerover" === a2)
                  w2 = Td, v2 = "onPointerLeave", u2 = "onPointerEnter", t2 = "pointer";
                z2 = null == k2 ? h3 : ue(k2);
                q2 = null == x2 ? h3 : ue(x2);
                h3 = new w2(v2, t2 + "leave", k2, c, e2);
                h3.target = z2;
                h3.relatedTarget = q2;
                v2 = null;
                wc(e2) === d2 && (w2 = new w2(u2, t2 + "enter", x2, c, e2), w2.target = q2, w2.relatedTarget = z2, v2 = w2);
                z2 = v2;
                if (k2 && x2)
                  b: {
                    w2 = k2;
                    u2 = x2;
                    t2 = 0;
                    for (q2 = w2; q2; q2 = gf(q2))
                      t2++;
                    q2 = 0;
                    for (v2 = u2; v2; v2 = gf(v2))
                      q2++;
                    for (; 0 < t2 - q2; )
                      w2 = gf(w2), t2--;
                    for (; 0 < q2 - t2; )
                      u2 = gf(u2), q2--;
                    for (; t2--; ) {
                      if (w2 === u2 || null !== u2 && w2 === u2.alternate)
                        break b;
                      w2 = gf(w2);
                      u2 = gf(u2);
                    }
                    w2 = null;
                  }
                else
                  w2 = null;
                null !== k2 && hf(g3, h3, k2, w2, false);
                null !== x2 && null !== z2 && hf(g3, z2, x2, w2, true);
              }
            }
          }
          a: {
            h3 = d2 ? ue(d2) : window;
            k2 = h3.nodeName && h3.nodeName.toLowerCase();
            if ("select" === k2 || "input" === k2 && "file" === h3.type)
              var J2 = ve;
            else if (me(h3))
              if (we)
                J2 = Fe;
              else {
                J2 = De;
                var K2 = Ce;
              }
            else
              (k2 = h3.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (J2 = Ee);
            if (J2 && (J2 = J2(a2, d2))) {
              ne(g3, J2, c, e2);
              break a;
            }
            K2 && K2(a2, h3, d2);
            "focusout" === a2 && (K2 = h3._wrapperState) && K2.controlled && "number" === h3.type && bb(h3, "number", h3.value);
          }
          K2 = d2 ? ue(d2) : window;
          switch (a2) {
            case "focusin":
              if (me(K2) || "true" === K2.contentEditable)
                Qe = K2, Re = d2, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g3, c, e2);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g3, c, e2);
          }
          var Q2;
          if (ae)
            b: {
              switch (a2) {
                case "compositionstart":
                  var L2 = "onCompositionStart";
                  break b;
                case "compositionend":
                  L2 = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  L2 = "onCompositionUpdate";
                  break b;
              }
              L2 = void 0;
            }
          else
            ie ? ge(a2, c) && (L2 = "onCompositionEnd") : "keydown" === a2 && 229 === c.keyCode && (L2 = "onCompositionStart");
          L2 && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== L2 ? "onCompositionEnd" === L2 && ie && (Q2 = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe(d2, L2), 0 < K2.length && (L2 = new Ld(L2, a2, null, c, e2), g3.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he(c), null !== Q2 && (L2.data = Q2))));
          if (Q2 = ce ? je(a2, c) : ke(a2, c))
            d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld(
              "onBeforeInput",
              "beforeinput",
              null,
              c,
              e2
            ), g3.push({ event: e2, listeners: d2 }), e2.data = Q2);
        }
        se(g3, b);
      });
    }
    function ef(a2, b, c) {
      return { instance: a2, listener: b, currentTarget: c };
    }
    function oe(a2, b) {
      for (var c = b + "Capture", d = []; null !== a2; ) {
        var e = a2, f2 = e.stateNode;
        5 === e.tag && null !== f2 && (e = f2, f2 = Ob(a2, c), null != f2 && d.unshift(ef(a2, f2, e)), f2 = Ob(a2, b), null != f2 && d.push(ef(a2, f2, e)));
        a2 = a2.return;
      }
      return d;
    }
    function gf(a2) {
      if (null === a2)
        return null;
      do
        a2 = a2.return;
      while (a2 && 5 !== a2.tag);
      return a2 ? a2 : null;
    }
    function hf(a2, b, c, d, e) {
      for (var f2 = b._reactName, g2 = []; null !== c && c !== d; ) {
        var h2 = c, k = h2.alternate, l2 = h2.stateNode;
        if (null !== k && k === d)
          break;
        5 === h2.tag && null !== l2 && (h2 = l2, e ? (k = Ob(c, f2), null != k && g2.unshift(ef(c, k, h2))) : e || (k = Ob(c, f2), null != k && g2.push(ef(c, k, h2))));
        c = c.return;
      }
      0 !== g2.length && a2.push({ event: b, listeners: g2 });
    }
    function jf() {
    }
    var kf = null, lf = null;
    function mf(a2, b) {
      switch (a2) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!b.autoFocus;
      }
      return false;
    }
    function nf(a2, b) {
      return "textarea" === a2 || "option" === a2 || "noscript" === a2 || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
    }
    var of = "function" === typeof setTimeout ? setTimeout : void 0, pf = "function" === typeof clearTimeout ? clearTimeout : void 0;
    function qf(a2) {
      1 === a2.nodeType ? a2.textContent = "" : 9 === a2.nodeType && (a2 = a2.body, null != a2 && (a2.textContent = ""));
    }
    function rf(a2) {
      for (; null != a2; a2 = a2.nextSibling) {
        var b = a2.nodeType;
        if (1 === b || 3 === b)
          break;
      }
      return a2;
    }
    function sf(a2) {
      a2 = a2.previousSibling;
      for (var b = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c = a2.data;
          if ("$" === c || "$!" === c || "$?" === c) {
            if (0 === b)
              return a2;
            b--;
          } else
            "/$" === c && b++;
        }
        a2 = a2.previousSibling;
      }
      return null;
    }
    var tf = 0;
    function uf(a2) {
      return { $$typeof: Ga, toString: a2, valueOf: a2 };
    }
    var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
    function wc(a2) {
      var b = a2[wf];
      if (b)
        return b;
      for (var c = a2.parentNode; c; ) {
        if (b = c[ff] || c[wf]) {
          c = b.alternate;
          if (null !== b.child || null !== c && null !== c.child)
            for (a2 = sf(a2); null !== a2; ) {
              if (c = a2[wf])
                return c;
              a2 = sf(a2);
            }
          return b;
        }
        a2 = c;
        c = a2.parentNode;
      }
      return null;
    }
    function Cb(a2) {
      a2 = a2[wf] || a2[ff];
      return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
    }
    function ue(a2) {
      if (5 === a2.tag || 6 === a2.tag)
        return a2.stateNode;
      throw Error(y(33));
    }
    function Db(a2) {
      return a2[xf] || null;
    }
    function $e(a2) {
      var b = a2[yf];
      void 0 === b && (b = a2[yf] = /* @__PURE__ */ new Set());
      return b;
    }
    var zf = [], Af = -1;
    function Bf(a2) {
      return { current: a2 };
    }
    function H(a2) {
      0 > Af || (a2.current = zf[Af], zf[Af] = null, Af--);
    }
    function I(a2, b) {
      Af++;
      zf[Af] = a2.current;
      a2.current = b;
    }
    var Cf = {}, M = Bf(Cf), N = Bf(false), Df = Cf;
    function Ef(a2, b) {
      var c = a2.type.contextTypes;
      if (!c)
        return Cf;
      var d = a2.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
        return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f2;
      for (f2 in c)
        e[f2] = b[f2];
      d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b, a2.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    function Ff(a2) {
      a2 = a2.childContextTypes;
      return null !== a2 && void 0 !== a2;
    }
    function Gf() {
      H(N);
      H(M);
    }
    function Hf(a2, b, c) {
      if (M.current !== Cf)
        throw Error(y(168));
      I(M, b);
      I(N, c);
    }
    function If(a2, b, c) {
      var d = a2.stateNode;
      a2 = b.childContextTypes;
      if ("function" !== typeof d.getChildContext)
        return c;
      d = d.getChildContext();
      for (var e in d)
        if (!(e in a2))
          throw Error(y(108, Ra(b) || "Unknown", e));
      return m({}, c, d);
    }
    function Jf(a2) {
      a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Cf;
      Df = M.current;
      I(M, a2);
      I(N, N.current);
      return true;
    }
    function Kf(a2, b, c) {
      var d = a2.stateNode;
      if (!d)
        throw Error(y(169));
      c ? (a2 = If(a2, b, Df), d.__reactInternalMemoizedMergedChildContext = a2, H(N), H(M), I(M, a2)) : H(N);
      I(N, c);
    }
    var Lf = null, Mf = null, Nf = r.unstable_runWithPriority, Of = r.unstable_scheduleCallback, Pf = r.unstable_cancelCallback, Qf = r.unstable_shouldYield, Rf = r.unstable_requestPaint, Sf = r.unstable_now, Tf = r.unstable_getCurrentPriorityLevel, Uf = r.unstable_ImmediatePriority, Vf = r.unstable_UserBlockingPriority, Wf = r.unstable_NormalPriority, Xf = r.unstable_LowPriority, Yf = r.unstable_IdlePriority, Zf = {}, $f = void 0 !== Rf ? Rf : function() {
    }, ag = null, bg = null, cg = false, dg = Sf(), O = 1e4 > dg ? Sf : function() {
      return Sf() - dg;
    };
    function eg() {
      switch (Tf()) {
        case Uf:
          return 99;
        case Vf:
          return 98;
        case Wf:
          return 97;
        case Xf:
          return 96;
        case Yf:
          return 95;
        default:
          throw Error(y(332));
      }
    }
    function fg(a2) {
      switch (a2) {
        case 99:
          return Uf;
        case 98:
          return Vf;
        case 97:
          return Wf;
        case 96:
          return Xf;
        case 95:
          return Yf;
        default:
          throw Error(y(332));
      }
    }
    function gg(a2, b) {
      a2 = fg(a2);
      return Nf(a2, b);
    }
    function hg(a2, b, c) {
      a2 = fg(a2);
      return Of(a2, b, c);
    }
    function ig() {
      if (null !== bg) {
        var a2 = bg;
        bg = null;
        Pf(a2);
      }
      jg();
    }
    function jg() {
      if (!cg && null !== ag) {
        cg = true;
        var a2 = 0;
        try {
          var b = ag;
          gg(99, function() {
            for (; a2 < b.length; a2++) {
              var c = b[a2];
              do
                c = c(true);
              while (null !== c);
            }
          });
          ag = null;
        } catch (c) {
          throw null !== ag && (ag = ag.slice(a2 + 1)), Of(Uf, ig), c;
        } finally {
          cg = false;
        }
      }
    }
    var kg = ra.ReactCurrentBatchConfig;
    function lg(a2, b) {
      if (a2 && a2.defaultProps) {
        b = m({}, b);
        a2 = a2.defaultProps;
        for (var c in a2)
          void 0 === b[c] && (b[c] = a2[c]);
        return b;
      }
      return b;
    }
    var mg = Bf(null), ng = null, og = null, pg = null;
    function qg() {
      pg = og = ng = null;
    }
    function rg(a2) {
      var b = mg.current;
      H(mg);
      a2.type._context._currentValue = b;
    }
    function sg(a2, b) {
      for (; null !== a2; ) {
        var c = a2.alternate;
        if ((a2.childLanes & b) === b)
          if (null === c || (c.childLanes & b) === b)
            break;
          else
            c.childLanes |= b;
        else
          a2.childLanes |= b, null !== c && (c.childLanes |= b);
        a2 = a2.return;
      }
    }
    function tg(a2, b) {
      ng = a2;
      pg = og = null;
      a2 = a2.dependencies;
      null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b) && (ug = true), a2.firstContext = null);
    }
    function vg(a2, b) {
      if (pg !== a2 && false !== b && 0 !== b) {
        if ("number" !== typeof b || 1073741823 === b)
          pg = a2, b = 1073741823;
        b = { context: a2, observedBits: b, next: null };
        if (null === og) {
          if (null === ng)
            throw Error(y(308));
          og = b;
          ng.dependencies = { lanes: 0, firstContext: b, responders: null };
        } else
          og = og.next = b;
      }
      return a2._currentValue;
    }
    var wg = false;
    function xg(a2) {
      a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
    }
    function yg(a2, b) {
      a2 = a2.updateQueue;
      b.updateQueue === a2 && (b.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
    }
    function zg(a2, b) {
      return { eventTime: a2, lane: b, tag: 0, payload: null, callback: null, next: null };
    }
    function Ag(a2, b) {
      a2 = a2.updateQueue;
      if (null !== a2) {
        a2 = a2.shared;
        var c = a2.pending;
        null === c ? b.next = b : (b.next = c.next, c.next = b);
        a2.pending = b;
      }
    }
    function Bg(a2, b) {
      var c = a2.updateQueue, d = a2.alternate;
      if (null !== d && (d = d.updateQueue, c === d)) {
        var e = null, f2 = null;
        c = c.firstBaseUpdate;
        if (null !== c) {
          do {
            var g2 = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
            null === f2 ? e = f2 = g2 : f2 = f2.next = g2;
            c = c.next;
          } while (null !== c);
          null === f2 ? e = f2 = b : f2 = f2.next = b;
        } else
          e = f2 = b;
        c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
        a2.updateQueue = c;
        return;
      }
      a2 = c.lastBaseUpdate;
      null === a2 ? c.firstBaseUpdate = b : a2.next = b;
      c.lastBaseUpdate = b;
    }
    function Cg(a2, b, c, d) {
      var e = a2.updateQueue;
      wg = false;
      var f2 = e.firstBaseUpdate, g2 = e.lastBaseUpdate, h2 = e.shared.pending;
      if (null !== h2) {
        e.shared.pending = null;
        var k = h2, l2 = k.next;
        k.next = null;
        null === g2 ? f2 = l2 : g2.next = l2;
        g2 = k;
        var n2 = a2.alternate;
        if (null !== n2) {
          n2 = n2.updateQueue;
          var A2 = n2.lastBaseUpdate;
          A2 !== g2 && (null === A2 ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k);
        }
      }
      if (null !== f2) {
        A2 = e.baseState;
        g2 = 0;
        n2 = l2 = k = null;
        do {
          h2 = f2.lane;
          var p2 = f2.eventTime;
          if ((d & h2) === h2) {
            null !== n2 && (n2 = n2.next = {
              eventTime: p2,
              lane: 0,
              tag: f2.tag,
              payload: f2.payload,
              callback: f2.callback,
              next: null
            });
            a: {
              var C2 = a2, x2 = f2;
              h2 = b;
              p2 = c;
              switch (x2.tag) {
                case 1:
                  C2 = x2.payload;
                  if ("function" === typeof C2) {
                    A2 = C2.call(p2, A2, h2);
                    break a;
                  }
                  A2 = C2;
                  break a;
                case 3:
                  C2.flags = C2.flags & -4097 | 64;
                case 0:
                  C2 = x2.payload;
                  h2 = "function" === typeof C2 ? C2.call(p2, A2, h2) : C2;
                  if (null === h2 || void 0 === h2)
                    break a;
                  A2 = m({}, A2, h2);
                  break a;
                case 2:
                  wg = true;
              }
            }
            null !== f2.callback && (a2.flags |= 32, h2 = e.effects, null === h2 ? e.effects = [f2] : h2.push(f2));
          } else
            p2 = { eventTime: p2, lane: h2, tag: f2.tag, payload: f2.payload, callback: f2.callback, next: null }, null === n2 ? (l2 = n2 = p2, k = A2) : n2 = n2.next = p2, g2 |= h2;
          f2 = f2.next;
          if (null === f2)
            if (h2 = e.shared.pending, null === h2)
              break;
            else
              f2 = h2.next, h2.next = null, e.lastBaseUpdate = h2, e.shared.pending = null;
        } while (1);
        null === n2 && (k = A2);
        e.baseState = k;
        e.firstBaseUpdate = l2;
        e.lastBaseUpdate = n2;
        Dg |= g2;
        a2.lanes = g2;
        a2.memoizedState = A2;
      }
    }
    function Eg(a2, b, c) {
      a2 = b.effects;
      b.effects = null;
      if (null !== a2)
        for (b = 0; b < a2.length; b++) {
          var d = a2[b], e = d.callback;
          if (null !== e) {
            d.callback = null;
            d = c;
            if ("function" !== typeof e)
              throw Error(y(191, e));
            e.call(d);
          }
        }
    }
    var Fg = new aa.Component().refs;
    function Gg(a2, b, c, d) {
      b = a2.memoizedState;
      c = c(d, b);
      c = null === c || void 0 === c ? b : m({}, b, c);
      a2.memoizedState = c;
      0 === a2.lanes && (a2.updateQueue.baseState = c);
    }
    var Kg = { isMounted: function(a2) {
      return (a2 = a2._reactInternals) ? Zb(a2) === a2 : false;
    }, enqueueSetState: function(a2, b, c) {
      a2 = a2._reactInternals;
      var d = Hg(), e = Ig(a2), f2 = zg(d, e);
      f2.payload = b;
      void 0 !== c && null !== c && (f2.callback = c);
      Ag(a2, f2);
      Jg(a2, e, d);
    }, enqueueReplaceState: function(a2, b, c) {
      a2 = a2._reactInternals;
      var d = Hg(), e = Ig(a2), f2 = zg(d, e);
      f2.tag = 1;
      f2.payload = b;
      void 0 !== c && null !== c && (f2.callback = c);
      Ag(a2, f2);
      Jg(a2, e, d);
    }, enqueueForceUpdate: function(a2, b) {
      a2 = a2._reactInternals;
      var c = Hg(), d = Ig(a2), e = zg(c, d);
      e.tag = 2;
      void 0 !== b && null !== b && (e.callback = b);
      Ag(a2, e);
      Jg(a2, d, c);
    } };
    function Lg(a2, b, c, d, e, f2, g2) {
      a2 = a2.stateNode;
      return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d, f2, g2) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f2) : true;
    }
    function Mg(a2, b, c) {
      var d = false, e = Cf;
      var f2 = b.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = vg(f2) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Ef(a2, e) : Cf);
      b = new b(c, f2);
      a2.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = Kg;
      a2.stateNode = b;
      b._reactInternals = a2;
      d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e, a2.__reactInternalMemoizedMaskedChildContext = f2);
      return b;
    }
    function Ng(a2, b, c, d) {
      a2 = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
      b.state !== a2 && Kg.enqueueReplaceState(b, b.state, null);
    }
    function Og(a2, b, c, d) {
      var e = a2.stateNode;
      e.props = c;
      e.state = a2.memoizedState;
      e.refs = Fg;
      xg(a2);
      var f2 = b.contextType;
      "object" === typeof f2 && null !== f2 ? e.context = vg(f2) : (f2 = Ff(b) ? Df : M.current, e.context = Ef(a2, f2));
      Cg(a2, c, e, d);
      e.state = a2.memoizedState;
      f2 = b.getDerivedStateFromProps;
      "function" === typeof f2 && (Gg(a2, b, f2, c), e.state = a2.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a2, c, e, d), e.state = a2.memoizedState);
      "function" === typeof e.componentDidMount && (a2.flags |= 4);
    }
    var Pg = Array.isArray;
    function Qg(a2, b, c) {
      a2 = c.ref;
      if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
        if (c._owner) {
          c = c._owner;
          if (c) {
            if (1 !== c.tag)
              throw Error(y(309));
            var d = c.stateNode;
          }
          if (!d)
            throw Error(y(147, a2));
          var e = "" + a2;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e)
            return b.ref;
          b = function(a3) {
            var b2 = d.refs;
            b2 === Fg && (b2 = d.refs = {});
            null === a3 ? delete b2[e] : b2[e] = a3;
          };
          b._stringRef = e;
          return b;
        }
        if ("string" !== typeof a2)
          throw Error(y(284));
        if (!c._owner)
          throw Error(y(290, a2));
      }
      return a2;
    }
    function Rg(a2, b) {
      if ("textarea" !== a2.type)
        throw Error(y(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
    }
    function Sg(a2) {
      function b(b2, c2) {
        if (a2) {
          var d2 = b2.lastEffect;
          null !== d2 ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
          c2.nextEffect = null;
          c2.flags = 8;
        }
      }
      function c(c2, d2) {
        if (!a2)
          return null;
        for (; null !== d2; )
          b(c2, d2), d2 = d2.sibling;
        return null;
      }
      function d(a3, b2) {
        for (a3 = /* @__PURE__ */ new Map(); null !== b2; )
          null !== b2.key ? a3.set(b2.key, b2) : a3.set(b2.index, b2), b2 = b2.sibling;
        return a3;
      }
      function e(a3, b2) {
        a3 = Tg(a3, b2);
        a3.index = 0;
        a3.sibling = null;
        return a3;
      }
      function f2(b2, c2, d2) {
        b2.index = d2;
        if (!a2)
          return c2;
        d2 = b2.alternate;
        if (null !== d2)
          return d2 = d2.index, d2 < c2 ? (b2.flags = 2, c2) : d2;
        b2.flags = 2;
        return c2;
      }
      function g2(b2) {
        a2 && null === b2.alternate && (b2.flags = 2);
        return b2;
      }
      function h2(a3, b2, c2, d2) {
        if (null === b2 || 6 !== b2.tag)
          return b2 = Ug(c2, a3.mode, d2), b2.return = a3, b2;
        b2 = e(b2, c2);
        b2.return = a3;
        return b2;
      }
      function k(a3, b2, c2, d2) {
        if (null !== b2 && b2.elementType === c2.type)
          return d2 = e(b2, c2.props), d2.ref = Qg(a3, b2, c2), d2.return = a3, d2;
        d2 = Vg(c2.type, c2.key, c2.props, null, a3.mode, d2);
        d2.ref = Qg(a3, b2, c2);
        d2.return = a3;
        return d2;
      }
      function l2(a3, b2, c2, d2) {
        if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
          return b2 = Wg(c2, a3.mode, d2), b2.return = a3, b2;
        b2 = e(b2, c2.children || []);
        b2.return = a3;
        return b2;
      }
      function n2(a3, b2, c2, d2, f3) {
        if (null === b2 || 7 !== b2.tag)
          return b2 = Xg(c2, a3.mode, d2, f3), b2.return = a3, b2;
        b2 = e(b2, c2);
        b2.return = a3;
        return b2;
      }
      function A2(a3, b2, c2) {
        if ("string" === typeof b2 || "number" === typeof b2)
          return b2 = Ug("" + b2, a3.mode, c2), b2.return = a3, b2;
        if ("object" === typeof b2 && null !== b2) {
          switch (b2.$$typeof) {
            case sa:
              return c2 = Vg(b2.type, b2.key, b2.props, null, a3.mode, c2), c2.ref = Qg(a3, null, b2), c2.return = a3, c2;
            case ta:
              return b2 = Wg(b2, a3.mode, c2), b2.return = a3, b2;
          }
          if (Pg(b2) || La(b2))
            return b2 = Xg(
              b2,
              a3.mode,
              c2,
              null
            ), b2.return = a3, b2;
          Rg(a3, b2);
        }
        return null;
      }
      function p2(a3, b2, c2, d2) {
        var e2 = null !== b2 ? b2.key : null;
        if ("string" === typeof c2 || "number" === typeof c2)
          return null !== e2 ? null : h2(a3, b2, "" + c2, d2);
        if ("object" === typeof c2 && null !== c2) {
          switch (c2.$$typeof) {
            case sa:
              return c2.key === e2 ? c2.type === ua ? n2(a3, b2, c2.props.children, d2, e2) : k(a3, b2, c2, d2) : null;
            case ta:
              return c2.key === e2 ? l2(a3, b2, c2, d2) : null;
          }
          if (Pg(c2) || La(c2))
            return null !== e2 ? null : n2(a3, b2, c2, d2, null);
          Rg(a3, c2);
        }
        return null;
      }
      function C2(a3, b2, c2, d2, e2) {
        if ("string" === typeof d2 || "number" === typeof d2)
          return a3 = a3.get(c2) || null, h2(b2, a3, "" + d2, e2);
        if ("object" === typeof d2 && null !== d2) {
          switch (d2.$$typeof) {
            case sa:
              return a3 = a3.get(null === d2.key ? c2 : d2.key) || null, d2.type === ua ? n2(b2, a3, d2.props.children, e2, d2.key) : k(b2, a3, d2, e2);
            case ta:
              return a3 = a3.get(null === d2.key ? c2 : d2.key) || null, l2(b2, a3, d2, e2);
          }
          if (Pg(d2) || La(d2))
            return a3 = a3.get(c2) || null, n2(b2, a3, d2, e2, null);
          Rg(b2, d2);
        }
        return null;
      }
      function x2(e2, g3, h3, k2) {
        for (var l3 = null, t2 = null, u2 = g3, z2 = g3 = 0, q2 = null; null !== u2 && z2 < h3.length; z2++) {
          u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
          var n3 = p2(e2, u2, h3[z2], k2);
          if (null === n3) {
            null === u2 && (u2 = q2);
            break;
          }
          a2 && u2 && null === n3.alternate && b(e2, u2);
          g3 = f2(n3, g3, z2);
          null === t2 ? l3 = n3 : t2.sibling = n3;
          t2 = n3;
          u2 = q2;
        }
        if (z2 === h3.length)
          return c(e2, u2), l3;
        if (null === u2) {
          for (; z2 < h3.length; z2++)
            u2 = A2(e2, h3[z2], k2), null !== u2 && (g3 = f2(u2, g3, z2), null === t2 ? l3 = u2 : t2.sibling = u2, t2 = u2);
          return l3;
        }
        for (u2 = d(e2, u2); z2 < h3.length; z2++)
          q2 = C2(u2, e2, z2, h3[z2], k2), null !== q2 && (a2 && null !== q2.alternate && u2.delete(null === q2.key ? z2 : q2.key), g3 = f2(q2, g3, z2), null === t2 ? l3 = q2 : t2.sibling = q2, t2 = q2);
        a2 && u2.forEach(function(a3) {
          return b(e2, a3);
        });
        return l3;
      }
      function w2(e2, g3, h3, k2) {
        var l3 = La(h3);
        if ("function" !== typeof l3)
          throw Error(y(150));
        h3 = l3.call(h3);
        if (null == h3)
          throw Error(y(151));
        for (var t2 = l3 = null, u2 = g3, z2 = g3 = 0, q2 = null, n3 = h3.next(); null !== u2 && !n3.done; z2++, n3 = h3.next()) {
          u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
          var w3 = p2(e2, u2, n3.value, k2);
          if (null === w3) {
            null === u2 && (u2 = q2);
            break;
          }
          a2 && u2 && null === w3.alternate && b(e2, u2);
          g3 = f2(w3, g3, z2);
          null === t2 ? l3 = w3 : t2.sibling = w3;
          t2 = w3;
          u2 = q2;
        }
        if (n3.done)
          return c(e2, u2), l3;
        if (null === u2) {
          for (; !n3.done; z2++, n3 = h3.next())
            n3 = A2(e2, n3.value, k2), null !== n3 && (g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
          return l3;
        }
        for (u2 = d(e2, u2); !n3.done; z2++, n3 = h3.next())
          n3 = C2(u2, e2, z2, n3.value, k2), null !== n3 && (a2 && null !== n3.alternate && u2.delete(null === n3.key ? z2 : n3.key), g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
        a2 && u2.forEach(function(a3) {
          return b(e2, a3);
        });
        return l3;
      }
      return function(a3, d2, f3, h3) {
        var k2 = "object" === typeof f3 && null !== f3 && f3.type === ua && null === f3.key;
        k2 && (f3 = f3.props.children);
        var l3 = "object" === typeof f3 && null !== f3;
        if (l3)
          switch (f3.$$typeof) {
            case sa:
              a: {
                l3 = f3.key;
                for (k2 = d2; null !== k2; ) {
                  if (k2.key === l3) {
                    switch (k2.tag) {
                      case 7:
                        if (f3.type === ua) {
                          c(a3, k2.sibling);
                          d2 = e(k2, f3.props.children);
                          d2.return = a3;
                          a3 = d2;
                          break a;
                        }
                        break;
                      default:
                        if (k2.elementType === f3.type) {
                          c(a3, k2.sibling);
                          d2 = e(k2, f3.props);
                          d2.ref = Qg(a3, k2, f3);
                          d2.return = a3;
                          a3 = d2;
                          break a;
                        }
                    }
                    c(a3, k2);
                    break;
                  } else
                    b(a3, k2);
                  k2 = k2.sibling;
                }
                f3.type === ua ? (d2 = Xg(f3.props.children, a3.mode, h3, f3.key), d2.return = a3, a3 = d2) : (h3 = Vg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Qg(a3, d2, f3), h3.return = a3, a3 = h3);
              }
              return g2(a3);
            case ta:
              a: {
                for (k2 = f3.key; null !== d2; ) {
                  if (d2.key === k2)
                    if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                      c(a3, d2.sibling);
                      d2 = e(d2, f3.children || []);
                      d2.return = a3;
                      a3 = d2;
                      break a;
                    } else {
                      c(a3, d2);
                      break;
                    }
                  else
                    b(a3, d2);
                  d2 = d2.sibling;
                }
                d2 = Wg(f3, a3.mode, h3);
                d2.return = a3;
                a3 = d2;
              }
              return g2(a3);
          }
        if ("string" === typeof f3 || "number" === typeof f3)
          return f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c(a3, d2.sibling), d2 = e(d2, f3), d2.return = a3, a3 = d2) : (c(a3, d2), d2 = Ug(f3, a3.mode, h3), d2.return = a3, a3 = d2), g2(a3);
        if (Pg(f3))
          return x2(a3, d2, f3, h3);
        if (La(f3))
          return w2(a3, d2, f3, h3);
        l3 && Rg(a3, f3);
        if ("undefined" === typeof f3 && !k2)
          switch (a3.tag) {
            case 1:
            case 22:
            case 0:
            case 11:
            case 15:
              throw Error(y(152, Ra(a3.type) || "Component"));
          }
        return c(a3, d2);
      };
    }
    var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch = Bf($g);
    function dh(a2) {
      if (a2 === $g)
        throw Error(y(174));
      return a2;
    }
    function eh(a2, b) {
      I(ch, b);
      I(bh, a2);
      I(ah, $g);
      a2 = b.nodeType;
      switch (a2) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
          break;
        default:
          a2 = 8 === a2 ? b.parentNode : b, b = a2.namespaceURI || null, a2 = a2.tagName, b = mb(b, a2);
      }
      H(ah);
      I(ah, b);
    }
    function fh() {
      H(ah);
      H(bh);
      H(ch);
    }
    function gh(a2) {
      dh(ch.current);
      var b = dh(ah.current);
      var c = mb(b, a2.type);
      b !== c && (I(bh, a2), I(ah, c));
    }
    function hh(a2) {
      bh.current === a2 && (H(ah), H(bh));
    }
    var P = Bf(0);
    function ih(a2) {
      for (var b = a2; null !== b; ) {
        if (13 === b.tag) {
          var c = b.memoizedState;
          if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data))
            return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.flags & 64))
            return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a2)
          break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a2)
            return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    var jh = null, kh = null, lh = false;
    function mh(a2, b) {
      var c = nh(5, null, null, 0);
      c.elementType = "DELETED";
      c.type = "DELETED";
      c.stateNode = b;
      c.return = a2;
      c.flags = 8;
      null !== a2.lastEffect ? (a2.lastEffect.nextEffect = c, a2.lastEffect = c) : a2.firstEffect = a2.lastEffect = c;
    }
    function oh(a2, b) {
      switch (a2.tag) {
        case 5:
          var c = a2.type;
          b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
          return null !== b ? (a2.stateNode = b, true) : false;
        case 6:
          return b = "" === a2.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a2.stateNode = b, true) : false;
        case 13:
          return false;
        default:
          return false;
      }
    }
    function ph(a2) {
      if (lh) {
        var b = kh;
        if (b) {
          var c = b;
          if (!oh(a2, b)) {
            b = rf(c.nextSibling);
            if (!b || !oh(a2, b)) {
              a2.flags = a2.flags & -1025 | 2;
              lh = false;
              jh = a2;
              return;
            }
            mh(jh, c);
          }
          jh = a2;
          kh = rf(b.firstChild);
        } else
          a2.flags = a2.flags & -1025 | 2, lh = false, jh = a2;
      }
    }
    function qh(a2) {
      for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
        a2 = a2.return;
      jh = a2;
    }
    function rh(a2) {
      if (a2 !== jh)
        return false;
      if (!lh)
        return qh(a2), lh = true, false;
      var b = a2.type;
      if (5 !== a2.tag || "head" !== b && "body" !== b && !nf(b, a2.memoizedProps))
        for (b = kh; b; )
          mh(a2, b), b = rf(b.nextSibling);
      qh(a2);
      if (13 === a2.tag) {
        a2 = a2.memoizedState;
        a2 = null !== a2 ? a2.dehydrated : null;
        if (!a2)
          throw Error(y(317));
        a: {
          a2 = a2.nextSibling;
          for (b = 0; a2; ) {
            if (8 === a2.nodeType) {
              var c = a2.data;
              if ("/$" === c) {
                if (0 === b) {
                  kh = rf(a2.nextSibling);
                  break a;
                }
                b--;
              } else
                "$" !== c && "$!" !== c && "$?" !== c || b++;
            }
            a2 = a2.nextSibling;
          }
          kh = null;
        }
      } else
        kh = jh ? rf(a2.stateNode.nextSibling) : null;
      return true;
    }
    function sh() {
      kh = jh = null;
      lh = false;
    }
    var th = [];
    function uh() {
      for (var a2 = 0; a2 < th.length; a2++)
        th[a2]._workInProgressVersionPrimary = null;
      th.length = 0;
    }
    var vh = ra.ReactCurrentDispatcher, wh = ra.ReactCurrentBatchConfig, xh = 0, R = null, S = null, T = null, yh = false, zh = false;
    function Ah() {
      throw Error(y(321));
    }
    function Bh(a2, b) {
      if (null === b)
        return false;
      for (var c = 0; c < b.length && c < a2.length; c++)
        if (!He(a2[c], b[c]))
          return false;
      return true;
    }
    function Ch(a2, b, c, d, e, f2) {
      xh = f2;
      R = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      vh.current = null === a2 || null === a2.memoizedState ? Dh : Eh;
      a2 = c(d, e);
      if (zh) {
        f2 = 0;
        do {
          zh = false;
          if (!(25 > f2))
            throw Error(y(301));
          f2 += 1;
          T = S = null;
          b.updateQueue = null;
          vh.current = Fh;
          a2 = c(d, e);
        } while (zh);
      }
      vh.current = Gh;
      b = null !== S && null !== S.next;
      xh = 0;
      T = S = R = null;
      yh = false;
      if (b)
        throw Error(y(300));
      return a2;
    }
    function Hh() {
      var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === T ? R.memoizedState = T = a2 : T = T.next = a2;
      return T;
    }
    function Ih() {
      if (null === S) {
        var a2 = R.alternate;
        a2 = null !== a2 ? a2.memoizedState : null;
      } else
        a2 = S.next;
      var b = null === T ? R.memoizedState : T.next;
      if (null !== b)
        T = b, S = a2;
      else {
        if (null === a2)
          throw Error(y(310));
        S = a2;
        a2 = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };
        null === T ? R.memoizedState = T = a2 : T = T.next = a2;
      }
      return T;
    }
    function Jh(a2, b) {
      return "function" === typeof b ? b(a2) : b;
    }
    function Kh(a2) {
      var b = Ih(), c = b.queue;
      if (null === c)
        throw Error(y(311));
      c.lastRenderedReducer = a2;
      var d = S, e = d.baseQueue, f2 = c.pending;
      if (null !== f2) {
        if (null !== e) {
          var g2 = e.next;
          e.next = f2.next;
          f2.next = g2;
        }
        d.baseQueue = e = f2;
        c.pending = null;
      }
      if (null !== e) {
        e = e.next;
        d = d.baseState;
        var h2 = g2 = f2 = null, k = e;
        do {
          var l2 = k.lane;
          if ((xh & l2) === l2)
            null !== h2 && (h2 = h2.next = { lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), d = k.eagerReducer === a2 ? k.eagerState : a2(d, k.action);
          else {
            var n2 = {
              lane: l2,
              action: k.action,
              eagerReducer: k.eagerReducer,
              eagerState: k.eagerState,
              next: null
            };
            null === h2 ? (g2 = h2 = n2, f2 = d) : h2 = h2.next = n2;
            R.lanes |= l2;
            Dg |= l2;
          }
          k = k.next;
        } while (null !== k && k !== e);
        null === h2 ? f2 = d : h2.next = g2;
        He(d, b.memoizedState) || (ug = true);
        b.memoizedState = d;
        b.baseState = f2;
        b.baseQueue = h2;
        c.lastRenderedState = d;
      }
      return [b.memoizedState, c.dispatch];
    }
    function Lh(a2) {
      var b = Ih(), c = b.queue;
      if (null === c)
        throw Error(y(311));
      c.lastRenderedReducer = a2;
      var d = c.dispatch, e = c.pending, f2 = b.memoizedState;
      if (null !== e) {
        c.pending = null;
        var g2 = e = e.next;
        do
          f2 = a2(f2, g2.action), g2 = g2.next;
        while (g2 !== e);
        He(f2, b.memoizedState) || (ug = true);
        b.memoizedState = f2;
        null === b.baseQueue && (b.baseState = f2);
        c.lastRenderedState = f2;
      }
      return [f2, d];
    }
    function Mh(a2, b, c) {
      var d = b._getVersion;
      d = d(b._source);
      var e = b._workInProgressVersionPrimary;
      if (null !== e)
        a2 = e === d;
      else if (a2 = a2.mutableReadLanes, a2 = (xh & a2) === a2)
        b._workInProgressVersionPrimary = d, th.push(b);
      if (a2)
        return c(b._source);
      th.push(b);
      throw Error(y(350));
    }
    function Nh(a2, b, c, d) {
      var e = U;
      if (null === e)
        throw Error(y(349));
      var f2 = b._getVersion, g2 = f2(b._source), h2 = vh.current, k = h2.useState(function() {
        return Mh(e, b, c);
      }), l2 = k[1], n2 = k[0];
      k = T;
      var A2 = a2.memoizedState, p2 = A2.refs, C2 = p2.getSnapshot, x2 = A2.source;
      A2 = A2.subscribe;
      var w2 = R;
      a2.memoizedState = { refs: p2, source: b, subscribe: d };
      h2.useEffect(function() {
        p2.getSnapshot = c;
        p2.setSnapshot = l2;
        var a3 = f2(b._source);
        if (!He(g2, a3)) {
          a3 = c(b._source);
          He(n2, a3) || (l2(a3), a3 = Ig(w2), e.mutableReadLanes |= a3 & e.pendingLanes);
          a3 = e.mutableReadLanes;
          e.entangledLanes |= a3;
          for (var d2 = e.entanglements, h3 = a3; 0 < h3; ) {
            var k2 = 31 - Vc(h3), v2 = 1 << k2;
            d2[k2] |= a3;
            h3 &= ~v2;
          }
        }
      }, [c, b, d]);
      h2.useEffect(function() {
        return d(b._source, function() {
          var a3 = p2.getSnapshot, c2 = p2.setSnapshot;
          try {
            c2(a3(b._source));
            var d2 = Ig(w2);
            e.mutableReadLanes |= d2 & e.pendingLanes;
          } catch (q2) {
            c2(function() {
              throw q2;
            });
          }
        });
      }, [b, d]);
      He(C2, c) && He(x2, b) && He(A2, d) || (a2 = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a2.dispatch = l2 = Oh.bind(null, R, a2), k.queue = a2, k.baseQueue = null, n2 = Mh(e, b, c), k.memoizedState = k.baseState = n2);
      return n2;
    }
    function Ph(a2, b, c) {
      var d = Ih();
      return Nh(d, a2, b, c);
    }
    function Qh(a2) {
      var b = Hh();
      "function" === typeof a2 && (a2 = a2());
      b.memoizedState = b.baseState = a2;
      a2 = b.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a2 };
      a2 = a2.dispatch = Oh.bind(null, R, a2);
      return [b.memoizedState, a2];
    }
    function Rh(a2, b, c, d) {
      a2 = { tag: a2, create: b, destroy: c, deps: d, next: null };
      b = R.updateQueue;
      null === b ? (b = { lastEffect: null }, R.updateQueue = b, b.lastEffect = a2.next = a2) : (c = b.lastEffect, null === c ? b.lastEffect = a2.next = a2 : (d = c.next, c.next = a2, a2.next = d, b.lastEffect = a2));
      return a2;
    }
    function Sh(a2) {
      var b = Hh();
      a2 = { current: a2 };
      return b.memoizedState = a2;
    }
    function Th() {
      return Ih().memoizedState;
    }
    function Uh(a2, b, c, d) {
      var e = Hh();
      R.flags |= a2;
      e.memoizedState = Rh(1 | b, c, void 0, void 0 === d ? null : d);
    }
    function Vh(a2, b, c, d) {
      var e = Ih();
      d = void 0 === d ? null : d;
      var f2 = void 0;
      if (null !== S) {
        var g2 = S.memoizedState;
        f2 = g2.destroy;
        if (null !== d && Bh(d, g2.deps)) {
          Rh(b, c, f2, d);
          return;
        }
      }
      R.flags |= a2;
      e.memoizedState = Rh(1 | b, c, f2, d);
    }
    function Wh(a2, b) {
      return Uh(516, 4, a2, b);
    }
    function Xh(a2, b) {
      return Vh(516, 4, a2, b);
    }
    function Yh(a2, b) {
      return Vh(4, 2, a2, b);
    }
    function Zh(a2, b) {
      if ("function" === typeof b)
        return a2 = a2(), b(a2), function() {
          b(null);
        };
      if (null !== b && void 0 !== b)
        return a2 = a2(), b.current = a2, function() {
          b.current = null;
        };
    }
    function $h(a2, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a2]) : null;
      return Vh(4, 2, Zh.bind(null, b, a2), c);
    }
    function ai() {
    }
    function bi(a2, b) {
      var c = Ih();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Bh(b, d[1]))
        return d[0];
      c.memoizedState = [a2, b];
      return a2;
    }
    function ci(a2, b) {
      var c = Ih();
      b = void 0 === b ? null : b;
      var d = c.memoizedState;
      if (null !== d && null !== b && Bh(b, d[1]))
        return d[0];
      a2 = a2();
      c.memoizedState = [a2, b];
      return a2;
    }
    function di(a2, b) {
      var c = eg();
      gg(98 > c ? 98 : c, function() {
        a2(true);
      });
      gg(97 < c ? 97 : c, function() {
        var c2 = wh.transition;
        wh.transition = 1;
        try {
          a2(false), b();
        } finally {
          wh.transition = c2;
        }
      });
    }
    function Oh(a2, b, c) {
      var d = Hg(), e = Ig(a2), f2 = { lane: e, action: c, eagerReducer: null, eagerState: null, next: null }, g2 = b.pending;
      null === g2 ? f2.next = f2 : (f2.next = g2.next, g2.next = f2);
      b.pending = f2;
      g2 = a2.alternate;
      if (a2 === R || null !== g2 && g2 === R)
        zh = yh = true;
      else {
        if (0 === a2.lanes && (null === g2 || 0 === g2.lanes) && (g2 = b.lastRenderedReducer, null !== g2))
          try {
            var h2 = b.lastRenderedState, k = g2(h2, c);
            f2.eagerReducer = g2;
            f2.eagerState = k;
            if (He(k, h2))
              return;
          } catch (l2) {
          } finally {
          }
        Jg(a2, e, d);
      }
    }
    var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a2, b) {
      Hh().memoizedState = [a2, void 0 === b ? null : b];
      return a2;
    }, useContext: vg, useEffect: Wh, useImperativeHandle: function(a2, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a2]) : null;
      return Uh(4, 2, Zh.bind(
        null,
        b,
        a2
      ), c);
    }, useLayoutEffect: function(a2, b) {
      return Uh(4, 2, a2, b);
    }, useMemo: function(a2, b) {
      var c = Hh();
      b = void 0 === b ? null : b;
      a2 = a2();
      c.memoizedState = [a2, b];
      return a2;
    }, useReducer: function(a2, b, c) {
      var d = Hh();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a2 = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b };
      a2 = a2.dispatch = Oh.bind(null, R, a2);
      return [d.memoizedState, a2];
    }, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a2) {
      var b = Qh(a2), c = b[0], d = b[1];
      Wh(function() {
        var b2 = wh.transition;
        wh.transition = 1;
        try {
          d(a2);
        } finally {
          wh.transition = b2;
        }
      }, [a2]);
      return c;
    }, useTransition: function() {
      var a2 = Qh(false), b = a2[0];
      a2 = di.bind(null, a2[1]);
      Sh(a2);
      return [a2, b];
    }, useMutableSource: function(a2, b, c) {
      var d = Hh();
      d.memoizedState = { refs: { getSnapshot: b, setSnapshot: null }, source: a2, subscribe: c };
      return Nh(d, a2, b, c);
    }, useOpaqueIdentifier: function() {
      if (lh) {
        var a2 = false, b = uf(function() {
          a2 || (a2 = true, c("r:" + (tf++).toString(36)));
          throw Error(y(355));
        }), c = Qh(b)[1];
        0 === (R.mode & 2) && (R.flags |= 516, Rh(
          5,
          function() {
            c("r:" + (tf++).toString(36));
          },
          void 0,
          null
        ));
        return b;
      }
      b = "r:" + (tf++).toString(36);
      Qh(b);
      return b;
    }, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
      return Kh(Jh);
    }, useDebugValue: ai, useDeferredValue: function(a2) {
      var b = Kh(Jh), c = b[0], d = b[1];
      Xh(function() {
        var b2 = wh.transition;
        wh.transition = 1;
        try {
          d(a2);
        } finally {
          wh.transition = b2;
        }
      }, [a2]);
      return c;
    }, useTransition: function() {
      var a2 = Kh(Jh)[0];
      return [
        Th().current,
        a2
      ];
    }, useMutableSource: Ph, useOpaqueIdentifier: function() {
      return Kh(Jh)[0];
    }, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
      return Lh(Jh);
    }, useDebugValue: ai, useDeferredValue: function(a2) {
      var b = Lh(Jh), c = b[0], d = b[1];
      Xh(function() {
        var b2 = wh.transition;
        wh.transition = 1;
        try {
          d(a2);
        } finally {
          wh.transition = b2;
        }
      }, [a2]);
      return c;
    }, useTransition: function() {
      var a2 = Lh(Jh)[0];
      return [
        Th().current,
        a2
      ];
    }, useMutableSource: Ph, useOpaqueIdentifier: function() {
      return Lh(Jh)[0];
    }, unstable_isNewReconciler: false }, ei = ra.ReactCurrentOwner, ug = false;
    function fi(a2, b, c, d) {
      b.child = null === a2 ? Zg(b, null, c, d) : Yg(b, a2.child, c, d);
    }
    function gi(a2, b, c, d, e) {
      c = c.render;
      var f2 = b.ref;
      tg(b, e);
      d = Ch(a2, b, c, d, f2, e);
      if (null !== a2 && !ug)
        return b.updateQueue = a2.updateQueue, b.flags &= -517, a2.lanes &= ~e, hi(a2, b, e);
      b.flags |= 1;
      fi(a2, b, d, e);
      return b.child;
    }
    function ii(a2, b, c, d, e, f2) {
      if (null === a2) {
        var g2 = c.type;
        if ("function" === typeof g2 && !ji(g2) && void 0 === g2.defaultProps && null === c.compare && void 0 === c.defaultProps)
          return b.tag = 15, b.type = g2, ki(a2, b, g2, d, e, f2);
        a2 = Vg(c.type, null, d, b, b.mode, f2);
        a2.ref = b.ref;
        a2.return = b;
        return b.child = a2;
      }
      g2 = a2.child;
      if (0 === (e & f2) && (e = g2.memoizedProps, c = c.compare, c = null !== c ? c : Je, c(e, d) && a2.ref === b.ref))
        return hi(a2, b, f2);
      b.flags |= 1;
      a2 = Tg(g2, d);
      a2.ref = b.ref;
      a2.return = b;
      return b.child = a2;
    }
    function ki(a2, b, c, d, e, f2) {
      if (null !== a2 && Je(a2.memoizedProps, d) && a2.ref === b.ref)
        if (ug = false, 0 !== (f2 & e))
          0 !== (a2.flags & 16384) && (ug = true);
        else
          return b.lanes = a2.lanes, hi(a2, b, f2);
      return li(a2, b, c, d, f2);
    }
    function mi(a2, b, c) {
      var d = b.pendingProps, e = d.children, f2 = null !== a2 ? a2.memoizedState : null;
      if ("hidden" === d.mode || "unstable-defer-without-hiding" === d.mode)
        if (0 === (b.mode & 4))
          b.memoizedState = { baseLanes: 0 }, ni(b, c);
        else if (0 !== (c & 1073741824))
          b.memoizedState = { baseLanes: 0 }, ni(b, null !== f2 ? f2.baseLanes : c);
        else
          return a2 = null !== f2 ? f2.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a2 }, ni(b, a2), null;
      else
        null !== f2 ? (d = f2.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
      fi(a2, b, e, c);
      return b.child;
    }
    function oi(a2, b) {
      var c = b.ref;
      if (null === a2 && null !== c || null !== a2 && a2.ref !== c)
        b.flags |= 128;
    }
    function li(a2, b, c, d, e) {
      var f2 = Ff(c) ? Df : M.current;
      f2 = Ef(b, f2);
      tg(b, e);
      c = Ch(a2, b, c, d, f2, e);
      if (null !== a2 && !ug)
        return b.updateQueue = a2.updateQueue, b.flags &= -517, a2.lanes &= ~e, hi(a2, b, e);
      b.flags |= 1;
      fi(a2, b, c, e);
      return b.child;
    }
    function pi(a2, b, c, d, e) {
      if (Ff(c)) {
        var f2 = true;
        Jf(b);
      } else
        f2 = false;
      tg(b, e);
      if (null === b.stateNode)
        null !== a2 && (a2.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = true;
      else if (null === a2) {
        var g2 = b.stateNode, h2 = b.memoizedProps;
        g2.props = h2;
        var k = g2.context, l2 = c.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = vg(l2) : (l2 = Ff(c) ? Df : M.current, l2 = Ef(b, l2));
        var n2 = c.getDerivedStateFromProps, A2 = "function" === typeof n2 || "function" === typeof g2.getSnapshotBeforeUpdate;
        A2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d || k !== l2) && Ng(b, g2, d, l2);
        wg = false;
        var p2 = b.memoizedState;
        g2.state = p2;
        Cg(b, d, g2, e);
        k = b.memoizedState;
        h2 !== d || p2 !== k || N.current || wg ? ("function" === typeof n2 && (Gg(b, c, n2, d), k = b.memoizedState), (h2 = wg || Lg(b, c, h2, d, p2, k, l2)) ? (A2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b.flags |= 4)) : ("function" === typeof g2.componentDidMount && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g2.props = d, g2.state = k, g2.context = l2, d = h2) : ("function" === typeof g2.componentDidMount && (b.flags |= 4), d = false);
      } else {
        g2 = b.stateNode;
        yg(a2, b);
        h2 = b.memoizedProps;
        l2 = b.type === b.elementType ? h2 : lg(b.type, h2);
        g2.props = l2;
        A2 = b.pendingProps;
        p2 = g2.context;
        k = c.contextType;
        "object" === typeof k && null !== k ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
        var C2 = c.getDerivedStateFromProps;
        (n2 = "function" === typeof C2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== A2 || p2 !== k) && Ng(b, g2, d, k);
        wg = false;
        p2 = b.memoizedState;
        g2.state = p2;
        Cg(b, d, g2, e);
        var x2 = b.memoizedState;
        h2 !== A2 || p2 !== x2 || N.current || wg ? ("function" === typeof C2 && (Gg(b, c, C2, d), x2 = b.memoizedState), (l2 = wg || Lg(b, c, l2, d, p2, x2, k)) ? (n2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(
          d,
          x2,
          k
        ), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d, x2, k)), "function" === typeof g2.componentDidUpdate && (b.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b.flags |= 256)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x2), g2.props = d, g2.state = x2, g2.context = k, d = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b.flags |= 256), d = false);
      }
      return qi(a2, b, c, d, f2, e);
    }
    function qi(a2, b, c, d, e, f2) {
      oi(a2, b);
      var g2 = 0 !== (b.flags & 64);
      if (!d && !g2)
        return e && Kf(b, c, false), hi(a2, b, f2);
      d = b.stateNode;
      ei.current = b;
      var h2 = g2 && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
      b.flags |= 1;
      null !== a2 && g2 ? (b.child = Yg(b, a2.child, null, f2), b.child = Yg(b, null, h2, f2)) : fi(a2, b, h2, f2);
      b.memoizedState = d.state;
      e && Kf(b, c, true);
      return b.child;
    }
    function ri(a2) {
      var b = a2.stateNode;
      b.pendingContext ? Hf(a2, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a2, b.context, false);
      eh(a2, b.containerInfo);
    }
    var si = { dehydrated: null, retryLane: 0 };
    function ti(a2, b, c) {
      var d = b.pendingProps, e = P.current, f2 = false, g2;
      (g2 = 0 !== (b.flags & 64)) || (g2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e & 2));
      g2 ? (f2 = true, b.flags &= -65) : null !== a2 && null === a2.memoizedState || void 0 === d.fallback || true === d.unstable_avoidThisFallback || (e |= 1);
      I(P, e & 1);
      if (null === a2) {
        void 0 !== d.fallback && ph(b);
        a2 = d.children;
        e = d.fallback;
        if (f2)
          return a2 = ui(b, a2, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, a2;
        if ("number" === typeof d.unstable_expectedLoadTime)
          return a2 = ui(b, a2, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, b.lanes = 33554432, a2;
        c = vi({ mode: "visible", children: a2 }, b.mode, c, null);
        c.return = b;
        return b.child = c;
      }
      if (null !== a2.memoizedState) {
        if (f2)
          return d = wi(a2, b, d.children, d.fallback, c), f2 = b.child, e = a2.child.memoizedState, f2.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f2.childLanes = a2.childLanes & ~c, b.memoizedState = si, d;
        c = xi(a2, b, d.children, c);
        b.memoizedState = null;
        return c;
      }
      if (f2)
        return d = wi(a2, b, d.children, d.fallback, c), f2 = b.child, e = a2.child.memoizedState, f2.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f2.childLanes = a2.childLanes & ~c, b.memoizedState = si, d;
      c = xi(a2, b, d.children, c);
      b.memoizedState = null;
      return c;
    }
    function ui(a2, b, c, d) {
      var e = a2.mode, f2 = a2.child;
      b = { mode: "hidden", children: b };
      0 === (e & 2) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = b) : f2 = vi(b, e, 0, null);
      c = Xg(c, e, d, null);
      f2.return = a2;
      c.return = a2;
      f2.sibling = c;
      a2.child = f2;
      return c;
    }
    function xi(a2, b, c, d) {
      var e = a2.child;
      a2 = e.sibling;
      c = Tg(e, { mode: "visible", children: c });
      0 === (b.mode & 2) && (c.lanes = d);
      c.return = b;
      c.sibling = null;
      null !== a2 && (a2.nextEffect = null, a2.flags = 8, b.firstEffect = b.lastEffect = a2);
      return b.child = c;
    }
    function wi(a2, b, c, d, e) {
      var f2 = b.mode, g2 = a2.child;
      a2 = g2.sibling;
      var h2 = { mode: "hidden", children: c };
      0 === (f2 & 2) && b.child !== g2 ? (c = b.child, c.childLanes = 0, c.pendingProps = h2, g2 = c.lastEffect, null !== g2 ? (b.firstEffect = c.firstEffect, b.lastEffect = g2, g2.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g2, h2);
      null !== a2 ? d = Tg(a2, d) : (d = Xg(d, f2, e, null), d.flags |= 2);
      d.return = b;
      c.return = b;
      c.sibling = d;
      b.child = c;
      return d;
    }
    function yi(a2, b) {
      a2.lanes |= b;
      var c = a2.alternate;
      null !== c && (c.lanes |= b);
      sg(a2.return, b);
    }
    function zi(a2, b, c, d, e, f2) {
      var g2 = a2.memoizedState;
      null === g2 ? a2.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e, lastEffect: f2 } : (g2.isBackwards = b, g2.rendering = null, g2.renderingStartTime = 0, g2.last = d, g2.tail = c, g2.tailMode = e, g2.lastEffect = f2);
    }
    function Ai(a2, b, c) {
      var d = b.pendingProps, e = d.revealOrder, f2 = d.tail;
      fi(a2, b, d.children, c);
      d = P.current;
      if (0 !== (d & 2))
        d = d & 1 | 2, b.flags |= 64;
      else {
        if (null !== a2 && 0 !== (a2.flags & 64))
          a:
            for (a2 = b.child; null !== a2; ) {
              if (13 === a2.tag)
                null !== a2.memoizedState && yi(a2, c);
              else if (19 === a2.tag)
                yi(a2, c);
              else if (null !== a2.child) {
                a2.child.return = a2;
                a2 = a2.child;
                continue;
              }
              if (a2 === b)
                break a;
              for (; null === a2.sibling; ) {
                if (null === a2.return || a2.return === b)
                  break a;
                a2 = a2.return;
              }
              a2.sibling.return = a2.return;
              a2 = a2.sibling;
            }
        d &= 1;
      }
      I(P, d);
      if (0 === (b.mode & 2))
        b.memoizedState = null;
      else
        switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; null !== c; )
              a2 = c.alternate, null !== a2 && null === ih(a2) && (e = c), c = c.sibling;
            c = e;
            null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
            zi(b, false, e, c, f2, b.lastEffect);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a2 = e.alternate;
              if (null !== a2 && null === ih(a2)) {
                b.child = e;
                break;
              }
              a2 = e.sibling;
              e.sibling = c;
              c = e;
              e = a2;
            }
            zi(b, true, c, null, f2, b.lastEffect);
            break;
          case "together":
            zi(b, false, null, null, void 0, b.lastEffect);
            break;
          default:
            b.memoizedState = null;
        }
      return b.child;
    }
    function hi(a2, b, c) {
      null !== a2 && (b.dependencies = a2.dependencies);
      Dg |= b.lanes;
      if (0 !== (c & b.childLanes)) {
        if (null !== a2 && b.child !== a2.child)
          throw Error(y(153));
        if (null !== b.child) {
          a2 = b.child;
          c = Tg(a2, a2.pendingProps);
          b.child = c;
          for (c.return = b; null !== a2.sibling; )
            a2 = a2.sibling, c = c.sibling = Tg(a2, a2.pendingProps), c.return = b;
          c.sibling = null;
        }
        return b.child;
      }
      return null;
    }
    var Bi, Ci, Di, Ei;
    Bi = function(a2, b) {
      for (var c = b.child; null !== c; ) {
        if (5 === c.tag || 6 === c.tag)
          a2.appendChild(c.stateNode);
        else if (4 !== c.tag && null !== c.child) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b)
          break;
        for (; null === c.sibling; ) {
          if (null === c.return || c.return === b)
            return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    };
    Ci = function() {
    };
    Di = function(a2, b, c, d) {
      var e = a2.memoizedProps;
      if (e !== d) {
        a2 = b.stateNode;
        dh(ah.current);
        var f2 = null;
        switch (c) {
          case "input":
            e = Ya(a2, e);
            d = Ya(a2, d);
            f2 = [];
            break;
          case "option":
            e = eb(a2, e);
            d = eb(a2, d);
            f2 = [];
            break;
          case "select":
            e = m({}, e, { value: void 0 });
            d = m({}, d, { value: void 0 });
            f2 = [];
            break;
          case "textarea":
            e = gb(a2, e);
            d = gb(a2, d);
            f2 = [];
            break;
          default:
            "function" !== typeof e.onClick && "function" === typeof d.onClick && (a2.onclick = jf);
        }
        vb(c, d);
        var g2;
        c = null;
        for (l2 in e)
          if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && null != e[l2])
            if ("style" === l2) {
              var h2 = e[l2];
              for (g2 in h2)
                h2.hasOwnProperty(g2) && (c || (c = {}), c[g2] = "");
            } else
              "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ca.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
        for (l2 in d) {
          var k = d[l2];
          h2 = null != e ? e[l2] : void 0;
          if (d.hasOwnProperty(l2) && k !== h2 && (null != k || null != h2))
            if ("style" === l2)
              if (h2) {
                for (g2 in h2)
                  !h2.hasOwnProperty(g2) || k && k.hasOwnProperty(g2) || (c || (c = {}), c[g2] = "");
                for (g2 in k)
                  k.hasOwnProperty(g2) && h2[g2] !== k[g2] && (c || (c = {}), c[g2] = k[g2]);
              } else
                c || (f2 || (f2 = []), f2.push(l2, c)), c = k;
            else
              "dangerouslySetInnerHTML" === l2 ? (k = k ? k.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k && h2 !== k && (f2 = f2 || []).push(l2, k)) : "children" === l2 ? "string" !== typeof k && "number" !== typeof k || (f2 = f2 || []).push(l2, "" + k) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ca.hasOwnProperty(l2) ? (null != k && "onScroll" === l2 && G("scroll", a2), f2 || h2 === k || (f2 = [])) : "object" === typeof k && null !== k && k.$$typeof === Ga ? k.toString() : (f2 = f2 || []).push(l2, k));
        }
        c && (f2 = f2 || []).push(
          "style",
          c
        );
        var l2 = f2;
        if (b.updateQueue = l2)
          b.flags |= 4;
      }
    };
    Ei = function(a2, b, c, d) {
      c !== d && (b.flags |= 4);
    };
    function Fi(a2, b) {
      if (!lh)
        switch (a2.tailMode) {
          case "hidden":
            b = a2.tail;
            for (var c = null; null !== b; )
              null !== b.alternate && (c = b), b = b.sibling;
            null === c ? a2.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a2.tail;
            for (var d = null; null !== c; )
              null !== c.alternate && (d = c), c = c.sibling;
            null === d ? b || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d.sibling = null;
        }
    }
    function Gi(a2, b, c) {
      var d = b.pendingProps;
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return null;
        case 1:
          return Ff(b.type) && Gf(), null;
        case 3:
          fh();
          H(N);
          H(M);
          uh();
          d = b.stateNode;
          d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
          if (null === a2 || null === a2.child)
            rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
          Ci(b);
          return null;
        case 5:
          hh(b);
          var e = dh(ch.current);
          c = b.type;
          if (null !== a2 && null != b.stateNode)
            Di(a2, b, c, d, e), a2.ref !== b.ref && (b.flags |= 128);
          else {
            if (!d) {
              if (null === b.stateNode)
                throw Error(y(166));
              return null;
            }
            a2 = dh(ah.current);
            if (rh(b)) {
              d = b.stateNode;
              c = b.type;
              var f2 = b.memoizedProps;
              d[wf] = b;
              d[xf] = f2;
              switch (c) {
                case "dialog":
                  G("cancel", d);
                  G("close", d);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  G("load", d);
                  break;
                case "video":
                case "audio":
                  for (a2 = 0; a2 < Xe.length; a2++)
                    G(Xe[a2], d);
                  break;
                case "source":
                  G("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  G("error", d);
                  G("load", d);
                  break;
                case "details":
                  G("toggle", d);
                  break;
                case "input":
                  Za(d, f2);
                  G("invalid", d);
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!f2.multiple };
                  G("invalid", d);
                  break;
                case "textarea":
                  hb(d, f2), G("invalid", d);
              }
              vb(c, f2);
              a2 = null;
              for (var g2 in f2)
                f2.hasOwnProperty(g2) && (e = f2[g2], "children" === g2 ? "string" === typeof e ? d.textContent !== e && (a2 = ["children", e]) : "number" === typeof e && d.textContent !== "" + e && (a2 = ["children", "" + e]) : ca.hasOwnProperty(g2) && null != e && "onScroll" === g2 && G("scroll", d));
              switch (c) {
                case "input":
                  Va(d);
                  cb$1(d, f2, true);
                  break;
                case "textarea":
                  Va(d);
                  jb(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d.onclick = jf);
              }
              d = a2;
              b.updateQueue = d;
              null !== d && (b.flags |= 4);
            } else {
              g2 = 9 === e.nodeType ? e : e.ownerDocument;
              a2 === kb.html && (a2 = lb(c));
              a2 === kb.html ? "script" === c ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d.is ? a2 = g2.createElement(c, { is: d.is }) : (a2 = g2.createElement(c), "select" === c && (g2 = a2, d.multiple ? g2.multiple = true : d.size && (g2.size = d.size))) : a2 = g2.createElementNS(a2, c);
              a2[wf] = b;
              a2[xf] = d;
              Bi(a2, b, false, false);
              b.stateNode = a2;
              g2 = wb(c, d);
              switch (c) {
                case "dialog":
                  G("cancel", a2);
                  G("close", a2);
                  e = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  G("load", a2);
                  e = d;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < Xe.length; e++)
                    G(Xe[e], a2);
                  e = d;
                  break;
                case "source":
                  G("error", a2);
                  e = d;
                  break;
                case "img":
                case "image":
                case "link":
                  G("error", a2);
                  G("load", a2);
                  e = d;
                  break;
                case "details":
                  G("toggle", a2);
                  e = d;
                  break;
                case "input":
                  Za(a2, d);
                  e = Ya(a2, d);
                  G("invalid", a2);
                  break;
                case "option":
                  e = eb(a2, d);
                  break;
                case "select":
                  a2._wrapperState = { wasMultiple: !!d.multiple };
                  e = m({}, d, { value: void 0 });
                  G("invalid", a2);
                  break;
                case "textarea":
                  hb(a2, d);
                  e = gb(a2, d);
                  G("invalid", a2);
                  break;
                default:
                  e = d;
              }
              vb(c, e);
              var h2 = e;
              for (f2 in h2)
                if (h2.hasOwnProperty(f2)) {
                  var k = h2[f2];
                  "style" === f2 ? tb(a2, k) : "dangerouslySetInnerHTML" === f2 ? (k = k ? k.__html : void 0, null != k && ob(a2, k)) : "children" === f2 ? "string" === typeof k ? ("textarea" !== c || "" !== k) && pb(a2, k) : "number" === typeof k && pb(a2, "" + k) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ca.hasOwnProperty(f2) ? null != k && "onScroll" === f2 && G("scroll", a2) : null != k && qa(a2, f2, k, g2));
                }
              switch (c) {
                case "input":
                  Va(a2);
                  cb$1(a2, d, false);
                  break;
                case "textarea":
                  Va(a2);
                  jb(a2);
                  break;
                case "option":
                  null != d.value && a2.setAttribute("value", "" + Sa(d.value));
                  break;
                case "select":
                  a2.multiple = !!d.multiple;
                  f2 = d.value;
                  null != f2 ? fb(a2, !!d.multiple, f2, false) : null != d.defaultValue && fb(a2, !!d.multiple, d.defaultValue, true);
                  break;
                default:
                  "function" === typeof e.onClick && (a2.onclick = jf);
              }
              mf(c, d) && (b.flags |= 4);
            }
            null !== b.ref && (b.flags |= 128);
          }
          return null;
        case 6:
          if (a2 && null != b.stateNode)
            Ei(a2, b, a2.memoizedProps, d);
          else {
            if ("string" !== typeof d && null === b.stateNode)
              throw Error(y(166));
            c = dh(ch.current);
            dh(ah.current);
            rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
          }
          return null;
        case 13:
          H(P);
          d = b.memoizedState;
          if (0 !== (b.flags & 64))
            return b.lanes = c, b;
          d = null !== d;
          c = false;
          null === a2 ? void 0 !== b.memoizedProps.fallback && rh(b) : c = null !== a2.memoizedState;
          if (d && !c && 0 !== (b.mode & 2))
            if (null === a2 && true !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (P.current & 1))
              0 === V && (V = 3);
            else {
              if (0 === V || 3 === V)
                V = 4;
              null === U || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U, W);
            }
          if (d || c)
            b.flags |= 4;
          return null;
        case 4:
          return fh(), Ci(b), null === a2 && cf(b.stateNode.containerInfo), null;
        case 10:
          return rg(b), null;
        case 17:
          return Ff(b.type) && Gf(), null;
        case 19:
          H(P);
          d = b.memoizedState;
          if (null === d)
            return null;
          f2 = 0 !== (b.flags & 64);
          g2 = d.rendering;
          if (null === g2)
            if (f2)
              Fi(d, false);
            else {
              if (0 !== V || null !== a2 && 0 !== (a2.flags & 64))
                for (a2 = b.child; null !== a2; ) {
                  g2 = ih(a2);
                  if (null !== g2) {
                    b.flags |= 64;
                    Fi(d, false);
                    f2 = g2.updateQueue;
                    null !== f2 && (b.updateQueue = f2, b.flags |= 4);
                    null === d.lastEffect && (b.firstEffect = null);
                    b.lastEffect = d.lastEffect;
                    d = c;
                    for (c = b.child; null !== c; )
                      f2 = c, a2 = d, f2.flags &= 2, f2.nextEffect = null, f2.firstEffect = null, f2.lastEffect = null, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c = c.sibling;
                    I(P, P.current & 1 | 2);
                    return b.child;
                  }
                  a2 = a2.sibling;
                }
              null !== d.tail && O() > Ji && (b.flags |= 64, f2 = true, Fi(d, false), b.lanes = 33554432);
            }
          else {
            if (!f2)
              if (a2 = ih(g2), null !== a2) {
                if (b.flags |= 64, f2 = true, c = a2.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Fi(d, true), null === d.tail && "hidden" === d.tailMode && !g2.alternate && !lh)
                  return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
              } else
                2 * O() - d.renderingStartTime > Ji && 1073741824 !== c && (b.flags |= 64, f2 = true, Fi(d, false), b.lanes = 33554432);
            d.isBackwards ? (g2.sibling = b.child, b.child = g2) : (c = d.last, null !== c ? c.sibling = g2 : b.child = g2, d.last = g2);
          }
          return null !== d.tail ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f2 ? b & 1 | 2 : b & 1), c) : null;
        case 23:
        case 24:
          return Ki(), null !== a2 && null !== a2.memoizedState !== (null !== b.memoizedState) && "unstable-defer-without-hiding" !== d.mode && (b.flags |= 4), null;
      }
      throw Error(y(156, b.tag));
    }
    function Li(a2) {
      switch (a2.tag) {
        case 1:
          Ff(a2.type) && Gf();
          var b = a2.flags;
          return b & 4096 ? (a2.flags = b & -4097 | 64, a2) : null;
        case 3:
          fh();
          H(N);
          H(M);
          uh();
          b = a2.flags;
          if (0 !== (b & 64))
            throw Error(y(285));
          a2.flags = b & -4097 | 64;
          return a2;
        case 5:
          return hh(a2), null;
        case 13:
          return H(P), b = a2.flags, b & 4096 ? (a2.flags = b & -4097 | 64, a2) : null;
        case 19:
          return H(P), null;
        case 4:
          return fh(), null;
        case 10:
          return rg(a2), null;
        case 23:
        case 24:
          return Ki(), null;
        default:
          return null;
      }
    }
    function Mi(a2, b) {
      try {
        var c = "", d = b;
        do
          c += Qa(d), d = d.return;
        while (d);
        var e = c;
      } catch (f2) {
        e = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return { value: a2, source: b, stack: e };
    }
    function Ni(a2, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    var Oi = "function" === typeof WeakMap ? WeakMap : Map;
    function Pi(a2, b, c) {
      c = zg(-1, c);
      c.tag = 3;
      c.payload = { element: null };
      var d = b.value;
      c.callback = function() {
        Qi || (Qi = true, Ri = d);
        Ni(a2, b);
      };
      return c;
    }
    function Si(a2, b, c) {
      c = zg(-1, c);
      c.tag = 3;
      var d = a2.type.getDerivedStateFromError;
      if ("function" === typeof d) {
        var e = b.value;
        c.payload = function() {
          Ni(a2, b);
          return d(e);
        };
      }
      var f2 = a2.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
        "function" !== typeof d && (null === Ti ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a2, b));
        var c2 = b.stack;
        this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
      });
      return c;
    }
    var Ui = "function" === typeof WeakSet ? WeakSet : Set;
    function Vi(a2) {
      var b = a2.ref;
      if (null !== b)
        if ("function" === typeof b)
          try {
            b(null);
          } catch (c) {
            Wi(a2, c);
          }
        else
          b.current = null;
    }
    function Xi(a2, b) {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          return;
        case 1:
          if (b.flags & 256 && null !== a2) {
            var c = a2.memoizedProps, d = a2.memoizedState;
            a2 = b.stateNode;
            b = a2.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
            a2.__reactInternalSnapshotBeforeUpdate = b;
          }
          return;
        case 3:
          b.flags & 256 && qf(b.stateNode.containerInfo);
          return;
        case 5:
        case 6:
        case 4:
        case 17:
          return;
      }
      throw Error(y(163));
    }
    function Yi(a2, b, c) {
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          b = c.updateQueue;
          b = null !== b ? b.lastEffect : null;
          if (null !== b) {
            a2 = b = b.next;
            do {
              if (3 === (a2.tag & 3)) {
                var d = a2.create;
                a2.destroy = d();
              }
              a2 = a2.next;
            } while (a2 !== b);
          }
          b = c.updateQueue;
          b = null !== b ? b.lastEffect : null;
          if (null !== b) {
            a2 = b = b.next;
            do {
              var e = a2;
              d = e.next;
              e = e.tag;
              0 !== (e & 4) && 0 !== (e & 1) && (Zi(c, a2), $i(c, a2));
              a2 = d;
            } while (a2 !== b);
          }
          return;
        case 1:
          a2 = c.stateNode;
          c.flags & 4 && (null === b ? a2.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a2.componentDidUpdate(
            d,
            b.memoizedState,
            a2.__reactInternalSnapshotBeforeUpdate
          )));
          b = c.updateQueue;
          null !== b && Eg(c, b, a2);
          return;
        case 3:
          b = c.updateQueue;
          if (null !== b) {
            a2 = null;
            if (null !== c.child)
              switch (c.child.tag) {
                case 5:
                  a2 = c.child.stateNode;
                  break;
                case 1:
                  a2 = c.child.stateNode;
              }
            Eg(c, b, a2);
          }
          return;
        case 5:
          a2 = c.stateNode;
          null === b && c.flags & 4 && mf(c.type, c.memoizedProps) && a2.focus();
          return;
        case 6:
          return;
        case 4:
          return;
        case 12:
          return;
        case 13:
          null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && Cc(c))));
          return;
        case 19:
        case 17:
        case 20:
        case 21:
        case 23:
        case 24:
          return;
      }
      throw Error(y(163));
    }
    function aj(a2, b) {
      for (var c = a2; ; ) {
        if (5 === c.tag) {
          var d = c.stateNode;
          if (b)
            d = d.style, "function" === typeof d.setProperty ? d.setProperty("display", "none", "important") : d.display = "none";
          else {
            d = c.stateNode;
            var e = c.memoizedProps.style;
            e = void 0 !== e && null !== e && e.hasOwnProperty("display") ? e.display : null;
            d.style.display = sb("display", e);
          }
        } else if (6 === c.tag)
          c.stateNode.nodeValue = b ? "" : c.memoizedProps;
        else if ((23 !== c.tag && 24 !== c.tag || null === c.memoizedState || c === a2) && null !== c.child) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === a2)
          break;
        for (; null === c.sibling; ) {
          if (null === c.return || c.return === a2)
            return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    }
    function bj(a2, b) {
      if (Mf && "function" === typeof Mf.onCommitFiberUnmount)
        try {
          Mf.onCommitFiberUnmount(Lf, b);
        } catch (f2) {
        }
      switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          a2 = b.updateQueue;
          if (null !== a2 && (a2 = a2.lastEffect, null !== a2)) {
            var c = a2 = a2.next;
            do {
              var d = c, e = d.destroy;
              d = d.tag;
              if (void 0 !== e)
                if (0 !== (d & 4))
                  Zi(b, c);
                else {
                  d = b;
                  try {
                    e();
                  } catch (f2) {
                    Wi(d, f2);
                  }
                }
              c = c.next;
            } while (c !== a2);
          }
          break;
        case 1:
          Vi(b);
          a2 = b.stateNode;
          if ("function" === typeof a2.componentWillUnmount)
            try {
              a2.props = b.memoizedProps, a2.state = b.memoizedState, a2.componentWillUnmount();
            } catch (f2) {
              Wi(
                b,
                f2
              );
            }
          break;
        case 5:
          Vi(b);
          break;
        case 4:
          cj(a2, b);
      }
    }
    function dj(a2) {
      a2.alternate = null;
      a2.child = null;
      a2.dependencies = null;
      a2.firstEffect = null;
      a2.lastEffect = null;
      a2.memoizedProps = null;
      a2.memoizedState = null;
      a2.pendingProps = null;
      a2.return = null;
      a2.updateQueue = null;
    }
    function ej(a2) {
      return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
    }
    function fj(a2) {
      a: {
        for (var b = a2.return; null !== b; ) {
          if (ej(b))
            break a;
          b = b.return;
        }
        throw Error(y(160));
      }
      var c = b;
      b = c.stateNode;
      switch (c.tag) {
        case 5:
          var d = false;
          break;
        case 3:
          b = b.containerInfo;
          d = true;
          break;
        case 4:
          b = b.containerInfo;
          d = true;
          break;
        default:
          throw Error(y(161));
      }
      c.flags & 16 && (pb(b, ""), c.flags &= -17);
      a:
        b:
          for (c = a2; ; ) {
            for (; null === c.sibling; ) {
              if (null === c.return || ej(c.return)) {
                c = null;
                break a;
              }
              c = c.return;
            }
            c.sibling.return = c.return;
            for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag; ) {
              if (c.flags & 2)
                continue b;
              if (null === c.child || 4 === c.tag)
                continue b;
              else
                c.child.return = c, c = c.child;
            }
            if (!(c.flags & 2)) {
              c = c.stateNode;
              break a;
            }
          }
      d ? gj(a2, c, b) : hj(a2, c, b);
    }
    function gj(a2, b, c) {
      var d = a2.tag, e = 5 === d || 6 === d;
      if (e)
        a2 = e ? a2.stateNode : a2.stateNode.instance, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a2, b) : c.insertBefore(a2, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a2, c)) : (b = c, b.appendChild(a2)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = jf));
      else if (4 !== d && (a2 = a2.child, null !== a2))
        for (gj(a2, b, c), a2 = a2.sibling; null !== a2; )
          gj(a2, b, c), a2 = a2.sibling;
    }
    function hj(a2, b, c) {
      var d = a2.tag, e = 5 === d || 6 === d;
      if (e)
        a2 = e ? a2.stateNode : a2.stateNode.instance, b ? c.insertBefore(a2, b) : c.appendChild(a2);
      else if (4 !== d && (a2 = a2.child, null !== a2))
        for (hj(a2, b, c), a2 = a2.sibling; null !== a2; )
          hj(a2, b, c), a2 = a2.sibling;
    }
    function cj(a2, b) {
      for (var c = b, d = false, e, f2; ; ) {
        if (!d) {
          d = c.return;
          a:
            for (; ; ) {
              if (null === d)
                throw Error(y(160));
              e = d.stateNode;
              switch (d.tag) {
                case 5:
                  f2 = false;
                  break a;
                case 3:
                  e = e.containerInfo;
                  f2 = true;
                  break a;
                case 4:
                  e = e.containerInfo;
                  f2 = true;
                  break a;
              }
              d = d.return;
            }
          d = true;
        }
        if (5 === c.tag || 6 === c.tag) {
          a:
            for (var g2 = a2, h2 = c, k = h2; ; )
              if (bj(g2, k), null !== k.child && 4 !== k.tag)
                k.child.return = k, k = k.child;
              else {
                if (k === h2)
                  break a;
                for (; null === k.sibling; ) {
                  if (null === k.return || k.return === h2)
                    break a;
                  k = k.return;
                }
                k.sibling.return = k.return;
                k = k.sibling;
              }
          f2 ? (g2 = e, h2 = c.stateNode, 8 === g2.nodeType ? g2.parentNode.removeChild(h2) : g2.removeChild(h2)) : e.removeChild(c.stateNode);
        } else if (4 === c.tag) {
          if (null !== c.child) {
            e = c.stateNode.containerInfo;
            f2 = true;
            c.child.return = c;
            c = c.child;
            continue;
          }
        } else if (bj(a2, c), null !== c.child) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b)
          break;
        for (; null === c.sibling; ) {
          if (null === c.return || c.return === b)
            return;
          c = c.return;
          4 === c.tag && (d = false);
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    }
    function ij(a2, b) {
      switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          var c = b.updateQueue;
          c = null !== c ? c.lastEffect : null;
          if (null !== c) {
            var d = c = c.next;
            do
              3 === (d.tag & 3) && (a2 = d.destroy, d.destroy = void 0, void 0 !== a2 && a2()), d = d.next;
            while (d !== c);
          }
          return;
        case 1:
          return;
        case 5:
          c = b.stateNode;
          if (null != c) {
            d = b.memoizedProps;
            var e = null !== a2 ? a2.memoizedProps : d;
            a2 = b.type;
            var f2 = b.updateQueue;
            b.updateQueue = null;
            if (null !== f2) {
              c[xf] = d;
              "input" === a2 && "radio" === d.type && null != d.name && $a(c, d);
              wb(a2, e);
              b = wb(a2, d);
              for (e = 0; e < f2.length; e += 2) {
                var g2 = f2[e], h2 = f2[e + 1];
                "style" === g2 ? tb(c, h2) : "dangerouslySetInnerHTML" === g2 ? ob(c, h2) : "children" === g2 ? pb(c, h2) : qa(c, g2, h2, b);
              }
              switch (a2) {
                case "input":
                  ab(c, d);
                  break;
                case "textarea":
                  ib(c, d);
                  break;
                case "select":
                  a2 = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f2 = d.value, null != f2 ? fb(c, !!d.multiple, f2, false) : a2 !== !!d.multiple && (null != d.defaultValue ? fb(c, !!d.multiple, d.defaultValue, true) : fb(c, !!d.multiple, d.multiple ? [] : "", false));
              }
            }
          }
          return;
        case 6:
          if (null === b.stateNode)
            throw Error(y(162));
          b.stateNode.nodeValue = b.memoizedProps;
          return;
        case 3:
          c = b.stateNode;
          c.hydrate && (c.hydrate = false, Cc(c.containerInfo));
          return;
        case 12:
          return;
        case 13:
          null !== b.memoizedState && (jj = O(), aj(b.child, true));
          kj(b);
          return;
        case 19:
          kj(b);
          return;
        case 17:
          return;
        case 23:
        case 24:
          aj(b, null !== b.memoizedState);
          return;
      }
      throw Error(y(163));
    }
    function kj(a2) {
      var b = a2.updateQueue;
      if (null !== b) {
        a2.updateQueue = null;
        var c = a2.stateNode;
        null === c && (c = a2.stateNode = new Ui());
        b.forEach(function(b2) {
          var d = lj.bind(null, a2, b2);
          c.has(b2) || (c.add(b2), b2.then(d, d));
        });
      }
    }
    function mj(a2, b) {
      return null !== a2 && (a2 = a2.memoizedState, null === a2 || null !== a2.dehydrated) ? (b = b.memoizedState, null !== b && null === b.dehydrated) : false;
    }
    var nj = Math.ceil, oj = ra.ReactCurrentDispatcher, pj = ra.ReactCurrentOwner, X = 0, U = null, Y = null, W = 0, qj = 0, rj = Bf(0), V = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji = Infinity;
    function wj() {
      Ji = O() + 500;
    }
    var Z = null, Qi = false, Ri = null, Ti = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
    function Hg() {
      return 0 !== (X & 48) ? O() : -1 !== Fj ? Fj : Fj = O();
    }
    function Ig(a2) {
      a2 = a2.mode;
      if (0 === (a2 & 2))
        return 1;
      if (0 === (a2 & 4))
        return 99 === eg() ? 1 : 2;
      0 === Gj && (Gj = tj);
      if (0 !== kg.transition) {
        0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
        a2 = Gj;
        var b = 4186112 & ~Hj;
        b &= -b;
        0 === b && (a2 = 4186112 & ~a2, b = a2 & -a2, 0 === b && (b = 8192));
        return b;
      }
      a2 = eg();
      0 !== (X & 4) && 98 === a2 ? a2 = Xc(12, Gj) : (a2 = Sc(a2), a2 = Xc(a2, Gj));
      return a2;
    }
    function Jg(a2, b, c) {
      if (50 < Dj)
        throw Dj = 0, Ej = null, Error(y(185));
      a2 = Kj(a2, b);
      if (null === a2)
        return null;
      $c(a2, b, c);
      a2 === U && (Hi |= b, 4 === V && Ii(a2, W));
      var d = eg();
      1 === b ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a2) : (Mj(a2, c), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d && 99 !== d || (null === Cj ? Cj = /* @__PURE__ */ new Set([a2]) : Cj.add(a2)), Mj(a2, c));
      vj = a2;
    }
    function Kj(a2, b) {
      a2.lanes |= b;
      var c = a2.alternate;
      null !== c && (c.lanes |= b);
      c = a2;
      for (a2 = a2.return; null !== a2; )
        a2.childLanes |= b, c = a2.alternate, null !== c && (c.childLanes |= b), c = a2, a2 = a2.return;
      return 3 === c.tag ? c.stateNode : null;
    }
    function Mj(a2, b) {
      for (var c = a2.callbackNode, d = a2.suspendedLanes, e = a2.pingedLanes, f2 = a2.expirationTimes, g2 = a2.pendingLanes; 0 < g2; ) {
        var h2 = 31 - Vc(g2), k = 1 << h2, l2 = f2[h2];
        if (-1 === l2) {
          if (0 === (k & d) || 0 !== (k & e)) {
            l2 = b;
            Rc(k);
            var n2 = F;
            f2[h2] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
          }
        } else
          l2 <= b && (a2.expiredLanes |= k);
        g2 &= ~k;
      }
      d = Uc(a2, a2 === U ? W : 0);
      b = F;
      if (0 === d)
        null !== c && (c !== Zf && Pf(c), a2.callbackNode = null, a2.callbackPriority = 0);
      else {
        if (null !== c) {
          if (a2.callbackPriority === b)
            return;
          c !== Zf && Pf(c);
        }
        15 === b ? (c = Lj.bind(null, a2), null === ag ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : 14 === b ? c = hg(99, Lj.bind(null, a2)) : (c = Tc(b), c = hg(c, Nj.bind(null, a2)));
        a2.callbackPriority = b;
        a2.callbackNode = c;
      }
    }
    function Nj(a2) {
      Fj = -1;
      Hj = Gj = 0;
      if (0 !== (X & 48))
        throw Error(y(327));
      var b = a2.callbackNode;
      if (Oj() && a2.callbackNode !== b)
        return null;
      var c = Uc(a2, a2 === U ? W : 0);
      if (0 === c)
        return null;
      var d = c;
      var e = X;
      X |= 16;
      var f2 = Pj();
      if (U !== a2 || W !== d)
        wj(), Qj(a2, d);
      do
        try {
          Rj();
          break;
        } catch (h2) {
          Sj(a2, h2);
        }
      while (1);
      qg();
      oj.current = f2;
      X = e;
      null !== Y ? d = 0 : (U = null, W = 0, d = V);
      if (0 !== (tj & Hi))
        Qj(a2, 0);
      else if (0 !== d) {
        2 === d && (X |= 64, a2.hydrate && (a2.hydrate = false, qf(a2.containerInfo)), c = Wc(a2), 0 !== c && (d = Tj(a2, c)));
        if (1 === d)
          throw b = sj, Qj(a2, 0), Ii(a2, c), Mj(a2, O()), b;
        a2.finishedWork = a2.current.alternate;
        a2.finishedLanes = c;
        switch (d) {
          case 0:
          case 1:
            throw Error(y(345));
          case 2:
            Uj(a2);
            break;
          case 3:
            Ii(a2, c);
            if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
              if (0 !== Uc(a2, 0))
                break;
              e = a2.suspendedLanes;
              if ((e & c) !== c) {
                Hg();
                a2.pingedLanes |= a2.suspendedLanes & e;
                break;
              }
              a2.timeoutHandle = of(Uj.bind(null, a2), d);
              break;
            }
            Uj(a2);
            break;
          case 4:
            Ii(a2, c);
            if ((c & 4186112) === c)
              break;
            d = a2.eventTimes;
            for (e = -1; 0 < c; ) {
              var g2 = 31 - Vc(c);
              f2 = 1 << g2;
              g2 = d[g2];
              g2 > e && (e = g2);
              c &= ~f2;
            }
            c = e;
            c = O() - c;
            c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;
            if (10 < c) {
              a2.timeoutHandle = of(Uj.bind(null, a2), c);
              break;
            }
            Uj(a2);
            break;
          case 5:
            Uj(a2);
            break;
          default:
            throw Error(y(329));
        }
      }
      Mj(a2, O());
      return a2.callbackNode === b ? Nj.bind(null, a2) : null;
    }
    function Ii(a2, b) {
      b &= ~uj;
      b &= ~Hi;
      a2.suspendedLanes |= b;
      a2.pingedLanes &= ~b;
      for (a2 = a2.expirationTimes; 0 < b; ) {
        var c = 31 - Vc(b), d = 1 << c;
        a2[c] = -1;
        b &= ~d;
      }
    }
    function Lj(a2) {
      if (0 !== (X & 48))
        throw Error(y(327));
      Oj();
      if (a2 === U && 0 !== (a2.expiredLanes & W)) {
        var b = W;
        var c = Tj(a2, b);
        0 !== (tj & Hi) && (b = Uc(a2, b), c = Tj(a2, b));
      } else
        b = Uc(a2, 0), c = Tj(a2, b);
      0 !== a2.tag && 2 === c && (X |= 64, a2.hydrate && (a2.hydrate = false, qf(a2.containerInfo)), b = Wc(a2), 0 !== b && (c = Tj(a2, b)));
      if (1 === c)
        throw c = sj, Qj(a2, 0), Ii(a2, b), Mj(a2, O()), c;
      a2.finishedWork = a2.current.alternate;
      a2.finishedLanes = b;
      Uj(a2);
      Mj(a2, O());
      return null;
    }
    function Vj() {
      if (null !== Cj) {
        var a2 = Cj;
        Cj = null;
        a2.forEach(function(a3) {
          a3.expiredLanes |= 24 & a3.pendingLanes;
          Mj(a3, O());
        });
      }
      ig();
    }
    function Wj(a2, b) {
      var c = X;
      X |= 1;
      try {
        return a2(b);
      } finally {
        X = c, 0 === X && (wj(), ig());
      }
    }
    function Xj(a2, b) {
      var c = X;
      X &= -2;
      X |= 8;
      try {
        return a2(b);
      } finally {
        X = c, 0 === X && (wj(), ig());
      }
    }
    function ni(a2, b) {
      I(rj, qj);
      qj |= b;
      tj |= b;
    }
    function Ki() {
      qj = rj.current;
      H(rj);
    }
    function Qj(a2, b) {
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      var c = a2.timeoutHandle;
      -1 !== c && (a2.timeoutHandle = -1, pf(c));
      if (null !== Y)
        for (c = Y.return; null !== c; ) {
          var d = c;
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && Gf();
              break;
            case 3:
              fh();
              H(N);
              H(M);
              uh();
              break;
            case 5:
              hh(d);
              break;
            case 4:
              fh();
              break;
            case 13:
              H(P);
              break;
            case 19:
              H(P);
              break;
            case 10:
              rg(d);
              break;
            case 23:
            case 24:
              Ki();
          }
          c = c.return;
        }
      U = a2;
      Y = Tg(a2.current, null);
      W = qj = tj = b;
      V = 0;
      sj = null;
      uj = Hi = Dg = 0;
    }
    function Sj(a2, b) {
      do {
        var c = Y;
        try {
          qg();
          vh.current = Gh;
          if (yh) {
            for (var d = R.memoizedState; null !== d; ) {
              var e = d.queue;
              null !== e && (e.pending = null);
              d = d.next;
            }
            yh = false;
          }
          xh = 0;
          T = S = R = null;
          zh = false;
          pj.current = null;
          if (null === c || null === c.return) {
            V = 1;
            sj = b;
            Y = null;
            break;
          }
          a: {
            var f2 = a2, g2 = c.return, h2 = c, k = b;
            b = W;
            h2.flags |= 2048;
            h2.firstEffect = h2.lastEffect = null;
            if (null !== k && "object" === typeof k && "function" === typeof k.then) {
              var l2 = k;
              if (0 === (h2.mode & 2)) {
                var n2 = h2.alternate;
                n2 ? (h2.updateQueue = n2.updateQueue, h2.memoizedState = n2.memoizedState, h2.lanes = n2.lanes) : (h2.updateQueue = null, h2.memoizedState = null);
              }
              var A2 = 0 !== (P.current & 1), p2 = g2;
              do {
                var C2;
                if (C2 = 13 === p2.tag) {
                  var x2 = p2.memoizedState;
                  if (null !== x2)
                    C2 = null !== x2.dehydrated ? true : false;
                  else {
                    var w2 = p2.memoizedProps;
                    C2 = void 0 === w2.fallback ? false : true !== w2.unstable_avoidThisFallback ? true : A2 ? false : true;
                  }
                }
                if (C2) {
                  var z2 = p2.updateQueue;
                  if (null === z2) {
                    var u2 = /* @__PURE__ */ new Set();
                    u2.add(l2);
                    p2.updateQueue = u2;
                  } else
                    z2.add(l2);
                  if (0 === (p2.mode & 2)) {
                    p2.flags |= 64;
                    h2.flags |= 16384;
                    h2.flags &= -2981;
                    if (1 === h2.tag)
                      if (null === h2.alternate)
                        h2.tag = 17;
                      else {
                        var t2 = zg(-1, 1);
                        t2.tag = 2;
                        Ag(h2, t2);
                      }
                    h2.lanes |= 1;
                    break a;
                  }
                  k = void 0;
                  h2 = b;
                  var q2 = f2.pingCache;
                  null === q2 ? (q2 = f2.pingCache = new Oi(), k = /* @__PURE__ */ new Set(), q2.set(l2, k)) : (k = q2.get(l2), void 0 === k && (k = /* @__PURE__ */ new Set(), q2.set(l2, k)));
                  if (!k.has(h2)) {
                    k.add(h2);
                    var v2 = Yj.bind(null, f2, l2, h2);
                    l2.then(v2, v2);
                  }
                  p2.flags |= 4096;
                  p2.lanes = b;
                  break a;
                }
                p2 = p2.return;
              } while (null !== p2);
              k = Error((Ra(h2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
            }
            5 !== V && (V = 2);
            k = Mi(k, h2);
            p2 = g2;
            do {
              switch (p2.tag) {
                case 3:
                  f2 = k;
                  p2.flags |= 4096;
                  b &= -b;
                  p2.lanes |= b;
                  var J2 = Pi(p2, f2, b);
                  Bg(p2, J2);
                  break a;
                case 1:
                  f2 = k;
                  var K2 = p2.type, Q2 = p2.stateNode;
                  if (0 === (p2.flags & 64) && ("function" === typeof K2.getDerivedStateFromError || null !== Q2 && "function" === typeof Q2.componentDidCatch && (null === Ti || !Ti.has(Q2)))) {
                    p2.flags |= 4096;
                    b &= -b;
                    p2.lanes |= b;
                    var L2 = Si(p2, f2, b);
                    Bg(p2, L2);
                    break a;
                  }
              }
              p2 = p2.return;
            } while (null !== p2);
          }
          Zj(c);
        } catch (va) {
          b = va;
          Y === c && null !== c && (Y = c = c.return);
          continue;
        }
        break;
      } while (1);
    }
    function Pj() {
      var a2 = oj.current;
      oj.current = Gh;
      return null === a2 ? Gh : a2;
    }
    function Tj(a2, b) {
      var c = X;
      X |= 16;
      var d = Pj();
      U === a2 && W === b || Qj(a2, b);
      do
        try {
          ak();
          break;
        } catch (e) {
          Sj(a2, e);
        }
      while (1);
      qg();
      X = c;
      oj.current = d;
      if (null !== Y)
        throw Error(y(261));
      U = null;
      W = 0;
      return V;
    }
    function ak() {
      for (; null !== Y; )
        bk(Y);
    }
    function Rj() {
      for (; null !== Y && !Qf(); )
        bk(Y);
    }
    function bk(a2) {
      var b = ck(a2.alternate, a2, qj);
      a2.memoizedProps = a2.pendingProps;
      null === b ? Zj(a2) : Y = b;
      pj.current = null;
    }
    function Zj(a2) {
      var b = a2;
      do {
        var c = b.alternate;
        a2 = b.return;
        if (0 === (b.flags & 2048)) {
          c = Gi(c, b, qj);
          if (null !== c) {
            Y = c;
            return;
          }
          c = b;
          if (24 !== c.tag && 23 !== c.tag || null === c.memoizedState || 0 !== (qj & 1073741824) || 0 === (c.mode & 4)) {
            for (var d = 0, e = c.child; null !== e; )
              d |= e.lanes | e.childLanes, e = e.sibling;
            c.childLanes = d;
          }
          null !== a2 && 0 === (a2.flags & 2048) && (null === a2.firstEffect && (a2.firstEffect = b.firstEffect), null !== b.lastEffect && (null !== a2.lastEffect && (a2.lastEffect.nextEffect = b.firstEffect), a2.lastEffect = b.lastEffect), 1 < b.flags && (null !== a2.lastEffect ? a2.lastEffect.nextEffect = b : a2.firstEffect = b, a2.lastEffect = b));
        } else {
          c = Li(b);
          if (null !== c) {
            c.flags &= 2047;
            Y = c;
            return;
          }
          null !== a2 && (a2.firstEffect = a2.lastEffect = null, a2.flags |= 2048);
        }
        b = b.sibling;
        if (null !== b) {
          Y = b;
          return;
        }
        Y = b = a2;
      } while (null !== b);
      0 === V && (V = 5);
    }
    function Uj(a2) {
      var b = eg();
      gg(99, dk.bind(null, a2, b));
      return null;
    }
    function dk(a2, b) {
      do
        Oj();
      while (null !== yj);
      if (0 !== (X & 48))
        throw Error(y(327));
      var c = a2.finishedWork;
      if (null === c)
        return null;
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      if (c === a2.current)
        throw Error(y(177));
      a2.callbackNode = null;
      var d = c.lanes | c.childLanes, e = d, f2 = a2.pendingLanes & ~e;
      a2.pendingLanes = e;
      a2.suspendedLanes = 0;
      a2.pingedLanes = 0;
      a2.expiredLanes &= e;
      a2.mutableReadLanes &= e;
      a2.entangledLanes &= e;
      e = a2.entanglements;
      for (var g2 = a2.eventTimes, h2 = a2.expirationTimes; 0 < f2; ) {
        var k = 31 - Vc(f2), l2 = 1 << k;
        e[k] = 0;
        g2[k] = -1;
        h2[k] = -1;
        f2 &= ~l2;
      }
      null !== Cj && 0 === (d & 24) && Cj.has(a2) && Cj.delete(a2);
      a2 === U && (Y = U = null, W = 0);
      1 < c.flags ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;
      if (null !== d) {
        e = X;
        X |= 32;
        pj.current = null;
        kf = fd;
        g2 = Ne();
        if (Oe(g2)) {
          if ("selectionStart" in g2)
            h2 = { start: g2.selectionStart, end: g2.selectionEnd };
          else
            a:
              if (h2 = (h2 = g2.ownerDocument) && h2.defaultView || window, (l2 = h2.getSelection && h2.getSelection()) && 0 !== l2.rangeCount) {
                h2 = l2.anchorNode;
                f2 = l2.anchorOffset;
                k = l2.focusNode;
                l2 = l2.focusOffset;
                try {
                  h2.nodeType, k.nodeType;
                } catch (va) {
                  h2 = null;
                  break a;
                }
                var n2 = 0, A2 = -1, p2 = -1, C2 = 0, x2 = 0, w2 = g2, z2 = null;
                b:
                  for (; ; ) {
                    for (var u2; ; ) {
                      w2 !== h2 || 0 !== f2 && 3 !== w2.nodeType || (A2 = n2 + f2);
                      w2 !== k || 0 !== l2 && 3 !== w2.nodeType || (p2 = n2 + l2);
                      3 === w2.nodeType && (n2 += w2.nodeValue.length);
                      if (null === (u2 = w2.firstChild))
                        break;
                      z2 = w2;
                      w2 = u2;
                    }
                    for (; ; ) {
                      if (w2 === g2)
                        break b;
                      z2 === h2 && ++C2 === f2 && (A2 = n2);
                      z2 === k && ++x2 === l2 && (p2 = n2);
                      if (null !== (u2 = w2.nextSibling))
                        break;
                      w2 = z2;
                      z2 = w2.parentNode;
                    }
                    w2 = u2;
                  }
                h2 = -1 === A2 || -1 === p2 ? null : { start: A2, end: p2 };
              } else
                h2 = null;
          h2 = h2 || { start: 0, end: 0 };
        } else
          h2 = null;
        lf = { focusedElem: g2, selectionRange: h2 };
        fd = false;
        Ij = null;
        Jj = false;
        Z = d;
        do
          try {
            ek();
          } catch (va) {
            if (null === Z)
              throw Error(y(330));
            Wi(Z, va);
            Z = Z.nextEffect;
          }
        while (null !== Z);
        Ij = null;
        Z = d;
        do
          try {
            for (g2 = a2; null !== Z; ) {
              var t2 = Z.flags;
              t2 & 16 && pb(Z.stateNode, "");
              if (t2 & 128) {
                var q2 = Z.alternate;
                if (null !== q2) {
                  var v2 = q2.ref;
                  null !== v2 && ("function" === typeof v2 ? v2(null) : v2.current = null);
                }
              }
              switch (t2 & 1038) {
                case 2:
                  fj(Z);
                  Z.flags &= -3;
                  break;
                case 6:
                  fj(Z);
                  Z.flags &= -3;
                  ij(Z.alternate, Z);
                  break;
                case 1024:
                  Z.flags &= -1025;
                  break;
                case 1028:
                  Z.flags &= -1025;
                  ij(Z.alternate, Z);
                  break;
                case 4:
                  ij(Z.alternate, Z);
                  break;
                case 8:
                  h2 = Z;
                  cj(g2, h2);
                  var J2 = h2.alternate;
                  dj(h2);
                  null !== J2 && dj(J2);
              }
              Z = Z.nextEffect;
            }
          } catch (va) {
            if (null === Z)
              throw Error(y(330));
            Wi(Z, va);
            Z = Z.nextEffect;
          }
        while (null !== Z);
        v2 = lf;
        q2 = Ne();
        t2 = v2.focusedElem;
        g2 = v2.selectionRange;
        if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
          null !== g2 && Oe(t2) && (q2 = g2.start, v2 = g2.end, void 0 === v2 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h2 = t2.textContent.length, J2 = Math.min(g2.start, h2), g2 = void 0 === g2.end ? J2 : Math.min(g2.end, h2), !v2.extend && J2 > g2 && (h2 = g2, g2 = J2, J2 = h2), h2 = Le(t2, J2), f2 = Le(t2, g2), h2 && f2 && (1 !== v2.rangeCount || v2.anchorNode !== h2.node || v2.anchorOffset !== h2.offset || v2.focusNode !== f2.node || v2.focusOffset !== f2.offset) && (q2 = q2.createRange(), q2.setStart(h2.node, h2.offset), v2.removeAllRanges(), J2 > g2 ? (v2.addRange(q2), v2.extend(f2.node, f2.offset)) : (q2.setEnd(f2.node, f2.offset), v2.addRange(q2))))));
          q2 = [];
          for (v2 = t2; v2 = v2.parentNode; )
            1 === v2.nodeType && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });
          "function" === typeof t2.focus && t2.focus();
          for (t2 = 0; t2 < q2.length; t2++)
            v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
        }
        fd = !!kf;
        lf = kf = null;
        a2.current = c;
        Z = d;
        do
          try {
            for (t2 = a2; null !== Z; ) {
              var K2 = Z.flags;
              K2 & 36 && Yi(t2, Z.alternate, Z);
              if (K2 & 128) {
                q2 = void 0;
                var Q2 = Z.ref;
                if (null !== Q2) {
                  var L2 = Z.stateNode;
                  switch (Z.tag) {
                    case 5:
                      q2 = L2;
                      break;
                    default:
                      q2 = L2;
                  }
                  "function" === typeof Q2 ? Q2(q2) : Q2.current = q2;
                }
              }
              Z = Z.nextEffect;
            }
          } catch (va) {
            if (null === Z)
              throw Error(y(330));
            Wi(Z, va);
            Z = Z.nextEffect;
          }
        while (null !== Z);
        Z = null;
        $f();
        X = e;
      } else
        a2.current = c;
      if (xj)
        xj = false, yj = a2, zj = b;
      else
        for (Z = d; null !== Z; )
          b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K2 = Z, K2.sibling = null, K2.stateNode = null), Z = b;
      d = a2.pendingLanes;
      0 === d && (Ti = null);
      1 === d ? a2 === Ej ? Dj++ : (Dj = 0, Ej = a2) : Dj = 0;
      c = c.stateNode;
      if (Mf && "function" === typeof Mf.onCommitFiberRoot)
        try {
          Mf.onCommitFiberRoot(Lf, c, void 0, 64 === (c.current.flags & 64));
        } catch (va) {
        }
      Mj(a2, O());
      if (Qi)
        throw Qi = false, a2 = Ri, Ri = null, a2;
      if (0 !== (X & 8))
        return null;
      ig();
      return null;
    }
    function ek() {
      for (; null !== Z; ) {
        var a2 = Z.alternate;
        Jj || null === Ij || (0 !== (Z.flags & 8) ? dc(Z, Ij) && (Jj = true) : 13 === Z.tag && mj(a2, Z) && dc(Z, Ij) && (Jj = true));
        var b = Z.flags;
        0 !== (b & 256) && Xi(a2, Z);
        0 === (b & 512) || xj || (xj = true, hg(97, function() {
          Oj();
          return null;
        }));
        Z = Z.nextEffect;
      }
    }
    function Oj() {
      if (90 !== zj) {
        var a2 = 97 < zj ? 97 : zj;
        zj = 90;
        return gg(a2, fk);
      }
      return false;
    }
    function $i(a2, b) {
      Aj.push(b, a2);
      xj || (xj = true, hg(97, function() {
        Oj();
        return null;
      }));
    }
    function Zi(a2, b) {
      Bj.push(b, a2);
      xj || (xj = true, hg(97, function() {
        Oj();
        return null;
      }));
    }
    function fk() {
      if (null === yj)
        return false;
      var a2 = yj;
      yj = null;
      if (0 !== (X & 48))
        throw Error(y(331));
      var b = X;
      X |= 32;
      var c = Bj;
      Bj = [];
      for (var d = 0; d < c.length; d += 2) {
        var e = c[d], f2 = c[d + 1], g2 = e.destroy;
        e.destroy = void 0;
        if ("function" === typeof g2)
          try {
            g2();
          } catch (k) {
            if (null === f2)
              throw Error(y(330));
            Wi(f2, k);
          }
      }
      c = Aj;
      Aj = [];
      for (d = 0; d < c.length; d += 2) {
        e = c[d];
        f2 = c[d + 1];
        try {
          var h2 = e.create;
          e.destroy = h2();
        } catch (k) {
          if (null === f2)
            throw Error(y(330));
          Wi(f2, k);
        }
      }
      for (h2 = a2.current.firstEffect; null !== h2; )
        a2 = h2.nextEffect, h2.nextEffect = null, h2.flags & 8 && (h2.sibling = null, h2.stateNode = null), h2 = a2;
      X = b;
      ig();
      return true;
    }
    function gk(a2, b, c) {
      b = Mi(c, b);
      b = Pi(a2, b, 1);
      Ag(a2, b);
      b = Hg();
      a2 = Kj(a2, 1);
      null !== a2 && ($c(a2, 1, b), Mj(a2, b));
    }
    function Wi(a2, b) {
      if (3 === a2.tag)
        gk(a2, a2, b);
      else
        for (var c = a2.return; null !== c; ) {
          if (3 === c.tag) {
            gk(c, a2, b);
            break;
          } else if (1 === c.tag) {
            var d = c.stateNode;
            if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) {
              a2 = Mi(b, a2);
              var e = Si(c, a2, 1);
              Ag(c, e);
              e = Hg();
              c = Kj(c, 1);
              if (null !== c)
                $c(c, 1, e), Mj(c, e);
              else if ("function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d)))
                try {
                  d.componentDidCatch(b, a2);
                } catch (f2) {
                }
              break;
            }
          }
          c = c.return;
        }
    }
    function Yj(a2, b, c) {
      var d = a2.pingCache;
      null !== d && d.delete(b);
      b = Hg();
      a2.pingedLanes |= a2.suspendedLanes & c;
      U === a2 && (W & c) === c && (4 === V || 3 === V && (W & 62914560) === W && 500 > O() - jj ? Qj(a2, 0) : uj |= c);
      Mj(a2, b);
    }
    function lj(a2, b) {
      var c = a2.stateNode;
      null !== c && c.delete(b);
      b = 0;
      0 === b && (b = a2.mode, 0 === (b & 2) ? b = 1 : 0 === (b & 4) ? b = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b = Yc(62914560 & ~Gj), 0 === b && (b = 4194304)));
      c = Hg();
      a2 = Kj(a2, b);
      null !== a2 && ($c(a2, b, c), Mj(a2, c));
    }
    var ck;
    ck = function(a2, b, c) {
      var d = b.lanes;
      if (null !== a2)
        if (a2.memoizedProps !== b.pendingProps || N.current)
          ug = true;
        else if (0 !== (c & d))
          ug = 0 !== (a2.flags & 16384) ? true : false;
        else {
          ug = false;
          switch (b.tag) {
            case 3:
              ri(b);
              sh();
              break;
            case 5:
              gh(b);
              break;
            case 1:
              Ff(b.type) && Jf(b);
              break;
            case 4:
              eh(b, b.stateNode.containerInfo);
              break;
            case 10:
              d = b.memoizedProps.value;
              var e = b.type._context;
              I(mg, e._currentValue);
              e._currentValue = d;
              break;
            case 13:
              if (null !== b.memoizedState) {
                if (0 !== (c & b.child.childLanes))
                  return ti(a2, b, c);
                I(P, P.current & 1);
                b = hi(a2, b, c);
                return null !== b ? b.sibling : null;
              }
              I(P, P.current & 1);
              break;
            case 19:
              d = 0 !== (c & b.childLanes);
              if (0 !== (a2.flags & 64)) {
                if (d)
                  return Ai(a2, b, c);
                b.flags |= 64;
              }
              e = b.memoizedState;
              null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
              I(P, P.current);
              if (d)
                break;
              else
                return null;
            case 23:
            case 24:
              return b.lanes = 0, mi(a2, b, c);
          }
          return hi(a2, b, c);
        }
      else
        ug = false;
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          d = b.type;
          null !== a2 && (a2.alternate = null, b.alternate = null, b.flags |= 2);
          a2 = b.pendingProps;
          e = Ef(b, M.current);
          tg(b, c);
          e = Ch(null, b, d, a2, e, c);
          b.flags |= 1;
          if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
            b.tag = 1;
            b.memoizedState = null;
            b.updateQueue = null;
            if (Ff(d)) {
              var f2 = true;
              Jf(b);
            } else
              f2 = false;
            b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
            xg(b);
            var g2 = d.getDerivedStateFromProps;
            "function" === typeof g2 && Gg(b, d, g2, a2);
            e.updater = Kg;
            b.stateNode = e;
            e._reactInternals = b;
            Og(b, d, a2, c);
            b = qi(null, b, d, true, f2, c);
          } else
            b.tag = 0, fi(null, b, e, c), b = b.child;
          return b;
        case 16:
          e = b.elementType;
          a: {
            null !== a2 && (a2.alternate = null, b.alternate = null, b.flags |= 2);
            a2 = b.pendingProps;
            f2 = e._init;
            e = f2(e._payload);
            b.type = e;
            f2 = b.tag = hk(e);
            a2 = lg(e, a2);
            switch (f2) {
              case 0:
                b = li(null, b, e, a2, c);
                break a;
              case 1:
                b = pi(null, b, e, a2, c);
                break a;
              case 11:
                b = gi(null, b, e, a2, c);
                break a;
              case 14:
                b = ii(null, b, e, lg(e.type, a2), d, c);
                break a;
            }
            throw Error(y(306, e, ""));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a2, b, d, e, c);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a2, b, d, e, c);
        case 3:
          ri(b);
          d = b.updateQueue;
          if (null === a2 || null === d)
            throw Error(y(282));
          d = b.pendingProps;
          e = b.memoizedState;
          e = null !== e ? e.element : null;
          yg(a2, b);
          Cg(b, d, null, c);
          d = b.memoizedState.element;
          if (d === e)
            sh(), b = hi(a2, b, c);
          else {
            e = b.stateNode;
            if (f2 = e.hydrate)
              kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f2 = lh = true;
            if (f2) {
              a2 = e.mutableSourceEagerHydrationData;
              if (null != a2)
                for (e = 0; e < a2.length; e += 2)
                  f2 = a2[e], f2._workInProgressVersionPrimary = a2[e + 1], th.push(f2);
              c = Zg(b, null, d, c);
              for (b.child = c; c; )
                c.flags = c.flags & -3 | 1024, c = c.sibling;
            } else
              fi(a2, b, d, c), sh();
            b = b.child;
          }
          return b;
        case 5:
          return gh(b), null === a2 && ph(b), d = b.type, e = b.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e.children, nf(d, e) ? g2 = null : null !== f2 && nf(d, f2) && (b.flags |= 16), oi(a2, b), fi(a2, b, g2, c), b.child;
        case 6:
          return null === a2 && ph(b), null;
        case 13:
          return ti(a2, b, c);
        case 4:
          return eh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a2 ? b.child = Yg(b, null, d, c) : fi(a2, b, d, c), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a2, b, d, e, c);
        case 7:
          return fi(a2, b, b.pendingProps, c), b.child;
        case 8:
          return fi(
            a2,
            b,
            b.pendingProps.children,
            c
          ), b.child;
        case 12:
          return fi(a2, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            d = b.type._context;
            e = b.pendingProps;
            g2 = b.memoizedProps;
            f2 = e.value;
            var h2 = b.type._context;
            I(mg, h2._currentValue);
            h2._currentValue = f2;
            if (null !== g2)
              if (h2 = g2.value, f2 = He(h2, f2) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h2, f2) : 1073741823) | 0, 0 === f2) {
                if (g2.children === e.children && !N.current) {
                  b = hi(a2, b, c);
                  break a;
                }
              } else
                for (h2 = b.child, null !== h2 && (h2.return = b); null !== h2; ) {
                  var k = h2.dependencies;
                  if (null !== k) {
                    g2 = h2.child;
                    for (var l2 = k.firstContext; null !== l2; ) {
                      if (l2.context === d && 0 !== (l2.observedBits & f2)) {
                        1 === h2.tag && (l2 = zg(-1, c & -c), l2.tag = 2, Ag(h2, l2));
                        h2.lanes |= c;
                        l2 = h2.alternate;
                        null !== l2 && (l2.lanes |= c);
                        sg(h2.return, c);
                        k.lanes |= c;
                        break;
                      }
                      l2 = l2.next;
                    }
                  } else
                    g2 = 10 === h2.tag ? h2.type === b.type ? null : h2.child : h2.child;
                  if (null !== g2)
                    g2.return = h2;
                  else
                    for (g2 = h2; null !== g2; ) {
                      if (g2 === b) {
                        g2 = null;
                        break;
                      }
                      h2 = g2.sibling;
                      if (null !== h2) {
                        h2.return = g2.return;
                        g2 = h2;
                        break;
                      }
                      g2 = g2.return;
                    }
                  h2 = g2;
                }
            fi(a2, b, e.children, c);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, f2 = b.pendingProps, d = f2.children, tg(b, c), e = vg(
            e,
            f2.unstable_observedBits
          ), d = d(e), b.flags |= 1, fi(a2, b, d, c), b.child;
        case 14:
          return e = b.type, f2 = lg(e, b.pendingProps), f2 = lg(e.type, f2), ii(a2, b, e, f2, d, c);
        case 15:
          return ki(a2, b, b.type, b.pendingProps, d, c);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), null !== a2 && (a2.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a2 = true, Jf(b)) : a2 = false, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, true, a2, c);
        case 19:
          return Ai(a2, b, c);
        case 23:
          return mi(a2, b, c);
        case 24:
          return mi(a2, b, c);
      }
      throw Error(y(156, b.tag));
    };
    function ik(a2, b, c, d) {
      this.tag = a2;
      this.key = c;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d;
      this.flags = 0;
      this.lastEffect = this.firstEffect = this.nextEffect = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function nh(a2, b, c, d) {
      return new ik(a2, b, c, d);
    }
    function ji(a2) {
      a2 = a2.prototype;
      return !(!a2 || !a2.isReactComponent);
    }
    function hk(a2) {
      if ("function" === typeof a2)
        return ji(a2) ? 1 : 0;
      if (void 0 !== a2 && null !== a2) {
        a2 = a2.$$typeof;
        if (a2 === Aa)
          return 11;
        if (a2 === Da)
          return 14;
      }
      return 2;
    }
    function Tg(a2, b) {
      var c = a2.alternate;
      null === c ? (c = nh(a2.tag, b, a2.key, a2.mode), c.elementType = a2.elementType, c.type = a2.type, c.stateNode = a2.stateNode, c.alternate = a2, a2.alternate = c) : (c.pendingProps = b, c.type = a2.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
      c.childLanes = a2.childLanes;
      c.lanes = a2.lanes;
      c.child = a2.child;
      c.memoizedProps = a2.memoizedProps;
      c.memoizedState = a2.memoizedState;
      c.updateQueue = a2.updateQueue;
      b = a2.dependencies;
      c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
      c.sibling = a2.sibling;
      c.index = a2.index;
      c.ref = a2.ref;
      return c;
    }
    function Vg(a2, b, c, d, e, f2) {
      var g2 = 2;
      d = a2;
      if ("function" === typeof a2)
        ji(a2) && (g2 = 1);
      else if ("string" === typeof a2)
        g2 = 5;
      else
        a:
          switch (a2) {
            case ua:
              return Xg(c.children, e, f2, b);
            case Ha:
              g2 = 8;
              e |= 16;
              break;
            case wa:
              g2 = 8;
              e |= 1;
              break;
            case xa:
              return a2 = nh(12, c, b, e | 8), a2.elementType = xa, a2.type = xa, a2.lanes = f2, a2;
            case Ba:
              return a2 = nh(13, c, b, e), a2.type = Ba, a2.elementType = Ba, a2.lanes = f2, a2;
            case Ca:
              return a2 = nh(19, c, b, e), a2.elementType = Ca, a2.lanes = f2, a2;
            case Ia:
              return vi(c, e, f2, b);
            case Ja:
              return a2 = nh(24, c, b, e), a2.elementType = Ja, a2.lanes = f2, a2;
            default:
              if ("object" === typeof a2 && null !== a2)
                switch (a2.$$typeof) {
                  case ya:
                    g2 = 10;
                    break a;
                  case za:
                    g2 = 9;
                    break a;
                  case Aa:
                    g2 = 11;
                    break a;
                  case Da:
                    g2 = 14;
                    break a;
                  case Ea:
                    g2 = 16;
                    d = null;
                    break a;
                  case Fa:
                    g2 = 22;
                    break a;
                }
              throw Error(y(130, null == a2 ? a2 : typeof a2, ""));
          }
      b = nh(g2, c, b, e);
      b.elementType = a2;
      b.type = d;
      b.lanes = f2;
      return b;
    }
    function Xg(a2, b, c, d) {
      a2 = nh(7, a2, d, b);
      a2.lanes = c;
      return a2;
    }
    function vi(a2, b, c, d) {
      a2 = nh(23, a2, d, b);
      a2.elementType = Ia;
      a2.lanes = c;
      return a2;
    }
    function Ug(a2, b, c) {
      a2 = nh(6, a2, null, b);
      a2.lanes = c;
      return a2;
    }
    function Wg(a2, b, c) {
      b = nh(4, null !== a2.children ? a2.children : [], a2.key, b);
      b.lanes = c;
      b.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
      return b;
    }
    function jk(a2, b, c) {
      this.tag = b;
      this.containerInfo = a2;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.pendingContext = this.context = null;
      this.hydrate = c;
      this.callbackNode = null;
      this.callbackPriority = 0;
      this.eventTimes = Zc(0);
      this.expirationTimes = Zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = Zc(0);
      this.mutableSourceEagerHydrationData = null;
    }
    function kk(a2, b, c) {
      var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: ta, key: null == d ? null : "" + d, children: a2, containerInfo: b, implementation: c };
    }
    function lk(a2, b, c, d) {
      var e = b.current, f2 = Hg(), g2 = Ig(e);
      a:
        if (c) {
          c = c._reactInternals;
          b: {
            if (Zb(c) !== c || 1 !== c.tag)
              throw Error(y(170));
            var h2 = c;
            do {
              switch (h2.tag) {
                case 3:
                  h2 = h2.stateNode.context;
                  break b;
                case 1:
                  if (Ff(h2.type)) {
                    h2 = h2.stateNode.__reactInternalMemoizedMergedChildContext;
                    break b;
                  }
              }
              h2 = h2.return;
            } while (null !== h2);
            throw Error(y(171));
          }
          if (1 === c.tag) {
            var k = c.type;
            if (Ff(k)) {
              c = If(c, k, h2);
              break a;
            }
          }
          c = h2;
        } else
          c = Cf;
      null === b.context ? b.context = c : b.pendingContext = c;
      b = zg(f2, g2);
      b.payload = { element: a2 };
      d = void 0 === d ? null : d;
      null !== d && (b.callback = d);
      Ag(e, b);
      Jg(e, g2, f2);
      return g2;
    }
    function mk(a2) {
      a2 = a2.current;
      if (!a2.child)
        return null;
      switch (a2.child.tag) {
        case 5:
          return a2.child.stateNode;
        default:
          return a2.child.stateNode;
      }
    }
    function nk(a2, b) {
      a2 = a2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        var c = a2.retryLane;
        a2.retryLane = 0 !== c && c < b ? c : b;
      }
    }
    function ok(a2, b) {
      nk(a2, b);
      (a2 = a2.alternate) && nk(a2, b);
    }
    function pk() {
      return null;
    }
    function qk(a2, b, c) {
      var d = null != c && null != c.hydrationOptions && c.hydrationOptions.mutableSources || null;
      c = new jk(a2, b, null != c && true === c.hydrate);
      b = nh(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
      c.current = b;
      b.stateNode = c;
      xg(b);
      a2[ff] = c.current;
      cf(8 === a2.nodeType ? a2.parentNode : a2);
      if (d)
        for (a2 = 0; a2 < d.length; a2++) {
          b = d[a2];
          var e = b._getVersion;
          e = e(b._source);
          null == c.mutableSourceEagerHydrationData ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
        }
      this._internalRoot = c;
    }
    qk.prototype.render = function(a2) {
      lk(a2, this._internalRoot, null, null);
    };
    qk.prototype.unmount = function() {
      var a2 = this._internalRoot, b = a2.containerInfo;
      lk(null, a2, null, function() {
        b[ff] = null;
      });
    };
    function rk(a2) {
      return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
    }
    function sk(a2, b) {
      b || (b = a2 ? 9 === a2.nodeType ? a2.documentElement : a2.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));
      if (!b)
        for (var c; c = a2.lastChild; )
          a2.removeChild(c);
      return new qk(a2, 0, b ? { hydrate: true } : void 0);
    }
    function tk(a2, b, c, d, e) {
      var f2 = c._reactRootContainer;
      if (f2) {
        var g2 = f2._internalRoot;
        if ("function" === typeof e) {
          var h2 = e;
          e = function() {
            var a3 = mk(g2);
            h2.call(a3);
          };
        }
        lk(b, g2, a2, e);
      } else {
        f2 = c._reactRootContainer = sk(c, d);
        g2 = f2._internalRoot;
        if ("function" === typeof e) {
          var k = e;
          e = function() {
            var a3 = mk(g2);
            k.call(a3);
          };
        }
        Xj(function() {
          lk(b, g2, a2, e);
        });
      }
      return mk(g2);
    }
    ec = function(a2) {
      if (13 === a2.tag) {
        var b = Hg();
        Jg(a2, 4, b);
        ok(a2, 4);
      }
    };
    fc = function(a2) {
      if (13 === a2.tag) {
        var b = Hg();
        Jg(a2, 67108864, b);
        ok(a2, 67108864);
      }
    };
    gc = function(a2) {
      if (13 === a2.tag) {
        var b = Hg(), c = Ig(a2);
        Jg(a2, c, b);
        ok(a2, c);
      }
    };
    hc = function(a2, b) {
      return b();
    };
    yb = function(a2, b, c) {
      switch (b) {
        case "input":
          ab(a2, c);
          b = c.name;
          if ("radio" === c.type && null != b) {
            for (c = a2; c.parentNode; )
              c = c.parentNode;
            c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
            for (b = 0; b < c.length; b++) {
              var d = c[b];
              if (d !== a2 && d.form === a2.form) {
                var e = Db(d);
                if (!e)
                  throw Error(y(90));
                Wa(d);
                ab(d, e);
              }
            }
          }
          break;
        case "textarea":
          ib(a2, c);
          break;
        case "select":
          b = c.value, null != b && fb(a2, !!c.multiple, b, false);
      }
    };
    Gb = Wj;
    Hb = function(a2, b, c, d, e) {
      var f2 = X;
      X |= 4;
      try {
        return gg(98, a2.bind(null, b, c, d, e));
      } finally {
        X = f2, 0 === X && (wj(), ig());
      }
    };
    Ib = function() {
      0 === (X & 49) && (Vj(), Oj());
    };
    Jb = function(a2, b) {
      var c = X;
      X |= 2;
      try {
        return a2(b);
      } finally {
        X = c, 0 === X && (wj(), ig());
      }
    };
    function uk(a2, b) {
      var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!rk(b))
        throw Error(y(200));
      return kk(a2, b, null, c);
    }
    var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
    var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
      a2 = cc(a2);
      return null === a2 ? null : a2.stateNode;
    }, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!yk.isDisabled && yk.supportsFiber)
        try {
          Lf = yk.inject(xk), Mf = yk;
        } catch (a2) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
    reactDom_production_min.createPortal = uk;
    reactDom_production_min.findDOMNode = function(a2) {
      if (null == a2)
        return null;
      if (1 === a2.nodeType)
        return a2;
      var b = a2._reactInternals;
      if (void 0 === b) {
        if ("function" === typeof a2.render)
          throw Error(y(188));
        throw Error(y(268, Object.keys(a2)));
      }
      a2 = cc(b);
      a2 = null === a2 ? null : a2.stateNode;
      return a2;
    };
    reactDom_production_min.flushSync = function(a2, b) {
      var c = X;
      if (0 !== (c & 48))
        return a2(b);
      X |= 1;
      try {
        if (a2)
          return gg(99, a2.bind(null, b));
      } finally {
        X = c, ig();
      }
    };
    reactDom_production_min.hydrate = function(a2, b, c) {
      if (!rk(b))
        throw Error(y(200));
      return tk(null, a2, b, true, c);
    };
    reactDom_production_min.render = function(a2, b, c) {
      if (!rk(b))
        throw Error(y(200));
      return tk(null, a2, b, false, c);
    };
    reactDom_production_min.unmountComponentAtNode = function(a2) {
      if (!rk(a2))
        throw Error(y(40));
      return a2._reactRootContainer ? (Xj(function() {
        tk(null, null, a2, false, function() {
          a2._reactRootContainer = null;
          a2[ff] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Wj;
    reactDom_production_min.unstable_createPortal = function(a2, b) {
      return uk(a2, b, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
    };
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b, c, d) {
      if (!rk(c))
        throw Error(y(200));
      if (null == a2 || void 0 === a2._reactInternals)
        throw Error(y(38));
      return tk(a2, b, c, false, d);
    };
    reactDom_production_min.version = "17.0.2";
    (function(module2) {
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        module2.exports = reactDom_production_min;
      }
    })(reactDom);
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDom.exports);
    class AngleDelta {
      constructor(x1, y1, x2, y2) {
        __publicField(this, "x");
        __publicField(this, "y");
        __publicField(this, "distance");
        __publicField(this, "angle");
        __publicField(this, "getVector", (magnitude, angle) => {
          let angleRadians = angle * Math.PI / 180;
          this.x = magnitude * Math.cos(angleRadians);
          this.y = magnitude * Math.sin(angleRadians);
          return this;
        });
        let x3 = x2 - x1;
        let y3 = y2 - y1;
        this.distance = Math.sqrt(x3 * x3 + y3 * y3);
        this.angle = Math.atan2(y3, x3) * 180 / Math.PI;
      }
    }
    var identicon = { exports: {} };
    var pnglib = { exports: {} };
    /**
    * A handy class to calculate color values.
    *
    * @version 1.0
    * @author Robert Eisele <robert@xarg.org>
    * @copyright Copyright (c) 2010, Robert Eisele
    * @link http://www.xarg.org/2010/03/generate-client-side-png-files-using-javascript/
    * @license http://www.opensource.org/licenses/bsd-license.php BSD License
    *
    */
    var hasRequiredPnglib;
    function requirePnglib() {
      if (hasRequiredPnglib)
        return pnglib.exports;
      hasRequiredPnglib = 1;
      (function(module2) {
        (function() {
          function write(buffer, offs) {
            for (var i2 = 2; i2 < arguments.length; i2++) {
              for (var j = 0; j < arguments[i2].length; j++) {
                buffer[offs++] = arguments[i2].charAt(j);
              }
            }
          }
          function byte2(w2) {
            return String.fromCharCode(w2 >> 8 & 255, w2 & 255);
          }
          function byte4(w2) {
            return String.fromCharCode(w2 >> 24 & 255, w2 >> 16 & 255, w2 >> 8 & 255, w2 & 255);
          }
          function byte2lsb(w2) {
            return String.fromCharCode(w2 & 255, w2 >> 8 & 255);
          }
          var PNGlib = function(width2, height2, depth) {
            this.width = width2;
            this.height = height2;
            this.depth = depth;
            this.pix_size = height2 * (width2 + 1);
            this.data_size = 2 + this.pix_size + 5 * Math.floor((65534 + this.pix_size) / 65535) + 4;
            this.ihdr_offs = 0;
            this.ihdr_size = 4 + 4 + 13 + 4;
            this.plte_offs = this.ihdr_offs + this.ihdr_size;
            this.plte_size = 4 + 4 + 3 * depth + 4;
            this.trns_offs = this.plte_offs + this.plte_size;
            this.trns_size = 4 + 4 + depth + 4;
            this.idat_offs = this.trns_offs + this.trns_size;
            this.idat_size = 4 + 4 + this.data_size + 4;
            this.iend_offs = this.idat_offs + this.idat_size;
            this.iend_size = 4 + 4 + 4;
            this.buffer_size = this.iend_offs + this.iend_size;
            this.buffer = new Array();
            this.palette = new Object();
            this.pindex = 0;
            var _crc32 = new Array();
            for (var i2 = 0; i2 < this.buffer_size; i2++) {
              this.buffer[i2] = "\0";
            }
            write(this.buffer, this.ihdr_offs, byte4(this.ihdr_size - 12), "IHDR", byte4(width2), byte4(height2), "\b");
            write(this.buffer, this.plte_offs, byte4(this.plte_size - 12), "PLTE");
            write(this.buffer, this.trns_offs, byte4(this.trns_size - 12), "tRNS");
            write(this.buffer, this.idat_offs, byte4(this.idat_size - 12), "IDAT");
            write(this.buffer, this.iend_offs, byte4(this.iend_size - 12), "IEND");
            var header = 8 + (7 << 4) << 8 | 3 << 6;
            header += 31 - header % 31;
            write(this.buffer, this.idat_offs + 8, byte2(header));
            for (var i2 = 0; (i2 << 16) - 1 < this.pix_size; i2++) {
              var size2, bits;
              if (i2 + 65535 < this.pix_size) {
                size2 = 65535;
                bits = "\0";
              } else {
                size2 = this.pix_size - (i2 << 16) - i2;
                bits = "";
              }
              write(this.buffer, this.idat_offs + 8 + 2 + (i2 << 16) + (i2 << 2), bits, byte2lsb(size2), byte2lsb(~size2));
            }
            for (var i2 = 0; i2 < 256; i2++) {
              var c = i2;
              for (var j = 0; j < 8; j++) {
                if (c & 1) {
                  c = -306674912 ^ c >> 1 & 2147483647;
                } else {
                  c = c >> 1 & 2147483647;
                }
              }
              _crc32[i2] = c;
            }
            this.index = function(x2, y2) {
              var i3 = y2 * (this.width + 1) + x2 + 1;
              var j2 = this.idat_offs + 8 + 2 + 5 * Math.floor(i3 / 65535 + 1) + i3;
              return j2;
            };
            this.color = function(red, green, blue, alpha) {
              alpha = alpha >= 0 ? alpha : 255;
              var color = ((alpha << 8 | red) << 8 | green) << 8 | blue;
              if (typeof this.palette[color] == "undefined") {
                if (this.pindex == this.depth)
                  return "\0";
                var ndx = this.plte_offs + 8 + 3 * this.pindex;
                this.buffer[ndx + 0] = String.fromCharCode(red);
                this.buffer[ndx + 1] = String.fromCharCode(green);
                this.buffer[ndx + 2] = String.fromCharCode(blue);
                this.buffer[this.trns_offs + 8 + this.pindex] = String.fromCharCode(alpha);
                this.palette[color] = String.fromCharCode(this.pindex++);
              }
              return this.palette[color];
            };
            this.getBase64 = function() {
              var s2 = this.getDump();
              var ch2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              var c1, c2, c3, e1, e2, e3, e4;
              var l2 = s2.length;
              var i3 = 0;
              var r2 = "";
              do {
                c1 = s2.charCodeAt(i3);
                e1 = c1 >> 2;
                c2 = s2.charCodeAt(i3 + 1);
                e2 = (c1 & 3) << 4 | c2 >> 4;
                c3 = s2.charCodeAt(i3 + 2);
                if (l2 < i3 + 2) {
                  e3 = 64;
                } else {
                  e3 = (c2 & 15) << 2 | c3 >> 6;
                }
                if (l2 < i3 + 3) {
                  e4 = 64;
                } else {
                  e4 = c3 & 63;
                }
                r2 += ch2.charAt(e1) + ch2.charAt(e2) + ch2.charAt(e3) + ch2.charAt(e4);
              } while ((i3 += 3) < l2);
              return r2;
            };
            this.getDump = function() {
              var BASE = 65521;
              var NMAX = 5552;
              var s1 = 1;
              var s2 = 0;
              var n2 = NMAX;
              for (var y2 = 0; y2 < this.height; y2++) {
                for (var x2 = -1; x2 < this.width; x2++) {
                  s1 += this.buffer[this.index(x2, y2)].charCodeAt(0);
                  s2 += s1;
                  if ((n2 -= 1) == 0) {
                    s1 %= BASE;
                    s2 %= BASE;
                    n2 = NMAX;
                  }
                }
              }
              s1 %= BASE;
              s2 %= BASE;
              write(this.buffer, this.idat_offs + this.idat_size - 8, byte4(s2 << 16 | s1));
              function crc32(png, offs, size3) {
                var crc = -1;
                for (var i3 = 4; i3 < size3 - 4; i3 += 1) {
                  crc = _crc32[(crc ^ png[offs + i3].charCodeAt(0)) & 255] ^ crc >> 8 & 16777215;
                }
                write(png, offs + size3 - 4, byte4(crc ^ -1));
              }
              crc32(this.buffer, this.ihdr_offs, this.ihdr_size);
              crc32(this.buffer, this.plte_offs, this.plte_size);
              crc32(this.buffer, this.trns_offs, this.trns_size);
              crc32(this.buffer, this.idat_offs, this.idat_size);
              crc32(this.buffer, this.iend_offs, this.iend_size);
              return "PNG\r\n\n" + this.buffer.join("");
            };
          };
          {
            module2.exports = PNGlib;
          }
        })();
      })(pnglib);
      return pnglib.exports;
    }
    (function(module2) {
      (function() {
        var PNGlib;
        {
          PNGlib = requirePnglib();
        }
        var Identicon2 = function(hash, options) {
          if (typeof hash !== "string" || hash.length < 15) {
            throw "A hash of at least 15 characters is required.";
          }
          this.defaults = {
            background: [240, 240, 240, 255],
            margin: 0.08,
            size: 64,
            saturation: 0.7,
            brightness: 0.5,
            format: "png"
          };
          this.options = typeof options === "object" ? options : this.defaults;
          if (typeof arguments[1] === "number") {
            this.options.size = arguments[1];
          }
          if (arguments[2]) {
            this.options.margin = arguments[2];
          }
          this.hash = hash;
          this.background = this.options.background || this.defaults.background;
          this.size = this.options.size || this.defaults.size;
          this.format = this.options.format || this.defaults.format;
          this.margin = this.options.margin !== void 0 ? this.options.margin : this.defaults.margin;
          var hue = parseInt(this.hash.substr(-7), 16) / 268435455;
          var saturation = this.options.saturation || this.defaults.saturation;
          var brightness = this.options.brightness || this.defaults.brightness;
          this.foreground = this.options.foreground || this.hsl2rgb(hue, saturation, brightness);
        };
        Identicon2.prototype = {
          background: null,
          foreground: null,
          hash: null,
          margin: null,
          size: null,
          format: null,
          image: function() {
            return this.isSvg() ? new Svg(this.size, this.foreground, this.background) : new PNGlib(this.size, this.size, 256);
          },
          render: function() {
            var image = this.image(), size2 = this.size, baseMargin = Math.floor(size2 * this.margin), cell = Math.floor((size2 - baseMargin * 2) / 5), margin = Math.floor((size2 - cell * 5) / 2), bg2 = image.color.apply(image, this.background), fg2 = image.color.apply(image, this.foreground);
            var i2, color;
            for (i2 = 0; i2 < 15; i2++) {
              color = parseInt(this.hash.charAt(i2), 16) % 2 ? bg2 : fg2;
              if (i2 < 5) {
                this.rectangle(2 * cell + margin, i2 * cell + margin, cell, cell, color, image);
              } else if (i2 < 10) {
                this.rectangle(1 * cell + margin, (i2 - 5) * cell + margin, cell, cell, color, image);
                this.rectangle(3 * cell + margin, (i2 - 5) * cell + margin, cell, cell, color, image);
              } else if (i2 < 15) {
                this.rectangle(0 * cell + margin, (i2 - 10) * cell + margin, cell, cell, color, image);
                this.rectangle(4 * cell + margin, (i2 - 10) * cell + margin, cell, cell, color, image);
              }
            }
            return image;
          },
          rectangle: function(x2, y2, w2, h2, color, image) {
            if (this.isSvg()) {
              image.rectangles.push({ x: x2, y: y2, w: w2, h: h2, color });
            } else {
              var i2, j;
              for (i2 = x2; i2 < x2 + w2; i2++) {
                for (j = y2; j < y2 + h2; j++) {
                  image.buffer[image.index(i2, j)] = color;
                }
              }
            }
          },
          hsl2rgb: function(h2, s2, b) {
            h2 *= 6;
            s2 = [
              b += s2 *= b < 0.5 ? b : 1 - b,
              b - h2 % 1 * s2 * 2,
              b -= s2 *= 2,
              b,
              b + h2 % 1 * s2,
              b + s2
            ];
            return [
              s2[~~h2 % 6] * 255,
              s2[(h2 | 16) % 6] * 255,
              s2[(h2 | 8) % 6] * 255
            ];
          },
          toString: function(raw) {
            if (raw) {
              return this.render().getDump();
            } else {
              return this.render().getBase64();
            }
          },
          isSvg: function() {
            return this.format.match(/svg/i);
          }
        };
        var Svg = function(size2, foreground, background) {
          this.size = size2;
          this.foreground = this.color.apply(this, foreground);
          this.background = this.color.apply(this, background);
          this.rectangles = [];
        };
        Svg.prototype = {
          size: null,
          foreground: null,
          background: null,
          rectangles: null,
          color: function(r2, g2, b, a2) {
            var values2 = [r2, g2, b].map(Math.round);
            values2.push(a2 >= 0 && a2 <= 255 ? a2 / 255 : 1);
            return "rgba(" + values2.join(",") + ")";
          },
          getDump: function() {
            var i2, xml, rect, fg2 = this.foreground, bg2 = this.background, stroke = this.size * 5e-3;
            xml = "<svg xmlns='http://www.w3.org/2000/svg' width='" + this.size + "' height='" + this.size + "' style='background-color:" + bg2 + ";'><g style='fill:" + fg2 + "; stroke:" + fg2 + "; stroke-width:" + stroke + ";'>";
            for (i2 = 0; i2 < this.rectangles.length; i2++) {
              rect = this.rectangles[i2];
              if (rect.color == bg2)
                continue;
              xml += "<rect  x='" + rect.x + "' y='" + rect.y + "' width='" + rect.w + "' height='" + rect.h + "'/>";
            }
            xml += "</g></svg>";
            return xml;
          },
          getBase64: function() {
            if ("function" === typeof btoa) {
              return btoa(this.getDump());
            } else if (Buffer) {
              return new Buffer(this.getDump(), "binary").toString("base64");
            } else {
              throw "Cannot generate base64 output";
            }
          }
        };
        {
          module2.exports = Identicon2;
        }
      })();
    })(identicon);
    const Identicon = identicon.exports;
    const hashFnv32a = (string, seed) => {
      let str = string;
      let i2, l2, hval = seed === void 0 ? 2166136261 : seed;
      for (i2 = 0, l2 = str.length; i2 < l2; i2++) {
        hval ^= str.charCodeAt(i2);
        hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
      }
      return ("00000000" + (hval >>> 0).toString(16)).substr(-8);
    };
    const createIdenticon = (seed, options) => {
      options = options ?? {};
      let hash = hashFnv32a(seed, 12345) + hashFnv32a(seed, 54321);
      let src2 = "data:image/svg+xml;base64," + new Identicon(hash, {
        background: options.background ?? [24, 27, 33, 1],
        margin: options.margin ?? 0,
        size: options.size ?? 60,
        format: options.format ?? "svg"
      });
      return src2.toString();
    };
    var promise = {};
    (function(exports2) {
      (function(global2) {
        var NativePromise = global2["Promise"];
        var nativePromiseSupported = NativePromise && "resolve" in NativePromise && "reject" in NativePromise && "all" in NativePromise && "race" in NativePromise && function() {
          var resolve2;
          new NativePromise(function(r2) {
            resolve2 = r2;
          });
          return typeof resolve2 === "function";
        }();
        if (exports2) {
          exports2.Promise = nativePromiseSupported ? NativePromise : Promise2;
          exports2.Polyfill = Promise2;
        } else {
          {
            if (!nativePromiseSupported)
              global2["Promise"] = Promise2;
          }
        }
        var PENDING = "pending";
        var SEALED = "sealed";
        var FULFILLED = "fulfilled";
        var REJECTED = "rejected";
        var NOOP = function() {
        };
        function isArray2(value2) {
          return Object.prototype.toString.call(value2) === "[object Array]";
        }
        var asyncSetTimer = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
        var asyncQueue = [];
        var asyncTimer;
        function asyncFlush() {
          for (var i2 = 0; i2 < asyncQueue.length; i2++)
            asyncQueue[i2][0](asyncQueue[i2][1]);
          asyncQueue = [];
          asyncTimer = false;
        }
        function asyncCall(callback, arg) {
          asyncQueue.push([callback, arg]);
          if (!asyncTimer) {
            asyncTimer = true;
            asyncSetTimer(asyncFlush, 0);
          }
        }
        function invokeResolver(resolver, promise2) {
          function resolvePromise(value2) {
            resolve(promise2, value2);
          }
          function rejectPromise(reason) {
            reject2(promise2, reason);
          }
          try {
            resolver(resolvePromise, rejectPromise);
          } catch (e) {
            rejectPromise(e);
          }
        }
        function invokeCallback(subscriber) {
          var owner = subscriber.owner;
          var settled = owner.state_;
          var value2 = owner.data_;
          var callback = subscriber[settled];
          var promise2 = subscriber.then;
          if (typeof callback === "function") {
            settled = FULFILLED;
            try {
              value2 = callback(value2);
            } catch (e) {
              reject2(promise2, e);
            }
          }
          if (!handleThenable(promise2, value2)) {
            if (settled === FULFILLED)
              resolve(promise2, value2);
            if (settled === REJECTED)
              reject2(promise2, value2);
          }
        }
        function handleThenable(promise2, value2) {
          var resolved;
          try {
            if (promise2 === value2)
              throw new TypeError("A promises callback cannot return that same promise.");
            if (value2 && (typeof value2 === "function" || typeof value2 === "object")) {
              var then = value2.then;
              if (typeof then === "function") {
                then.call(value2, function(val) {
                  if (!resolved) {
                    resolved = true;
                    if (value2 !== val)
                      resolve(promise2, val);
                    else
                      fulfill(promise2, val);
                  }
                }, function(reason) {
                  if (!resolved) {
                    resolved = true;
                    reject2(promise2, reason);
                  }
                });
                return true;
              }
            }
          } catch (e) {
            if (!resolved)
              reject2(promise2, e);
            return true;
          }
          return false;
        }
        function resolve(promise2, value2) {
          if (promise2 === value2 || !handleThenable(promise2, value2))
            fulfill(promise2, value2);
        }
        function fulfill(promise2, value2) {
          if (promise2.state_ === PENDING) {
            promise2.state_ = SEALED;
            promise2.data_ = value2;
            asyncCall(publishFulfillment, promise2);
          }
        }
        function reject2(promise2, reason) {
          if (promise2.state_ === PENDING) {
            promise2.state_ = SEALED;
            promise2.data_ = reason;
            asyncCall(publishRejection, promise2);
          }
        }
        function publish(promise2) {
          var callbacks = promise2.then_;
          promise2.then_ = void 0;
          for (var i2 = 0; i2 < callbacks.length; i2++) {
            invokeCallback(callbacks[i2]);
          }
        }
        function publishFulfillment(promise2) {
          promise2.state_ = FULFILLED;
          publish(promise2);
        }
        function publishRejection(promise2) {
          promise2.state_ = REJECTED;
          publish(promise2);
        }
        function Promise2(resolver) {
          if (typeof resolver !== "function")
            throw new TypeError("Promise constructor takes a function argument");
          if (this instanceof Promise2 === false)
            throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
          this.then_ = [];
          invokeResolver(resolver, this);
        }
        Promise2.prototype = {
          constructor: Promise2,
          state_: PENDING,
          then_: null,
          data_: void 0,
          then: function(onFulfillment, onRejection) {
            var subscriber = {
              owner: this,
              then: new this.constructor(NOOP),
              fulfilled: onFulfillment,
              rejected: onRejection
            };
            if (this.state_ === FULFILLED || this.state_ === REJECTED) {
              asyncCall(invokeCallback, subscriber);
            } else {
              this.then_.push(subscriber);
            }
            return subscriber.then;
          },
          "catch": function(onRejection) {
            return this.then(null, onRejection);
          }
        };
        Promise2.all = function(promises) {
          var Class = this;
          if (!isArray2(promises))
            throw new TypeError("You must pass an array to Promise.all().");
          return new Class(function(resolve2, reject3) {
            var results = [];
            var remaining = 0;
            function resolver(index2) {
              remaining++;
              return function(value2) {
                results[index2] = value2;
                if (!--remaining)
                  resolve2(results);
              };
            }
            for (var i2 = 0, promise2; i2 < promises.length; i2++) {
              promise2 = promises[i2];
              if (promise2 && typeof promise2.then === "function")
                promise2.then(resolver(i2), reject3);
              else
                results[i2] = promise2;
            }
            if (!remaining)
              resolve2(results);
          });
        };
        Promise2.race = function(promises) {
          var Class = this;
          if (!isArray2(promises))
            throw new TypeError("You must pass an array to Promise.race().");
          return new Class(function(resolve2, reject3) {
            for (var i2 = 0, promise2; i2 < promises.length; i2++) {
              promise2 = promises[i2];
              if (promise2 && typeof promise2.then === "function")
                promise2.then(resolve2, reject3);
              else
                resolve2(promise2);
            }
          });
        };
        Promise2.resolve = function(value2) {
          var Class = this;
          if (value2 && typeof value2 === "object" && value2.constructor === Class)
            return value2;
          return new Class(function(resolve2) {
            resolve2(value2);
          });
        };
        Promise2.reject = function(reason) {
          var Class = this;
          return new Class(function(resolve2, reject3) {
            reject3(reason);
          });
        };
      })(typeof window != "undefined" ? window : typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : commonjsGlobal);
    })(promise);
    /*!
     * @pixi/polyfill - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/polyfill is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    if (!window.Promise) {
      window.Promise = promise.Polyfill;
    }
    if (!Object.assign) {
      Object.assign = objectAssign;
    }
    var ONE_FRAME_TIME = 16;
    if (!(Date.now && Date.prototype.getTime)) {
      Date.now = function now2() {
        return new Date().getTime();
      };
    }
    if (!(window.performance && window.performance.now)) {
      var startTime_1 = Date.now();
      if (!window.performance) {
        window.performance = {};
      }
      window.performance.now = function() {
        return Date.now() - startTime_1;
      };
    }
    var lastTime = Date.now();
    var vendors = ["ms", "moz", "webkit", "o"];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
      var p = vendors[x];
      window.requestAnimationFrame = window[p + "RequestAnimationFrame"];
      window.cancelAnimationFrame = window[p + "CancelAnimationFrame"] || window[p + "CancelRequestAnimationFrame"];
    }
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(callback) {
        if (typeof callback !== "function") {
          throw new TypeError(callback + "is not a function");
        }
        var currentTime = Date.now();
        var delay2 = ONE_FRAME_TIME + lastTime - currentTime;
        if (delay2 < 0) {
          delay2 = 0;
        }
        lastTime = currentTime;
        return window.setTimeout(function() {
          lastTime = Date.now();
          callback(performance.now());
        }, delay2);
      };
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = function(id2) {
        return clearTimeout(id2);
      };
    }
    if (!Math.sign) {
      Math.sign = function mathSign(x2) {
        x2 = Number(x2);
        if (x2 === 0 || isNaN(x2)) {
          return x2;
        }
        return x2 > 0 ? 1 : -1;
      };
    }
    if (!Number.isInteger) {
      Number.isInteger = function numberIsInteger(value2) {
        return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
      };
    }
    if (!window.ArrayBuffer) {
      window.ArrayBuffer = Array;
    }
    if (!window.Float32Array) {
      window.Float32Array = Array;
    }
    if (!window.Uint32Array) {
      window.Uint32Array = Array;
    }
    if (!window.Uint16Array) {
      window.Uint16Array = Array;
    }
    if (!window.Uint8Array) {
      window.Uint8Array = Array;
    }
    if (!window.Int32Array) {
      window.Int32Array = Array;
    }
    var appleIphone = /iPhone/i;
    var appleIpod = /iPod/i;
    var appleTablet = /iPad/i;
    var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
    var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
    var androidTablet = /Android/i;
    var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
    var amazonTablet = /Silk/i;
    var windowsPhone = /Windows Phone/i;
    var windowsTablet = /\bWindows(?:.+)ARM\b/i;
    var otherBlackBerry = /BlackBerry/i;
    var otherBlackBerry10 = /BB10/i;
    var otherOpera = /Opera Mini/i;
    var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
    var otherFirefox = /Mobile(?:.+)Firefox\b/i;
    var isAppleTabletOnIos13 = function(navigator2) {
      return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
    };
    function createMatch(userAgent) {
      return function(regex) {
        return regex.test(userAgent);
      };
    }
    function isMobile$1(param) {
      var nav = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
      };
      if (!param && typeof navigator !== "undefined") {
        nav = {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          maxTouchPoints: navigator.maxTouchPoints || 0
        };
      } else if (typeof param === "string") {
        nav.userAgent = param;
      } else if (param && param.userAgent) {
        nav = {
          userAgent: param.userAgent,
          platform: param.platform,
          maxTouchPoints: param.maxTouchPoints || 0
        };
      }
      var userAgent = nav.userAgent;
      var tmp = userAgent.split("[FBAN");
      if (typeof tmp[1] !== "undefined") {
        userAgent = tmp[0];
      }
      tmp = userAgent.split("Twitter");
      if (typeof tmp[1] !== "undefined") {
        userAgent = tmp[0];
      }
      var match = createMatch(userAgent);
      var result2 = {
        apple: {
          phone: match(appleIphone) && !match(windowsPhone),
          ipod: match(appleIpod),
          tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
          universal: match(appleUniversal),
          device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
        },
        amazon: {
          phone: match(amazonPhone),
          tablet: !match(amazonPhone) && match(amazonTablet),
          device: match(amazonPhone) || match(amazonTablet)
        },
        android: {
          phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
          tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
          device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
        },
        windows: {
          phone: match(windowsPhone),
          tablet: match(windowsTablet),
          device: match(windowsPhone) || match(windowsTablet)
        },
        other: {
          blackberry: match(otherBlackBerry),
          blackberry10: match(otherBlackBerry10),
          opera: match(otherOpera),
          firefox: match(otherFirefox),
          chrome: match(otherChrome),
          device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
        },
        any: false,
        phone: false,
        tablet: false
      };
      result2.any = result2.apple.device || result2.android.device || result2.windows.device || result2.other.device;
      result2.phone = result2.apple.phone || result2.android.phone || result2.windows.phone;
      result2.tablet = result2.apple.tablet || result2.android.tablet || result2.windows.tablet;
      return result2;
    }
    /*!
     * @pixi/settings - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/settings is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var isMobile = isMobile$1(window.navigator);
    function maxRecommendedTextures(max2) {
      var allowMax = true;
      if (isMobile.tablet || isMobile.phone) {
        if (isMobile.apple.device) {
          var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
          if (match) {
            var majorVersion = parseInt(match[1], 10);
            if (majorVersion < 11) {
              allowMax = false;
            }
          }
        }
        if (isMobile.android.device) {
          var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
          if (match) {
            var majorVersion = parseInt(match[1], 10);
            if (majorVersion < 7) {
              allowMax = false;
            }
          }
        }
      }
      return allowMax ? max2 : 4;
    }
    function canUploadSameBuffer() {
      return !isMobile.apple.device;
    }
    var settings = {
      MIPMAP_TEXTURES: 1,
      ANISOTROPIC_LEVEL: 0,
      RESOLUTION: 1,
      FILTER_RESOLUTION: 1,
      SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
      SPRITE_BATCH_SIZE: 4096,
      RENDER_OPTIONS: {
        view: null,
        antialias: false,
        autoDensity: false,
        transparent: false,
        backgroundColor: 0,
        clearBeforeRender: true,
        preserveDrawingBuffer: false,
        width: 800,
        height: 600,
        legacy: false
      },
      GC_MODE: 0,
      GC_MAX_IDLE: 60 * 60,
      GC_MAX_CHECK_COUNT: 60 * 10,
      WRAP_MODE: 33071,
      SCALE_MODE: 1,
      PRECISION_VERTEX: "highp",
      PRECISION_FRAGMENT: isMobile.apple.device ? "highp" : "mediump",
      CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
      CREATE_IMAGE_BITMAP: false,
      ROUND_PIXELS: false
    };
    var eventemitter3 = { exports: {} };
    (function(module2) {
      var has2 = Object.prototype.hasOwnProperty, prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context2, once2) {
        this.fn = fn;
        this.context = context2;
        this.once = once2 || false;
      }
      function addListener(emitter, event, fn, context2, once2) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context2 || emitter, once2), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events2, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events2 = this._events) {
          if (has2.call(events2, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events2));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
          ee2[i2] = handlers[i2].fn;
        }
        return ee2;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i2;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i2 = 0; i2 < length; i2++) {
            if (listeners[i2].once)
              this.removeListener(event, listeners[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i2].fn.call(listeners[i2].context);
                break;
              case 2:
                listeners[i2].fn.call(listeners[i2].context, a1);
                break;
              case 3:
                listeners[i2].fn.call(listeners[i2].context, a1, a2);
                break;
              case 4:
                listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i2].fn.apply(listeners[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context2) {
        return addListener(this, event, fn, context2, false);
      };
      EventEmitter2.prototype.once = function once2(event, fn, context2) {
        return addListener(this, event, fn, context2, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once2) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once2 || listeners.once) && (!context2 || listeners.context === context2)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events2 = [], length = listeners.length; i2 < length; i2++) {
            if (listeners[i2].fn !== fn || once2 && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
              events2.push(listeners[i2]);
            }
          }
          if (events2.length)
            this._events[evt] = events2.length === 1 ? events2[0] : events2;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      {
        module2.exports = EventEmitter2;
      }
    })(eventemitter3);
    const EventEmitter = eventemitter3.exports;
    var earcut$1 = { exports: {} };
    earcut$1.exports = earcut;
    earcut$1.exports.default = earcut;
    function earcut(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x2, y2, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i2 = dim; i2 < outerLen; i2 += dim) {
          x2 = data[i2];
          y2 = data[i2 + 1];
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i2, last2;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i2 = start; i2 < end; i2 += dim)
          last2 = insertNode(i2, data[i2], data[i2 + 1], last2);
      } else {
        for (i2 = end - dim; i2 >= start; i2 -= dim)
          last2 = insertNode(i2, data[i2], data[i2 + 1], last2);
      }
      if (last2 && equals(last2, last2.next)) {
        removeNode(last2);
        last2 = last2.next;
      }
      return last2;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p2 = start, again;
      do {
        again = false;
        if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
          removeNode(p2);
          p2 = end = p2.prev;
          if (p2 === p2.next)
            break;
          again = true;
        } else {
          p2 = p2.next;
        }
      } while (again || p2 !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a2 = ear.prev, b = ear, c = ear.next;
      if (area(a2, b, c) >= 0)
        return false;
      var ax = a2.x, bx = b.x, cx = c.x, ay = a2.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p2 = c.next;
      while (p2 !== a2) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a2 = ear.prev, b = ear, c = ear.next;
      if (area(a2, b, c) >= 0)
        return false;
      var ax = a2.x, bx = b.x, cx = c.x, ay = a2.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p2 = ear.prevZ, n2 = ear.nextZ;
      while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      while (p2 && p2.z >= minZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
      }
      while (n2 && n2.z <= maxZ) {
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p2 = start;
      do {
        var a2 = p2.prev, b = p2.next.next;
        if (!equals(a2, b) && intersects(a2, p2, p2.next, b) && locallyInside(a2, b) && locallyInside(b, a2)) {
          triangles.push(a2.i / dim | 0);
          triangles.push(p2.i / dim | 0);
          triangles.push(b.i / dim | 0);
          removeNode(p2);
          removeNode(p2.next);
          p2 = start = b;
        }
        p2 = p2.next;
      } while (p2 !== start);
      return filterPoints(p2);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a2 = start;
      do {
        var b = a2.next.next;
        while (b !== a2.prev) {
          if (a2.i !== b.i && isValidDiagonal(a2, b)) {
            var c = splitPolygon(a2, b);
            a2 = filterPoints(a2, a2.next);
            c = filterPoints(c, c.next);
            earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b = b.next;
        }
        a2 = a2.next;
      } while (a2 !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue2 = [], i2, len, start, end, list;
      for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
        start = holeIndices[i2] * dim;
        end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue2.push(getLeftmost(list));
      }
      queue2.sort(compareX);
      for (i2 = 0; i2 < queue2.length; i2++) {
        outerNode = eliminateHole(queue2[i2], outerNode);
      }
      return outerNode;
    }
    function compareX(a2, b) {
      return a2.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
      do {
        if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
          var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
          if (x2 <= hx && x2 > qx) {
            qx = x2;
            m2 = p2.x < p2.next.x ? p2 : p2.next;
            if (x2 === hx)
              return m2;
          }
        }
        p2 = p2.next;
      } while (p2 !== outerNode);
      if (!m2)
        return null;
      var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
      p2 = m2;
      do {
        if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
          tan = Math.abs(hy - p2.y) / (hx - p2.x);
          if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
            m2 = p2;
            tanMin = tan;
          }
        }
        p2 = p2.next;
      } while (p2 !== stop);
      return m2;
    }
    function sectorContainsSector(m2, p2) {
      return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p2 = start;
      do {
        if (p2.z === 0)
          p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
        p2.prevZ = p2.prev;
        p2.nextZ = p2.next;
        p2 = p2.next;
      } while (p2 !== start);
      p2.prevZ.nextZ = null;
      p2.prevZ = null;
      sortLinked(p2);
    }
    function sortLinked(list) {
      var i2, p2, q2, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p2 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p2) {
          numMerges++;
          q2 = p2;
          pSize = 0;
          for (i2 = 0; i2 < inSize; i2++) {
            pSize++;
            q2 = q2.nextZ;
            if (!q2)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q2) {
            if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
              e = p2;
              p2 = p2.nextZ;
              pSize--;
            } else {
              e = q2;
              q2 = q2.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p2 = q2;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x2, y2, minX, minY, invSize) {
      x2 = (x2 - minX) * invSize | 0;
      y2 = (y2 - minY) * invSize | 0;
      x2 = (x2 | x2 << 8) & 16711935;
      x2 = (x2 | x2 << 4) & 252645135;
      x2 = (x2 | x2 << 2) & 858993459;
      x2 = (x2 | x2 << 1) & 1431655765;
      y2 = (y2 | y2 << 8) & 16711935;
      y2 = (y2 | y2 << 4) & 252645135;
      y2 = (y2 | y2 << 2) & 858993459;
      y2 = (y2 | y2 << 1) & 1431655765;
      return x2 | y2 << 1;
    }
    function getLeftmost(start) {
      var p2 = start, leftmost = start;
      do {
        if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
          leftmost = p2;
        p2 = p2.next;
      } while (p2 !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a2, b) {
      return a2.next.i !== b.i && a2.prev.i !== b.i && !intersectsPolygon(a2, b) && (locallyInside(a2, b) && locallyInside(b, a2) && middleInside(a2, b) && (area(a2.prev, a2, b.prev) || area(a2, b.prev, b)) || equals(a2, b) && area(a2.prev, a2, a2.next) > 0 && area(b.prev, b, b.next) > 0);
    }
    function area(p2, q2, r2) {
      return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign$2(area(p1, q1, p2));
      var o2 = sign$2(area(p1, q1, q2));
      var o3 = sign$2(area(p2, q2, p1));
      var o4 = sign$2(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p2, q2, r2) {
      return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
    }
    function sign$2(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a2, b) {
      var p2 = a2;
      do {
        if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b.i && p2.next.i !== b.i && intersects(p2, p2.next, a2, b))
          return true;
        p2 = p2.next;
      } while (p2 !== a2);
      return false;
    }
    function locallyInside(a2, b) {
      return area(a2.prev, a2, a2.next) < 0 ? area(a2, b, a2.next) >= 0 && area(a2, a2.prev, b) >= 0 : area(a2, b, a2.prev) < 0 || area(a2, a2.next, b) < 0;
    }
    function middleInside(a2, b) {
      var p2 = a2, inside = false, px = (a2.x + b.x) / 2, py = (a2.y + b.y) / 2;
      do {
        if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
          inside = !inside;
        p2 = p2.next;
      } while (p2 !== a2);
      return inside;
    }
    function splitPolygon(a2, b) {
      var a22 = new Node(a2.i, a2.x, a2.y), b2 = new Node(b.i, b.x, b.y), an = a2.next, bp = b.prev;
      a2.next = b;
      b.prev = a2;
      a22.next = an;
      an.prev = a22;
      b2.next = a22;
      a22.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i2, x2, y2, last2) {
      var p2 = new Node(i2, x2, y2);
      if (!last2) {
        p2.prev = p2;
        p2.next = p2;
      } else {
        p2.next = last2.next;
        p2.prev = last2;
        last2.next.prev = p2;
        last2.next = p2;
      }
      return p2;
    }
    function removeNode(p2) {
      p2.next.prev = p2.prev;
      p2.prev.next = p2.next;
      if (p2.prevZ)
        p2.prevZ.nextZ = p2.nextZ;
      if (p2.nextZ)
        p2.nextZ.prevZ = p2.prevZ;
    }
    function Node(i2, x2, y2) {
      this.i = i2;
      this.x = x2;
      this.y = y2;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
          var start = holeIndices[i2] * dim;
          var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i2 = 0; i2 < triangles.length; i2 += 3) {
        var a2 = triangles[i2] * dim;
        var b = triangles[i2 + 1] * dim;
        var c = triangles[i2 + 2] * dim;
        trianglesArea += Math.abs(
          (data[a2] - data[c]) * (data[b + 1] - data[a2 + 1]) - (data[a2] - data[b]) * (data[c + 1] - data[a2 + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i2 = start, j = end - dim; i2 < end; i2 += dim) {
        sum += (data[j] - data[i2]) * (data[i2 + 1] + data[j + 1]);
        j = i2;
      }
      return sum;
    }
    earcut.flatten = function(data) {
      var dim = data[0][0].length, result2 = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i2 = 0; i2 < data.length; i2++) {
        for (var j = 0; j < data[i2].length; j++) {
          for (var d = 0; d < dim; d++)
            result2.vertices.push(data[i2][j][d]);
        }
        if (i2 > 0) {
          holeIndex += data[i2 - 1].length;
          result2.holes.push(holeIndex);
        }
      }
      return result2;
    };
    var url = {};
    var punycode$1 = { exports: {} };
    /*! https://mths.be/punycode v1.3.2 by @mathias */
    (function(module2, exports2) {
      (function(root2) {
        var freeExports = exports2 && !exports2.nodeType && exports2;
        var freeModule = module2 && !module2.nodeType && module2;
        var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
          root2 = freeGlobal;
        }
        var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
        function error(type) {
          throw RangeError(errors[type]);
        }
        function map2(array, fn) {
          var length = array.length;
          var result2 = [];
          while (length--) {
            result2[length] = fn(array[length]);
          }
          return result2;
        }
        function mapDomain(string, fn) {
          var parts = string.split("@");
          var result2 = "";
          if (parts.length > 1) {
            result2 = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators, ".");
          var labels = string.split(".");
          var encoded = map2(labels, fn).join(".");
          return result2 + encoded;
        }
        function ucs2decode(string) {
          var output = [], counter = 0, length = string.length, value2, extra;
          while (counter < length) {
            value2 = string.charCodeAt(counter++);
            if (value2 >= 55296 && value2 <= 56319 && counter < length) {
              extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value2);
                counter--;
              }
            } else {
              output.push(value2);
            }
          }
          return output;
        }
        function ucs2encode(array) {
          return map2(array, function(value2) {
            var output = "";
            if (value2 > 65535) {
              value2 -= 65536;
              output += stringFromCharCode(value2 >>> 10 & 1023 | 55296);
              value2 = 56320 | value2 & 1023;
            }
            output += stringFromCharCode(value2);
            return output;
          }).join("");
        }
        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        }
        function digitToBasic(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }
        function adapt(delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }
        function decode2(input) {
          var output = [], inputLength = input.length, out, i2 = 0, n2 = initialN, bias = initialBias, basic, j, index2, oldi, w2, k, digit, t2, baseMinusT;
          basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (j = 0; j < basic; ++j) {
            if (input.charCodeAt(j) >= 128) {
              error("not-basic");
            }
            output.push(input.charCodeAt(j));
          }
          for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
            for (oldi = i2, w2 = 1, k = base; ; k += base) {
              if (index2 >= inputLength) {
                error("invalid-input");
              }
              digit = basicToDigit(input.charCodeAt(index2++));
              if (digit >= base || digit > floor((maxInt - i2) / w2)) {
                error("overflow");
              }
              i2 += digit * w2;
              t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (digit < t2) {
                break;
              }
              baseMinusT = base - t2;
              if (w2 > floor(maxInt / baseMinusT)) {
                error("overflow");
              }
              w2 *= baseMinusT;
            }
            out = output.length + 1;
            bias = adapt(i2 - oldi, out, oldi == 0);
            if (floor(i2 / out) > maxInt - n2) {
              error("overflow");
            }
            n2 += floor(i2 / out);
            i2 %= out;
            output.splice(i2++, 0, n2);
          }
          return ucs2encode(output);
        }
        function encode2(input) {
          var n2, delta, handledCPCount, basicLength, bias, j, m2, q2, k, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
          input = ucs2decode(input);
          inputLength = input.length;
          n2 = initialN;
          delta = 0;
          bias = initialBias;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 128) {
              output.push(stringFromCharCode(currentValue));
            }
          }
          handledCPCount = basicLength = output.length;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            for (m2 = maxInt, j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue >= n2 && currentValue < m2) {
                m2 = currentValue;
              }
            }
            handledCPCountPlusOne = handledCPCount + 1;
            if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error("overflow");
            }
            delta += (m2 - n2) * handledCPCountPlusOne;
            n2 = m2;
            for (j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue < n2 && ++delta > maxInt) {
                error("overflow");
              }
              if (currentValue == n2) {
                for (q2 = delta, k = base; ; k += base) {
                  t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q2 < t2) {
                    break;
                  }
                  qMinusT = q2 - t2;
                  baseMinusT = base - t2;
                  output.push(
                    stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
                  );
                  q2 = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q2, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
            ++delta;
            ++n2;
          }
          return output.join("");
        }
        function toUnicode(input) {
          return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
          });
        }
        function toASCII(input) {
          return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
          });
        }
        punycode2 = {
          "version": "1.3.2",
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode2,
          "encode": encode2,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        if (freeExports && freeModule) {
          if (module2.exports == freeExports) {
            freeModule.exports = punycode2;
          } else {
            for (key in punycode2) {
              punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
            }
          }
        } else {
          root2.punycode = punycode2;
        }
      })(commonjsGlobal);
    })(punycode$1, punycode$1.exports);
    var util$1 = {
      isString: function(arg) {
        return typeof arg === "string";
      },
      isObject: function(arg) {
        return typeof arg === "object" && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };
    var querystring$1 = {};
    function hasOwnProperty$2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var decode = function(qs, sep, eq2, options) {
      sep = sep || "&";
      eq2 = eq2 || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i2 = 0; i2 < len; ++i2) {
        var x2 = qs[i2].replace(regexp, "%20"), idx = x2.indexOf(eq2), kstr, vstr, k, v2;
        if (idx >= 0) {
          kstr = x2.substr(0, idx);
          vstr = x2.substr(idx + 1);
        } else {
          kstr = x2;
          vstr = "";
        }
        k = decodeURIComponent(kstr);
        v2 = decodeURIComponent(vstr);
        if (!hasOwnProperty$2(obj, k)) {
          obj[k] = v2;
        } else if (Array.isArray(obj[k])) {
          obj[k].push(v2);
        } else {
          obj[k] = [obj[k], v2];
        }
      }
      return obj;
    };
    var stringifyPrimitive = function(v2) {
      switch (typeof v2) {
        case "string":
          return v2;
        case "boolean":
          return v2 ? "true" : "false";
        case "number":
          return isFinite(v2) ? v2 : "";
        default:
          return "";
      }
    };
    var encode$2 = function(obj, sep, eq2, name) {
      sep = sep || "&";
      eq2 = eq2 || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return Object.keys(obj).map(function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq2;
          if (Array.isArray(obj[k])) {
            return obj[k].map(function(v2) {
              return ks + encodeURIComponent(stringifyPrimitive(v2));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
      }
      if (!name)
        return "";
      return encodeURIComponent(stringifyPrimitive(name)) + eq2 + encodeURIComponent(stringifyPrimitive(obj));
    };
    querystring$1.decode = querystring$1.parse = decode;
    querystring$1.encode = querystring$1.stringify = encode$2;
    var punycode = punycode$1.exports;
    var util = util$1;
    var parse = url.parse = urlParse;
    url.resolve = urlResolve;
    url.resolveObject = urlResolveObject;
    url.format = urlFormat;
    url.Url = Url$1;
    function Url$1() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
      "javascript": true,
      "javascript:": true
    }, hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    }, slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    }, querystring = querystring$1;
    function urlParse(url2, parseQueryString, slashesDenoteHost) {
      if (url2 && util.isObject(url2) && url2 instanceof Url$1)
        return url2;
      var u2 = new Url$1();
      u2.parse(url2, parseQueryString, slashesDenoteHost);
      return u2;
    }
    Url$1.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url2)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
      }
      var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url2 = uSplit.join(splitter);
      var rest2 = url2;
      rest2 = rest2.trim();
      if (!slashesDenoteHost && url2.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest2);
        if (simplePath) {
          this.path = rest2;
          this.href = rest2;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto2 = protocolPattern.exec(rest2);
      if (proto2) {
        proto2 = proto2[0];
        var lowerProto = proto2.toLowerCase();
        this.protocol = lowerProto;
        rest2 = rest2.substr(proto2.length);
      }
      if (slashesDenoteHost || proto2 || rest2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest2.substr(0, 2) === "//";
        if (slashes && !(proto2 && hostlessProtocol[proto2])) {
          rest2 = rest2.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto2] && (slashes || proto2 && !slashedProtocol[proto2])) {
        var hostEnd = -1;
        for (var i2 = 0; i2 < hostEndingChars.length; i2++) {
          var hec = rest2.indexOf(hostEndingChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest2.lastIndexOf("@");
        } else {
          atSign = rest2.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest2.slice(0, atSign);
          rest2 = rest2.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i2 = 0; i2 < nonHostChars.length; i2++) {
          var hec = rest2.indexOf(nonHostChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        if (hostEnd === -1)
          hostEnd = rest2.length;
        this.host = rest2.slice(0, hostEnd);
        rest2 = rest2.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
            var part = hostparts[i2];
            if (!part)
              continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i2);
                var notHost = hostparts.slice(i2 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest2 = "/" + notHost.join(".") + rest2;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p2 = this.port ? ":" + this.port : "";
        var h2 = this.hostname || "";
        this.host = h2 + p2;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest2[0] !== "/") {
            rest2 = "/" + rest2;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {
          var ae2 = autoEscape[i2];
          if (rest2.indexOf(ae2) === -1)
            continue;
          var esc = encodeURIComponent(ae2);
          if (esc === ae2) {
            esc = escape(ae2);
          }
          rest2 = rest2.split(ae2).join(esc);
        }
      }
      var hash = rest2.indexOf("#");
      if (hash !== -1) {
        this.hash = rest2.substr(hash);
        rest2 = rest2.slice(0, hash);
      }
      var qm = rest2.indexOf("?");
      if (qm !== -1) {
        this.search = rest2.substr(qm);
        this.query = rest2.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest2 = rest2.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest2)
        this.pathname = rest2;
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p2 = this.pathname || "";
        var s2 = this.search || "";
        this.path = p2 + s2;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (util.isString(obj))
        obj = urlParse(obj);
      if (!(obj instanceof Url$1))
        return Url$1.prototype.format.call(obj);
      return obj.format();
    }
    Url$1.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":")
        protocol += ":";
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/")
          pathname = "/" + pathname;
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#")
        hash = "#" + hash;
      if (search && search.charAt(0) !== "?")
        search = "?" + search;
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    Url$1.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    function urlResolveObject(source, relative) {
      if (!source)
        return relative;
      return urlParse(source, false, true).resolveObject(relative);
    }
    Url$1.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel = new Url$1();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result2 = new Url$1();
      var tkeys = Object.keys(this);
      for (var tk2 = 0; tk2 < tkeys.length; tk2++) {
        var tkey = tkeys[tk2];
        result2[tkey] = this[tkey];
      }
      result2.hash = relative.hash;
      if (relative.href === "") {
        result2.href = result2.format();
        return result2;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk2 = 0; rk2 < rkeys.length; rk2++) {
          var rkey = rkeys[rk2];
          if (rkey !== "protocol")
            result2[rkey] = relative[rkey];
        }
        if (slashedProtocol[result2.protocol] && result2.hostname && !result2.pathname) {
          result2.path = result2.pathname = "/";
        }
        result2.href = result2.format();
        return result2;
      }
      if (relative.protocol && relative.protocol !== result2.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys2 = Object.keys(relative);
          for (var v2 = 0; v2 < keys2.length; v2++) {
            var k = keys2[v2];
            result2[k] = relative[k];
          }
          result2.href = result2.format();
          return result2;
        }
        result2.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result2.pathname = relPath.join("/");
        } else {
          result2.pathname = relative.pathname;
        }
        result2.search = relative.search;
        result2.query = relative.query;
        result2.host = relative.host || "";
        result2.auth = relative.auth;
        result2.hostname = relative.hostname || relative.host;
        result2.port = relative.port;
        if (result2.pathname || result2.search) {
          var p2 = result2.pathname || "";
          var s2 = result2.search || "";
          result2.path = p2 + s2;
        }
        result2.slashes = result2.slashes || relative.slashes;
        result2.href = result2.format();
        return result2;
      }
      var isSourceAbs = result2.pathname && result2.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result2.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result2.pathname && result2.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result2.protocol && !slashedProtocol[result2.protocol];
      if (psychotic) {
        result2.hostname = "";
        result2.port = null;
        if (result2.host) {
          if (srcPath[0] === "")
            srcPath[0] = result2.host;
          else
            srcPath.unshift(result2.host);
        }
        result2.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result2.host = relative.host || relative.host === "" ? relative.host : result2.host;
        result2.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result2.hostname;
        result2.search = relative.search;
        result2.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result2.search = relative.search;
        result2.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result2.hostname = result2.host = srcPath.shift();
          var authInHost = result2.host && result2.host.indexOf("@") > 0 ? result2.host.split("@") : false;
          if (authInHost) {
            result2.auth = authInHost.shift();
            result2.host = result2.hostname = authInHost.shift();
          }
        }
        result2.search = relative.search;
        result2.query = relative.query;
        if (!util.isNull(result2.pathname) || !util.isNull(result2.search)) {
          result2.path = (result2.pathname ? result2.pathname : "") + (result2.search ? result2.search : "");
        }
        result2.href = result2.format();
        return result2;
      }
      if (!srcPath.length) {
        result2.pathname = null;
        if (result2.search) {
          result2.path = "/" + result2.search;
        } else {
          result2.path = null;
        }
        result2.href = result2.format();
        return result2;
      }
      var last2 = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result2.host || relative.host || srcPath.length > 1) && (last2 === "." || last2 === "..") || last2 === "";
      var up = 0;
      for (var i2 = srcPath.length; i2 >= 0; i2--) {
        last2 = srcPath[i2];
        if (last2 === ".") {
          srcPath.splice(i2, 1);
        } else if (last2 === "..") {
          srcPath.splice(i2, 1);
          up++;
        } else if (up) {
          srcPath.splice(i2, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result2.hostname = result2.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        var authInHost = result2.host && result2.host.indexOf("@") > 0 ? result2.host.split("@") : false;
        if (authInHost) {
          result2.auth = authInHost.shift();
          result2.host = result2.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result2.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result2.pathname = null;
        result2.path = null;
      } else {
        result2.pathname = srcPath.join("/");
      }
      if (!util.isNull(result2.pathname) || !util.isNull(result2.search)) {
        result2.path = (result2.pathname ? result2.pathname : "") + (result2.search ? result2.search : "");
      }
      result2.auth = relative.auth || result2.auth;
      result2.slashes = result2.slashes || relative.slashes;
      result2.href = result2.format();
      return result2;
    };
    Url$1.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host)
        this.hostname = host;
    };
    /*!
     * @pixi/constants - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/constants is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var ENV$1;
    (function(ENV2) {
      ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
      ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
      ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
    })(ENV$1 || (ENV$1 = {}));
    var RENDERER_TYPE$1;
    (function(RENDERER_TYPE2) {
      RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
      RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
      RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
    })(RENDERER_TYPE$1 || (RENDERER_TYPE$1 = {}));
    var BUFFER_BITS$1;
    (function(BUFFER_BITS2) {
      BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
      BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
      BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
    })(BUFFER_BITS$1 || (BUFFER_BITS$1 = {}));
    var BLEND_MODES$1;
    (function(BLEND_MODES2) {
      BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
      BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
      BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
      BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
      BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
      BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
      BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
      BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
      BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
      BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
      BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
      BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
      BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
      BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
      BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
      BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
      BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
      BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
      BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
      BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
      BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
      BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
      BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
      BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
      BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
      BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
      BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
      BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
      BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
      BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
      BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
      BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
    })(BLEND_MODES$1 || (BLEND_MODES$1 = {}));
    var DRAW_MODES$1;
    (function(DRAW_MODES2) {
      DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
      DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
      DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
      DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
      DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
      DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
      DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    })(DRAW_MODES$1 || (DRAW_MODES$1 = {}));
    var FORMATS$1;
    (function(FORMATS2) {
      FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
      FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
      FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
      FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
      FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    })(FORMATS$1 || (FORMATS$1 = {}));
    var TARGETS$1;
    (function(TARGETS2) {
      TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    })(TARGETS$1 || (TARGETS$1 = {}));
    var TYPES$1;
    (function(TYPES2) {
      TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
      TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
    })(TYPES$1 || (TYPES$1 = {}));
    var SCALE_MODES$1;
    (function(SCALE_MODES2) {
      SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
      SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
    })(SCALE_MODES$1 || (SCALE_MODES$1 = {}));
    var WRAP_MODES$1;
    (function(WRAP_MODES2) {
      WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
      WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
      WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    })(WRAP_MODES$1 || (WRAP_MODES$1 = {}));
    var MIPMAP_MODES$1;
    (function(MIPMAP_MODES2) {
      MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
      MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
      MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
    })(MIPMAP_MODES$1 || (MIPMAP_MODES$1 = {}));
    var ALPHA_MODES$1;
    (function(ALPHA_MODES2) {
      ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
      ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
      ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
      ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
      ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
      ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
    })(ALPHA_MODES$1 || (ALPHA_MODES$1 = {}));
    var CLEAR_MODES$1;
    (function(CLEAR_MODES2) {
      CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
      CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
      CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
      CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
      CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
      CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
    })(CLEAR_MODES$1 || (CLEAR_MODES$1 = {}));
    var GC_MODES$1;
    (function(GC_MODES2) {
      GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
      GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
    })(GC_MODES$1 || (GC_MODES$1 = {}));
    var PRECISION$1;
    (function(PRECISION2) {
      PRECISION2["LOW"] = "lowp";
      PRECISION2["MEDIUM"] = "mediump";
      PRECISION2["HIGH"] = "highp";
    })(PRECISION$1 || (PRECISION$1 = {}));
    var MASK_TYPES$1;
    (function(MASK_TYPES2) {
      MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
      MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
      MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
      MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
    })(MASK_TYPES$1 || (MASK_TYPES$1 = {}));
    var MSAA_QUALITY$1;
    (function(MSAA_QUALITY2) {
      MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
      MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
      MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
      MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
    })(MSAA_QUALITY$1 || (MSAA_QUALITY$1 = {}));
    /*!
     * @pixi/utils - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/utils is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    settings.RETINA_PREFIX = /@([0-9\.]+)x/;
    settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = true;
    var saidHello = false;
    var VERSION$2 = "5.3.12";
    function sayHello(type) {
      var _a2;
      if (saidHello) {
        return;
      }
      if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
        var args = [
          "\n %c %c %c PixiJS " + VERSION$2 + " -  " + type + "   %c  %c  http://www.pixijs.com/  %c %c %c%c \n\n",
          "background: #ff66a5; padding:5px 0;",
          "background: #ff66a5; padding:5px 0;",
          "color: #ff66a5; background: #030307; padding:5px 0;",
          "background: #ff66a5; padding:5px 0;",
          "background: #ffc3dc; padding:5px 0;",
          "background: #ff66a5; padding:5px 0;",
          "color: #ff2424; background: #fff; padding:5px 0;",
          "color: #ff2424; background: #fff; padding:5px 0;",
          "color: #ff2424; background: #fff; padding:5px 0;"
        ];
        (_a2 = window.console).log.apply(_a2, args);
      } else if (window.console) {
        window.console.log("PixiJS " + VERSION$2 + " - " + type + " - http://www.pixijs.com/");
      }
      saidHello = true;
    }
    var supported;
    function isWebGLSupported() {
      if (typeof supported === "undefined") {
        supported = function supported2() {
          var contextOptions = {
            stencil: true,
            failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
          };
          try {
            if (!window.WebGLRenderingContext) {
              return false;
            }
            var canvas2 = document.createElement("canvas");
            var gl = canvas2.getContext("webgl", contextOptions) || canvas2.getContext("experimental-webgl", contextOptions);
            var success = !!(gl && gl.getContextAttributes().stencil);
            if (gl) {
              var loseContext = gl.getExtension("WEBGL_lose_context");
              if (loseContext) {
                loseContext.loseContext();
              }
            }
            gl = null;
            return success;
          } catch (e) {
            return false;
          }
        }();
      }
      return supported;
    }
    function hex2rgb(hex, out) {
      if (out === void 0) {
        out = [];
      }
      out[0] = (hex >> 16 & 255) / 255;
      out[1] = (hex >> 8 & 255) / 255;
      out[2] = (hex & 255) / 255;
      return out;
    }
    function hex2string(hex) {
      var hexString = hex.toString(16);
      hexString = "000000".substr(0, 6 - hexString.length) + hexString;
      return "#" + hexString;
    }
    function string2hex(string) {
      if (typeof string === "string" && string[0] === "#") {
        string = string.substr(1);
      }
      return parseInt(string, 16);
    }
    function mapPremultipliedBlendModes() {
      var pm = [];
      var npm = [];
      for (var i2 = 0; i2 < 32; i2++) {
        pm[i2] = i2;
        npm[i2] = i2;
      }
      pm[BLEND_MODES$1.NORMAL_NPM] = BLEND_MODES$1.NORMAL;
      pm[BLEND_MODES$1.ADD_NPM] = BLEND_MODES$1.ADD;
      pm[BLEND_MODES$1.SCREEN_NPM] = BLEND_MODES$1.SCREEN;
      npm[BLEND_MODES$1.NORMAL] = BLEND_MODES$1.NORMAL_NPM;
      npm[BLEND_MODES$1.ADD] = BLEND_MODES$1.ADD_NPM;
      npm[BLEND_MODES$1.SCREEN] = BLEND_MODES$1.SCREEN_NPM;
      var array = [];
      array.push(npm);
      array.push(pm);
      return array;
    }
    var premultiplyBlendMode = mapPremultipliedBlendModes();
    function correctBlendMode(blendMode, premultiplied) {
      return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
    }
    function premultiplyRgba(rgb, alpha, out, premultiply) {
      out = out || new Float32Array(4);
      if (premultiply || premultiply === void 0) {
        out[0] = rgb[0] * alpha;
        out[1] = rgb[1] * alpha;
        out[2] = rgb[2] * alpha;
      } else {
        out[0] = rgb[0];
        out[1] = rgb[1];
        out[2] = rgb[2];
      }
      out[3] = alpha;
      return out;
    }
    function premultiplyTint(tint, alpha) {
      if (alpha === 1) {
        return (alpha * 255 << 24) + tint;
      }
      if (alpha === 0) {
        return 0;
      }
      var R2 = tint >> 16 & 255;
      var G2 = tint >> 8 & 255;
      var B2 = tint & 255;
      R2 = R2 * alpha + 0.5 | 0;
      G2 = G2 * alpha + 0.5 | 0;
      B2 = B2 * alpha + 0.5 | 0;
      return (alpha * 255 << 24) + (R2 << 16) + (G2 << 8) + B2;
    }
    function premultiplyTintToRgba(tint, alpha, out, premultiply) {
      out = out || new Float32Array(4);
      out[0] = (tint >> 16 & 255) / 255;
      out[1] = (tint >> 8 & 255) / 255;
      out[2] = (tint & 255) / 255;
      if (premultiply || premultiply === void 0) {
        out[0] *= alpha;
        out[1] *= alpha;
        out[2] *= alpha;
      }
      out[3] = alpha;
      return out;
    }
    function createIndicesForQuads(size2, outBuffer) {
      if (outBuffer === void 0) {
        outBuffer = null;
      }
      var totalIndices = size2 * 6;
      outBuffer = outBuffer || new Uint16Array(totalIndices);
      if (outBuffer.length !== totalIndices) {
        throw new Error("Out buffer length is incorrect, got " + outBuffer.length + " and expected " + totalIndices);
      }
      for (var i2 = 0, j = 0; i2 < totalIndices; i2 += 6, j += 4) {
        outBuffer[i2 + 0] = j + 0;
        outBuffer[i2 + 1] = j + 1;
        outBuffer[i2 + 2] = j + 2;
        outBuffer[i2 + 3] = j + 0;
        outBuffer[i2 + 4] = j + 2;
        outBuffer[i2 + 5] = j + 3;
      }
      return outBuffer;
    }
    function nextPow2(v2) {
      v2 += v2 === 0 ? 1 : 0;
      --v2;
      v2 |= v2 >>> 1;
      v2 |= v2 >>> 2;
      v2 |= v2 >>> 4;
      v2 |= v2 >>> 8;
      v2 |= v2 >>> 16;
      return v2 + 1;
    }
    function isPow2(v2) {
      return !(v2 & v2 - 1) && !!v2;
    }
    function log2(v2) {
      var r2 = (v2 > 65535 ? 1 : 0) << 4;
      v2 >>>= r2;
      var shift = (v2 > 255 ? 1 : 0) << 3;
      v2 >>>= shift;
      r2 |= shift;
      shift = (v2 > 15 ? 1 : 0) << 2;
      v2 >>>= shift;
      r2 |= shift;
      shift = (v2 > 3 ? 1 : 0) << 1;
      v2 >>>= shift;
      r2 |= shift;
      return r2 | v2 >> 1;
    }
    function removeItems(arr, startIdx, removeCount) {
      var length = arr.length;
      var i2;
      if (startIdx >= length || removeCount === 0) {
        return;
      }
      removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
      var len = length - removeCount;
      for (i2 = startIdx; i2 < len; ++i2) {
        arr[i2] = arr[i2 + removeCount];
      }
      arr.length = len;
    }
    function sign$1(n2) {
      if (n2 === 0) {
        return 0;
      }
      return n2 < 0 ? -1 : 1;
    }
    var nextUid = 0;
    function uid() {
      return ++nextUid;
    }
    var warnings = {};
    function deprecation(version, message, ignoreDepth) {
      if (ignoreDepth === void 0) {
        ignoreDepth = 3;
      }
      if (warnings[message]) {
        return;
      }
      var stack = new Error().stack;
      if (typeof stack === "undefined") {
        console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
      } else {
        stack = stack.split("\n").splice(ignoreDepth).join("\n");
        if (console.groupCollapsed) {
          console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", message + "\nDeprecated since v" + version);
          console.warn(stack);
          console.groupEnd();
        } else {
          console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version);
          console.warn(stack);
        }
      }
      warnings[message] = true;
    }
    var ProgramCache = {};
    var TextureCache = /* @__PURE__ */ Object.create(null);
    var BaseTextureCache = /* @__PURE__ */ Object.create(null);
    var CanvasRenderTarget = function() {
      function CanvasRenderTarget2(width2, height2, resolution) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        this.resolution = resolution || settings.RESOLUTION;
        this.resize(width2, height2);
      }
      CanvasRenderTarget2.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      };
      CanvasRenderTarget2.prototype.resize = function(width2, height2) {
        this.canvas.width = width2 * this.resolution;
        this.canvas.height = height2 * this.resolution;
      };
      CanvasRenderTarget2.prototype.destroy = function() {
        this.context = null;
        this.canvas = null;
      };
      Object.defineProperty(CanvasRenderTarget2.prototype, "width", {
        get: function() {
          return this.canvas.width;
        },
        set: function(val) {
          this.canvas.width = val;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CanvasRenderTarget2.prototype, "height", {
        get: function() {
          return this.canvas.height;
        },
        set: function(val) {
          this.canvas.height = val;
        },
        enumerable: false,
        configurable: true
      });
      return CanvasRenderTarget2;
    }();
    function trimCanvas(canvas2) {
      var width2 = canvas2.width;
      var height2 = canvas2.height;
      var context2 = canvas2.getContext("2d");
      var imageData = context2.getImageData(0, 0, width2, height2);
      var pixels = imageData.data;
      var len = pixels.length;
      var bound = {
        top: null,
        left: null,
        right: null,
        bottom: null
      };
      var data = null;
      var i2;
      var x2;
      var y2;
      for (i2 = 0; i2 < len; i2 += 4) {
        if (pixels[i2 + 3] !== 0) {
          x2 = i2 / 4 % width2;
          y2 = ~~(i2 / 4 / width2);
          if (bound.top === null) {
            bound.top = y2;
          }
          if (bound.left === null) {
            bound.left = x2;
          } else if (x2 < bound.left) {
            bound.left = x2;
          }
          if (bound.right === null) {
            bound.right = x2 + 1;
          } else if (bound.right < x2) {
            bound.right = x2 + 1;
          }
          if (bound.bottom === null) {
            bound.bottom = y2;
          } else if (bound.bottom < y2) {
            bound.bottom = y2;
          }
        }
      }
      if (bound.top !== null) {
        width2 = bound.right - bound.left;
        height2 = bound.bottom - bound.top + 1;
        data = context2.getImageData(bound.left, bound.top, width2, height2);
      }
      return {
        height: height2,
        width: width2,
        data
      };
    }
    var tempAnchor$1;
    function determineCrossOrigin(url2, loc) {
      if (loc === void 0) {
        loc = window.location;
      }
      if (url2.indexOf("data:") === 0) {
        return "";
      }
      loc = loc || window.location;
      if (!tempAnchor$1) {
        tempAnchor$1 = document.createElement("a");
      }
      tempAnchor$1.href = url2;
      var parsedUrl = parse(tempAnchor$1.href);
      var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
      if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
        return "anonymous";
      }
      return "";
    }
    function getResolutionOfUrl(url2, defaultValue2) {
      var resolution = settings.RETINA_PREFIX.exec(url2);
      if (resolution) {
        return parseFloat(resolution[1]);
      }
      return defaultValue2 !== void 0 ? defaultValue2 : 1;
    }
    /*!
     * @pixi/math - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/math is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var PI_2 = Math.PI * 2;
    var RAD_TO_DEG = 180 / Math.PI;
    var DEG_TO_RAD = Math.PI / 180;
    var SHAPES;
    (function(SHAPES2) {
      SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
      SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
      SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
      SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
      SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
    })(SHAPES || (SHAPES = {}));
    var Rectangle = function() {
      function Rectangle2(x2, y2, width2, height2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (width2 === void 0) {
          width2 = 0;
        }
        if (height2 === void 0) {
          height2 = 0;
        }
        this.x = Number(x2);
        this.y = Number(y2);
        this.width = Number(width2);
        this.height = Number(height2);
        this.type = SHAPES.RECT;
      }
      Object.defineProperty(Rectangle2.prototype, "left", {
        get: function() {
          return this.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle2.prototype, "right", {
        get: function() {
          return this.x + this.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle2.prototype, "top", {
        get: function() {
          return this.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle2.prototype, "bottom", {
        get: function() {
          return this.y + this.height;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Rectangle2, "EMPTY", {
        get: function() {
          return new Rectangle2(0, 0, 0, 0);
        },
        enumerable: false,
        configurable: true
      });
      Rectangle2.prototype.clone = function() {
        return new Rectangle2(this.x, this.y, this.width, this.height);
      };
      Rectangle2.prototype.copyFrom = function(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      };
      Rectangle2.prototype.copyTo = function(rectangle) {
        rectangle.x = this.x;
        rectangle.y = this.y;
        rectangle.width = this.width;
        rectangle.height = this.height;
        return rectangle;
      };
      Rectangle2.prototype.contains = function(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x2 >= this.x && x2 < this.x + this.width) {
          if (y2 >= this.y && y2 < this.y + this.height) {
            return true;
          }
        }
        return false;
      };
      Rectangle2.prototype.pad = function(paddingX, paddingY) {
        if (paddingX === void 0) {
          paddingX = 0;
        }
        if (paddingY === void 0) {
          paddingY = paddingX;
        }
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
      };
      Rectangle2.prototype.fit = function(rectangle) {
        var x1 = Math.max(this.x, rectangle.x);
        var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.max(this.y, rectangle.y);
        var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x2 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
        return this;
      };
      Rectangle2.prototype.ceil = function(resolution, eps) {
        if (resolution === void 0) {
          resolution = 1;
        }
        if (eps === void 0) {
          eps = 1e-3;
        }
        var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x2 - this.x;
        this.height = y2 - this.y;
        return this;
      };
      Rectangle2.prototype.enlarge = function(rectangle) {
        var x1 = Math.min(this.x, rectangle.x);
        var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.min(this.y, rectangle.y);
        var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
        return this;
      };
      return Rectangle2;
    }();
    var Circle = function() {
      function Circle2(x2, y2, radius) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (radius === void 0) {
          radius = 0;
        }
        this.x = x2;
        this.y = y2;
        this.radius = radius;
        this.type = SHAPES.CIRC;
      }
      Circle2.prototype.clone = function() {
        return new Circle2(this.x, this.y, this.radius);
      };
      Circle2.prototype.contains = function(x2, y2) {
        if (this.radius <= 0) {
          return false;
        }
        var r2 = this.radius * this.radius;
        var dx = this.x - x2;
        var dy = this.y - y2;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
      };
      Circle2.prototype.getBounds = function() {
        return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
      };
      return Circle2;
    }();
    var Ellipse = function() {
      function Ellipse2(x2, y2, halfWidth, halfHeight) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (halfWidth === void 0) {
          halfWidth = 0;
        }
        if (halfHeight === void 0) {
          halfHeight = 0;
        }
        this.x = x2;
        this.y = y2;
        this.width = halfWidth;
        this.height = halfHeight;
        this.type = SHAPES.ELIP;
      }
      Ellipse2.prototype.clone = function() {
        return new Ellipse2(this.x, this.y, this.width, this.height);
      };
      Ellipse2.prototype.contains = function(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        var normx = (x2 - this.x) / this.width;
        var normy = (y2 - this.y) / this.height;
        normx *= normx;
        normy *= normy;
        return normx + normy <= 1;
      };
      Ellipse2.prototype.getBounds = function() {
        return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
      };
      return Ellipse2;
    }();
    var Polygon = function() {
      function Polygon2() {
        var arguments$1 = arguments;
        var points = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          points[_i] = arguments$1[_i];
        }
        var flat = Array.isArray(points[0]) ? points[0] : points;
        if (typeof flat[0] !== "number") {
          var p2 = [];
          for (var i2 = 0, il = flat.length; i2 < il; i2++) {
            p2.push(flat[i2].x, flat[i2].y);
          }
          flat = p2;
        }
        this.points = flat;
        this.type = SHAPES.POLY;
        this.closeStroke = true;
      }
      Polygon2.prototype.clone = function() {
        var points = this.points.slice();
        var polygon = new Polygon2(points);
        polygon.closeStroke = this.closeStroke;
        return polygon;
      };
      Polygon2.prototype.contains = function(x2, y2) {
        var inside = false;
        var length = this.points.length / 2;
        for (var i2 = 0, j = length - 1; i2 < length; j = i2++) {
          var xi2 = this.points[i2 * 2];
          var yi2 = this.points[i2 * 2 + 1];
          var xj2 = this.points[j * 2];
          var yj2 = this.points[j * 2 + 1];
          var intersect = yi2 > y2 !== yj2 > y2 && x2 < (xj2 - xi2) * ((y2 - yi2) / (yj2 - yi2)) + xi2;
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      };
      return Polygon2;
    }();
    var RoundedRectangle = function() {
      function RoundedRectangle2(x2, y2, width2, height2, radius) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (width2 === void 0) {
          width2 = 0;
        }
        if (height2 === void 0) {
          height2 = 0;
        }
        if (radius === void 0) {
          radius = 20;
        }
        this.x = x2;
        this.y = y2;
        this.width = width2;
        this.height = height2;
        this.radius = radius;
        this.type = SHAPES.RREC;
      }
      RoundedRectangle2.prototype.clone = function() {
        return new RoundedRectangle2(this.x, this.y, this.width, this.height, this.radius);
      };
      RoundedRectangle2.prototype.contains = function(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x2 >= this.x && x2 <= this.x + this.width) {
          if (y2 >= this.y && y2 <= this.y + this.height) {
            if (y2 >= this.y + this.radius && y2 <= this.y + this.height - this.radius || x2 >= this.x + this.radius && x2 <= this.x + this.width - this.radius) {
              return true;
            }
            var dx = x2 - (this.x + this.radius);
            var dy = y2 - (this.y + this.radius);
            var radius2 = this.radius * this.radius;
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x2 - (this.x + this.width - this.radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dy = y2 - (this.y + this.height - this.radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x2 - (this.x + this.radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
          }
        }
        return false;
      };
      return RoundedRectangle2;
    }();
    var Point = function() {
      function Point2(x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        this.x = x2;
        this.y = y2;
      }
      Point2.prototype.clone = function() {
        return new Point2(this.x, this.y);
      };
      Point2.prototype.copyFrom = function(p2) {
        this.set(p2.x, p2.y);
        return this;
      };
      Point2.prototype.copyTo = function(p2) {
        p2.set(this.x, this.y);
        return p2;
      };
      Point2.prototype.equals = function(p2) {
        return p2.x === this.x && p2.y === this.y;
      };
      Point2.prototype.set = function(x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = x2;
        }
        this.x = x2;
        this.y = y2;
        return this;
      };
      return Point2;
    }();
    var ObservablePoint = function() {
      function ObservablePoint2(cb2, scope, x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        this._x = x2;
        this._y = y2;
        this.cb = cb2;
        this.scope = scope;
      }
      ObservablePoint2.prototype.clone = function(cb2, scope) {
        if (cb2 === void 0) {
          cb2 = this.cb;
        }
        if (scope === void 0) {
          scope = this.scope;
        }
        return new ObservablePoint2(cb2, scope, this._x, this._y);
      };
      ObservablePoint2.prototype.set = function(x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = x2;
        }
        if (this._x !== x2 || this._y !== y2) {
          this._x = x2;
          this._y = y2;
          this.cb.call(this.scope);
        }
        return this;
      };
      ObservablePoint2.prototype.copyFrom = function(p2) {
        if (this._x !== p2.x || this._y !== p2.y) {
          this._x = p2.x;
          this._y = p2.y;
          this.cb.call(this.scope);
        }
        return this;
      };
      ObservablePoint2.prototype.copyTo = function(p2) {
        p2.set(this._x, this._y);
        return p2;
      };
      ObservablePoint2.prototype.equals = function(p2) {
        return p2.x === this._x && p2.y === this._y;
      };
      Object.defineProperty(ObservablePoint2.prototype, "x", {
        get: function() {
          return this._x;
        },
        set: function(value2) {
          if (this._x !== value2) {
            this._x = value2;
            this.cb.call(this.scope);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ObservablePoint2.prototype, "y", {
        get: function() {
          return this._y;
        },
        set: function(value2) {
          if (this._y !== value2) {
            this._y = value2;
            this.cb.call(this.scope);
          }
        },
        enumerable: false,
        configurable: true
      });
      return ObservablePoint2;
    }();
    var Matrix = function() {
      function Matrix2(a2, b, c, d, tx, ty) {
        if (a2 === void 0) {
          a2 = 1;
        }
        if (b === void 0) {
          b = 0;
        }
        if (c === void 0) {
          c = 0;
        }
        if (d === void 0) {
          d = 1;
        }
        if (tx === void 0) {
          tx = 0;
        }
        if (ty === void 0) {
          ty = 0;
        }
        this.array = null;
        this.a = a2;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
      }
      Matrix2.prototype.fromArray = function(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
      };
      Matrix2.prototype.set = function(a2, b, c, d, tx, ty) {
        this.a = a2;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        return this;
      };
      Matrix2.prototype.toArray = function(transpose, out) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        var array = out || this.array;
        if (transpose) {
          array[0] = this.a;
          array[1] = this.b;
          array[2] = 0;
          array[3] = this.c;
          array[4] = this.d;
          array[5] = 0;
          array[6] = this.tx;
          array[7] = this.ty;
          array[8] = 1;
        } else {
          array[0] = this.a;
          array[1] = this.c;
          array[2] = this.tx;
          array[3] = this.b;
          array[4] = this.d;
          array[5] = this.ty;
          array[6] = 0;
          array[7] = 0;
          array[8] = 1;
        }
        return array;
      };
      Matrix2.prototype.apply = function(pos, newPos) {
        newPos = newPos || new Point();
        var x2 = pos.x;
        var y2 = pos.y;
        newPos.x = this.a * x2 + this.c * y2 + this.tx;
        newPos.y = this.b * x2 + this.d * y2 + this.ty;
        return newPos;
      };
      Matrix2.prototype.applyInverse = function(pos, newPos) {
        newPos = newPos || new Point();
        var id2 = 1 / (this.a * this.d + this.c * -this.b);
        var x2 = pos.x;
        var y2 = pos.y;
        newPos.x = this.d * id2 * x2 + -this.c * id2 * y2 + (this.ty * this.c - this.tx * this.d) * id2;
        newPos.y = this.a * id2 * y2 + -this.b * id2 * x2 + (-this.ty * this.a + this.tx * this.b) * id2;
        return newPos;
      };
      Matrix2.prototype.translate = function(x2, y2) {
        this.tx += x2;
        this.ty += y2;
        return this;
      };
      Matrix2.prototype.scale = function(x2, y2) {
        this.a *= x2;
        this.d *= y2;
        this.c *= x2;
        this.b *= y2;
        this.tx *= x2;
        this.ty *= y2;
        return this;
      };
      Matrix2.prototype.rotate = function(angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      };
      Matrix2.prototype.append = function(matrix) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      };
      Matrix2.prototype.setTransform = function(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x2 - (pivotX * this.a + pivotY * this.c);
        this.ty = y2 - (pivotX * this.b + pivotY * this.d);
        return this;
      };
      Matrix2.prototype.prepend = function(matrix) {
        var tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          var a1 = this.a;
          var c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      };
      Matrix2.prototype.decompose = function(transform) {
        var a2 = this.a;
        var b = this.b;
        var c = this.c;
        var d = this.d;
        var skewX = -Math.atan2(-c, d);
        var skewY = Math.atan2(b, a2);
        var delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
          transform.rotation = skewY;
          transform.skew.x = transform.skew.y = 0;
        } else {
          transform.rotation = 0;
          transform.skew.x = skewX;
          transform.skew.y = skewY;
        }
        transform.scale.x = Math.sqrt(a2 * a2 + b * b);
        transform.scale.y = Math.sqrt(c * c + d * d);
        transform.position.x = this.tx;
        transform.position.y = this.ty;
        return transform;
      };
      Matrix2.prototype.invert = function() {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n2 = a1 * d1 - b1 * c1;
        this.a = d1 / n2;
        this.b = -b1 / n2;
        this.c = -c1 / n2;
        this.d = a1 / n2;
        this.tx = (c1 * this.ty - d1 * tx1) / n2;
        this.ty = -(a1 * this.ty - b1 * tx1) / n2;
        return this;
      };
      Matrix2.prototype.identity = function() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      };
      Matrix2.prototype.clone = function() {
        var matrix = new Matrix2();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      };
      Matrix2.prototype.copyTo = function(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      };
      Matrix2.prototype.copyFrom = function(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
      };
      Object.defineProperty(Matrix2, "IDENTITY", {
        get: function() {
          return new Matrix2();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Matrix2, "TEMP_MATRIX", {
        get: function() {
          return new Matrix2();
        },
        enumerable: false,
        configurable: true
      });
      return Matrix2;
    }();
    var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
    var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
    var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
    var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
    var rotationCayley = [];
    var rotationMatrices = [];
    var signum = Math.sign;
    function init() {
      for (var i2 = 0; i2 < 16; i2++) {
        var row = [];
        rotationCayley.push(row);
        for (var j = 0; j < 16; j++) {
          var _ux = signum(ux[i2] * ux[j] + vx[i2] * uy[j]);
          var _uy = signum(uy[i2] * ux[j] + vy[i2] * uy[j]);
          var _vx = signum(ux[i2] * vx[j] + vx[i2] * vy[j]);
          var _vy = signum(uy[i2] * vx[j] + vy[i2] * vy[j]);
          for (var k = 0; k < 16; k++) {
            if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
              row.push(k);
              break;
            }
          }
        }
      }
      for (var i2 = 0; i2 < 16; i2++) {
        var mat = new Matrix();
        mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
        rotationMatrices.push(mat);
      }
    }
    init();
    var groupD8 = {
      E: 0,
      SE: 1,
      S: 2,
      SW: 3,
      W: 4,
      NW: 5,
      N: 6,
      NE: 7,
      MIRROR_VERTICAL: 8,
      MAIN_DIAGONAL: 10,
      MIRROR_HORIZONTAL: 12,
      REVERSE_DIAGONAL: 14,
      uX: function(ind) {
        return ux[ind];
      },
      uY: function(ind) {
        return uy[ind];
      },
      vX: function(ind) {
        return vx[ind];
      },
      vY: function(ind) {
        return vy[ind];
      },
      inv: function(rotation) {
        if (rotation & 8) {
          return rotation & 15;
        }
        return -rotation & 7;
      },
      add: function(rotationSecond, rotationFirst) {
        return rotationCayley[rotationSecond][rotationFirst];
      },
      sub: function(rotationSecond, rotationFirst) {
        return rotationCayley[rotationSecond][groupD8.inv(rotationFirst)];
      },
      rotate180: function(rotation) {
        return rotation ^ 4;
      },
      isVertical: function(rotation) {
        return (rotation & 3) === 2;
      },
      byDirection: function(dx, dy) {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
          if (dy >= 0) {
            return groupD8.S;
          }
          return groupD8.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
          if (dx > 0) {
            return groupD8.E;
          }
          return groupD8.W;
        } else if (dy > 0) {
          if (dx > 0) {
            return groupD8.SE;
          }
          return groupD8.SW;
        } else if (dx > 0) {
          return groupD8.NE;
        }
        return groupD8.NW;
      },
      matrixAppendRotationInv: function(matrix, rotation, tx, ty) {
        if (tx === void 0) {
          tx = 0;
        }
        if (ty === void 0) {
          ty = 0;
        }
        var mat = rotationMatrices[groupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
      }
    };
    var Transform = function() {
      function Transform2() {
        this.worldTransform = new Matrix();
        this.localTransform = new Matrix();
        this.position = new ObservablePoint(this.onChange, this, 0, 0);
        this.scale = new ObservablePoint(this.onChange, this, 1, 1);
        this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
        this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
        this._rotation = 0;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
        this._localID = 0;
        this._currentLocalID = 0;
        this._worldID = 0;
        this._parentID = 0;
      }
      Transform2.prototype.onChange = function() {
        this._localID++;
      };
      Transform2.prototype.updateSkew = function() {
        this._cx = Math.cos(this._rotation + this.skew.y);
        this._sx = Math.sin(this._rotation + this.skew.y);
        this._cy = -Math.sin(this._rotation - this.skew.x);
        this._sy = Math.cos(this._rotation - this.skew.x);
        this._localID++;
      };
      Transform2.prototype.updateLocalTransform = function() {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
          lt.a = this._cx * this.scale.x;
          lt.b = this._sx * this.scale.x;
          lt.c = this._cy * this.scale.y;
          lt.d = this._sy * this.scale.y;
          lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
          lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
          this._currentLocalID = this._localID;
          this._parentID = -1;
        }
      };
      Transform2.prototype.updateTransform = function(parentTransform) {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
          lt.a = this._cx * this.scale.x;
          lt.b = this._sx * this.scale.x;
          lt.c = this._cy * this.scale.y;
          lt.d = this._sy * this.scale.y;
          lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
          lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
          this._currentLocalID = this._localID;
          this._parentID = -1;
        }
        if (this._parentID !== parentTransform._worldID) {
          var pt = parentTransform.worldTransform;
          var wt = this.worldTransform;
          wt.a = lt.a * pt.a + lt.b * pt.c;
          wt.b = lt.a * pt.b + lt.b * pt.d;
          wt.c = lt.c * pt.a + lt.d * pt.c;
          wt.d = lt.c * pt.b + lt.d * pt.d;
          wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
          wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
          this._parentID = parentTransform._worldID;
          this._worldID++;
        }
      };
      Transform2.prototype.setFromMatrix = function(matrix) {
        matrix.decompose(this);
        this._localID++;
      };
      Object.defineProperty(Transform2.prototype, "rotation", {
        get: function() {
          return this._rotation;
        },
        set: function(value2) {
          if (this._rotation !== value2) {
            this._rotation = value2;
            this.updateSkew();
          }
        },
        enumerable: false,
        configurable: true
      });
      Transform2.IDENTITY = new Transform2();
      return Transform2;
    }();
    /*!
     * @pixi/display - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/display is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    settings.SORTABLE_CHILDREN = false;
    var Bounds = function() {
      function Bounds2() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.rect = null;
        this.updateID = -1;
      }
      Bounds2.prototype.isEmpty = function() {
        return this.minX > this.maxX || this.minY > this.maxY;
      };
      Bounds2.prototype.clear = function() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
      };
      Bounds2.prototype.getRectangle = function(rect) {
        if (this.minX > this.maxX || this.minY > this.maxY) {
          return Rectangle.EMPTY;
        }
        rect = rect || new Rectangle(0, 0, 1, 1);
        rect.x = this.minX;
        rect.y = this.minY;
        rect.width = this.maxX - this.minX;
        rect.height = this.maxY - this.minY;
        return rect;
      };
      Bounds2.prototype.addPoint = function(point) {
        this.minX = Math.min(this.minX, point.x);
        this.maxX = Math.max(this.maxX, point.x);
        this.minY = Math.min(this.minY, point.y);
        this.maxY = Math.max(this.maxY, point.y);
      };
      Bounds2.prototype.addQuad = function(vertices) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x2 = vertices[0];
        var y2 = vertices[1];
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = vertices[2];
        y2 = vertices[3];
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = vertices[4];
        y2 = vertices[5];
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = vertices[6];
        y2 = vertices[7];
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds2.prototype.addFrame = function(transform, x0, y0, x1, y1) {
        this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
      };
      Bounds2.prototype.addFrameMatrix = function(matrix, x0, y0, x1, y1) {
        var a2 = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x2 = a2 * x0 + c * y0 + tx;
        var y2 = b * x0 + d * y0 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = a2 * x1 + c * y0 + tx;
        y2 = b * x1 + d * y0 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = a2 * x0 + c * y1 + tx;
        y2 = b * x0 + d * y1 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        x2 = a2 * x1 + c * y1 + tx;
        y2 = b * x1 + d * y1 + ty;
        minX = x2 < minX ? x2 : minX;
        minY = y2 < minY ? y2 : minY;
        maxX = x2 > maxX ? x2 : maxX;
        maxY = y2 > maxY ? y2 : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds2.prototype.addVertexData = function(vertexData, beginOffset, endOffset) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i2 = beginOffset; i2 < endOffset; i2 += 2) {
          var x2 = vertexData[i2];
          var y2 = vertexData[i2 + 1];
          minX = x2 < minX ? x2 : minX;
          minY = y2 < minY ? y2 : minY;
          maxX = x2 > maxX ? x2 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds2.prototype.addVertices = function(transform, vertices, beginOffset, endOffset) {
        this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
      };
      Bounds2.prototype.addVerticesMatrix = function(matrix, vertices, beginOffset, endOffset, padX, padY) {
        if (padX === void 0) {
          padX = 0;
        }
        if (padY === void 0) {
          padY = padX;
        }
        var a2 = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i2 = beginOffset; i2 < endOffset; i2 += 2) {
          var rawX = vertices[i2];
          var rawY = vertices[i2 + 1];
          var x2 = a2 * rawX + c * rawY + tx;
          var y2 = d * rawY + b * rawX + ty;
          minX = Math.min(minX, x2 - padX);
          maxX = Math.max(maxX, x2 + padX);
          minY = Math.min(minY, y2 - padY);
          maxY = Math.max(maxY, y2 + padY);
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      };
      Bounds2.prototype.addBounds = function(bounds) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = bounds.minX < minX ? bounds.minX : minX;
        this.minY = bounds.minY < minY ? bounds.minY : minY;
        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
      };
      Bounds2.prototype.addBoundsMask = function(bounds, mask) {
        var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
        var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
        var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
        var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
        if (_minX <= _maxX && _minY <= _maxY) {
          var minX = this.minX;
          var minY = this.minY;
          var maxX = this.maxX;
          var maxY = this.maxY;
          this.minX = _minX < minX ? _minX : minX;
          this.minY = _minY < minY ? _minY : minY;
          this.maxX = _maxX > maxX ? _maxX : maxX;
          this.maxY = _maxY > maxY ? _maxY : maxY;
        }
      };
      Bounds2.prototype.addBoundsMatrix = function(bounds, matrix) {
        this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
      };
      Bounds2.prototype.addBoundsArea = function(bounds, area2) {
        var _minX = bounds.minX > area2.x ? bounds.minX : area2.x;
        var _minY = bounds.minY > area2.y ? bounds.minY : area2.y;
        var _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width;
        var _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;
        if (_minX <= _maxX && _minY <= _maxY) {
          var minX = this.minX;
          var minY = this.minY;
          var maxX = this.maxX;
          var maxY = this.maxY;
          this.minX = _minX < minX ? _minX : minX;
          this.minY = _minY < minY ? _minY : minY;
          this.maxX = _maxX > maxX ? _maxX : maxX;
          this.maxY = _maxY > maxY ? _maxY : maxY;
        }
      };
      Bounds2.prototype.pad = function(paddingX, paddingY) {
        if (paddingX === void 0) {
          paddingX = 0;
        }
        if (paddingY === void 0) {
          paddingY = paddingX;
        }
        if (!this.isEmpty()) {
          this.minX -= paddingX;
          this.maxX += paddingX;
          this.minY -= paddingY;
          this.maxY += paddingY;
        }
      };
      Bounds2.prototype.addFramePad = function(x0, y0, x1, y1, padX, padY) {
        x0 -= padX;
        y0 -= padY;
        x1 += padX;
        y1 += padY;
        this.minX = this.minX < x0 ? this.minX : x0;
        this.maxX = this.maxX > x1 ? this.maxX : x1;
        this.minY = this.minY < y0 ? this.minY : y0;
        this.maxY = this.maxY > y1 ? this.maxY : y1;
      };
      return Bounds2;
    }();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$j = function(d, b) {
      extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$j(d, b);
    };
    function __extends$j(d, b) {
      extendStatics$j(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var DisplayObject = function(_super) {
      __extends$j(DisplayObject2, _super);
      function DisplayObject2() {
        var _this = _super.call(this) || this;
        _this.tempDisplayObjectParent = null;
        _this.transform = new Transform();
        _this.alpha = 1;
        _this.visible = true;
        _this.renderable = true;
        _this.parent = null;
        _this.worldAlpha = 1;
        _this._lastSortedIndex = 0;
        _this._zIndex = 0;
        _this.filterArea = null;
        _this.filters = null;
        _this._enabledFilters = null;
        _this._bounds = new Bounds();
        _this._localBounds = null;
        _this._boundsID = 0;
        _this._boundsRect = null;
        _this._localBoundsRect = null;
        _this._mask = null;
        _this._destroyed = false;
        _this.isSprite = false;
        _this.isMask = false;
        return _this;
      }
      DisplayObject2.mixin = function(source) {
        var keys2 = Object.keys(source);
        for (var i2 = 0; i2 < keys2.length; ++i2) {
          var propertyName = keys2[i2];
          Object.defineProperty(DisplayObject2.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
      };
      DisplayObject2.prototype._recursivePostUpdateTransform = function() {
        if (this.parent) {
          this.parent._recursivePostUpdateTransform();
          this.transform.updateTransform(this.parent.transform);
        } else {
          this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
      };
      DisplayObject2.prototype.updateTransform = function() {
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
      };
      DisplayObject2.prototype.getBounds = function(skipUpdate, rect) {
        if (!skipUpdate) {
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
          } else {
            this._recursivePostUpdateTransform();
            this.updateTransform();
          }
        }
        if (this._bounds.updateID !== this._boundsID) {
          this.calculateBounds();
          this._bounds.updateID = this._boundsID;
        }
        if (!rect) {
          if (!this._boundsRect) {
            this._boundsRect = new Rectangle();
          }
          rect = this._boundsRect;
        }
        return this._bounds.getRectangle(rect);
      };
      DisplayObject2.prototype.getLocalBounds = function(rect) {
        if (!rect) {
          if (!this._localBoundsRect) {
            this._localBoundsRect = new Rectangle();
          }
          rect = this._localBoundsRect;
        }
        if (!this._localBounds) {
          this._localBounds = new Bounds();
        }
        var transformRef = this.transform;
        var parentRef = this.parent;
        this.parent = null;
        this.transform = this._tempDisplayObjectParent.transform;
        var worldBounds = this._bounds;
        var worldBoundsID = this._boundsID;
        this._bounds = this._localBounds;
        var bounds = this.getBounds(false, rect);
        this.parent = parentRef;
        this.transform = transformRef;
        this._bounds = worldBounds;
        this._bounds.updateID += this._boundsID - worldBoundsID;
        return bounds;
      };
      DisplayObject2.prototype.toGlobal = function(position, point, skipUpdate) {
        if (skipUpdate === void 0) {
          skipUpdate = false;
        }
        if (!skipUpdate) {
          this._recursivePostUpdateTransform();
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.displayObjectUpdateTransform();
            this.parent = null;
          } else {
            this.displayObjectUpdateTransform();
          }
        }
        return this.worldTransform.apply(position, point);
      };
      DisplayObject2.prototype.toLocal = function(position, from2, point, skipUpdate) {
        if (from2) {
          position = from2.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
          this._recursivePostUpdateTransform();
          if (!this.parent) {
            this.parent = this._tempDisplayObjectParent;
            this.displayObjectUpdateTransform();
            this.parent = null;
          } else {
            this.displayObjectUpdateTransform();
          }
        }
        return this.worldTransform.applyInverse(position, point);
      };
      DisplayObject2.prototype.setParent = function(container) {
        if (!container || !container.addChild) {
          throw new Error("setParent: Argument must be a Container");
        }
        container.addChild(this);
        return container;
      };
      DisplayObject2.prototype.setTransform = function(x2, y2, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (scaleX === void 0) {
          scaleX = 1;
        }
        if (scaleY === void 0) {
          scaleY = 1;
        }
        if (rotation === void 0) {
          rotation = 0;
        }
        if (skewX === void 0) {
          skewX = 0;
        }
        if (skewY === void 0) {
          skewY = 0;
        }
        if (pivotX === void 0) {
          pivotX = 0;
        }
        if (pivotY === void 0) {
          pivotY = 0;
        }
        this.position.x = x2;
        this.position.y = y2;
        this.scale.x = !scaleX ? 1 : scaleX;
        this.scale.y = !scaleY ? 1 : scaleY;
        this.rotation = rotation;
        this.skew.x = skewX;
        this.skew.y = skewY;
        this.pivot.x = pivotX;
        this.pivot.y = pivotY;
        return this;
      };
      DisplayObject2.prototype.destroy = function(_options) {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.removeAllListeners();
        this.transform = null;
        this.parent = null;
        this._bounds = null;
        this._mask = null;
        this.filters = null;
        this.filterArea = null;
        this.hitArea = null;
        this.interactive = false;
        this.interactiveChildren = false;
        this._destroyed = true;
      };
      Object.defineProperty(DisplayObject2.prototype, "_tempDisplayObjectParent", {
        get: function() {
          if (this.tempDisplayObjectParent === null) {
            this.tempDisplayObjectParent = new TemporaryDisplayObject();
          }
          return this.tempDisplayObjectParent;
        },
        enumerable: false,
        configurable: true
      });
      DisplayObject2.prototype.enableTempParent = function() {
        var myParent = this.parent;
        this.parent = this._tempDisplayObjectParent;
        return myParent;
      };
      DisplayObject2.prototype.disableTempParent = function(cacheParent) {
        this.parent = cacheParent;
      };
      Object.defineProperty(DisplayObject2.prototype, "x", {
        get: function() {
          return this.position.x;
        },
        set: function(value2) {
          this.transform.position.x = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "y", {
        get: function() {
          return this.position.y;
        },
        set: function(value2) {
          this.transform.position.y = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "worldTransform", {
        get: function() {
          return this.transform.worldTransform;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "localTransform", {
        get: function() {
          return this.transform.localTransform;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "position", {
        get: function() {
          return this.transform.position;
        },
        set: function(value2) {
          this.transform.position.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "scale", {
        get: function() {
          return this.transform.scale;
        },
        set: function(value2) {
          this.transform.scale.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "pivot", {
        get: function() {
          return this.transform.pivot;
        },
        set: function(value2) {
          this.transform.pivot.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "skew", {
        get: function() {
          return this.transform.skew;
        },
        set: function(value2) {
          this.transform.skew.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "rotation", {
        get: function() {
          return this.transform.rotation;
        },
        set: function(value2) {
          this.transform.rotation = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "angle", {
        get: function() {
          return this.transform.rotation * RAD_TO_DEG;
        },
        set: function(value2) {
          this.transform.rotation = value2 * DEG_TO_RAD;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "zIndex", {
        get: function() {
          return this._zIndex;
        },
        set: function(value2) {
          this._zIndex = value2;
          if (this.parent) {
            this.parent.sortDirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "worldVisible", {
        get: function() {
          var item = this;
          do {
            if (!item.visible) {
              return false;
            }
            item = item.parent;
          } while (item);
          return true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DisplayObject2.prototype, "mask", {
        get: function() {
          return this._mask;
        },
        set: function(value2) {
          if (this._mask) {
            var maskObject = this._mask.maskObject || this._mask;
            maskObject.renderable = true;
            maskObject.isMask = false;
          }
          this._mask = value2;
          if (this._mask) {
            var maskObject = this._mask.maskObject || this._mask;
            maskObject.renderable = false;
            maskObject.isMask = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      return DisplayObject2;
    }(EventEmitter);
    var TemporaryDisplayObject = function(_super) {
      __extends$j(TemporaryDisplayObject2, _super);
      function TemporaryDisplayObject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.sortDirty = null;
        return _this;
      }
      return TemporaryDisplayObject2;
    }(DisplayObject);
    DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
    function sortChildren(a2, b) {
      if (a2.zIndex === b.zIndex) {
        return a2._lastSortedIndex - b._lastSortedIndex;
      }
      return a2.zIndex - b.zIndex;
    }
    var Container = function(_super) {
      __extends$j(Container2, _super);
      function Container2() {
        var _this = _super.call(this) || this;
        _this.children = [];
        _this.sortableChildren = settings.SORTABLE_CHILDREN;
        _this.sortDirty = false;
        return _this;
      }
      Container2.prototype.onChildrenChange = function(_length) {
      };
      Container2.prototype.addChild = function() {
        var arguments$1 = arguments;
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          children[_i] = arguments$1[_i];
        }
        if (children.length > 1) {
          for (var i2 = 0; i2 < children.length; i2++) {
            this.addChild(children[i2]);
          }
        } else {
          var child = children[0];
          if (child.parent) {
            child.parent.removeChild(child);
          }
          child.parent = this;
          this.sortDirty = true;
          child.transform._parentID = -1;
          this.children.push(child);
          this._boundsID++;
          this.onChildrenChange(this.children.length - 1);
          this.emit("childAdded", child, this, this.children.length - 1);
          child.emit("added", this);
        }
        return children[0];
      };
      Container2.prototype.addChildAt = function(child, index2) {
        if (index2 < 0 || index2 > this.children.length) {
          throw new Error(child + "addChildAt: The index " + index2 + " supplied is out of bounds " + this.children.length);
        }
        if (child.parent) {
          child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        child.transform._parentID = -1;
        this.children.splice(index2, 0, child);
        this._boundsID++;
        this.onChildrenChange(index2);
        child.emit("added", this);
        this.emit("childAdded", child, this, index2);
        return child;
      };
      Container2.prototype.swapChildren = function(child, child2) {
        if (child === child2) {
          return;
        }
        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
      };
      Container2.prototype.getChildIndex = function(child) {
        var index2 = this.children.indexOf(child);
        if (index2 === -1) {
          throw new Error("The supplied DisplayObject must be a child of the caller");
        }
        return index2;
      };
      Container2.prototype.setChildIndex = function(child, index2) {
        if (index2 < 0 || index2 >= this.children.length) {
          throw new Error("The index " + index2 + " supplied is out of bounds " + this.children.length);
        }
        var currentIndex = this.getChildIndex(child);
        removeItems(this.children, currentIndex, 1);
        this.children.splice(index2, 0, child);
        this.onChildrenChange(index2);
      };
      Container2.prototype.getChildAt = function(index2) {
        if (index2 < 0 || index2 >= this.children.length) {
          throw new Error("getChildAt: Index (" + index2 + ") does not exist.");
        }
        return this.children[index2];
      };
      Container2.prototype.removeChild = function() {
        var arguments$1 = arguments;
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          children[_i] = arguments$1[_i];
        }
        if (children.length > 1) {
          for (var i2 = 0; i2 < children.length; i2++) {
            this.removeChild(children[i2]);
          }
        } else {
          var child = children[0];
          var index2 = this.children.indexOf(child);
          if (index2 === -1) {
            return null;
          }
          child.parent = null;
          child.transform._parentID = -1;
          removeItems(this.children, index2, 1);
          this._boundsID++;
          this.onChildrenChange(index2);
          child.emit("removed", this);
          this.emit("childRemoved", child, this, index2);
        }
        return children[0];
      };
      Container2.prototype.removeChildAt = function(index2) {
        var child = this.getChildAt(index2);
        child.parent = null;
        child.transform._parentID = -1;
        removeItems(this.children, index2, 1);
        this._boundsID++;
        this.onChildrenChange(index2);
        child.emit("removed", this);
        this.emit("childRemoved", child, this, index2);
        return child;
      };
      Container2.prototype.removeChildren = function(beginIndex, endIndex) {
        if (beginIndex === void 0) {
          beginIndex = 0;
        }
        if (endIndex === void 0) {
          endIndex = this.children.length;
        }
        var begin = beginIndex;
        var end = endIndex;
        var range2 = end - begin;
        var removed;
        if (range2 > 0 && range2 <= end) {
          removed = this.children.splice(begin, range2);
          for (var i2 = 0; i2 < removed.length; ++i2) {
            removed[i2].parent = null;
            if (removed[i2].transform) {
              removed[i2].transform._parentID = -1;
            }
          }
          this._boundsID++;
          this.onChildrenChange(beginIndex);
          for (var i2 = 0; i2 < removed.length; ++i2) {
            removed[i2].emit("removed", this);
            this.emit("childRemoved", removed[i2], this, i2);
          }
          return removed;
        } else if (range2 === 0 && this.children.length === 0) {
          return [];
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
      };
      Container2.prototype.sortChildren = function() {
        var sortRequired = false;
        for (var i2 = 0, j = this.children.length; i2 < j; ++i2) {
          var child = this.children[i2];
          child._lastSortedIndex = i2;
          if (!sortRequired && child.zIndex !== 0) {
            sortRequired = true;
          }
        }
        if (sortRequired && this.children.length > 1) {
          this.children.sort(sortChildren);
        }
        this.sortDirty = false;
      };
      Container2.prototype.updateTransform = function() {
        if (this.sortableChildren && this.sortDirty) {
          this.sortChildren();
        }
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (var i2 = 0, j = this.children.length; i2 < j; ++i2) {
          var child = this.children[i2];
          if (child.visible) {
            child.updateTransform();
          }
        }
      };
      Container2.prototype.calculateBounds = function() {
        this._bounds.clear();
        this._calculateBounds();
        for (var i2 = 0; i2 < this.children.length; i2++) {
          var child = this.children[i2];
          if (!child.visible || !child.renderable) {
            continue;
          }
          child.calculateBounds();
          if (child._mask) {
            var maskObject = child._mask.maskObject || child._mask;
            maskObject.calculateBounds();
            this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
          } else if (child.filterArea) {
            this._bounds.addBoundsArea(child._bounds, child.filterArea);
          } else {
            this._bounds.addBounds(child._bounds);
          }
        }
        this._bounds.updateID = this._boundsID;
      };
      Container2.prototype.getLocalBounds = function(rect, skipChildrenUpdate) {
        if (skipChildrenUpdate === void 0) {
          skipChildrenUpdate = false;
        }
        var result2 = _super.prototype.getLocalBounds.call(this, rect);
        if (!skipChildrenUpdate) {
          for (var i2 = 0, j = this.children.length; i2 < j; ++i2) {
            var child = this.children[i2];
            if (child.visible) {
              child.updateTransform();
            }
          }
        }
        return result2;
      };
      Container2.prototype._calculateBounds = function() {
      };
      Container2.prototype.render = function(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
          return;
        }
        if (this._mask || this.filters && this.filters.length) {
          this.renderAdvanced(renderer);
        } else {
          this._render(renderer);
          for (var i2 = 0, j = this.children.length; i2 < j; ++i2) {
            this.children[i2].render(renderer);
          }
        }
      };
      Container2.prototype.renderAdvanced = function(renderer) {
        renderer.batch.flush();
        var filters = this.filters;
        var mask = this._mask;
        if (filters) {
          if (!this._enabledFilters) {
            this._enabledFilters = [];
          }
          this._enabledFilters.length = 0;
          for (var i2 = 0; i2 < filters.length; i2++) {
            if (filters[i2].enabled) {
              this._enabledFilters.push(filters[i2]);
            }
          }
          if (this._enabledFilters.length) {
            renderer.filter.push(this, this._enabledFilters);
          }
        }
        if (mask) {
          renderer.mask.push(this, this._mask);
        }
        this._render(renderer);
        for (var i2 = 0, j = this.children.length; i2 < j; i2++) {
          this.children[i2].render(renderer);
        }
        renderer.batch.flush();
        if (mask) {
          renderer.mask.pop(this);
        }
        if (filters && this._enabledFilters && this._enabledFilters.length) {
          renderer.filter.pop();
        }
      };
      Container2.prototype._render = function(_renderer) {
      };
      Container2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this);
        this.sortDirty = false;
        var destroyChildren = typeof options === "boolean" ? options : options && options.children;
        var oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
          for (var i2 = 0; i2 < oldChildren.length; ++i2) {
            oldChildren[i2].destroy(options);
          }
        }
      };
      Object.defineProperty(Container2.prototype, "width", {
        get: function() {
          return this.scale.x * this.getLocalBounds().width;
        },
        set: function(value2) {
          var width2 = this.getLocalBounds().width;
          if (width2 !== 0) {
            this.scale.x = value2 / width2;
          } else {
            this.scale.x = 1;
          }
          this._width = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Container2.prototype, "height", {
        get: function() {
          return this.scale.y * this.getLocalBounds().height;
        },
        set: function(value2) {
          var height2 = this.getLocalBounds().height;
          if (height2 !== 0) {
            this.scale.y = value2 / height2;
          } else {
            this.scale.y = 1;
          }
          this._height = value2;
        },
        enumerable: false,
        configurable: true
      });
      return Container2;
    }(DisplayObject);
    Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
    /*!
     * @pixi/accessibility - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/accessibility is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var accessibleTarget = {
      accessible: false,
      accessibleTitle: null,
      accessibleHint: null,
      tabIndex: 0,
      _accessibleActive: false,
      _accessibleDiv: null,
      accessibleType: "button",
      accessiblePointerEvents: "auto",
      accessibleChildren: true,
      renderId: -1
    };
    DisplayObject.mixin(accessibleTarget);
    var KEY_CODE_TAB = 9;
    var DIV_TOUCH_SIZE = 100;
    var DIV_TOUCH_POS_X = 0;
    var DIV_TOUCH_POS_Y = 0;
    var DIV_TOUCH_ZINDEX = 2;
    var DIV_HOOK_SIZE = 1;
    var DIV_HOOK_POS_X = -1e3;
    var DIV_HOOK_POS_Y = -1e3;
    var DIV_HOOK_ZINDEX = 2;
    var AccessibilityManager = function() {
      function AccessibilityManager2(renderer) {
        this._hookDiv = null;
        if (isMobile.tablet || isMobile.phone) {
          this.createTouchHook();
        }
        var div = document.createElement("div");
        div.style.width = DIV_TOUCH_SIZE + "px";
        div.style.height = DIV_TOUCH_SIZE + "px";
        div.style.position = "absolute";
        div.style.top = DIV_TOUCH_POS_X + "px";
        div.style.left = DIV_TOUCH_POS_Y + "px";
        div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
        this.div = div;
        this.pool = [];
        this.renderId = 0;
        this.debug = false;
        this.renderer = renderer;
        this.children = [];
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        this._isActive = false;
        this._isMobileAccessibility = false;
        this.androidUpdateCount = 0;
        this.androidUpdateFrequency = 500;
        window.addEventListener("keydown", this._onKeyDown, false);
      }
      Object.defineProperty(AccessibilityManager2.prototype, "isActive", {
        get: function() {
          return this._isActive;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AccessibilityManager2.prototype, "isMobileAccessibility", {
        get: function() {
          return this._isMobileAccessibility;
        },
        enumerable: false,
        configurable: true
      });
      AccessibilityManager2.prototype.createTouchHook = function() {
        var _this = this;
        var hookDiv = document.createElement("button");
        hookDiv.style.width = DIV_HOOK_SIZE + "px";
        hookDiv.style.height = DIV_HOOK_SIZE + "px";
        hookDiv.style.position = "absolute";
        hookDiv.style.top = DIV_HOOK_POS_X + "px";
        hookDiv.style.left = DIV_HOOK_POS_Y + "px";
        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = "#FF0000";
        hookDiv.title = "select to enable accessability for this content";
        hookDiv.addEventListener("focus", function() {
          _this._isMobileAccessibility = true;
          _this.activate();
          _this.destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
      };
      AccessibilityManager2.prototype.destroyTouchHook = function() {
        if (!this._hookDiv) {
          return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
      };
      AccessibilityManager2.prototype.activate = function() {
        if (this._isActive) {
          return;
        }
        this._isActive = true;
        window.document.addEventListener("mousemove", this._onMouseMove, true);
        window.removeEventListener("keydown", this._onKeyDown, false);
        this.renderer.on("postrender", this.update, this);
        if (this.renderer.view.parentNode) {
          this.renderer.view.parentNode.appendChild(this.div);
        }
      };
      AccessibilityManager2.prototype.deactivate = function() {
        if (!this._isActive || this._isMobileAccessibility) {
          return;
        }
        this._isActive = false;
        window.document.removeEventListener("mousemove", this._onMouseMove, true);
        window.addEventListener("keydown", this._onKeyDown, false);
        this.renderer.off("postrender", this.update);
        if (this.div.parentNode) {
          this.div.parentNode.removeChild(this.div);
        }
      };
      AccessibilityManager2.prototype.updateAccessibleObjects = function(displayObject) {
        if (!displayObject.visible || !displayObject.accessibleChildren) {
          return;
        }
        if (displayObject.accessible && displayObject.interactive) {
          if (!displayObject._accessibleActive) {
            this.addChild(displayObject);
          }
          displayObject.renderId = this.renderId;
        }
        var children = displayObject.children;
        for (var i2 = 0; i2 < children.length; i2++) {
          this.updateAccessibleObjects(children[i2]);
        }
      };
      AccessibilityManager2.prototype.update = function() {
        var now2 = performance.now();
        if (isMobile.android.device && now2 < this.androidUpdateCount) {
          return;
        }
        this.androidUpdateCount = now2 + this.androidUpdateFrequency;
        if (!this.renderer.renderingToScreen) {
          return;
        }
        if (this.renderer._lastObjectRendered) {
          this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        }
        var rect = this.renderer.view.getBoundingClientRect();
        var resolution = this.renderer.resolution;
        var sx = rect.width / this.renderer.width * resolution;
        var sy = rect.height / this.renderer.height * resolution;
        var div = this.div;
        div.style.left = rect.left + "px";
        div.style.top = rect.top + "px";
        div.style.width = this.renderer.width + "px";
        div.style.height = this.renderer.height + "px";
        for (var i2 = 0; i2 < this.children.length; i2++) {
          var child = this.children[i2];
          if (child.renderId !== this.renderId) {
            child._accessibleActive = false;
            removeItems(this.children, i2, 1);
            this.div.removeChild(child._accessibleDiv);
            this.pool.push(child._accessibleDiv);
            child._accessibleDiv = null;
            i2--;
          } else {
            div = child._accessibleDiv;
            var hitArea = child.hitArea;
            var wt = child.worldTransform;
            if (child.hitArea) {
              div.style.left = (wt.tx + hitArea.x * wt.a) * sx + "px";
              div.style.top = (wt.ty + hitArea.y * wt.d) * sy + "px";
              div.style.width = hitArea.width * wt.a * sx + "px";
              div.style.height = hitArea.height * wt.d * sy + "px";
            } else {
              hitArea = child.getBounds();
              this.capHitArea(hitArea);
              div.style.left = hitArea.x * sx + "px";
              div.style.top = hitArea.y * sy + "px";
              div.style.width = hitArea.width * sx + "px";
              div.style.height = hitArea.height * sy + "px";
              if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                div.title = child.accessibleTitle;
              }
              if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                div.setAttribute("aria-label", child.accessibleHint);
              }
            }
            if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
              div.title = child.accessibleTitle;
              div.tabIndex = child.tabIndex;
              if (this.debug) {
                this.updateDebugHTML(div);
              }
            }
          }
        }
        this.renderId++;
      };
      AccessibilityManager2.prototype.updateDebugHTML = function(div) {
        div.innerHTML = "type: " + div.type + "</br> title : " + div.title + "</br> tabIndex: " + div.tabIndex;
      };
      AccessibilityManager2.prototype.capHitArea = function(hitArea) {
        if (hitArea.x < 0) {
          hitArea.width += hitArea.x;
          hitArea.x = 0;
        }
        if (hitArea.y < 0) {
          hitArea.height += hitArea.y;
          hitArea.y = 0;
        }
        if (hitArea.x + hitArea.width > this.renderer.width) {
          hitArea.width = this.renderer.width - hitArea.x;
        }
        if (hitArea.y + hitArea.height > this.renderer.height) {
          hitArea.height = this.renderer.height - hitArea.y;
        }
      };
      AccessibilityManager2.prototype.addChild = function(displayObject) {
        var div = this.pool.pop();
        if (!div) {
          div = document.createElement("button");
          div.style.width = DIV_TOUCH_SIZE + "px";
          div.style.height = DIV_TOUCH_SIZE + "px";
          div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
          div.style.position = "absolute";
          div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          div.style.borderStyle = "none";
          if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
            div.setAttribute("aria-live", "off");
          } else {
            div.setAttribute("aria-live", "polite");
          }
          if (navigator.userAgent.match(/rv:.*Gecko\//)) {
            div.setAttribute("aria-relevant", "additions");
          } else {
            div.setAttribute("aria-relevant", "text");
          }
          div.addEventListener("click", this._onClick.bind(this));
          div.addEventListener("focus", this._onFocus.bind(this));
          div.addEventListener("focusout", this._onFocusOut.bind(this));
        }
        div.style.pointerEvents = displayObject.accessiblePointerEvents;
        div.type = displayObject.accessibleType;
        if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
          div.title = displayObject.accessibleTitle;
        } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
          div.title = "displayObject " + displayObject.tabIndex;
        }
        if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
          div.setAttribute("aria-label", displayObject.accessibleHint);
        }
        if (this.debug) {
          this.updateDebugHTML(div);
        }
        displayObject._accessibleActive = true;
        displayObject._accessibleDiv = div;
        div.displayObject = displayObject;
        this.children.push(displayObject);
        this.div.appendChild(displayObject._accessibleDiv);
        displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
      };
      AccessibilityManager2.prototype._onClick = function(e) {
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, "click", interactionManager.eventData);
        interactionManager.dispatchEvent(e.target.displayObject, "pointertap", interactionManager.eventData);
        interactionManager.dispatchEvent(e.target.displayObject, "tap", interactionManager.eventData);
      };
      AccessibilityManager2.prototype._onFocus = function(e) {
        if (!e.target.getAttribute("aria-live")) {
          e.target.setAttribute("aria-live", "assertive");
        }
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, "mouseover", interactionManager.eventData);
      };
      AccessibilityManager2.prototype._onFocusOut = function(e) {
        if (!e.target.getAttribute("aria-live")) {
          e.target.setAttribute("aria-live", "polite");
        }
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, "mouseout", interactionManager.eventData);
      };
      AccessibilityManager2.prototype._onKeyDown = function(e) {
        if (e.keyCode !== KEY_CODE_TAB) {
          return;
        }
        this.activate();
      };
      AccessibilityManager2.prototype._onMouseMove = function(e) {
        if (e.movementX === 0 && e.movementY === 0) {
          return;
        }
        this.deactivate();
      };
      AccessibilityManager2.prototype.destroy = function() {
        this.destroyTouchHook();
        this.div = null;
        window.document.removeEventListener("mousemove", this._onMouseMove, true);
        window.removeEventListener("keydown", this._onKeyDown);
        this.pool = null;
        this.children = null;
        this.renderer = null;
      };
      return AccessibilityManager2;
    }();
    /*!
     * @pixi/ticker - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/ticker is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    settings.TARGET_FPMS = 0.06;
    var UPDATE_PRIORITY;
    (function(UPDATE_PRIORITY2) {
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
    })(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
    var TickerListener = function() {
      function TickerListener2(fn, context2, priority, once2) {
        if (context2 === void 0) {
          context2 = null;
        }
        if (priority === void 0) {
          priority = 0;
        }
        if (once2 === void 0) {
          once2 = false;
        }
        this.fn = fn;
        this.context = context2;
        this.priority = priority;
        this.once = once2;
        this.next = null;
        this.previous = null;
        this._destroyed = false;
      }
      TickerListener2.prototype.match = function(fn, context2) {
        if (context2 === void 0) {
          context2 = null;
        }
        return this.fn === fn && this.context === context2;
      };
      TickerListener2.prototype.emit = function(deltaTime) {
        if (this.fn) {
          if (this.context) {
            this.fn.call(this.context, deltaTime);
          } else {
            this.fn(deltaTime);
          }
        }
        var redirect = this.next;
        if (this.once) {
          this.destroy(true);
        }
        if (this._destroyed) {
          this.next = null;
        }
        return redirect;
      };
      TickerListener2.prototype.connect = function(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      };
      TickerListener2.prototype.destroy = function(hard) {
        if (hard === void 0) {
          hard = false;
        }
        this._destroyed = true;
        this.fn = null;
        this.context = null;
        if (this.previous) {
          this.previous.next = this.next;
        }
        if (this.next) {
          this.next.previous = this.previous;
        }
        var redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
      };
      return TickerListener2;
    }();
    var Ticker = function() {
      function Ticker2() {
        var _this = this;
        this._head = new TickerListener(null, null, Infinity);
        this._requestId = null;
        this._maxElapsedMS = 100;
        this._minElapsedMS = 0;
        this.autoStart = false;
        this.deltaTime = 1;
        this.deltaMS = 1 / settings.TARGET_FPMS;
        this.elapsedMS = 1 / settings.TARGET_FPMS;
        this.lastTime = -1;
        this.speed = 1;
        this.started = false;
        this._protected = false;
        this._lastFrame = -1;
        this._tick = function(time) {
          _this._requestId = null;
          if (_this.started) {
            _this.update(time);
            if (_this.started && _this._requestId === null && _this._head.next) {
              _this._requestId = requestAnimationFrame(_this._tick);
            }
          }
        };
      }
      Ticker2.prototype._requestIfNeeded = function() {
        if (this._requestId === null && this._head.next) {
          this.lastTime = performance.now();
          this._lastFrame = this.lastTime;
          this._requestId = requestAnimationFrame(this._tick);
        }
      };
      Ticker2.prototype._cancelIfNeeded = function() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      };
      Ticker2.prototype._startIfPossible = function() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      };
      Ticker2.prototype.add = function(fn, context2, priority) {
        if (priority === void 0) {
          priority = UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener(fn, context2, priority));
      };
      Ticker2.prototype.addOnce = function(fn, context2, priority) {
        if (priority === void 0) {
          priority = UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener(fn, context2, priority, true));
      };
      Ticker2.prototype._addListener = function(listener) {
        var current = this._head.next;
        var previous = this._head;
        if (!current) {
          listener.connect(previous);
        } else {
          while (current) {
            if (listener.priority > current.priority) {
              listener.connect(previous);
              break;
            }
            previous = current;
            current = current.next;
          }
          if (!listener.previous) {
            listener.connect(previous);
          }
        }
        this._startIfPossible();
        return this;
      };
      Ticker2.prototype.remove = function(fn, context2) {
        var listener = this._head.next;
        while (listener) {
          if (listener.match(fn, context2)) {
            listener = listener.destroy();
          } else {
            listener = listener.next;
          }
        }
        if (!this._head.next) {
          this._cancelIfNeeded();
        }
        return this;
      };
      Object.defineProperty(Ticker2.prototype, "count", {
        get: function() {
          if (!this._head) {
            return 0;
          }
          var count = 0;
          var current = this._head;
          while (current = current.next) {
            count++;
          }
          return count;
        },
        enumerable: false,
        configurable: true
      });
      Ticker2.prototype.start = function() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      };
      Ticker2.prototype.stop = function() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      };
      Ticker2.prototype.destroy = function() {
        if (!this._protected) {
          this.stop();
          var listener = this._head.next;
          while (listener) {
            listener = listener.destroy(true);
          }
          this._head.destroy();
          this._head = null;
        }
      };
      Ticker2.prototype.update = function(currentTime) {
        if (currentTime === void 0) {
          currentTime = performance.now();
        }
        var elapsedMS;
        if (currentTime > this.lastTime) {
          elapsedMS = this.elapsedMS = currentTime - this.lastTime;
          if (elapsedMS > this._maxElapsedMS) {
            elapsedMS = this._maxElapsedMS;
          }
          elapsedMS *= this.speed;
          if (this._minElapsedMS) {
            var delta = currentTime - this._lastFrame | 0;
            if (delta < this._minElapsedMS) {
              return;
            }
            this._lastFrame = currentTime - delta % this._minElapsedMS;
          }
          this.deltaMS = elapsedMS;
          this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
          var head = this._head;
          var listener = head.next;
          while (listener) {
            listener = listener.emit(this.deltaTime);
          }
          if (!head.next) {
            this._cancelIfNeeded();
          }
        } else {
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
      };
      Object.defineProperty(Ticker2.prototype, "FPS", {
        get: function() {
          return 1e3 / this.elapsedMS;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker2.prototype, "minFPS", {
        get: function() {
          return 1e3 / this._maxElapsedMS;
        },
        set: function(fps) {
          var minFPS = Math.min(this.maxFPS, fps);
          var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS);
          this._maxElapsedMS = 1 / minFPMS;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker2.prototype, "maxFPS", {
        get: function() {
          if (this._minElapsedMS) {
            return Math.round(1e3 / this._minElapsedMS);
          }
          return 0;
        },
        set: function(fps) {
          if (fps === 0) {
            this._minElapsedMS = 0;
          } else {
            var maxFPS = Math.max(this.minFPS, fps);
            this._minElapsedMS = 1 / (maxFPS / 1e3);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker2, "shared", {
        get: function() {
          if (!Ticker2._shared) {
            var shared = Ticker2._shared = new Ticker2();
            shared.autoStart = true;
            shared._protected = true;
          }
          return Ticker2._shared;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Ticker2, "system", {
        get: function() {
          if (!Ticker2._system) {
            var system = Ticker2._system = new Ticker2();
            system.autoStart = true;
            system._protected = true;
          }
          return Ticker2._system;
        },
        enumerable: false,
        configurable: true
      });
      return Ticker2;
    }();
    var TickerPlugin = function() {
      function TickerPlugin2() {
      }
      TickerPlugin2.init = function(options) {
        var _this = this;
        options = Object.assign({
          autoStart: true,
          sharedTicker: false
        }, options);
        Object.defineProperty(this, "ticker", {
          set: function(ticker) {
            if (this._ticker) {
              this._ticker.remove(this.render, this);
            }
            this._ticker = ticker;
            if (ticker) {
              ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
            }
          },
          get: function() {
            return this._ticker;
          }
        });
        this.stop = function() {
          _this._ticker.stop();
        };
        this.start = function() {
          _this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
        if (options.autoStart) {
          this.start();
        }
      };
      TickerPlugin2.destroy = function() {
        if (this._ticker) {
          var oldTicker = this._ticker;
          this.ticker = null;
          oldTicker.destroy();
        }
      };
      return TickerPlugin2;
    }();
    /*!
     * @pixi/interaction - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/interaction is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var InteractionData = function() {
      function InteractionData2() {
        this.pressure = 0;
        this.rotationAngle = 0;
        this.twist = 0;
        this.tangentialPressure = 0;
        this.global = new Point();
        this.target = null;
        this.originalEvent = null;
        this.identifier = null;
        this.isPrimary = false;
        this.button = 0;
        this.buttons = 0;
        this.width = 0;
        this.height = 0;
        this.tiltX = 0;
        this.tiltY = 0;
        this.pointerType = null;
        this.pressure = 0;
        this.rotationAngle = 0;
        this.twist = 0;
        this.tangentialPressure = 0;
      }
      Object.defineProperty(InteractionData2.prototype, "pointerId", {
        get: function() {
          return this.identifier;
        },
        enumerable: false,
        configurable: true
      });
      InteractionData2.prototype.getLocalPosition = function(displayObject, point, globalPos) {
        return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
      };
      InteractionData2.prototype.copyEvent = function(event) {
        if ("isPrimary" in event && event.isPrimary) {
          this.isPrimary = true;
        }
        this.button = "button" in event && event.button;
        var buttons = "buttons" in event && event.buttons;
        this.buttons = Number.isInteger(buttons) ? buttons : "which" in event && event.which;
        this.width = "width" in event && event.width;
        this.height = "height" in event && event.height;
        this.tiltX = "tiltX" in event && event.tiltX;
        this.tiltY = "tiltY" in event && event.tiltY;
        this.pointerType = "pointerType" in event && event.pointerType;
        this.pressure = "pressure" in event && event.pressure;
        this.rotationAngle = "rotationAngle" in event && event.rotationAngle;
        this.twist = "twist" in event && event.twist || 0;
        this.tangentialPressure = "tangentialPressure" in event && event.tangentialPressure || 0;
      };
      InteractionData2.prototype.reset = function() {
        this.isPrimary = false;
      };
      return InteractionData2;
    }();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$i = function(d, b) {
      extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$i(d, b);
    };
    function __extends$i(d, b) {
      extendStatics$i(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var InteractionEvent = function() {
      function InteractionEvent2() {
        this.stopped = false;
        this.stopsPropagatingAt = null;
        this.stopPropagationHint = false;
        this.target = null;
        this.currentTarget = null;
        this.type = null;
        this.data = null;
      }
      InteractionEvent2.prototype.stopPropagation = function() {
        this.stopped = true;
        this.stopPropagationHint = true;
        this.stopsPropagatingAt = this.currentTarget;
      };
      InteractionEvent2.prototype.reset = function() {
        this.stopped = false;
        this.stopsPropagatingAt = null;
        this.stopPropagationHint = false;
        this.currentTarget = null;
        this.target = null;
      };
      return InteractionEvent2;
    }();
    var InteractionTrackingData = function() {
      function InteractionTrackingData2(pointerId) {
        this._pointerId = pointerId;
        this._flags = InteractionTrackingData2.FLAGS.NONE;
      }
      InteractionTrackingData2.prototype._doSet = function(flag, yn) {
        if (yn) {
          this._flags = this._flags | flag;
        } else {
          this._flags = this._flags & ~flag;
        }
      };
      Object.defineProperty(InteractionTrackingData2.prototype, "pointerId", {
        get: function() {
          return this._pointerId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "flags", {
        get: function() {
          return this._flags;
        },
        set: function(flags) {
          this._flags = flags;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "none", {
        get: function() {
          return this._flags === InteractionTrackingData2.FLAGS.NONE;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "over", {
        get: function() {
          return (this._flags & InteractionTrackingData2.FLAGS.OVER) !== 0;
        },
        set: function(yn) {
          this._doSet(InteractionTrackingData2.FLAGS.OVER, yn);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "rightDown", {
        get: function() {
          return (this._flags & InteractionTrackingData2.FLAGS.RIGHT_DOWN) !== 0;
        },
        set: function(yn) {
          this._doSet(InteractionTrackingData2.FLAGS.RIGHT_DOWN, yn);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionTrackingData2.prototype, "leftDown", {
        get: function() {
          return (this._flags & InteractionTrackingData2.FLAGS.LEFT_DOWN) !== 0;
        },
        set: function(yn) {
          this._doSet(InteractionTrackingData2.FLAGS.LEFT_DOWN, yn);
        },
        enumerable: false,
        configurable: true
      });
      InteractionTrackingData2.FLAGS = Object.freeze({
        NONE: 0,
        OVER: 1 << 0,
        LEFT_DOWN: 1 << 1,
        RIGHT_DOWN: 1 << 2
      });
      return InteractionTrackingData2;
    }();
    var TreeSearch = function() {
      function TreeSearch2() {
        this._tempPoint = new Point();
      }
      TreeSearch2.prototype.recursiveFindHit = function(interactionEvent, displayObject, func, hitTest, interactive) {
        if (!displayObject || !displayObject.visible) {
          return false;
        }
        var point = interactionEvent.data.global;
        interactive = displayObject.interactive || interactive;
        var hit = false;
        var interactiveParent = interactive;
        var hitTestChildren = true;
        if (displayObject.hitArea) {
          if (hitTest) {
            displayObject.worldTransform.applyInverse(point, this._tempPoint);
            if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
              hitTest = false;
              hitTestChildren = false;
            } else {
              hit = true;
            }
          }
          interactiveParent = false;
        } else if (displayObject._mask) {
          if (hitTest) {
            if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {
              hitTest = false;
            }
          }
        }
        if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
          var children = displayObject.children;
          for (var i2 = children.length - 1; i2 >= 0; i2--) {
            var child = children[i2];
            var childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);
            if (childHit) {
              if (!child.parent) {
                continue;
              }
              interactiveParent = false;
              if (childHit) {
                if (interactionEvent.target) {
                  hitTest = false;
                }
                hit = true;
              }
            }
          }
        }
        if (interactive) {
          if (hitTest && !interactionEvent.target) {
            if (!displayObject.hitArea && displayObject.containsPoint) {
              if (displayObject.containsPoint(point)) {
                hit = true;
              }
            }
          }
          if (displayObject.interactive) {
            if (hit && !interactionEvent.target) {
              interactionEvent.target = displayObject;
            }
            if (func) {
              func(interactionEvent, displayObject, !!hit);
            }
          }
        }
        return hit;
      };
      TreeSearch2.prototype.findHit = function(interactionEvent, displayObject, func, hitTest) {
        this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);
      };
      return TreeSearch2;
    }();
    var interactiveTarget = {
      interactive: false,
      interactiveChildren: true,
      hitArea: null,
      get buttonMode() {
        return this.cursor === "pointer";
      },
      set buttonMode(value2) {
        if (value2) {
          this.cursor = "pointer";
        } else if (this.cursor === "pointer") {
          this.cursor = null;
        }
      },
      cursor: null,
      get trackedPointers() {
        if (this._trackedPointers === void 0) {
          this._trackedPointers = {};
        }
        return this._trackedPointers;
      },
      _trackedPointers: void 0
    };
    DisplayObject.mixin(interactiveTarget);
    var MOUSE_POINTER_ID = 1;
    var hitTestEvent = {
      target: null,
      data: {
        global: null
      }
    };
    var InteractionManager = function(_super) {
      __extends$i(InteractionManager2, _super);
      function InteractionManager2(renderer, options) {
        var _this = _super.call(this) || this;
        options = options || {};
        _this.renderer = renderer;
        _this.autoPreventDefault = options.autoPreventDefault !== void 0 ? options.autoPreventDefault : true;
        _this.interactionFrequency = options.interactionFrequency || 10;
        _this.mouse = new InteractionData();
        _this.mouse.identifier = MOUSE_POINTER_ID;
        _this.mouse.global.set(-999999);
        _this.activeInteractionData = {};
        _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
        _this.interactionDataPool = [];
        _this.eventData = new InteractionEvent();
        _this.interactionDOMElement = null;
        _this.moveWhenInside = false;
        _this.eventsAdded = false;
        _this.tickerAdded = false;
        _this.mouseOverRenderer = false;
        _this.supportsTouchEvents = "ontouchstart" in window;
        _this.supportsPointerEvents = !!window.PointerEvent;
        _this.onPointerUp = _this.onPointerUp.bind(_this);
        _this.processPointerUp = _this.processPointerUp.bind(_this);
        _this.onPointerCancel = _this.onPointerCancel.bind(_this);
        _this.processPointerCancel = _this.processPointerCancel.bind(_this);
        _this.onPointerDown = _this.onPointerDown.bind(_this);
        _this.processPointerDown = _this.processPointerDown.bind(_this);
        _this.onPointerMove = _this.onPointerMove.bind(_this);
        _this.processPointerMove = _this.processPointerMove.bind(_this);
        _this.onPointerOut = _this.onPointerOut.bind(_this);
        _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
        _this.onPointerOver = _this.onPointerOver.bind(_this);
        _this.cursorStyles = {
          default: "inherit",
          pointer: "pointer"
        };
        _this.currentCursorMode = null;
        _this.cursor = null;
        _this.resolution = 1;
        _this.delayedEvents = [];
        _this.search = new TreeSearch();
        _this._tempDisplayObject = new TemporaryDisplayObject();
        _this._useSystemTicker = options.useSystemTicker !== void 0 ? options.useSystemTicker : true;
        _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);
        return _this;
      }
      Object.defineProperty(InteractionManager2.prototype, "useSystemTicker", {
        get: function() {
          return this._useSystemTicker;
        },
        set: function(useSystemTicker) {
          this._useSystemTicker = useSystemTicker;
          if (useSystemTicker) {
            this.addTickerListener();
          } else {
            this.removeTickerListener();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(InteractionManager2.prototype, "lastObjectRendered", {
        get: function() {
          return this.renderer._lastObjectRendered || this._tempDisplayObject;
        },
        enumerable: false,
        configurable: true
      });
      InteractionManager2.prototype.hitTest = function(globalPoint, root2) {
        hitTestEvent.target = null;
        hitTestEvent.data.global = globalPoint;
        if (!root2) {
          root2 = this.lastObjectRendered;
        }
        this.processInteractive(hitTestEvent, root2, null, true);
        return hitTestEvent.target;
      };
      InteractionManager2.prototype.setTargetElement = function(element, resolution) {
        if (resolution === void 0) {
          resolution = 1;
        }
        this.removeTickerListener();
        this.removeEvents();
        this.interactionDOMElement = element;
        this.resolution = resolution;
        this.addEvents();
        this.addTickerListener();
      };
      InteractionManager2.prototype.addTickerListener = function() {
        if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {
          return;
        }
        Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
        this.tickerAdded = true;
      };
      InteractionManager2.prototype.removeTickerListener = function() {
        if (!this.tickerAdded) {
          return;
        }
        Ticker.system.remove(this.tickerUpdate, this);
        this.tickerAdded = false;
      };
      InteractionManager2.prototype.addEvents = function() {
        if (this.eventsAdded || !this.interactionDOMElement) {
          return;
        }
        var style = this.interactionDOMElement.style;
        if (window.navigator.msPointerEnabled) {
          style.msContentZooming = "none";
          style.msTouchAction = "none";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "none";
        }
        if (this.supportsPointerEvents) {
          window.document.addEventListener("pointermove", this.onPointerMove, true);
          this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, true);
          this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, true);
          this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, true);
          window.addEventListener("pointercancel", this.onPointerCancel, true);
          window.addEventListener("pointerup", this.onPointerUp, true);
        } else {
          window.document.addEventListener("mousemove", this.onPointerMove, true);
          this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, true);
          this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, true);
          this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, true);
          window.addEventListener("mouseup", this.onPointerUp, true);
        }
        if (this.supportsTouchEvents) {
          this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, true);
          this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, true);
          this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, true);
          this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, true);
        }
        this.eventsAdded = true;
      };
      InteractionManager2.prototype.removeEvents = function() {
        if (!this.eventsAdded || !this.interactionDOMElement) {
          return;
        }
        var style = this.interactionDOMElement.style;
        if (window.navigator.msPointerEnabled) {
          style.msContentZooming = "";
          style.msTouchAction = "";
        } else if (this.supportsPointerEvents) {
          style.touchAction = "";
        }
        if (this.supportsPointerEvents) {
          window.document.removeEventListener("pointermove", this.onPointerMove, true);
          this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, true);
          this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, true);
          this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, true);
          window.removeEventListener("pointercancel", this.onPointerCancel, true);
          window.removeEventListener("pointerup", this.onPointerUp, true);
        } else {
          window.document.removeEventListener("mousemove", this.onPointerMove, true);
          this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, true);
          this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, true);
          this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, true);
          window.removeEventListener("mouseup", this.onPointerUp, true);
        }
        if (this.supportsTouchEvents) {
          this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, true);
          this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, true);
          this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, true);
          this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, true);
        }
        this.interactionDOMElement = null;
        this.eventsAdded = false;
      };
      InteractionManager2.prototype.tickerUpdate = function(deltaTime) {
        this._deltaTime += deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
          return;
        }
        this._deltaTime = 0;
        this.update();
      };
      InteractionManager2.prototype.update = function() {
        if (!this.interactionDOMElement) {
          return;
        }
        if (this._didMove) {
          this._didMove = false;
          return;
        }
        this.cursor = null;
        for (var k in this.activeInteractionData) {
          if (this.activeInteractionData.hasOwnProperty(k)) {
            var interactionData = this.activeInteractionData[k];
            if (interactionData.originalEvent && interactionData.pointerType !== "touch") {
              var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
              this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, true);
            }
          }
        }
        this.setCursorMode(this.cursor);
      };
      InteractionManager2.prototype.setCursorMode = function(mode) {
        mode = mode || "default";
        if (this.currentCursorMode === mode) {
          return;
        }
        this.currentCursorMode = mode;
        var style = this.cursorStyles[mode];
        if (style) {
          switch (typeof style) {
            case "string":
              this.interactionDOMElement.style.cursor = style;
              break;
            case "function":
              style(mode);
              break;
            case "object":
              Object.assign(this.interactionDOMElement.style, style);
              break;
          }
        } else if (typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
          this.interactionDOMElement.style.cursor = mode;
        }
      };
      InteractionManager2.prototype.dispatchEvent = function(displayObject, eventString, eventData) {
        if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {
          eventData.currentTarget = displayObject;
          eventData.type = eventString;
          displayObject.emit(eventString, eventData);
          if (displayObject[eventString]) {
            displayObject[eventString](eventData);
          }
        }
      };
      InteractionManager2.prototype.delayDispatchEvent = function(displayObject, eventString, eventData) {
        this.delayedEvents.push({ displayObject, eventString, eventData });
      };
      InteractionManager2.prototype.mapPositionToPoint = function(point, x2, y2) {
        var rect;
        if (!this.interactionDOMElement.parentElement) {
          rect = { x: 0, y: 0, width: 0, height: 0 };
        } else {
          rect = this.interactionDOMElement.getBoundingClientRect();
        }
        var resolutionMultiplier = 1 / this.resolution;
        point.x = (x2 - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
        point.y = (y2 - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
      };
      InteractionManager2.prototype.processInteractive = function(interactionEvent, displayObject, func, hitTest) {
        var hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);
        var delayedEvents = this.delayedEvents;
        if (!delayedEvents.length) {
          return hit;
        }
        interactionEvent.stopPropagationHint = false;
        var delayedLen = delayedEvents.length;
        this.delayedEvents = [];
        for (var i2 = 0; i2 < delayedLen; i2++) {
          var _a2 = delayedEvents[i2], displayObject_1 = _a2.displayObject, eventString = _a2.eventString, eventData = _a2.eventData;
          if (eventData.stopsPropagatingAt === displayObject_1) {
            eventData.stopPropagationHint = true;
          }
          this.dispatchEvent(displayObject_1, eventString, eventData);
        }
        return hit;
      };
      InteractionManager2.prototype.onPointerDown = function(originalEvent) {
        if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
          return;
        }
        var events2 = this.normalizeToPointerData(originalEvent);
        if (this.autoPreventDefault && events2[0].isNormalized) {
          var cancelable = originalEvent.cancelable || !("cancelable" in originalEvent);
          if (cancelable) {
            originalEvent.preventDefault();
          }
        }
        var eventLen = events2.length;
        for (var i2 = 0; i2 < eventLen; i2++) {
          var event = events2[i2];
          var interactionData = this.getInteractionDataForPointerId(event);
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
          interactionEvent.data.originalEvent = originalEvent;
          this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerDown, true);
          this.emit("pointerdown", interactionEvent);
          if (event.pointerType === "touch") {
            this.emit("touchstart", interactionEvent);
          } else if (event.pointerType === "mouse" || event.pointerType === "pen") {
            var isRightButton = event.button === 2;
            this.emit(isRightButton ? "rightdown" : "mousedown", this.eventData);
          }
        }
      };
      InteractionManager2.prototype.processPointerDown = function(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var id2 = interactionEvent.data.identifier;
        if (hit) {
          if (!displayObject.trackedPointers[id2]) {
            displayObject.trackedPointers[id2] = new InteractionTrackingData(id2);
          }
          this.dispatchEvent(displayObject, "pointerdown", interactionEvent);
          if (data.pointerType === "touch") {
            this.dispatchEvent(displayObject, "touchstart", interactionEvent);
          } else if (data.pointerType === "mouse" || data.pointerType === "pen") {
            var isRightButton = data.button === 2;
            if (isRightButton) {
              displayObject.trackedPointers[id2].rightDown = true;
            } else {
              displayObject.trackedPointers[id2].leftDown = true;
            }
            this.dispatchEvent(displayObject, isRightButton ? "rightdown" : "mousedown", interactionEvent);
          }
        }
      };
      InteractionManager2.prototype.onPointerComplete = function(originalEvent, cancelled, func) {
        var events2 = this.normalizeToPointerData(originalEvent);
        var eventLen = events2.length;
        var eventAppend = originalEvent.target !== this.interactionDOMElement ? "outside" : "";
        for (var i2 = 0; i2 < eventLen; i2++) {
          var event = events2[i2];
          var interactionData = this.getInteractionDataForPointerId(event);
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
          interactionEvent.data.originalEvent = originalEvent;
          this.processInteractive(interactionEvent, this.lastObjectRendered, func, cancelled || !eventAppend);
          this.emit(cancelled ? "pointercancel" : "pointerup" + eventAppend, interactionEvent);
          if (event.pointerType === "mouse" || event.pointerType === "pen") {
            var isRightButton = event.button === 2;
            this.emit(isRightButton ? "rightup" + eventAppend : "mouseup" + eventAppend, interactionEvent);
          } else if (event.pointerType === "touch") {
            this.emit(cancelled ? "touchcancel" : "touchend" + eventAppend, interactionEvent);
            this.releaseInteractionDataForPointerId(event.pointerId);
          }
        }
      };
      InteractionManager2.prototype.onPointerCancel = function(event) {
        if (this.supportsTouchEvents && event.pointerType === "touch") {
          return;
        }
        this.onPointerComplete(event, true, this.processPointerCancel);
      };
      InteractionManager2.prototype.processPointerCancel = function(interactionEvent, displayObject) {
        var data = interactionEvent.data;
        var id2 = interactionEvent.data.identifier;
        if (displayObject.trackedPointers[id2] !== void 0) {
          delete displayObject.trackedPointers[id2];
          this.dispatchEvent(displayObject, "pointercancel", interactionEvent);
          if (data.pointerType === "touch") {
            this.dispatchEvent(displayObject, "touchcancel", interactionEvent);
          }
        }
      };
      InteractionManager2.prototype.onPointerUp = function(event) {
        if (this.supportsTouchEvents && event.pointerType === "touch") {
          return;
        }
        this.onPointerComplete(event, false, this.processPointerUp);
      };
      InteractionManager2.prototype.processPointerUp = function(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var id2 = interactionEvent.data.identifier;
        var trackingData = displayObject.trackedPointers[id2];
        var isTouch = data.pointerType === "touch";
        var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
        var isMouseTap = false;
        if (isMouse) {
          var isRightButton = data.button === 2;
          var flags = InteractionTrackingData.FLAGS;
          var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
          var isDown = trackingData !== void 0 && trackingData.flags & test;
          if (hit) {
            this.dispatchEvent(displayObject, isRightButton ? "rightup" : "mouseup", interactionEvent);
            if (isDown) {
              this.dispatchEvent(displayObject, isRightButton ? "rightclick" : "click", interactionEvent);
              isMouseTap = true;
            }
          } else if (isDown) {
            this.dispatchEvent(displayObject, isRightButton ? "rightupoutside" : "mouseupoutside", interactionEvent);
          }
          if (trackingData) {
            if (isRightButton) {
              trackingData.rightDown = false;
            } else {
              trackingData.leftDown = false;
            }
          }
        }
        if (hit) {
          this.dispatchEvent(displayObject, "pointerup", interactionEvent);
          if (isTouch) {
            this.dispatchEvent(displayObject, "touchend", interactionEvent);
          }
          if (trackingData) {
            if (!isMouse || isMouseTap) {
              this.dispatchEvent(displayObject, "pointertap", interactionEvent);
            }
            if (isTouch) {
              this.dispatchEvent(displayObject, "tap", interactionEvent);
              trackingData.over = false;
            }
          }
        } else if (trackingData) {
          this.dispatchEvent(displayObject, "pointerupoutside", interactionEvent);
          if (isTouch) {
            this.dispatchEvent(displayObject, "touchendoutside", interactionEvent);
          }
        }
        if (trackingData && trackingData.none) {
          delete displayObject.trackedPointers[id2];
        }
      };
      InteractionManager2.prototype.onPointerMove = function(originalEvent) {
        if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
          return;
        }
        var events2 = this.normalizeToPointerData(originalEvent);
        if (events2[0].pointerType === "mouse" || events2[0].pointerType === "pen") {
          this._didMove = true;
          this.cursor = null;
        }
        var eventLen = events2.length;
        for (var i2 = 0; i2 < eventLen; i2++) {
          var event = events2[i2];
          var interactionData = this.getInteractionDataForPointerId(event);
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
          interactionEvent.data.originalEvent = originalEvent;
          this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerMove, true);
          this.emit("pointermove", interactionEvent);
          if (event.pointerType === "touch") {
            this.emit("touchmove", interactionEvent);
          }
          if (event.pointerType === "mouse" || event.pointerType === "pen") {
            this.emit("mousemove", interactionEvent);
          }
        }
        if (events2[0].pointerType === "mouse") {
          this.setCursorMode(this.cursor);
        }
      };
      InteractionManager2.prototype.processPointerMove = function(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var isTouch = data.pointerType === "touch";
        var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
        if (isMouse) {
          this.processPointerOverOut(interactionEvent, displayObject, hit);
        }
        if (!this.moveWhenInside || hit) {
          this.dispatchEvent(displayObject, "pointermove", interactionEvent);
          if (isTouch) {
            this.dispatchEvent(displayObject, "touchmove", interactionEvent);
          }
          if (isMouse) {
            this.dispatchEvent(displayObject, "mousemove", interactionEvent);
          }
        }
      };
      InteractionManager2.prototype.onPointerOut = function(originalEvent) {
        if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
          return;
        }
        var events2 = this.normalizeToPointerData(originalEvent);
        var event = events2[0];
        if (event.pointerType === "mouse") {
          this.mouseOverRenderer = false;
          this.setCursorMode(null);
        }
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = event;
        this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, false);
        this.emit("pointerout", interactionEvent);
        if (event.pointerType === "mouse" || event.pointerType === "pen") {
          this.emit("mouseout", interactionEvent);
        } else {
          this.releaseInteractionDataForPointerId(interactionData.identifier);
        }
      };
      InteractionManager2.prototype.processPointerOverOut = function(interactionEvent, displayObject, hit) {
        var data = interactionEvent.data;
        var id2 = interactionEvent.data.identifier;
        var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
        var trackingData = displayObject.trackedPointers[id2];
        if (hit && !trackingData) {
          trackingData = displayObject.trackedPointers[id2] = new InteractionTrackingData(id2);
        }
        if (trackingData === void 0) {
          return;
        }
        if (hit && this.mouseOverRenderer) {
          if (!trackingData.over) {
            trackingData.over = true;
            this.delayDispatchEvent(displayObject, "pointerover", interactionEvent);
            if (isMouse) {
              this.delayDispatchEvent(displayObject, "mouseover", interactionEvent);
            }
          }
          if (isMouse && this.cursor === null) {
            this.cursor = displayObject.cursor;
          }
        } else if (trackingData.over) {
          trackingData.over = false;
          this.dispatchEvent(displayObject, "pointerout", this.eventData);
          if (isMouse) {
            this.dispatchEvent(displayObject, "mouseout", interactionEvent);
          }
          if (trackingData.none) {
            delete displayObject.trackedPointers[id2];
          }
        }
      };
      InteractionManager2.prototype.onPointerOver = function(originalEvent) {
        var events2 = this.normalizeToPointerData(originalEvent);
        var event = events2[0];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = event;
        if (event.pointerType === "mouse") {
          this.mouseOverRenderer = true;
        }
        this.emit("pointerover", interactionEvent);
        if (event.pointerType === "mouse" || event.pointerType === "pen") {
          this.emit("mouseover", interactionEvent);
        }
      };
      InteractionManager2.prototype.getInteractionDataForPointerId = function(event) {
        var pointerId = event.pointerId;
        var interactionData;
        if (pointerId === MOUSE_POINTER_ID || event.pointerType === "mouse") {
          interactionData = this.mouse;
        } else if (this.activeInteractionData[pointerId]) {
          interactionData = this.activeInteractionData[pointerId];
        } else {
          interactionData = this.interactionDataPool.pop() || new InteractionData();
          interactionData.identifier = pointerId;
          this.activeInteractionData[pointerId] = interactionData;
        }
        interactionData.copyEvent(event);
        return interactionData;
      };
      InteractionManager2.prototype.releaseInteractionDataForPointerId = function(pointerId) {
        var interactionData = this.activeInteractionData[pointerId];
        if (interactionData) {
          delete this.activeInteractionData[pointerId];
          interactionData.reset();
          this.interactionDataPool.push(interactionData);
        }
      };
      InteractionManager2.prototype.configureInteractionEventForDOMEvent = function(interactionEvent, pointerEvent, interactionData) {
        interactionEvent.data = interactionData;
        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
        if (pointerEvent.pointerType === "touch") {
          pointerEvent.globalX = interactionData.global.x;
          pointerEvent.globalY = interactionData.global.y;
        }
        interactionData.originalEvent = pointerEvent;
        interactionEvent.reset();
        return interactionEvent;
      };
      InteractionManager2.prototype.normalizeToPointerData = function(event) {
        var normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
          for (var i2 = 0, li2 = event.changedTouches.length; i2 < li2; i2++) {
            var touch = event.changedTouches[i2];
            if (typeof touch.button === "undefined") {
              touch.button = event.touches.length ? 1 : 0;
            }
            if (typeof touch.buttons === "undefined") {
              touch.buttons = event.touches.length ? 1 : 0;
            }
            if (typeof touch.isPrimary === "undefined") {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if (typeof touch.width === "undefined") {
              touch.width = touch.radiusX || 1;
            }
            if (typeof touch.height === "undefined") {
              touch.height = touch.radiusY || 1;
            }
            if (typeof touch.tiltX === "undefined") {
              touch.tiltX = 0;
            }
            if (typeof touch.tiltY === "undefined") {
              touch.tiltY = 0;
            }
            if (typeof touch.pointerType === "undefined") {
              touch.pointerType = "touch";
            }
            if (typeof touch.pointerId === "undefined") {
              touch.pointerId = touch.identifier || 0;
            }
            if (typeof touch.pressure === "undefined") {
              touch.pressure = touch.force || 0.5;
            }
            if (typeof touch.twist === "undefined") {
              touch.twist = 0;
            }
            if (typeof touch.tangentialPressure === "undefined") {
              touch.tangentialPressure = 0;
            }
            if (typeof touch.layerX === "undefined") {
              touch.layerX = touch.offsetX = touch.clientX;
            }
            if (typeof touch.layerY === "undefined") {
              touch.layerY = touch.offsetY = touch.clientY;
            }
            touch.isNormalized = true;
            normalizedEvents.push(touch);
          }
        } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {
          var tempEvent = event;
          if (typeof tempEvent.isPrimary === "undefined") {
            tempEvent.isPrimary = true;
          }
          if (typeof tempEvent.width === "undefined") {
            tempEvent.width = 1;
          }
          if (typeof tempEvent.height === "undefined") {
            tempEvent.height = 1;
          }
          if (typeof tempEvent.tiltX === "undefined") {
            tempEvent.tiltX = 0;
          }
          if (typeof tempEvent.tiltY === "undefined") {
            tempEvent.tiltY = 0;
          }
          if (typeof tempEvent.pointerType === "undefined") {
            tempEvent.pointerType = "mouse";
          }
          if (typeof tempEvent.pointerId === "undefined") {
            tempEvent.pointerId = MOUSE_POINTER_ID;
          }
          if (typeof tempEvent.pressure === "undefined") {
            tempEvent.pressure = 0.5;
          }
          if (typeof tempEvent.twist === "undefined") {
            tempEvent.twist = 0;
          }
          if (typeof tempEvent.tangentialPressure === "undefined") {
            tempEvent.tangentialPressure = 0;
          }
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      };
      InteractionManager2.prototype.destroy = function() {
        this.removeEvents();
        this.removeTickerListener();
        this.removeAllListeners();
        this.renderer = null;
        this.mouse = null;
        this.eventData = null;
        this.interactionDOMElement = null;
        this.onPointerDown = null;
        this.processPointerDown = null;
        this.onPointerUp = null;
        this.processPointerUp = null;
        this.onPointerCancel = null;
        this.processPointerCancel = null;
        this.onPointerMove = null;
        this.processPointerMove = null;
        this.onPointerOut = null;
        this.processPointerOverOut = null;
        this.onPointerOver = null;
        this.search = null;
      };
      return InteractionManager2;
    }(EventEmitter);
    /*!
     * @pixi/runner - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/runner is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var Runner = function() {
      function Runner2(name) {
        this.items = [];
        this._name = name;
        this._aliasCount = 0;
      }
      Runner2.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {
        if (arguments.length > 8) {
          throw new Error("max arguments reached");
        }
        var _a2 = this, name = _a2.name, items2 = _a2.items;
        this._aliasCount++;
        for (var i2 = 0, len = items2.length; i2 < len; i2++) {
          items2[i2][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        if (items2 === this.items) {
          this._aliasCount--;
        }
        return this;
      };
      Runner2.prototype.ensureNonAliasedItems = function() {
        if (this._aliasCount > 0 && this.items.length > 1) {
          this._aliasCount = 0;
          this.items = this.items.slice(0);
        }
      };
      Runner2.prototype.add = function(item) {
        if (item[this._name]) {
          this.ensureNonAliasedItems();
          this.remove(item);
          this.items.push(item);
        }
        return this;
      };
      Runner2.prototype.remove = function(item) {
        var index2 = this.items.indexOf(item);
        if (index2 !== -1) {
          this.ensureNonAliasedItems();
          this.items.splice(index2, 1);
        }
        return this;
      };
      Runner2.prototype.contains = function(item) {
        return this.items.indexOf(item) !== -1;
      };
      Runner2.prototype.removeAll = function() {
        this.ensureNonAliasedItems();
        this.items.length = 0;
        return this;
      };
      Runner2.prototype.destroy = function() {
        this.removeAll();
        this.items = null;
        this._name = null;
      };
      Object.defineProperty(Runner2.prototype, "empty", {
        get: function() {
          return this.items.length === 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Runner2.prototype, "name", {
        get: function() {
          return this._name;
        },
        enumerable: false,
        configurable: true
      });
      return Runner2;
    }();
    Object.defineProperties(Runner.prototype, {
      dispatch: { value: Runner.prototype.emit },
      run: { value: Runner.prototype.emit }
    });
    /*!
     * @pixi/core - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/core is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    settings.PREFER_ENV = isMobile.any ? ENV$1.WEBGL : ENV$1.WEBGL2;
    settings.STRICT_TEXTURE_CACHE = false;
    var INSTALLED = [];
    function autoDetectResource(source, options) {
      if (!source) {
        return null;
      }
      var extension = "";
      if (typeof source === "string") {
        var result2 = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
        if (result2) {
          extension = result2[1].toLowerCase();
        }
      }
      for (var i2 = INSTALLED.length - 1; i2 >= 0; --i2) {
        var ResourcePlugin = INSTALLED[i2];
        if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
          return new ResourcePlugin(source, options);
        }
      }
      throw new Error("Unrecognized source type to auto-detect Resource");
    }
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$h = function(d, b) {
      extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$h(d, b);
    };
    function __extends$h(d, b) {
      extendStatics$h(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var Resource$1 = function() {
      function Resource2(width2, height2) {
        if (width2 === void 0) {
          width2 = 0;
        }
        if (height2 === void 0) {
          height2 = 0;
        }
        this._width = width2;
        this._height = height2;
        this.destroyed = false;
        this.internal = false;
        this.onResize = new Runner("setRealSize");
        this.onUpdate = new Runner("update");
        this.onError = new Runner("onError");
      }
      Resource2.prototype.bind = function(baseTexture) {
        this.onResize.add(baseTexture);
        this.onUpdate.add(baseTexture);
        this.onError.add(baseTexture);
        if (this._width || this._height) {
          this.onResize.emit(this._width, this._height);
        }
      };
      Resource2.prototype.unbind = function(baseTexture) {
        this.onResize.remove(baseTexture);
        this.onUpdate.remove(baseTexture);
        this.onError.remove(baseTexture);
      };
      Resource2.prototype.resize = function(width2, height2) {
        if (width2 !== this._width || height2 !== this._height) {
          this._width = width2;
          this._height = height2;
          this.onResize.emit(width2, height2);
        }
      };
      Object.defineProperty(Resource2.prototype, "valid", {
        get: function() {
          return !!this._width && !!this._height;
        },
        enumerable: false,
        configurable: true
      });
      Resource2.prototype.update = function() {
        if (!this.destroyed) {
          this.onUpdate.emit();
        }
      };
      Resource2.prototype.load = function() {
        return Promise.resolve(this);
      };
      Object.defineProperty(Resource2.prototype, "width", {
        get: function() {
          return this._width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Resource2.prototype, "height", {
        get: function() {
          return this._height;
        },
        enumerable: false,
        configurable: true
      });
      Resource2.prototype.style = function(_renderer, _baseTexture, _glTexture) {
        return false;
      };
      Resource2.prototype.dispose = function() {
      };
      Resource2.prototype.destroy = function() {
        if (!this.destroyed) {
          this.destroyed = true;
          this.dispose();
          this.onError.removeAll();
          this.onError = null;
          this.onResize.removeAll();
          this.onResize = null;
          this.onUpdate.removeAll();
          this.onUpdate = null;
        }
      };
      Resource2.test = function(_source, _extension) {
        return false;
      };
      return Resource2;
    }();
    var BufferResource = function(_super) {
      __extends$h(BufferResource2, _super);
      function BufferResource2(source, options) {
        var _this = this;
        var _a2 = options || {}, width2 = _a2.width, height2 = _a2.height;
        if (!width2 || !height2) {
          throw new Error("BufferResource width or height invalid");
        }
        _this = _super.call(this, width2, height2) || this;
        _this.data = source;
        return _this;
      }
      BufferResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$1.UNPACK);
        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
          gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
        } else {
          glTexture.width = baseTexture.width;
          glTexture.height = baseTexture.height;
          gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.width, baseTexture.height, 0, baseTexture.format, glTexture.type, this.data);
        }
        return true;
      };
      BufferResource2.prototype.dispose = function() {
        this.data = null;
      };
      BufferResource2.test = function(source) {
        return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
      };
      return BufferResource2;
    }(Resource$1);
    var defaultBufferOptions = {
      scaleMode: SCALE_MODES$1.NEAREST,
      format: FORMATS$1.RGBA,
      alphaMode: ALPHA_MODES$1.NPM
    };
    var BaseTexture = function(_super) {
      __extends$h(BaseTexture2, _super);
      function BaseTexture2(resource, options) {
        if (resource === void 0) {
          resource = null;
        }
        if (options === void 0) {
          options = null;
        }
        var _this = _super.call(this) || this;
        options = options || {};
        var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width2 = options.width, height2 = options.height, wrapMode = options.wrapMode, format2 = options.format, type = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
        if (resource && !(resource instanceof Resource$1)) {
          resource = autoDetectResource(resource, resourceOptions);
          resource.internal = true;
        }
        _this.width = width2 || 0;
        _this.height = height2 || 0;
        _this.resolution = resolution || settings.RESOLUTION;
        _this.mipmap = mipmap !== void 0 ? mipmap : settings.MIPMAP_TEXTURES;
        _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings.ANISOTROPIC_LEVEL;
        _this.wrapMode = wrapMode || settings.WRAP_MODE;
        _this.scaleMode = scaleMode !== void 0 ? scaleMode : settings.SCALE_MODE;
        _this.format = format2 || FORMATS$1.RGBA;
        _this.type = type || TYPES$1.UNSIGNED_BYTE;
        _this.target = target || TARGETS$1.TEXTURE_2D;
        _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES$1.UNPACK;
        if (options.premultiplyAlpha !== void 0) {
          _this.premultiplyAlpha = options.premultiplyAlpha;
        }
        _this.uid = uid();
        _this.touched = 0;
        _this.isPowerOfTwo = false;
        _this._refreshPOT();
        _this._glTextures = {};
        _this.dirtyId = 0;
        _this.dirtyStyleId = 0;
        _this.cacheId = null;
        _this.valid = width2 > 0 && height2 > 0;
        _this.textureCacheIds = [];
        _this.destroyed = false;
        _this.resource = null;
        _this._batchEnabled = 0;
        _this._batchLocation = 0;
        _this.parentTextureArray = null;
        _this.setResource(resource);
        return _this;
      }
      Object.defineProperty(BaseTexture2.prototype, "realWidth", {
        get: function() {
          return Math.ceil(this.width * this.resolution - 1e-4);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseTexture2.prototype, "realHeight", {
        get: function() {
          return Math.ceil(this.height * this.resolution - 1e-4);
        },
        enumerable: false,
        configurable: true
      });
      BaseTexture2.prototype.setStyle = function(scaleMode, mipmap) {
        var dirty;
        if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
          this.scaleMode = scaleMode;
          dirty = true;
        }
        if (mipmap !== void 0 && mipmap !== this.mipmap) {
          this.mipmap = mipmap;
          dirty = true;
        }
        if (dirty) {
          this.dirtyStyleId++;
        }
        return this;
      };
      BaseTexture2.prototype.setSize = function(width2, height2, resolution) {
        this.resolution = resolution || this.resolution;
        this.width = width2;
        this.height = height2;
        this._refreshPOT();
        this.update();
        return this;
      };
      BaseTexture2.prototype.setRealSize = function(realWidth, realHeight, resolution) {
        this.resolution = resolution || this.resolution;
        this.width = realWidth / this.resolution;
        this.height = realHeight / this.resolution;
        this._refreshPOT();
        this.update();
        return this;
      };
      BaseTexture2.prototype._refreshPOT = function() {
        this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
      };
      BaseTexture2.prototype.setResolution = function(resolution) {
        var oldResolution = this.resolution;
        if (oldResolution === resolution) {
          return this;
        }
        this.resolution = resolution;
        if (this.valid) {
          this.width = this.width * oldResolution / resolution;
          this.height = this.height * oldResolution / resolution;
          this.emit("update", this);
        }
        this._refreshPOT();
        return this;
      };
      BaseTexture2.prototype.setResource = function(resource) {
        if (this.resource === resource) {
          return this;
        }
        if (this.resource) {
          throw new Error("Resource can be set only once");
        }
        resource.bind(this);
        this.resource = resource;
        return this;
      };
      BaseTexture2.prototype.update = function() {
        if (!this.valid) {
          if (this.width > 0 && this.height > 0) {
            this.valid = true;
            this.emit("loaded", this);
            this.emit("update", this);
          }
        } else {
          this.dirtyId++;
          this.dirtyStyleId++;
          this.emit("update", this);
        }
      };
      BaseTexture2.prototype.onError = function(event) {
        this.emit("error", this, event);
      };
      BaseTexture2.prototype.destroy = function() {
        if (this.resource) {
          this.resource.unbind(this);
          if (this.resource.internal) {
            this.resource.destroy();
          }
          this.resource = null;
        }
        if (this.cacheId) {
          delete BaseTextureCache[this.cacheId];
          delete TextureCache[this.cacheId];
          this.cacheId = null;
        }
        this.dispose();
        BaseTexture2.removeFromCache(this);
        this.textureCacheIds = null;
        this.destroyed = true;
      };
      BaseTexture2.prototype.dispose = function() {
        this.emit("dispose", this);
      };
      BaseTexture2.prototype.castToBaseTexture = function() {
        return this;
      };
      BaseTexture2.from = function(source, options, strict) {
        if (strict === void 0) {
          strict = settings.STRICT_TEXTURE_CACHE;
        }
        var isFrame = typeof source === "string";
        var cacheId = null;
        if (isFrame) {
          cacheId = source;
        } else {
          if (!source._pixiId) {
            source._pixiId = "pixiid_" + uid();
          }
          cacheId = source._pixiId;
        }
        var baseTexture = BaseTextureCache[cacheId];
        if (isFrame && strict && !baseTexture) {
          throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
        }
        if (!baseTexture) {
          baseTexture = new BaseTexture2(source, options);
          baseTexture.cacheId = cacheId;
          BaseTexture2.addToCache(baseTexture, cacheId);
        }
        return baseTexture;
      };
      BaseTexture2.fromBuffer = function(buffer, width2, height2, options) {
        buffer = buffer || new Float32Array(width2 * height2 * 4);
        var resource = new BufferResource(buffer, { width: width2, height: height2 });
        var type = buffer instanceof Float32Array ? TYPES$1.FLOAT : TYPES$1.UNSIGNED_BYTE;
        return new BaseTexture2(resource, Object.assign(defaultBufferOptions, options || { width: width2, height: height2, type }));
      };
      BaseTexture2.addToCache = function(baseTexture, id2) {
        if (id2) {
          if (baseTexture.textureCacheIds.indexOf(id2) === -1) {
            baseTexture.textureCacheIds.push(id2);
          }
          if (BaseTextureCache[id2]) {
            console.warn("BaseTexture added to the cache with an id [" + id2 + "] that already had an entry");
          }
          BaseTextureCache[id2] = baseTexture;
        }
      };
      BaseTexture2.removeFromCache = function(baseTexture) {
        if (typeof baseTexture === "string") {
          var baseTextureFromCache = BaseTextureCache[baseTexture];
          if (baseTextureFromCache) {
            var index2 = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
            if (index2 > -1) {
              baseTextureFromCache.textureCacheIds.splice(index2, 1);
            }
            delete BaseTextureCache[baseTexture];
            return baseTextureFromCache;
          }
        } else if (baseTexture && baseTexture.textureCacheIds) {
          for (var i2 = 0; i2 < baseTexture.textureCacheIds.length; ++i2) {
            delete BaseTextureCache[baseTexture.textureCacheIds[i2]];
          }
          baseTexture.textureCacheIds.length = 0;
          return baseTexture;
        }
        return null;
      };
      BaseTexture2._globalBatch = 0;
      return BaseTexture2;
    }(EventEmitter);
    var AbstractMultiResource = function(_super) {
      __extends$h(AbstractMultiResource2, _super);
      function AbstractMultiResource2(length, options) {
        var _this = this;
        var _a2 = options || {}, width2 = _a2.width, height2 = _a2.height;
        _this = _super.call(this, width2, height2) || this;
        _this.items = [];
        _this.itemDirtyIds = [];
        for (var i2 = 0; i2 < length; i2++) {
          var partTexture = new BaseTexture();
          _this.items.push(partTexture);
          _this.itemDirtyIds.push(-2);
        }
        _this.length = length;
        _this._load = null;
        _this.baseTexture = null;
        return _this;
      }
      AbstractMultiResource2.prototype.initFromArray = function(resources, options) {
        for (var i2 = 0; i2 < this.length; i2++) {
          if (!resources[i2]) {
            continue;
          }
          if (resources[i2].castToBaseTexture) {
            this.addBaseTextureAt(resources[i2].castToBaseTexture(), i2);
          } else if (resources[i2] instanceof Resource$1) {
            this.addResourceAt(resources[i2], i2);
          } else {
            this.addResourceAt(autoDetectResource(resources[i2], options), i2);
          }
        }
      };
      AbstractMultiResource2.prototype.dispose = function() {
        for (var i2 = 0, len = this.length; i2 < len; i2++) {
          this.items[i2].destroy();
        }
        this.items = null;
        this.itemDirtyIds = null;
        this._load = null;
      };
      AbstractMultiResource2.prototype.addResourceAt = function(resource, index2) {
        if (!this.items[index2]) {
          throw new Error("Index " + index2 + " is out of bounds");
        }
        if (resource.valid && !this.valid) {
          this.resize(resource.width, resource.height);
        }
        this.items[index2].setResource(resource);
        return this;
      };
      AbstractMultiResource2.prototype.bind = function(baseTexture) {
        if (this.baseTexture !== null) {
          throw new Error("Only one base texture per TextureArray is allowed");
        }
        _super.prototype.bind.call(this, baseTexture);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.items[i2].parentTextureArray = baseTexture;
          this.items[i2].on("update", baseTexture.update, baseTexture);
        }
      };
      AbstractMultiResource2.prototype.unbind = function(baseTexture) {
        _super.prototype.unbind.call(this, baseTexture);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.items[i2].parentTextureArray = null;
          this.items[i2].off("update", baseTexture.update, baseTexture);
        }
      };
      AbstractMultiResource2.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        var resources = this.items.map(function(item) {
          return item.resource;
        }).filter(function(item) {
          return item;
        });
        var promises = resources.map(function(item) {
          return item.load();
        });
        this._load = Promise.all(promises).then(function() {
          var _a2 = _this.items[0], realWidth = _a2.realWidth, realHeight = _a2.realHeight;
          _this.resize(realWidth, realHeight);
          return Promise.resolve(_this);
        });
        return this._load;
      };
      return AbstractMultiResource2;
    }(Resource$1);
    var ArrayResource = function(_super) {
      __extends$h(ArrayResource2, _super);
      function ArrayResource2(source, options) {
        var _this = this;
        var _a2 = options || {}, width2 = _a2.width, height2 = _a2.height;
        var urls;
        var length;
        if (Array.isArray(source)) {
          urls = source;
          length = source.length;
        } else {
          length = source;
        }
        _this = _super.call(this, length, { width: width2, height: height2 }) || this;
        if (urls) {
          _this.initFromArray(urls, options);
        }
        return _this;
      }
      ArrayResource2.prototype.addBaseTextureAt = function(baseTexture, index2) {
        if (baseTexture.resource) {
          this.addResourceAt(baseTexture.resource, index2);
        } else {
          throw new Error("ArrayResource does not support RenderTexture");
        }
        return this;
      };
      ArrayResource2.prototype.bind = function(baseTexture) {
        _super.prototype.bind.call(this, baseTexture);
        baseTexture.target = TARGETS$1.TEXTURE_2D_ARRAY;
      };
      ArrayResource2.prototype.upload = function(renderer, texture, glTexture) {
        var _a2 = this, length = _a2.length, itemDirtyIds = _a2.itemDirtyIds, items2 = _a2.items;
        var gl = renderer.gl;
        if (glTexture.dirtyId < 0) {
          gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, texture.format, this._width, this._height, length, 0, texture.format, texture.type, null);
        }
        for (var i2 = 0; i2 < length; i2++) {
          var item = items2[i2];
          if (itemDirtyIds[i2] < item.dirtyId) {
            itemDirtyIds[i2] = item.dirtyId;
            if (item.valid) {
              gl.texSubImage3D(
                gl.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                i2,
                item.resource.width,
                item.resource.height,
                1,
                texture.format,
                texture.type,
                item.resource.source
              );
            }
          }
        }
        return true;
      };
      return ArrayResource2;
    }(AbstractMultiResource);
    var BaseImageResource = function(_super) {
      __extends$h(BaseImageResource2, _super);
      function BaseImageResource2(source) {
        var _this = this;
        var sourceAny = source;
        var width2 = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
        var height2 = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
        _this = _super.call(this, width2, height2) || this;
        _this.source = source;
        _this.noSubImage = false;
        return _this;
      }
      BaseImageResource2.crossOrigin = function(element, url2, crossorigin) {
        if (crossorigin === void 0 && url2.indexOf("data:") !== 0) {
          element.crossOrigin = determineCrossOrigin(url2);
        } else if (crossorigin !== false) {
          element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
        }
      };
      BaseImageResource2.prototype.upload = function(renderer, baseTexture, glTexture, source) {
        var gl = renderer.gl;
        var width2 = baseTexture.realWidth;
        var height2 = baseTexture.realHeight;
        source = source || this.source;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$1.UNPACK);
        if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width2 && glTexture.height === height2) {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
        } else {
          glTexture.width = width2;
          glTexture.height = height2;
          gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
        }
        return true;
      };
      BaseImageResource2.prototype.update = function() {
        if (this.destroyed) {
          return;
        }
        var source = this.source;
        var width2 = source.naturalWidth || source.videoWidth || source.width;
        var height2 = source.naturalHeight || source.videoHeight || source.height;
        this.resize(width2, height2);
        _super.prototype.update.call(this);
      };
      BaseImageResource2.prototype.dispose = function() {
        this.source = null;
      };
      return BaseImageResource2;
    }(Resource$1);
    var CanvasResource = function(_super) {
      __extends$h(CanvasResource2, _super);
      function CanvasResource2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CanvasResource2.test = function(source) {
        var OffscreenCanvas2 = window.OffscreenCanvas;
        if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
          return true;
        }
        return source instanceof HTMLCanvasElement;
      };
      return CanvasResource2;
    }(BaseImageResource);
    var CubeResource = function(_super) {
      __extends$h(CubeResource2, _super);
      function CubeResource2(source, options) {
        var _this = this;
        var _a2 = options || {}, width2 = _a2.width, height2 = _a2.height, autoLoad = _a2.autoLoad, linkBaseTexture = _a2.linkBaseTexture;
        if (source && source.length !== CubeResource2.SIDES) {
          throw new Error("Invalid length. Got " + source.length + ", expected 6");
        }
        _this = _super.call(this, 6, { width: width2, height: height2 }) || this;
        for (var i2 = 0; i2 < CubeResource2.SIDES; i2++) {
          _this.items[i2].target = TARGETS$1.TEXTURE_CUBE_MAP_POSITIVE_X + i2;
        }
        _this.linkBaseTexture = linkBaseTexture !== false;
        if (source) {
          _this.initFromArray(source, options);
        }
        if (autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      CubeResource2.prototype.bind = function(baseTexture) {
        _super.prototype.bind.call(this, baseTexture);
        baseTexture.target = TARGETS$1.TEXTURE_CUBE_MAP;
      };
      CubeResource2.prototype.addBaseTextureAt = function(baseTexture, index2, linkBaseTexture) {
        if (linkBaseTexture === void 0) {
          linkBaseTexture = this.linkBaseTexture;
        }
        if (!this.items[index2]) {
          throw new Error("Index " + index2 + " is out of bounds");
        }
        if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
          if (baseTexture.resource) {
            this.addResourceAt(baseTexture.resource, index2);
          } else {
            throw new Error("CubeResource does not support copying of renderTexture.");
          }
        } else {
          baseTexture.target = TARGETS$1.TEXTURE_CUBE_MAP_POSITIVE_X + index2;
          baseTexture.parentTextureArray = this.baseTexture;
          this.items[index2] = baseTexture;
        }
        if (baseTexture.valid && !this.valid) {
          this.resize(baseTexture.realWidth, baseTexture.realHeight);
        }
        this.items[index2] = baseTexture;
        return this;
      };
      CubeResource2.prototype.upload = function(renderer, _baseTexture, glTexture) {
        var dirty = this.itemDirtyIds;
        for (var i2 = 0; i2 < CubeResource2.SIDES; i2++) {
          var side = this.items[i2];
          if (dirty[i2] < side.dirtyId) {
            if (side.valid && side.resource) {
              side.resource.upload(renderer, side, glTexture);
              dirty[i2] = side.dirtyId;
            } else if (dirty[i2] < -1) {
              renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
              dirty[i2] = -1;
            }
          }
        }
        return true;
      };
      CubeResource2.test = function(source) {
        return Array.isArray(source) && source.length === CubeResource2.SIDES;
      };
      CubeResource2.SIDES = 6;
      return CubeResource2;
    }(AbstractMultiResource);
    var ImageResource = function(_super) {
      __extends$h(ImageResource2, _super);
      function ImageResource2(source, options) {
        var _this = this;
        options = options || {};
        if (!(source instanceof HTMLImageElement)) {
          var imageElement = new Image();
          BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
          imageElement.src = source;
          source = imageElement;
        }
        _this = _super.call(this, source) || this;
        if (!source.complete && !!_this._width && !!_this._height) {
          _this._width = 0;
          _this._height = 0;
        }
        _this.url = source.src;
        _this._process = null;
        _this.preserveBitmap = false;
        _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!window.createImageBitmap;
        _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
        if (options.premultiplyAlpha !== void 0) {
          _this.premultiplyAlpha = options.premultiplyAlpha;
        }
        _this.bitmap = null;
        _this._load = null;
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      ImageResource2.prototype.load = function(createBitmap) {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        if (createBitmap !== void 0) {
          this.createBitmap = createBitmap;
        }
        this._load = new Promise(function(resolve, reject2) {
          var source = _this.source;
          _this.url = source.src;
          var completed = function() {
            if (_this.destroyed) {
              return;
            }
            source.onload = null;
            source.onerror = null;
            _this.resize(source.width, source.height);
            _this._load = null;
            if (_this.createBitmap) {
              resolve(_this.process());
            } else {
              resolve(_this);
            }
          };
          if (source.complete && source.src) {
            completed();
          } else {
            source.onload = completed;
            source.onerror = function(event) {
              reject2(event);
              _this.onError.emit(event);
            };
          }
        });
        return this._load;
      };
      ImageResource2.prototype.process = function() {
        var _this = this;
        var source = this.source;
        if (this._process !== null) {
          return this._process;
        }
        if (this.bitmap !== null || !window.createImageBitmap) {
          return Promise.resolve(this);
        }
        this._process = window.createImageBitmap(source, 0, 0, source.width, source.height, {
          premultiplyAlpha: this.alphaMode === ALPHA_MODES$1.UNPACK ? "premultiply" : "none"
        }).then(function(bitmap) {
          if (_this.destroyed) {
            return Promise.reject();
          }
          _this.bitmap = bitmap;
          _this.update();
          _this._process = null;
          return Promise.resolve(_this);
        });
        return this._process;
      };
      ImageResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
        if (typeof this.alphaMode === "number") {
          baseTexture.alphaMode = this.alphaMode;
        }
        if (!this.createBitmap) {
          return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);
        }
        if (!this.bitmap) {
          this.process();
          if (!this.bitmap) {
            return false;
          }
        }
        _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);
        if (!this.preserveBitmap) {
          var flag = true;
          var glTextures = baseTexture._glTextures;
          for (var key in glTextures) {
            var otherTex = glTextures[key];
            if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
              flag = false;
              break;
            }
          }
          if (flag) {
            if (this.bitmap.close) {
              this.bitmap.close();
            }
            this.bitmap = null;
          }
        }
        return true;
      };
      ImageResource2.prototype.dispose = function() {
        this.source.onload = null;
        this.source.onerror = null;
        _super.prototype.dispose.call(this);
        if (this.bitmap) {
          this.bitmap.close();
          this.bitmap = null;
        }
        this._process = null;
        this._load = null;
      };
      ImageResource2.test = function(source) {
        return typeof source === "string" || source instanceof HTMLImageElement;
      };
      return ImageResource2;
    }(BaseImageResource);
    var SVGResource = function(_super) {
      __extends$h(SVGResource2, _super);
      function SVGResource2(sourceBase64, options) {
        var _this = this;
        options = options || {};
        _this = _super.call(this, document.createElement("canvas")) || this;
        _this._width = 0;
        _this._height = 0;
        _this.svg = sourceBase64;
        _this.scale = options.scale || 1;
        _this._overrideWidth = options.width;
        _this._overrideHeight = options.height;
        _this._resolve = null;
        _this._crossorigin = options.crossorigin;
        _this._load = null;
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      SVGResource2.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        this._load = new Promise(function(resolve) {
          _this._resolve = function() {
            _this.resize(_this.source.width, _this.source.height);
            resolve(_this);
          };
          if (/^\<svg/.test(_this.svg.trim())) {
            if (!btoa) {
              throw new Error("Your browser doesn't support base64 conversions.");
            }
            _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
          }
          _this._loadSvg();
        });
        return this._load;
      };
      SVGResource2.prototype._loadSvg = function() {
        var _this = this;
        var tempImage = new Image();
        BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
        tempImage.src = this.svg;
        tempImage.onerror = function(event) {
          if (!_this._resolve) {
            return;
          }
          tempImage.onerror = null;
          _this.onError.emit(event);
        };
        tempImage.onload = function() {
          if (!_this._resolve) {
            return;
          }
          var svgWidth = tempImage.width;
          var svgHeight = tempImage.height;
          if (!svgWidth || !svgHeight) {
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          }
          var width2 = svgWidth * _this.scale;
          var height2 = svgHeight * _this.scale;
          if (_this._overrideWidth || _this._overrideHeight) {
            width2 = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
            height2 = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
          }
          width2 = Math.round(width2);
          height2 = Math.round(height2);
          var canvas2 = _this.source;
          canvas2.width = width2;
          canvas2.height = height2;
          canvas2._pixiId = "canvas_" + uid();
          canvas2.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width2, height2);
          _this._resolve();
          _this._resolve = null;
        };
      };
      SVGResource2.getSize = function(svgString) {
        var sizeMatch = SVGResource2.SVG_SIZE.exec(svgString);
        var size2 = {};
        if (sizeMatch) {
          size2[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
          size2[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
        }
        return size2;
      };
      SVGResource2.prototype.dispose = function() {
        _super.prototype.dispose.call(this);
        this._resolve = null;
        this._crossorigin = null;
      };
      SVGResource2.test = function(source, extension) {
        return extension === "svg" || typeof source === "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(source) || typeof source === "string" && source.indexOf("<svg") === 0;
      };
      SVGResource2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
      return SVGResource2;
    }(BaseImageResource);
    var VideoResource = function(_super) {
      __extends$h(VideoResource2, _super);
      function VideoResource2(source, options) {
        var _this = this;
        options = options || {};
        if (!(source instanceof HTMLVideoElement)) {
          var videoElement = document.createElement("video");
          videoElement.setAttribute("preload", "auto");
          videoElement.setAttribute("webkit-playsinline", "");
          videoElement.setAttribute("playsinline", "");
          if (typeof source === "string") {
            source = [source];
          }
          var firstSrc = source[0].src || source[0];
          BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
          for (var i2 = 0; i2 < source.length; ++i2) {
            var sourceElement = document.createElement("source");
            var _a2 = source[i2], src2 = _a2.src, mime = _a2.mime;
            src2 = src2 || source[i2];
            var baseSrc = src2.split("?").shift().toLowerCase();
            var ext = baseSrc.substr(baseSrc.lastIndexOf(".") + 1);
            mime = mime || VideoResource2.MIME_TYPES[ext] || "video/" + ext;
            sourceElement.src = src2;
            sourceElement.type = mime;
            videoElement.appendChild(sourceElement);
          }
          source = videoElement;
        }
        _this = _super.call(this, source) || this;
        _this.noSubImage = true;
        _this._autoUpdate = true;
        _this._isConnectedToTicker = false;
        _this._updateFPS = options.updateFPS || 0;
        _this._msToNextUpdate = 0;
        _this.autoPlay = options.autoPlay !== false;
        _this._load = null;
        _this._resolve = null;
        _this._onCanPlay = _this._onCanPlay.bind(_this);
        _this._onError = _this._onError.bind(_this);
        if (options.autoLoad !== false) {
          _this.load();
        }
        return _this;
      }
      VideoResource2.prototype.update = function(_deltaTime) {
        if (!this.destroyed) {
          var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
          if (!this._updateFPS || this._msToNextUpdate <= 0) {
            _super.prototype.update.call(this);
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
          }
        }
      };
      VideoResource2.prototype.load = function() {
        var _this = this;
        if (this._load) {
          return this._load;
        }
        var source = this.source;
        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
          source.complete = true;
        }
        source.addEventListener("play", this._onPlayStart.bind(this));
        source.addEventListener("pause", this._onPlayStop.bind(this));
        if (!this._isSourceReady()) {
          source.addEventListener("canplay", this._onCanPlay);
          source.addEventListener("canplaythrough", this._onCanPlay);
          source.addEventListener("error", this._onError, true);
        } else {
          this._onCanPlay();
        }
        this._load = new Promise(function(resolve) {
          if (_this.valid) {
            resolve(_this);
          } else {
            _this._resolve = resolve;
            source.load();
          }
        });
        return this._load;
      };
      VideoResource2.prototype._onError = function(event) {
        this.source.removeEventListener("error", this._onError, true);
        this.onError.emit(event);
      };
      VideoResource2.prototype._isSourcePlaying = function() {
        var source = this.source;
        return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
      };
      VideoResource2.prototype._isSourceReady = function() {
        var source = this.source;
        return source.readyState === 3 || source.readyState === 4;
      };
      VideoResource2.prototype._onPlayStart = function() {
        if (!this.valid) {
          this._onCanPlay();
        }
        if (this.autoUpdate && !this._isConnectedToTicker) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      };
      VideoResource2.prototype._onPlayStop = function() {
        if (this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        }
      };
      VideoResource2.prototype._onCanPlay = function() {
        var source = this.source;
        source.removeEventListener("canplay", this._onCanPlay);
        source.removeEventListener("canplaythrough", this._onCanPlay);
        var valid = this.valid;
        this.resize(source.videoWidth, source.videoHeight);
        if (!valid && this._resolve) {
          this._resolve(this);
          this._resolve = null;
        }
        if (this._isSourcePlaying()) {
          this._onPlayStart();
        } else if (this.autoPlay) {
          source.play();
        }
      };
      VideoResource2.prototype.dispose = function() {
        if (this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
        }
        var source = this.source;
        if (source) {
          source.removeEventListener("error", this._onError, true);
          source.pause();
          source.src = "";
          source.load();
        }
        _super.prototype.dispose.call(this);
      };
      Object.defineProperty(VideoResource2.prototype, "autoUpdate", {
        get: function() {
          return this._autoUpdate;
        },
        set: function(value2) {
          if (value2 !== this._autoUpdate) {
            this._autoUpdate = value2;
            if (!this._autoUpdate && this._isConnectedToTicker) {
              Ticker.shared.remove(this.update, this);
              this._isConnectedToTicker = false;
            } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
              Ticker.shared.add(this.update, this);
              this._isConnectedToTicker = true;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(VideoResource2.prototype, "updateFPS", {
        get: function() {
          return this._updateFPS;
        },
        set: function(value2) {
          if (value2 !== this._updateFPS) {
            this._updateFPS = value2;
          }
        },
        enumerable: false,
        configurable: true
      });
      VideoResource2.test = function(source, extension) {
        return source instanceof HTMLVideoElement || VideoResource2.TYPES.indexOf(extension) > -1;
      };
      VideoResource2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
      VideoResource2.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
      };
      return VideoResource2;
    }(BaseImageResource);
    var ImageBitmapResource = function(_super) {
      __extends$h(ImageBitmapResource2, _super);
      function ImageBitmapResource2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ImageBitmapResource2.test = function(source) {
        return !!window.createImageBitmap && source instanceof ImageBitmap;
      };
      return ImageBitmapResource2;
    }(BaseImageResource);
    INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
    var System = function() {
      function System2(renderer) {
        this.renderer = renderer;
      }
      System2.prototype.destroy = function() {
        this.renderer = null;
      };
      return System2;
    }();
    var DepthResource = function(_super) {
      __extends$h(DepthResource2, _super);
      function DepthResource2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DepthResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$1.UNPACK);
        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
          gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
        } else {
          glTexture.width = baseTexture.width;
          glTexture.height = baseTexture.height;
          gl.texImage2D(
            baseTexture.target,
            0,
            renderer.context.webGLVersion === 1 ? gl.DEPTH_COMPONENT : gl.DEPTH_COMPONENT16,
            baseTexture.width,
            baseTexture.height,
            0,
            baseTexture.format,
            baseTexture.type,
            this.data
          );
        }
        return true;
      };
      return DepthResource2;
    }(BufferResource);
    var Framebuffer = function() {
      function Framebuffer2(width2, height2) {
        this.width = Math.ceil(width2 || 100);
        this.height = Math.ceil(height2 || 100);
        this.stencil = false;
        this.depth = false;
        this.dirtyId = 0;
        this.dirtyFormat = 0;
        this.dirtySize = 0;
        this.depthTexture = null;
        this.colorTextures = [];
        this.glFramebuffers = {};
        this.disposeRunner = new Runner("disposeFramebuffer");
        this.multisample = MSAA_QUALITY$1.NONE;
      }
      Object.defineProperty(Framebuffer2.prototype, "colorTexture", {
        get: function() {
          return this.colorTextures[0];
        },
        enumerable: false,
        configurable: true
      });
      Framebuffer2.prototype.addColorTexture = function(index2, texture) {
        if (index2 === void 0) {
          index2 = 0;
        }
        this.colorTextures[index2] = texture || new BaseTexture(null, {
          scaleMode: SCALE_MODES$1.NEAREST,
          resolution: 1,
          mipmap: MIPMAP_MODES$1.OFF,
          width: this.width,
          height: this.height
        });
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer2.prototype.addDepthTexture = function(texture) {
        this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
          scaleMode: SCALE_MODES$1.NEAREST,
          resolution: 1,
          width: this.width,
          height: this.height,
          mipmap: MIPMAP_MODES$1.OFF,
          format: FORMATS$1.DEPTH_COMPONENT,
          type: TYPES$1.UNSIGNED_SHORT
        });
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer2.prototype.enableDepth = function() {
        this.depth = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer2.prototype.enableStencil = function() {
        this.stencil = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
      };
      Framebuffer2.prototype.resize = function(width2, height2) {
        width2 = Math.ceil(width2);
        height2 = Math.ceil(height2);
        if (width2 === this.width && height2 === this.height) {
          return;
        }
        this.width = width2;
        this.height = height2;
        this.dirtyId++;
        this.dirtySize++;
        for (var i2 = 0; i2 < this.colorTextures.length; i2++) {
          var texture = this.colorTextures[i2];
          var resolution = texture.resolution;
          texture.setSize(width2 / resolution, height2 / resolution);
        }
        if (this.depthTexture) {
          var resolution = this.depthTexture.resolution;
          this.depthTexture.setSize(width2 / resolution, height2 / resolution);
        }
      };
      Framebuffer2.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Framebuffer2.prototype.destroyDepthTexture = function() {
        if (this.depthTexture) {
          this.depthTexture.destroy();
          this.depthTexture = null;
          ++this.dirtyId;
          ++this.dirtyFormat;
        }
      };
      return Framebuffer2;
    }();
    var BaseRenderTexture = function(_super) {
      __extends$h(BaseRenderTexture2, _super);
      function BaseRenderTexture2(options) {
        var _this = this;
        if (typeof options === "number") {
          var width_1 = arguments[0];
          var height_1 = arguments[1];
          var scaleMode = arguments[2];
          var resolution = arguments[3];
          options = { width: width_1, height: height_1, scaleMode, resolution };
        }
        _this = _super.call(this, null, options) || this;
        var _a2 = options || {}, width2 = _a2.width, height2 = _a2.height;
        _this.mipmap = 0;
        _this.width = Math.ceil(width2) || 100;
        _this.height = Math.ceil(height2) || 100;
        _this.valid = true;
        _this.clearColor = [0, 0, 0, 0];
        _this.framebuffer = new Framebuffer(_this.width * _this.resolution, _this.height * _this.resolution).addColorTexture(0, _this);
        _this.maskStack = [];
        _this.filterStack = [{}];
        return _this;
      }
      BaseRenderTexture2.prototype.resize = function(width2, height2) {
        width2 = Math.ceil(width2);
        height2 = Math.ceil(height2);
        this.framebuffer.resize(width2 * this.resolution, height2 * this.resolution);
      };
      BaseRenderTexture2.prototype.dispose = function() {
        this.framebuffer.dispose();
        _super.prototype.dispose.call(this);
      };
      BaseRenderTexture2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        this.framebuffer.destroyDepthTexture();
        this.framebuffer = null;
      };
      return BaseRenderTexture2;
    }(BaseTexture);
    var TextureUvs = function() {
      function TextureUvs2() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 1;
        this.y1 = 0;
        this.x2 = 1;
        this.y2 = 1;
        this.x3 = 0;
        this.y3 = 1;
        this.uvsFloat32 = new Float32Array(8);
      }
      TextureUvs2.prototype.set = function(frame, baseFrame, rotate) {
        var tw = baseFrame.width;
        var th2 = baseFrame.height;
        if (rotate) {
          var w2 = frame.width / 2 / tw;
          var h2 = frame.height / 2 / th2;
          var cX = frame.x / tw + w2;
          var cY = frame.y / th2 + h2;
          rotate = groupD8.add(rotate, groupD8.NW);
          this.x0 = cX + w2 * groupD8.uX(rotate);
          this.y0 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          this.x1 = cX + w2 * groupD8.uX(rotate);
          this.y1 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          this.x2 = cX + w2 * groupD8.uX(rotate);
          this.y2 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          this.x3 = cX + w2 * groupD8.uX(rotate);
          this.y3 = cY + h2 * groupD8.uY(rotate);
        } else {
          this.x0 = frame.x / tw;
          this.y0 = frame.y / th2;
          this.x1 = (frame.x + frame.width) / tw;
          this.y1 = frame.y / th2;
          this.x2 = (frame.x + frame.width) / tw;
          this.y2 = (frame.y + frame.height) / th2;
          this.x3 = frame.x / tw;
          this.y3 = (frame.y + frame.height) / th2;
        }
        this.uvsFloat32[0] = this.x0;
        this.uvsFloat32[1] = this.y0;
        this.uvsFloat32[2] = this.x1;
        this.uvsFloat32[3] = this.y1;
        this.uvsFloat32[4] = this.x2;
        this.uvsFloat32[5] = this.y2;
        this.uvsFloat32[6] = this.x3;
        this.uvsFloat32[7] = this.y3;
      };
      return TextureUvs2;
    }();
    var DEFAULT_UVS = new TextureUvs();
    var Texture = function(_super) {
      __extends$h(Texture2, _super);
      function Texture2(baseTexture, frame, orig, trim2, rotate, anchor) {
        var _this = _super.call(this) || this;
        _this.noFrame = false;
        if (!frame) {
          _this.noFrame = true;
          frame = new Rectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof Texture2) {
          baseTexture = baseTexture.baseTexture;
        }
        _this.baseTexture = baseTexture;
        _this._frame = frame;
        _this.trim = trim2;
        _this.valid = false;
        _this._uvs = DEFAULT_UVS;
        _this.uvMatrix = null;
        _this.orig = orig || frame;
        _this._rotate = Number(rotate || 0);
        if (rotate === true) {
          _this._rotate = 2;
        } else if (_this._rotate % 2 !== 0) {
          throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        }
        _this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
        _this._updateID = 0;
        _this.textureCacheIds = [];
        if (!baseTexture.valid) {
          baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
        } else if (_this.noFrame) {
          if (baseTexture.valid) {
            _this.onBaseTextureUpdated(baseTexture);
          }
        } else {
          _this.frame = frame;
        }
        if (_this.noFrame) {
          baseTexture.on("update", _this.onBaseTextureUpdated, _this);
        }
        return _this;
      }
      Texture2.prototype.update = function() {
        if (this.baseTexture.resource) {
          this.baseTexture.resource.update();
        }
      };
      Texture2.prototype.onBaseTextureUpdated = function(baseTexture) {
        if (this.noFrame) {
          if (!this.baseTexture.valid) {
            return;
          }
          this._frame.width = baseTexture.width;
          this._frame.height = baseTexture.height;
          this.valid = true;
          this.updateUvs();
        } else {
          this.frame = this._frame;
        }
        this.emit("update", this);
      };
      Texture2.prototype.destroy = function(destroyBase) {
        if (this.baseTexture) {
          if (destroyBase) {
            var resource = this.baseTexture;
            if (resource && resource.url && TextureCache[resource.url]) {
              Texture2.removeFromCache(resource.url);
            }
            this.baseTexture.destroy();
          }
          this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
          this.baseTexture.off("update", this.onBaseTextureUpdated, this);
          this.baseTexture = null;
        }
        this._frame = null;
        this._uvs = null;
        this.trim = null;
        this.orig = null;
        this.valid = false;
        Texture2.removeFromCache(this);
        this.textureCacheIds = null;
      };
      Texture2.prototype.clone = function() {
        return new Texture2(this.baseTexture, this.frame.clone(), this.orig.clone(), this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
      };
      Texture2.prototype.updateUvs = function() {
        if (this._uvs === DEFAULT_UVS) {
          this._uvs = new TextureUvs();
        }
        this._uvs.set(this._frame, this.baseTexture, this.rotate);
        this._updateID++;
      };
      Texture2.from = function(source, options, strict) {
        if (options === void 0) {
          options = {};
        }
        if (strict === void 0) {
          strict = settings.STRICT_TEXTURE_CACHE;
        }
        var isFrame = typeof source === "string";
        var cacheId = null;
        if (isFrame) {
          cacheId = source;
        } else {
          if (!source._pixiId) {
            source._pixiId = "pixiid_" + uid();
          }
          cacheId = source._pixiId;
        }
        var texture = TextureCache[cacheId];
        if (isFrame && strict && !texture) {
          throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
        }
        if (!texture) {
          if (!options.resolution) {
            options.resolution = getResolutionOfUrl(source);
          }
          texture = new Texture2(new BaseTexture(source, options));
          texture.baseTexture.cacheId = cacheId;
          BaseTexture.addToCache(texture.baseTexture, cacheId);
          Texture2.addToCache(texture, cacheId);
        }
        return texture;
      };
      Texture2.fromURL = function(url2, options) {
        var resourceOptions = Object.assign({ autoLoad: false }, options === null || options === void 0 ? void 0 : options.resourceOptions);
        var texture = Texture2.from(url2, Object.assign({ resourceOptions }, options), false);
        var resource = texture.baseTexture.resource;
        if (texture.baseTexture.valid) {
          return Promise.resolve(texture);
        }
        return resource.load().then(function() {
          return Promise.resolve(texture);
        });
      };
      Texture2.fromBuffer = function(buffer, width2, height2, options) {
        return new Texture2(BaseTexture.fromBuffer(buffer, width2, height2, options));
      };
      Texture2.fromLoader = function(source, imageUrl, name) {
        var resource = new ImageResource(source);
        resource.url = imageUrl;
        var baseTexture = new BaseTexture(resource, {
          scaleMode: settings.SCALE_MODE,
          resolution: getResolutionOfUrl(imageUrl)
        });
        var texture = new Texture2(baseTexture);
        if (!name) {
          name = imageUrl;
        }
        BaseTexture.addToCache(texture.baseTexture, name);
        Texture2.addToCache(texture, name);
        if (name !== imageUrl) {
          BaseTexture.addToCache(texture.baseTexture, imageUrl);
          Texture2.addToCache(texture, imageUrl);
        }
        return texture;
      };
      Texture2.addToCache = function(texture, id2) {
        if (id2) {
          if (texture.textureCacheIds.indexOf(id2) === -1) {
            texture.textureCacheIds.push(id2);
          }
          if (TextureCache[id2]) {
            console.warn("Texture added to the cache with an id [" + id2 + "] that already had an entry");
          }
          TextureCache[id2] = texture;
        }
      };
      Texture2.removeFromCache = function(texture) {
        if (typeof texture === "string") {
          var textureFromCache = TextureCache[texture];
          if (textureFromCache) {
            var index2 = textureFromCache.textureCacheIds.indexOf(texture);
            if (index2 > -1) {
              textureFromCache.textureCacheIds.splice(index2, 1);
            }
            delete TextureCache[texture];
            return textureFromCache;
          }
        } else if (texture && texture.textureCacheIds) {
          for (var i2 = 0; i2 < texture.textureCacheIds.length; ++i2) {
            if (TextureCache[texture.textureCacheIds[i2]] === texture) {
              delete TextureCache[texture.textureCacheIds[i2]];
            }
          }
          texture.textureCacheIds.length = 0;
          return texture;
        }
        return null;
      };
      Object.defineProperty(Texture2.prototype, "resolution", {
        get: function() {
          return this.baseTexture.resolution;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture2.prototype, "frame", {
        get: function() {
          return this._frame;
        },
        set: function(frame) {
          this._frame = frame;
          this.noFrame = false;
          var x2 = frame.x, y2 = frame.y, width2 = frame.width, height2 = frame.height;
          var xNotFit = x2 + width2 > this.baseTexture.width;
          var yNotFit = y2 + height2 > this.baseTexture.height;
          if (xNotFit || yNotFit) {
            var relationship = xNotFit && yNotFit ? "and" : "or";
            var errorX = "X: " + x2 + " + " + width2 + " = " + (x2 + width2) + " > " + this.baseTexture.width;
            var errorY = "Y: " + y2 + " + " + height2 + " = " + (y2 + height2) + " > " + this.baseTexture.height;
            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
          }
          this.valid = width2 && height2 && this.baseTexture.valid;
          if (!this.trim && !this.rotate) {
            this.orig = frame;
          }
          if (this.valid) {
            this.updateUvs();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture2.prototype, "rotate", {
        get: function() {
          return this._rotate;
        },
        set: function(rotate) {
          this._rotate = rotate;
          if (this.valid) {
            this.updateUvs();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture2.prototype, "width", {
        get: function() {
          return this.orig.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Texture2.prototype, "height", {
        get: function() {
          return this.orig.height;
        },
        enumerable: false,
        configurable: true
      });
      Texture2.prototype.castToBaseTexture = function() {
        return this.baseTexture;
      };
      return Texture2;
    }(EventEmitter);
    function createWhiteTexture() {
      var canvas2 = document.createElement("canvas");
      canvas2.width = 16;
      canvas2.height = 16;
      var context2 = canvas2.getContext("2d");
      context2.fillStyle = "white";
      context2.fillRect(0, 0, 16, 16);
      return new Texture(new BaseTexture(new CanvasResource(canvas2)));
    }
    function removeAllHandlers(tex) {
      tex.destroy = function _emptyDestroy() {
      };
      tex.on = function _emptyOn() {
      };
      tex.once = function _emptyOnce() {
      };
      tex.emit = function _emptyEmit() {
      };
    }
    Texture.EMPTY = new Texture(new BaseTexture());
    removeAllHandlers(Texture.EMPTY);
    removeAllHandlers(Texture.EMPTY.baseTexture);
    Texture.WHITE = createWhiteTexture();
    removeAllHandlers(Texture.WHITE);
    removeAllHandlers(Texture.WHITE.baseTexture);
    var RenderTexture = function(_super) {
      __extends$h(RenderTexture2, _super);
      function RenderTexture2(baseRenderTexture, frame) {
        var _this = this;
        var _legacyRenderer = null;
        if (!(baseRenderTexture instanceof BaseRenderTexture)) {
          var width2 = arguments[1];
          var height2 = arguments[2];
          var scaleMode = arguments[3];
          var resolution = arguments[4];
          console.warn("Please use RenderTexture.create(" + width2 + ", " + height2 + ") instead of the ctor directly.");
          _legacyRenderer = arguments[0];
          frame = null;
          baseRenderTexture = new BaseRenderTexture({
            width: width2,
            height: height2,
            scaleMode,
            resolution
          });
        }
        _this = _super.call(this, baseRenderTexture, frame) || this;
        _this.legacyRenderer = _legacyRenderer;
        _this.valid = true;
        _this.filterFrame = null;
        _this.filterPoolKey = null;
        _this.updateUvs();
        return _this;
      }
      Object.defineProperty(RenderTexture2.prototype, "framebuffer", {
        get: function() {
          return this.baseTexture.framebuffer;
        },
        enumerable: false,
        configurable: true
      });
      RenderTexture2.prototype.resize = function(width2, height2, resizeBaseTexture) {
        if (resizeBaseTexture === void 0) {
          resizeBaseTexture = true;
        }
        width2 = Math.ceil(width2);
        height2 = Math.ceil(height2);
        this.valid = width2 > 0 && height2 > 0;
        this._frame.width = this.orig.width = width2;
        this._frame.height = this.orig.height = height2;
        if (resizeBaseTexture) {
          this.baseTexture.resize(width2, height2);
        }
        this.updateUvs();
      };
      RenderTexture2.prototype.setResolution = function(resolution) {
        var baseTexture = this.baseTexture;
        if (baseTexture.resolution === resolution) {
          return;
        }
        baseTexture.setResolution(resolution);
        this.resize(baseTexture.width, baseTexture.height, false);
      };
      RenderTexture2.create = function(options) {
        if (typeof options === "number") {
          options = {
            width: options,
            height: arguments[1],
            scaleMode: arguments[2],
            resolution: arguments[3]
          };
        }
        return new RenderTexture2(new BaseRenderTexture(options));
      };
      return RenderTexture2;
    }(Texture);
    var RenderTexturePool = function() {
      function RenderTexturePool2(textureOptions) {
        this.texturePool = {};
        this.textureOptions = textureOptions || {};
        this.enableFullScreen = false;
        this._pixelsWidth = 0;
        this._pixelsHeight = 0;
      }
      RenderTexturePool2.prototype.createTexture = function(realWidth, realHeight) {
        var baseRenderTexture = new BaseRenderTexture(Object.assign({
          width: realWidth,
          height: realHeight,
          resolution: 1
        }, this.textureOptions));
        return new RenderTexture(baseRenderTexture);
      };
      RenderTexturePool2.prototype.getOptimalTexture = function(minWidth, minHeight, resolution) {
        if (resolution === void 0) {
          resolution = 1;
        }
        var key = RenderTexturePool2.SCREEN_KEY;
        minWidth *= resolution;
        minHeight *= resolution;
        if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
          minWidth = nextPow2(minWidth);
          minHeight = nextPow2(minHeight);
          key = (minWidth & 65535) << 16 | minHeight & 65535;
        }
        if (!this.texturePool[key]) {
          this.texturePool[key] = [];
        }
        var renderTexture = this.texturePool[key].pop();
        if (!renderTexture) {
          renderTexture = this.createTexture(minWidth, minHeight);
        }
        renderTexture.filterPoolKey = key;
        renderTexture.setResolution(resolution);
        return renderTexture;
      };
      RenderTexturePool2.prototype.getFilterTexture = function(input, resolution) {
        var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution);
        filterTexture.filterFrame = input.filterFrame;
        return filterTexture;
      };
      RenderTexturePool2.prototype.returnTexture = function(renderTexture) {
        var key = renderTexture.filterPoolKey;
        renderTexture.filterFrame = null;
        this.texturePool[key].push(renderTexture);
      };
      RenderTexturePool2.prototype.returnFilterTexture = function(renderTexture) {
        this.returnTexture(renderTexture);
      };
      RenderTexturePool2.prototype.clear = function(destroyTextures) {
        destroyTextures = destroyTextures !== false;
        if (destroyTextures) {
          for (var i2 in this.texturePool) {
            var textures = this.texturePool[i2];
            if (textures) {
              for (var j = 0; j < textures.length; j++) {
                textures[j].destroy(true);
              }
            }
          }
        }
        this.texturePool = {};
      };
      RenderTexturePool2.prototype.setScreenSize = function(size2) {
        if (size2.width === this._pixelsWidth && size2.height === this._pixelsHeight) {
          return;
        }
        var screenKey = RenderTexturePool2.SCREEN_KEY;
        var textures = this.texturePool[screenKey];
        this.enableFullScreen = size2.width > 0 && size2.height > 0;
        if (textures) {
          for (var j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
        this.texturePool[screenKey] = [];
        this._pixelsWidth = size2.width;
        this._pixelsHeight = size2.height;
      };
      RenderTexturePool2.SCREEN_KEY = "screen";
      return RenderTexturePool2;
    }();
    var Attribute = function() {
      function Attribute2(buffer, size2, normalized, type, stride, start, instance) {
        if (size2 === void 0) {
          size2 = 0;
        }
        if (normalized === void 0) {
          normalized = false;
        }
        if (type === void 0) {
          type = 5126;
        }
        this.buffer = buffer;
        this.size = size2;
        this.normalized = normalized;
        this.type = type;
        this.stride = stride;
        this.start = start;
        this.instance = instance;
      }
      Attribute2.prototype.destroy = function() {
        this.buffer = null;
      };
      Attribute2.from = function(buffer, size2, normalized, type, stride) {
        return new Attribute2(buffer, size2, normalized, type, stride);
      };
      return Attribute2;
    }();
    var UID = 0;
    var Buffer$1 = function() {
      function Buffer2(data, _static, index2) {
        if (_static === void 0) {
          _static = true;
        }
        if (index2 === void 0) {
          index2 = false;
        }
        this.data = data || new Float32Array(1);
        this._glBuffers = {};
        this._updateID = 0;
        this.index = index2;
        this.static = _static;
        this.id = UID++;
        this.disposeRunner = new Runner("disposeBuffer");
      }
      Buffer2.prototype.update = function(data) {
        this.data = data || this.data;
        this._updateID++;
      };
      Buffer2.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Buffer2.prototype.destroy = function() {
        this.dispose();
        this.data = null;
      };
      Buffer2.from = function(data) {
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        return new Buffer2(data);
      };
      return Buffer2;
    }();
    function getBufferType(array) {
      if (array.BYTES_PER_ELEMENT === 4) {
        if (array instanceof Float32Array) {
          return "Float32Array";
        } else if (array instanceof Uint32Array) {
          return "Uint32Array";
        }
        return "Int32Array";
      } else if (array.BYTES_PER_ELEMENT === 2) {
        if (array instanceof Uint16Array) {
          return "Uint16Array";
        }
      } else if (array.BYTES_PER_ELEMENT === 1) {
        if (array instanceof Uint8Array) {
          return "Uint8Array";
        }
      }
      return null;
    }
    var map$2 = {
      Float32Array,
      Uint32Array,
      Int32Array,
      Uint8Array
    };
    function interleaveTypedArrays(arrays, sizes) {
      var outSize = 0;
      var stride = 0;
      var views = {};
      for (var i2 = 0; i2 < arrays.length; i2++) {
        stride += sizes[i2];
        outSize += arrays[i2].length;
      }
      var buffer = new ArrayBuffer(outSize * 4);
      var out = null;
      var littleOffset = 0;
      for (var i2 = 0; i2 < arrays.length; i2++) {
        var size2 = sizes[i2];
        var array = arrays[i2];
        var type = getBufferType(array);
        if (!views[type]) {
          views[type] = new map$2[type](buffer);
        }
        out = views[type];
        for (var j = 0; j < array.length; j++) {
          var indexStart = (j / size2 | 0) * stride + littleOffset;
          var index2 = j % size2;
          out[indexStart + index2] = array[j];
        }
        littleOffset += size2;
      }
      return new Float32Array(buffer);
    }
    var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
    var UID$1 = 0;
    var map$1$1 = {
      Float32Array,
      Uint32Array,
      Int32Array,
      Uint8Array,
      Uint16Array
    };
    var Geometry = function() {
      function Geometry2(buffers, attributes) {
        if (buffers === void 0) {
          buffers = [];
        }
        if (attributes === void 0) {
          attributes = {};
        }
        this.buffers = buffers;
        this.indexBuffer = null;
        this.attributes = attributes;
        this.glVertexArrayObjects = {};
        this.id = UID$1++;
        this.instanced = false;
        this.instanceCount = 1;
        this.disposeRunner = new Runner("disposeGeometry");
        this.refCount = 0;
      }
      Geometry2.prototype.addAttribute = function(id2, buffer, size2, normalized, type, stride, start, instance) {
        if (size2 === void 0) {
          size2 = 0;
        }
        if (normalized === void 0) {
          normalized = false;
        }
        if (instance === void 0) {
          instance = false;
        }
        if (!buffer) {
          throw new Error("You must pass a buffer when creating an attribute");
        }
        if (!(buffer instanceof Buffer$1)) {
          if (buffer instanceof Array) {
            buffer = new Float32Array(buffer);
          }
          buffer = new Buffer$1(buffer);
        }
        var ids = id2.split("|");
        if (ids.length > 1) {
          for (var i2 = 0; i2 < ids.length; i2++) {
            this.addAttribute(ids[i2], buffer, size2, normalized, type);
          }
          return this;
        }
        var bufferIndex = this.buffers.indexOf(buffer);
        if (bufferIndex === -1) {
          this.buffers.push(buffer);
          bufferIndex = this.buffers.length - 1;
        }
        this.attributes[id2] = new Attribute(bufferIndex, size2, normalized, type, stride, start, instance);
        this.instanced = this.instanced || instance;
        return this;
      };
      Geometry2.prototype.getAttribute = function(id2) {
        return this.attributes[id2];
      };
      Geometry2.prototype.getBuffer = function(id2) {
        return this.buffers[this.getAttribute(id2).buffer];
      };
      Geometry2.prototype.addIndex = function(buffer) {
        if (!(buffer instanceof Buffer$1)) {
          if (buffer instanceof Array) {
            buffer = new Uint16Array(buffer);
          }
          buffer = new Buffer$1(buffer);
        }
        buffer.index = true;
        this.indexBuffer = buffer;
        if (this.buffers.indexOf(buffer) === -1) {
          this.buffers.push(buffer);
        }
        return this;
      };
      Geometry2.prototype.getIndex = function() {
        return this.indexBuffer;
      };
      Geometry2.prototype.interleave = function() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
          return this;
        }
        var arrays = [];
        var sizes = [];
        var interleavedBuffer = new Buffer$1();
        var i2;
        for (i2 in this.attributes) {
          var attribute = this.attributes[i2];
          var buffer = this.buffers[attribute.buffer];
          arrays.push(buffer.data);
          sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
          attribute.buffer = 0;
        }
        interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
        for (i2 = 0; i2 < this.buffers.length; i2++) {
          if (this.buffers[i2] !== this.indexBuffer) {
            this.buffers[i2].destroy();
          }
        }
        this.buffers = [interleavedBuffer];
        if (this.indexBuffer) {
          this.buffers.push(this.indexBuffer);
        }
        return this;
      };
      Geometry2.prototype.getSize = function() {
        for (var i2 in this.attributes) {
          var attribute = this.attributes[i2];
          var buffer = this.buffers[attribute.buffer];
          return buffer.data.length / (attribute.stride / 4 || attribute.size);
        }
        return 0;
      };
      Geometry2.prototype.dispose = function() {
        this.disposeRunner.emit(this, false);
      };
      Geometry2.prototype.destroy = function() {
        this.dispose();
        this.buffers = null;
        this.indexBuffer = null;
        this.attributes = null;
      };
      Geometry2.prototype.clone = function() {
        var geometry = new Geometry2();
        for (var i2 = 0; i2 < this.buffers.length; i2++) {
          geometry.buffers[i2] = new Buffer$1(this.buffers[i2].data.slice(0));
        }
        for (var i2 in this.attributes) {
          var attrib = this.attributes[i2];
          geometry.attributes[i2] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
        }
        if (this.indexBuffer) {
          geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
          geometry.indexBuffer.index = true;
        }
        return geometry;
      };
      Geometry2.merge = function(geometries) {
        var geometryOut = new Geometry2();
        var arrays = [];
        var sizes = [];
        var offsets = [];
        var geometry;
        for (var i2 = 0; i2 < geometries.length; i2++) {
          geometry = geometries[i2];
          for (var j = 0; j < geometry.buffers.length; j++) {
            sizes[j] = sizes[j] || 0;
            sizes[j] += geometry.buffers[j].data.length;
            offsets[j] = 0;
          }
        }
        for (var i2 = 0; i2 < geometry.buffers.length; i2++) {
          arrays[i2] = new map$1$1[getBufferType(geometry.buffers[i2].data)](sizes[i2]);
          geometryOut.buffers[i2] = new Buffer$1(arrays[i2]);
        }
        for (var i2 = 0; i2 < geometries.length; i2++) {
          geometry = geometries[i2];
          for (var j = 0; j < geometry.buffers.length; j++) {
            arrays[j].set(geometry.buffers[j].data, offsets[j]);
            offsets[j] += geometry.buffers[j].data.length;
          }
        }
        geometryOut.attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
          geometryOut.indexBuffer.index = true;
          var offset2 = 0;
          var stride = 0;
          var offset22 = 0;
          var bufferIndexToCount = 0;
          for (var i2 = 0; i2 < geometry.buffers.length; i2++) {
            if (geometry.buffers[i2] !== geometry.indexBuffer) {
              bufferIndexToCount = i2;
              break;
            }
          }
          for (var i2 in geometry.attributes) {
            var attribute = geometry.attributes[i2];
            if ((attribute.buffer | 0) === bufferIndexToCount) {
              stride += attribute.size * byteSizeMap[attribute.type] / 4;
            }
          }
          for (var i2 = 0; i2 < geometries.length; i2++) {
            var indexBufferData = geometries[i2].indexBuffer.data;
            for (var j = 0; j < indexBufferData.length; j++) {
              geometryOut.indexBuffer.data[j + offset22] += offset2;
            }
            offset2 += geometry.buffers[bufferIndexToCount].data.length / stride;
            offset22 += indexBufferData.length;
          }
        }
        return geometryOut;
      };
      return Geometry2;
    }();
    var Quad = function(_super) {
      __extends$h(Quad2, _super);
      function Quad2() {
        var _this = _super.call(this) || this;
        _this.addAttribute("aVertexPosition", new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ])).addIndex([0, 1, 3, 2]);
        return _this;
      }
      return Quad2;
    }(Geometry);
    var QuadUv = function(_super) {
      __extends$h(QuadUv2, _super);
      function QuadUv2() {
        var _this = _super.call(this) || this;
        _this.vertices = new Float32Array([
          -1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          1
        ]);
        _this.uvs = new Float32Array([
          0,
          0,
          1,
          0,
          1,
          1,
          0,
          1
        ]);
        _this.vertexBuffer = new Buffer$1(_this.vertices);
        _this.uvBuffer = new Buffer$1(_this.uvs);
        _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
        return _this;
      }
      QuadUv2.prototype.map = function(targetTextureFrame, destinationFrame) {
        var x2 = 0;
        var y2 = 0;
        this.uvs[0] = x2;
        this.uvs[1] = y2;
        this.uvs[2] = x2 + destinationFrame.width / targetTextureFrame.width;
        this.uvs[3] = y2;
        this.uvs[4] = x2 + destinationFrame.width / targetTextureFrame.width;
        this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height;
        this.uvs[6] = x2;
        this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height;
        x2 = destinationFrame.x;
        y2 = destinationFrame.y;
        this.vertices[0] = x2;
        this.vertices[1] = y2;
        this.vertices[2] = x2 + destinationFrame.width;
        this.vertices[3] = y2;
        this.vertices[4] = x2 + destinationFrame.width;
        this.vertices[5] = y2 + destinationFrame.height;
        this.vertices[6] = x2;
        this.vertices[7] = y2 + destinationFrame.height;
        this.invalidate();
        return this;
      };
      QuadUv2.prototype.invalidate = function() {
        this.vertexBuffer._updateID++;
        this.uvBuffer._updateID++;
        return this;
      };
      return QuadUv2;
    }(Geometry);
    var UID$2 = 0;
    var UniformGroup = function() {
      function UniformGroup2(uniforms, _static) {
        this.uniforms = uniforms;
        this.group = true;
        this.syncUniforms = {};
        this.dirtyId = 0;
        this.id = UID$2++;
        this.static = !!_static;
      }
      UniformGroup2.prototype.update = function() {
        this.dirtyId++;
      };
      UniformGroup2.prototype.add = function(name, uniforms, _static) {
        this.uniforms[name] = new UniformGroup2(uniforms, _static);
      };
      UniformGroup2.from = function(uniforms, _static) {
        return new UniformGroup2(uniforms, _static);
      };
      return UniformGroup2;
    }();
    var FilterState = function() {
      function FilterState2() {
        this.renderTexture = null;
        this.target = null;
        this.legacy = false;
        this.resolution = 1;
        this.sourceFrame = new Rectangle();
        this.destinationFrame = new Rectangle();
        this.filters = [];
      }
      FilterState2.prototype.clear = function() {
        this.target = null;
        this.filters = null;
        this.renderTexture = null;
      };
      return FilterState2;
    }();
    var FilterSystem = function(_super) {
      __extends$h(FilterSystem2, _super);
      function FilterSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.defaultFilterStack = [{}];
        _this.texturePool = new RenderTexturePool();
        _this.texturePool.setScreenSize(renderer.view);
        _this.statePool = [];
        _this.quad = new Quad();
        _this.quadUv = new QuadUv();
        _this.tempRect = new Rectangle();
        _this.activeState = {};
        _this.globalUniforms = new UniformGroup({
          outputFrame: _this.tempRect,
          inputSize: new Float32Array(4),
          inputPixel: new Float32Array(4),
          inputClamp: new Float32Array(4),
          resolution: 1,
          filterArea: new Float32Array(4),
          filterClamp: new Float32Array(4)
        }, true);
        _this.forceClear = false;
        _this.useMaxPadding = false;
        return _this;
      }
      FilterSystem2.prototype.push = function(target, filters) {
        var renderer = this.renderer;
        var filterStack = this.defaultFilterStack;
        var state = this.statePool.pop() || new FilterState();
        var resolution = filters[0].resolution;
        var padding = filters[0].padding;
        var autoFit = filters[0].autoFit;
        var legacy = filters[0].legacy;
        for (var i2 = 1; i2 < filters.length; i2++) {
          var filter2 = filters[i2];
          resolution = Math.min(resolution, filter2.resolution);
          padding = this.useMaxPadding ? Math.max(padding, filter2.padding) : padding + filter2.padding;
          autoFit = autoFit && filter2.autoFit;
          legacy = legacy || filter2.legacy;
        }
        if (filterStack.length === 1) {
          this.defaultFilterStack[0].renderTexture = renderer.renderTexture.current;
        }
        filterStack.push(state);
        state.resolution = resolution;
        state.legacy = legacy;
        state.target = target;
        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
        state.sourceFrame.pad(padding);
        if (autoFit) {
          state.sourceFrame.fit(this.renderer.renderTexture.sourceFrame);
        }
        state.sourceFrame.ceil(resolution);
        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);
        state.filters = filters;
        state.destinationFrame.width = state.renderTexture.width;
        state.destinationFrame.height = state.renderTexture.height;
        var destinationFrame = this.tempRect;
        destinationFrame.width = state.sourceFrame.width;
        destinationFrame.height = state.sourceFrame.height;
        state.renderTexture.filterFrame = state.sourceFrame;
        renderer.renderTexture.bind(state.renderTexture, state.sourceFrame, destinationFrame);
        renderer.renderTexture.clear();
      };
      FilterSystem2.prototype.pop = function() {
        var filterStack = this.defaultFilterStack;
        var state = filterStack.pop();
        var filters = state.filters;
        this.activeState = state;
        var globalUniforms = this.globalUniforms.uniforms;
        globalUniforms.outputFrame = state.sourceFrame;
        globalUniforms.resolution = state.resolution;
        var inputSize = globalUniforms.inputSize;
        var inputPixel = globalUniforms.inputPixel;
        var inputClamp = globalUniforms.inputClamp;
        inputSize[0] = state.destinationFrame.width;
        inputSize[1] = state.destinationFrame.height;
        inputSize[2] = 1 / inputSize[0];
        inputSize[3] = 1 / inputSize[1];
        inputPixel[0] = inputSize[0] * state.resolution;
        inputPixel[1] = inputSize[1] * state.resolution;
        inputPixel[2] = 1 / inputPixel[0];
        inputPixel[3] = 1 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
        inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
        if (state.legacy) {
          var filterArea = globalUniforms.filterArea;
          filterArea[0] = state.destinationFrame.width;
          filterArea[1] = state.destinationFrame.height;
          filterArea[2] = state.sourceFrame.x;
          filterArea[3] = state.sourceFrame.y;
          globalUniforms.filterClamp = globalUniforms.inputClamp;
        }
        this.globalUniforms.update();
        var lastState = filterStack[filterStack.length - 1];
        if (state.renderTexture.framebuffer.multisample > 1) {
          this.renderer.framebuffer.blit();
        }
        if (filters.length === 1) {
          filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES$1.BLEND, state);
          this.returnFilterTexture(state.renderTexture);
        } else {
          var flip = state.renderTexture;
          var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
          var i2 = 0;
          for (i2 = 0; i2 < filters.length - 1; ++i2) {
            filters[i2].apply(this, flip, flop, CLEAR_MODES$1.CLEAR, state);
            var t2 = flip;
            flip = flop;
            flop = t2;
          }
          filters[i2].apply(this, flip, lastState.renderTexture, CLEAR_MODES$1.BLEND, state);
          this.returnFilterTexture(flip);
          this.returnFilterTexture(flop);
        }
        state.clear();
        this.statePool.push(state);
      };
      FilterSystem2.prototype.bindAndClear = function(filterTexture, clearMode) {
        if (clearMode === void 0) {
          clearMode = CLEAR_MODES$1.CLEAR;
        }
        if (filterTexture && filterTexture.filterFrame) {
          var destinationFrame = this.tempRect;
          destinationFrame.width = filterTexture.filterFrame.width;
          destinationFrame.height = filterTexture.filterFrame.height;
          this.renderer.renderTexture.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
        } else {
          this.renderer.renderTexture.bind(filterTexture);
        }
        if (typeof clearMode === "boolean") {
          clearMode = clearMode ? CLEAR_MODES$1.CLEAR : CLEAR_MODES$1.BLEND;
          deprecation("5.2.1", "Use CLEAR_MODES when using clear applyFilter option");
        }
        if (clearMode === CLEAR_MODES$1.CLEAR || clearMode === CLEAR_MODES$1.BLIT && this.forceClear) {
          this.renderer.renderTexture.clear();
        }
      };
      FilterSystem2.prototype.applyFilter = function(filter2, input, output, clearMode) {
        var renderer = this.renderer;
        this.bindAndClear(output, clearMode);
        filter2.uniforms.uSampler = input;
        filter2.uniforms.filterGlobals = this.globalUniforms;
        renderer.state.set(filter2.state);
        renderer.shader.bind(filter2);
        if (filter2.legacy) {
          this.quadUv.map(input._frame, input.filterFrame);
          renderer.geometry.bind(this.quadUv);
          renderer.geometry.draw(DRAW_MODES$1.TRIANGLES);
        } else {
          renderer.geometry.bind(this.quad);
          renderer.geometry.draw(DRAW_MODES$1.TRIANGLE_STRIP);
        }
      };
      FilterSystem2.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
        var _a2 = this.activeState, sourceFrame = _a2.sourceFrame, destinationFrame = _a2.destinationFrame;
        var orig = sprite._texture.orig;
        var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
        var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1 / orig.width, 1 / orig.height);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
      };
      FilterSystem2.prototype.destroy = function() {
        this.texturePool.clear(false);
      };
      FilterSystem2.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution) {
        if (resolution === void 0) {
          resolution = 1;
        }
        return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution);
      };
      FilterSystem2.prototype.getFilterTexture = function(input, resolution) {
        if (typeof input === "number") {
          var swap = input;
          input = resolution;
          resolution = swap;
        }
        input = input || this.activeState.renderTexture;
        var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution);
        filterTexture.filterFrame = input.filterFrame;
        return filterTexture;
      };
      FilterSystem2.prototype.returnFilterTexture = function(renderTexture) {
        this.texturePool.returnTexture(renderTexture);
      };
      FilterSystem2.prototype.emptyPool = function() {
        this.texturePool.clear(true);
      };
      FilterSystem2.prototype.resize = function() {
        this.texturePool.setScreenSize(this.renderer.view);
      };
      return FilterSystem2;
    }(System);
    var ObjectRenderer = function() {
      function ObjectRenderer2(renderer) {
        this.renderer = renderer;
      }
      ObjectRenderer2.prototype.flush = function() {
      };
      ObjectRenderer2.prototype.destroy = function() {
        this.renderer = null;
      };
      ObjectRenderer2.prototype.start = function() {
      };
      ObjectRenderer2.prototype.stop = function() {
        this.flush();
      };
      ObjectRenderer2.prototype.render = function(_object) {
      };
      return ObjectRenderer2;
    }();
    var BatchSystem = function(_super) {
      __extends$h(BatchSystem2, _super);
      function BatchSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.emptyRenderer = new ObjectRenderer(renderer);
        _this.currentRenderer = _this.emptyRenderer;
        return _this;
      }
      BatchSystem2.prototype.setObjectRenderer = function(objectRenderer) {
        if (this.currentRenderer === objectRenderer) {
          return;
        }
        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;
        this.currentRenderer.start();
      };
      BatchSystem2.prototype.flush = function() {
        this.setObjectRenderer(this.emptyRenderer);
      };
      BatchSystem2.prototype.reset = function() {
        this.setObjectRenderer(this.emptyRenderer);
      };
      BatchSystem2.prototype.copyBoundTextures = function(arr, maxTextures) {
        var boundTextures = this.renderer.texture.boundTextures;
        for (var i2 = maxTextures - 1; i2 >= 0; --i2) {
          arr[i2] = boundTextures[i2] || null;
          if (arr[i2]) {
            arr[i2]._batchLocation = i2;
          }
        }
      };
      BatchSystem2.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
        var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
        var j = 0;
        for (var i2 = 0; i2 < count; i2++) {
          var tex = elements[i2];
          var loc = tex._batchLocation;
          if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
            ids[i2] = loc;
            continue;
          }
          while (j < maxTextures) {
            var bound = boundTextures[j];
            if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
              j++;
              continue;
            }
            ids[i2] = j;
            tex._batchLocation = j;
            boundTextures[j] = tex;
            break;
          }
        }
      };
      return BatchSystem2;
    }(System);
    var CONTEXT_UID_COUNTER = 0;
    var ContextSystem = function(_super) {
      __extends$h(ContextSystem2, _super);
      function ContextSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.webGLVersion = 1;
        _this.extensions = {};
        _this.supports = {
          uint32Indices: false
        };
        _this.handleContextLost = _this.handleContextLost.bind(_this);
        _this.handleContextRestored = _this.handleContextRestored.bind(_this);
        renderer.view.addEventListener("webglcontextlost", _this.handleContextLost, false);
        renderer.view.addEventListener("webglcontextrestored", _this.handleContextRestored, false);
        return _this;
      }
      Object.defineProperty(ContextSystem2.prototype, "isLost", {
        get: function() {
          return !this.gl || this.gl.isContextLost();
        },
        enumerable: false,
        configurable: true
      });
      ContextSystem2.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
        if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
          gl.getExtension("WEBGL_lose_context").restoreContext();
        }
      };
      ContextSystem2.prototype.initFromContext = function(gl) {
        this.gl = gl;
        this.validateContext(gl);
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
        this.renderer.runners.contextChange.emit(gl);
      };
      ContextSystem2.prototype.initFromOptions = function(options) {
        var gl = this.createContext(this.renderer.view, options);
        this.initFromContext(gl);
      };
      ContextSystem2.prototype.createContext = function(canvas2, options) {
        var gl;
        if (settings.PREFER_ENV >= ENV$1.WEBGL2) {
          gl = canvas2.getContext("webgl2", options);
        }
        if (gl) {
          this.webGLVersion = 2;
        } else {
          this.webGLVersion = 1;
          gl = canvas2.getContext("webgl", options) || canvas2.getContext("experimental-webgl", options);
          if (!gl) {
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
          }
        }
        this.gl = gl;
        this.getExtensions();
        return this.gl;
      };
      ContextSystem2.prototype.getExtensions = function() {
        var gl = this.gl;
        if (this.webGLVersion === 1) {
          Object.assign(this.extensions, {
            drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
            depthTexture: gl.getExtension("WEBGL_depth_texture"),
            loseContext: gl.getExtension("WEBGL_lose_context"),
            vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
            anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
            uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
            floatTexture: gl.getExtension("OES_texture_float"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            textureHalfFloat: gl.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
          });
        } else if (this.webGLVersion === 2) {
          Object.assign(this.extensions, {
            anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
            colorBufferFloat: gl.getExtension("EXT_color_buffer_float"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear")
          });
        }
      };
      ContextSystem2.prototype.handleContextLost = function(event) {
        event.preventDefault();
      };
      ContextSystem2.prototype.handleContextRestored = function() {
        this.renderer.runners.contextChange.emit(this.gl);
      };
      ContextSystem2.prototype.destroy = function() {
        var view = this.renderer.view;
        view.removeEventListener("webglcontextlost", this.handleContextLost);
        view.removeEventListener("webglcontextrestored", this.handleContextRestored);
        this.gl.useProgram(null);
        if (this.extensions.loseContext) {
          this.extensions.loseContext.loseContext();
        }
      };
      ContextSystem2.prototype.postrender = function() {
        if (this.renderer.renderingToScreen) {
          this.gl.flush();
        }
      };
      ContextSystem2.prototype.validateContext = function(gl) {
        var attributes = gl.getContextAttributes();
        var isWebGl2 = "WebGL2RenderingContext" in window && gl instanceof window.WebGL2RenderingContext;
        if (isWebGl2) {
          this.webGLVersion = 2;
        }
        if (!attributes.stencil) {
          console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        }
        var hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = hasuint32;
        if (!hasuint32) {
          console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
        }
      };
      return ContextSystem2;
    }(System);
    var GLFramebuffer = function() {
      function GLFramebuffer2(framebuffer) {
        this.framebuffer = framebuffer;
        this.stencil = null;
        this.dirtyId = 0;
        this.dirtyFormat = 0;
        this.dirtySize = 0;
        this.multisample = MSAA_QUALITY$1.NONE;
        this.msaaBuffer = null;
        this.blitFramebuffer = null;
      }
      return GLFramebuffer2;
    }();
    var tempRectangle = new Rectangle();
    var FramebufferSystem = function(_super) {
      __extends$h(FramebufferSystem2, _super);
      function FramebufferSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.managedFramebuffers = [];
        _this.unknownFramebuffer = new Framebuffer(10, 10);
        _this.msaaSamples = null;
        return _this;
      }
      FramebufferSystem2.prototype.contextChange = function() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle();
        this.hasMRT = true;
        this.writeDepthTexture = true;
        this.disposeAll(true);
        if (this.renderer.context.webGLVersion === 1) {
          var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
          var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
          if (settings.PREFER_ENV === ENV$1.WEBGL_LEGACY) {
            nativeDrawBuffersExtension_1 = null;
            nativeDepthTextureExtension = null;
          }
          if (nativeDrawBuffersExtension_1) {
            gl.drawBuffers = function(activeTextures) {
              return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
            };
          } else {
            this.hasMRT = false;
            gl.drawBuffers = function() {
            };
          }
          if (!nativeDepthTextureExtension) {
            this.writeDepthTexture = false;
          }
        } else {
          this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
        }
      };
      FramebufferSystem2.prototype.bind = function(framebuffer, frame) {
        var gl = this.gl;
        if (framebuffer) {
          var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
          if (this.current !== framebuffer) {
            this.current = framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
          }
          if (fbo.dirtyId !== framebuffer.dirtyId) {
            fbo.dirtyId = framebuffer.dirtyId;
            if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
              fbo.dirtyFormat = framebuffer.dirtyFormat;
              this.updateFramebuffer(framebuffer);
            } else if (fbo.dirtySize !== framebuffer.dirtySize) {
              fbo.dirtySize = framebuffer.dirtySize;
              this.resizeFramebuffer(framebuffer);
            }
          }
          for (var i2 = 0; i2 < framebuffer.colorTextures.length; i2++) {
            var tex = framebuffer.colorTextures[i2];
            this.renderer.texture.unbind(tex.parentTextureArray || tex);
          }
          if (framebuffer.depthTexture) {
            this.renderer.texture.unbind(framebuffer.depthTexture);
          }
          if (frame) {
            this.setViewport(frame.x, frame.y, frame.width, frame.height);
          } else {
            this.setViewport(0, 0, framebuffer.width, framebuffer.height);
          }
        } else {
          if (this.current) {
            this.current = null;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          }
          if (frame) {
            this.setViewport(frame.x, frame.y, frame.width, frame.height);
          } else {
            this.setViewport(0, 0, this.renderer.width, this.renderer.height);
          }
        }
      };
      FramebufferSystem2.prototype.setViewport = function(x2, y2, width2, height2) {
        var v2 = this.viewport;
        if (v2.width !== width2 || v2.height !== height2 || v2.x !== x2 || v2.y !== y2) {
          v2.x = x2;
          v2.y = y2;
          v2.width = width2;
          v2.height = height2;
          this.gl.viewport(x2, y2, width2, height2);
        }
      };
      Object.defineProperty(FramebufferSystem2.prototype, "size", {
        get: function() {
          if (this.current) {
            return { x: 0, y: 0, width: this.current.width, height: this.current.height };
          }
          return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
        },
        enumerable: false,
        configurable: true
      });
      FramebufferSystem2.prototype.clear = function(r2, g2, b, a2, mask) {
        if (mask === void 0) {
          mask = BUFFER_BITS$1.COLOR | BUFFER_BITS$1.DEPTH;
        }
        var gl = this.gl;
        gl.clearColor(r2, g2, b, a2);
        gl.clear(mask);
      };
      FramebufferSystem2.prototype.initFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = new GLFramebuffer(gl.createFramebuffer());
        fbo.multisample = this.detectSamples(framebuffer.multisample);
        framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
        this.managedFramebuffers.push(framebuffer);
        framebuffer.disposeRunner.add(this);
        return fbo;
      };
      FramebufferSystem2.prototype.resizeFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (fbo.stencil) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
        var colorTextures = framebuffer.colorTextures;
        for (var i2 = 0; i2 < colorTextures.length; i2++) {
          this.renderer.texture.bind(colorTextures[i2], 0);
        }
        if (framebuffer.depthTexture) {
          this.renderer.texture.bind(framebuffer.depthTexture, 0);
        }
      };
      FramebufferSystem2.prototype.updateFramebuffer = function(framebuffer) {
        var gl = this.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var colorTextures = framebuffer.colorTextures;
        var count = colorTextures.length;
        if (!gl.drawBuffers) {
          count = Math.min(count, 1);
        }
        if (fbo.multisample > 1) {
          fbo.msaaBuffer = gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
        }
        var activeTextures = [];
        for (var i2 = 0; i2 < count; i2++) {
          if (i2 === 0 && fbo.multisample > 1) {
            continue;
          }
          var texture = framebuffer.colorTextures[i2];
          var parentTexture = texture.parentTextureArray || texture;
          this.renderer.texture.bind(parentTexture, 0);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, 0);
          activeTextures.push(gl.COLOR_ATTACHMENT0 + i2);
        }
        if (activeTextures.length > 1) {
          gl.drawBuffers(activeTextures);
        }
        if (framebuffer.depthTexture) {
          var writeDepthTexture = this.writeDepthTexture;
          if (writeDepthTexture) {
            var depthTexture = framebuffer.depthTexture;
            this.renderer.texture.bind(depthTexture, 0);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, 0);
          }
        }
        if (!fbo.stencil && (framebuffer.stencil || framebuffer.depth)) {
          fbo.stencil = gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
          gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
          if (!framebuffer.depthTexture) {
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
          }
        }
      };
      FramebufferSystem2.prototype.detectSamples = function(samples) {
        var msaaSamples = this.msaaSamples;
        var res = MSAA_QUALITY$1.NONE;
        if (samples <= 1 || msaaSamples === null) {
          return res;
        }
        for (var i2 = 0; i2 < msaaSamples.length; i2++) {
          if (msaaSamples[i2] <= samples) {
            res = msaaSamples[i2];
            break;
          }
        }
        if (res === 1) {
          res = MSAA_QUALITY$1.NONE;
        }
        return res;
      };
      FramebufferSystem2.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
        var _a2 = this, current = _a2.current, renderer = _a2.renderer, gl = _a2.gl, CONTEXT_UID = _a2.CONTEXT_UID;
        if (renderer.context.webGLVersion !== 2) {
          return;
        }
        if (!current) {
          return;
        }
        var fbo = current.glFramebuffers[CONTEXT_UID];
        if (!fbo) {
          return;
        }
        if (!framebuffer) {
          if (fbo.multisample <= 1) {
            return;
          }
          if (!fbo.blitFramebuffer) {
            fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
            fbo.blitFramebuffer.addColorTexture(0, current.colorTextures[0]);
          }
          framebuffer = fbo.blitFramebuffer;
          framebuffer.width = current.width;
          framebuffer.height = current.height;
        }
        if (!sourcePixels) {
          sourcePixels = tempRectangle;
          sourcePixels.width = current.width;
          sourcePixels.height = current.height;
        }
        if (!destPixels) {
          destPixels = sourcePixels;
        }
        var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
        this.bind(framebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
        gl.blitFramebuffer(sourcePixels.x, sourcePixels.y, sourcePixels.width, sourcePixels.height, destPixels.x, destPixels.y, destPixels.width, destPixels.height, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
      };
      FramebufferSystem2.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var gl = this.gl;
        if (!fbo) {
          return;
        }
        delete framebuffer.glFramebuffers[this.CONTEXT_UID];
        var index2 = this.managedFramebuffers.indexOf(framebuffer);
        if (index2 >= 0) {
          this.managedFramebuffers.splice(index2, 1);
        }
        framebuffer.disposeRunner.remove(this);
        if (!contextLost) {
          gl.deleteFramebuffer(fbo.framebuffer);
          if (fbo.stencil) {
            gl.deleteRenderbuffer(fbo.stencil);
          }
        }
      };
      FramebufferSystem2.prototype.disposeAll = function(contextLost) {
        var list = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (var i2 = 0; i2 < list.length; i2++) {
          this.disposeFramebuffer(list[i2], contextLost);
        }
      };
      FramebufferSystem2.prototype.forceStencil = function() {
        var framebuffer = this.current;
        if (!framebuffer) {
          return;
        }
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (!fbo || fbo.stencil) {
          return;
        }
        framebuffer.enableStencil();
        var w2 = framebuffer.width;
        var h2 = framebuffer.height;
        var gl = this.gl;
        var stencil = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w2, h2);
        fbo.stencil = stencil;
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
      };
      FramebufferSystem2.prototype.reset = function() {
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle();
      };
      return FramebufferSystem2;
    }(System);
    var GLBuffer = function() {
      function GLBuffer2(buffer) {
        this.buffer = buffer || null;
        this.updateID = -1;
        this.byteLength = -1;
        this.refCount = 0;
      }
      return GLBuffer2;
    }();
    var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
    var GeometrySystem = function(_super) {
      __extends$h(GeometrySystem2, _super);
      function GeometrySystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this._activeGeometry = null;
        _this._activeVao = null;
        _this.hasVao = true;
        _this.hasInstance = true;
        _this.canUseUInt32ElementIndex = false;
        _this.managedGeometries = {};
        _this.managedBuffers = {};
        return _this;
      }
      GeometrySystem2.prototype.contextChange = function() {
        this.disposeAll(true);
        var gl = this.gl = this.renderer.gl;
        var context2 = this.renderer.context;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        if (context2.webGLVersion !== 2) {
          var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
          if (settings.PREFER_ENV === ENV$1.WEBGL_LEGACY) {
            nativeVaoExtension_1 = null;
          }
          if (nativeVaoExtension_1) {
            gl.createVertexArray = function() {
              return nativeVaoExtension_1.createVertexArrayOES();
            };
            gl.bindVertexArray = function(vao) {
              return nativeVaoExtension_1.bindVertexArrayOES(vao);
            };
            gl.deleteVertexArray = function(vao) {
              return nativeVaoExtension_1.deleteVertexArrayOES(vao);
            };
          } else {
            this.hasVao = false;
            gl.createVertexArray = function() {
              return null;
            };
            gl.bindVertexArray = function() {
              return null;
            };
            gl.deleteVertexArray = function() {
              return null;
            };
          }
        }
        if (context2.webGLVersion !== 2) {
          var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
          if (instanceExt_1) {
            gl.vertexAttribDivisor = function(a2, b) {
              return instanceExt_1.vertexAttribDivisorANGLE(a2, b);
            };
            gl.drawElementsInstanced = function(a2, b, c, d, e) {
              return instanceExt_1.drawElementsInstancedANGLE(a2, b, c, d, e);
            };
            gl.drawArraysInstanced = function(a2, b, c, d) {
              return instanceExt_1.drawArraysInstancedANGLE(a2, b, c, d);
            };
          } else {
            this.hasInstance = false;
          }
        }
        this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
      };
      GeometrySystem2.prototype.bind = function(geometry, shader) {
        shader = shader || this.renderer.shader.shader;
        var gl = this.gl;
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var incRefCount = false;
        if (!vaos) {
          this.managedGeometries[geometry.id] = geometry;
          geometry.disposeRunner.add(this);
          geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
          incRefCount = true;
        }
        var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader.program, incRefCount);
        this._activeGeometry = geometry;
        if (this._activeVao !== vao) {
          this._activeVao = vao;
          if (this.hasVao) {
            gl.bindVertexArray(vao);
          } else {
            this.activateVao(geometry, shader.program);
          }
        }
        this.updateBuffers();
      };
      GeometrySystem2.prototype.reset = function() {
        this.unbind();
      };
      GeometrySystem2.prototype.updateBuffers = function() {
        var geometry = this._activeGeometry;
        var gl = this.gl;
        for (var i2 = 0; i2 < geometry.buffers.length; i2++) {
          var buffer = geometry.buffers[i2];
          var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
          if (buffer._updateID !== glBuffer.updateID) {
            glBuffer.updateID = buffer._updateID;
            var type = buffer.index ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
            gl.bindBuffer(type, glBuffer.buffer);
            this._boundBuffer = glBuffer;
            if (glBuffer.byteLength >= buffer.data.byteLength) {
              gl.bufferSubData(type, 0, buffer.data);
            } else {
              var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
              glBuffer.byteLength = buffer.data.byteLength;
              gl.bufferData(type, buffer.data, drawType);
            }
          }
        }
      };
      GeometrySystem2.prototype.checkCompatibility = function(geometry, program) {
        var geometryAttributes = geometry.attributes;
        var shaderAttributes = program.attributeData;
        for (var j in shaderAttributes) {
          if (!geometryAttributes[j]) {
            throw new Error('shader and geometry incompatible, geometry missing the "' + j + '" attribute');
          }
        }
      };
      GeometrySystem2.prototype.getSignature = function(geometry, program) {
        var attribs = geometry.attributes;
        var shaderAttributes = program.attributeData;
        var strings = ["g", geometry.id];
        for (var i2 in attribs) {
          if (shaderAttributes[i2]) {
            strings.push(i2);
          }
        }
        return strings.join("-");
      };
      GeometrySystem2.prototype.initGeometryVao = function(geometry, program, incRefCount) {
        if (incRefCount === void 0) {
          incRefCount = true;
        }
        this.checkCompatibility(geometry, program);
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var signature = this.getSignature(geometry, program);
        var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var vao = vaoObjectHash[signature];
        if (vao) {
          vaoObjectHash[program.id] = vao;
          return vao;
        }
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        var tempStride = {};
        var tempStart = {};
        for (var j in buffers) {
          tempStride[j] = 0;
          tempStart[j] = 0;
        }
        for (var j in attributes) {
          if (!attributes[j].size && program.attributeData[j]) {
            attributes[j].size = program.attributeData[j].size;
          } else if (!attributes[j].size) {
            console.warn("PIXI Geometry attribute '" + j + "' size cannot be determined (likely the bound shader does not have the attribute)");
          }
          tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap$1[attributes[j].type];
        }
        for (var j in attributes) {
          var attribute = attributes[j];
          var attribSize = attribute.size;
          if (attribute.stride === void 0) {
            if (tempStride[attribute.buffer] === attribSize * byteSizeMap$1[attribute.type]) {
              attribute.stride = 0;
            } else {
              attribute.stride = tempStride[attribute.buffer];
            }
          }
          if (attribute.start === void 0) {
            attribute.start = tempStart[attribute.buffer];
            tempStart[attribute.buffer] += attribSize * byteSizeMap$1[attribute.type];
          }
        }
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        for (var i2 = 0; i2 < buffers.length; i2++) {
          var buffer = buffers[i2];
          if (!buffer._glBuffers[CONTEXT_UID]) {
            buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
            this.managedBuffers[buffer.id] = buffer;
            buffer.disposeRunner.add(this);
          }
          if (incRefCount) {
            buffer._glBuffers[CONTEXT_UID].refCount++;
          }
        }
        this.activateVao(geometry, program);
        this._activeVao = vao;
        vaoObjectHash[program.id] = vao;
        vaoObjectHash[signature] = vao;
        return vao;
      };
      GeometrySystem2.prototype.disposeBuffer = function(buffer, contextLost) {
        if (!this.managedBuffers[buffer.id]) {
          return;
        }
        delete this.managedBuffers[buffer.id];
        var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
        var gl = this.gl;
        buffer.disposeRunner.remove(this);
        if (!glBuffer) {
          return;
        }
        if (!contextLost) {
          gl.deleteBuffer(glBuffer.buffer);
        }
        delete buffer._glBuffers[this.CONTEXT_UID];
      };
      GeometrySystem2.prototype.disposeGeometry = function(geometry, contextLost) {
        if (!this.managedGeometries[geometry.id]) {
          return;
        }
        delete this.managedGeometries[geometry.id];
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var gl = this.gl;
        var buffers = geometry.buffers;
        geometry.disposeRunner.remove(this);
        if (!vaos) {
          return;
        }
        for (var i2 = 0; i2 < buffers.length; i2++) {
          var buf = buffers[i2]._glBuffers[this.CONTEXT_UID];
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            this.disposeBuffer(buffers[i2], contextLost);
          }
        }
        if (!contextLost) {
          for (var vaoId in vaos) {
            if (vaoId[0] === "g") {
              var vao = vaos[vaoId];
              if (this._activeVao === vao) {
                this.unbind();
              }
              gl.deleteVertexArray(vao);
            }
          }
        }
        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
      };
      GeometrySystem2.prototype.disposeAll = function(contextLost) {
        var all = Object.keys(this.managedGeometries);
        for (var i2 = 0; i2 < all.length; i2++) {
          this.disposeGeometry(this.managedGeometries[all[i2]], contextLost);
        }
        all = Object.keys(this.managedBuffers);
        for (var i2 = 0; i2 < all.length; i2++) {
          this.disposeBuffer(this.managedBuffers[all[i2]], contextLost);
        }
      };
      GeometrySystem2.prototype.activateVao = function(geometry, program) {
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.indexBuffer._glBuffers[CONTEXT_UID].buffer);
        }
        var lastBuffer = null;
        for (var j in attributes) {
          var attribute = attributes[j];
          var buffer = buffers[attribute.buffer];
          var glBuffer = buffer._glBuffers[CONTEXT_UID];
          if (program.attributeData[j]) {
            if (lastBuffer !== glBuffer) {
              gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer.buffer);
              lastBuffer = glBuffer;
            }
            var location = program.attributeData[j].location;
            gl.enableVertexAttribArray(location);
            gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
            if (attribute.instance) {
              if (this.hasInstance) {
                gl.vertexAttribDivisor(location, 1);
              } else {
                throw new Error("geometry error, GPU Instancing is not supported on this device");
              }
            }
          }
        }
      };
      GeometrySystem2.prototype.draw = function(type, size2, start, instanceCount) {
        var gl = this.gl;
        var geometry = this._activeGeometry;
        if (geometry.indexBuffer) {
          var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
            if (geometry.instanced) {
              gl.drawElementsInstanced(type, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
            } else {
              gl.drawElements(type, size2 || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
            }
          } else {
            console.warn("unsupported index buffer type: uint32");
          }
        } else if (geometry.instanced) {
          gl.drawArraysInstanced(type, start, size2 || geometry.getSize(), instanceCount || 1);
        } else {
          gl.drawArrays(type, start, size2 || geometry.getSize());
        }
        return this;
      };
      GeometrySystem2.prototype.unbind = function() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
      };
      return GeometrySystem2;
    }(System);
    var MaskData = function() {
      function MaskData2(maskObject) {
        if (maskObject === void 0) {
          maskObject = null;
        }
        this.type = MASK_TYPES$1.NONE;
        this.autoDetect = true;
        this.maskObject = maskObject || null;
        this.pooled = false;
        this.isMaskData = true;
        this._stencilCounter = 0;
        this._scissorCounter = 0;
        this._scissorRect = null;
        this._target = null;
      }
      MaskData2.prototype.reset = function() {
        if (this.pooled) {
          this.maskObject = null;
          this.type = MASK_TYPES$1.NONE;
          this.autoDetect = true;
        }
        this._target = null;
      };
      MaskData2.prototype.copyCountersOrReset = function(maskAbove) {
        if (maskAbove) {
          this._stencilCounter = maskAbove._stencilCounter;
          this._scissorCounter = maskAbove._scissorCounter;
          this._scissorRect = maskAbove._scissorRect;
        } else {
          this._stencilCounter = 0;
          this._scissorCounter = 0;
          this._scissorRect = null;
        }
      };
      return MaskData2;
    }();
    function compileShader(gl, type, src2) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, src2);
      gl.compileShader(shader);
      return shader;
    }
    function compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations) {
      var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
      var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
      var program = gl.createProgram();
      gl.attachShader(program, glVertShader);
      gl.attachShader(program, glFragShader);
      if (attributeLocations) {
        for (var i2 in attributeLocations) {
          gl.bindAttribLocation(program, attributeLocations[i2], i2);
        }
      }
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        if (!gl.getShaderParameter(glVertShader, gl.COMPILE_STATUS)) {
          console.warn(vertexSrc);
          console.error(gl.getShaderInfoLog(glVertShader));
        }
        if (!gl.getShaderParameter(glFragShader, gl.COMPILE_STATUS)) {
          console.warn(fragmentSrc);
          console.error(gl.getShaderInfoLog(glFragShader));
        }
        console.error("Pixi.js Error: Could not initialize shader.");
        console.error("gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS));
        console.error("gl.getError()", gl.getError());
        if (gl.getProgramInfoLog(program) !== "") {
          console.warn("Pixi.js Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
        }
        gl.deleteProgram(program);
        program = null;
      }
      gl.deleteShader(glVertShader);
      gl.deleteShader(glFragShader);
      return program;
    }
    function booleanArray(size2) {
      var array = new Array(size2);
      for (var i2 = 0; i2 < array.length; i2++) {
        array[i2] = false;
      }
      return array;
    }
    function defaultValue(type, size2) {
      switch (type) {
        case "float":
          return 0;
        case "vec2":
          return new Float32Array(2 * size2);
        case "vec3":
          return new Float32Array(3 * size2);
        case "vec4":
          return new Float32Array(4 * size2);
        case "int":
        case "sampler2D":
        case "sampler2DArray":
          return 0;
        case "ivec2":
          return new Int32Array(2 * size2);
        case "ivec3":
          return new Int32Array(3 * size2);
        case "ivec4":
          return new Int32Array(4 * size2);
        case "bool":
          return false;
        case "bvec2":
          return booleanArray(2 * size2);
        case "bvec3":
          return booleanArray(3 * size2);
        case "bvec4":
          return booleanArray(4 * size2);
        case "mat2":
          return new Float32Array([
            1,
            0,
            0,
            1
          ]);
        case "mat3":
          return new Float32Array([
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ]);
        case "mat4":
          return new Float32Array([
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ]);
      }
      return null;
    }
    var unknownContext = {};
    var context = unknownContext;
    function getTestContext() {
      if (context === unknownContext || context && context.isContextLost()) {
        var canvas2 = document.createElement("canvas");
        var gl = void 0;
        if (settings.PREFER_ENV >= ENV$1.WEBGL2) {
          gl = canvas2.getContext("webgl2", {});
        }
        if (!gl) {
          gl = canvas2.getContext("webgl", {}) || canvas2.getContext("experimental-webgl", {});
          if (!gl) {
            gl = null;
          } else {
            gl.getExtension("WEBGL_draw_buffers");
          }
        }
        context = gl;
      }
      return context;
    }
    var maxFragmentPrecision;
    function getMaxFragmentPrecision() {
      if (!maxFragmentPrecision) {
        maxFragmentPrecision = PRECISION$1.MEDIUM;
        var gl = getTestContext();
        if (gl) {
          if (gl.getShaderPrecisionFormat) {
            var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
            maxFragmentPrecision = shaderFragment.precision ? PRECISION$1.HIGH : PRECISION$1.MEDIUM;
          }
        }
      }
      return maxFragmentPrecision;
    }
    function setPrecision(src2, requestedPrecision, maxSupportedPrecision) {
      if (src2.substring(0, 9) !== "precision") {
        var precision = requestedPrecision;
        if (requestedPrecision === PRECISION$1.HIGH && maxSupportedPrecision !== PRECISION$1.HIGH) {
          precision = PRECISION$1.MEDIUM;
        }
        return "precision " + precision + " float;\n" + src2;
      } else if (maxSupportedPrecision !== PRECISION$1.HIGH && src2.substring(0, 15) === "precision highp") {
        return src2.replace("precision highp", "precision mediump");
      }
      return src2;
    }
    var GLSL_TO_SIZE = {
      float: 1,
      vec2: 2,
      vec3: 3,
      vec4: 4,
      int: 1,
      ivec2: 2,
      ivec3: 3,
      ivec4: 4,
      bool: 1,
      bvec2: 2,
      bvec3: 3,
      bvec4: 4,
      mat2: 4,
      mat3: 9,
      mat4: 16,
      sampler2D: 1
    };
    function mapSize(type) {
      return GLSL_TO_SIZE[type];
    }
    var GL_TABLE = null;
    var GL_TO_GLSL_TYPES = {
      FLOAT: "float",
      FLOAT_VEC2: "vec2",
      FLOAT_VEC3: "vec3",
      FLOAT_VEC4: "vec4",
      INT: "int",
      INT_VEC2: "ivec2",
      INT_VEC3: "ivec3",
      INT_VEC4: "ivec4",
      BOOL: "bool",
      BOOL_VEC2: "bvec2",
      BOOL_VEC3: "bvec3",
      BOOL_VEC4: "bvec4",
      FLOAT_MAT2: "mat2",
      FLOAT_MAT3: "mat3",
      FLOAT_MAT4: "mat4",
      SAMPLER_2D: "sampler2D",
      INT_SAMPLER_2D: "sampler2D",
      UNSIGNED_INT_SAMPLER_2D: "sampler2D",
      SAMPLER_CUBE: "samplerCube",
      INT_SAMPLER_CUBE: "samplerCube",
      UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
      SAMPLER_2D_ARRAY: "sampler2DArray",
      INT_SAMPLER_2D_ARRAY: "sampler2DArray",
      UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    };
    function mapType(gl, type) {
      if (!GL_TABLE) {
        var typeNames = Object.keys(GL_TO_GLSL_TYPES);
        GL_TABLE = {};
        for (var i2 = 0; i2 < typeNames.length; ++i2) {
          var tn = typeNames[i2];
          GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
        }
      }
      return GL_TABLE[type];
    }
    var uniformParsers = [
      {
        test: function(data) {
          return data.type === "float" && data.size === 1;
        },
        code: function(name) {
          return '\n            if(uv["' + name + '"] !== ud["' + name + '"].value)\n            {\n                ud["' + name + '"].value = uv["' + name + '"]\n                gl.uniform1f(ud["' + name + '"].location, uv["' + name + '"])\n            }\n            ';
        }
      },
      {
        test: function(data) {
          return (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray;
        },
        code: function(name) {
          return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name + '"], t);\n\n            if(ud["' + name + '"].value !== t)\n            {\n                ud["' + name + '"].value = t;\n                gl.uniform1i(ud["' + name + '"].location, t);\n; // eslint-disable-line max-len\n            }';
        }
      },
      {
        test: function(data, uniform) {
          return data.type === "mat3" && data.size === 1 && uniform.a !== void 0;
        },
        code: function(name) {
          return '\n            gl.uniformMatrix3fv(ud["' + name + '"].location, false, uv["' + name + '"].toArray(true));\n            ';
        }
      },
      {
        test: function(data, uniform) {
          return data.type === "vec2" && data.size === 1 && uniform.x !== void 0;
        },
        code: function(name) {
          return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name + '"].location, v.x, v.y);\n                }';
        }
      },
      {
        test: function(data) {
          return data.type === "vec2" && data.size === 1;
        },
        code: function(name) {
          return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name + '"].location, v[0], v[1]);\n                }\n            ';
        }
      },
      {
        test: function(data, uniform) {
          return data.type === "vec4" && data.size === 1 && uniform.width !== void 0;
        },
        code: function(name) {
          return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name + '"].location, v.x, v.y, v.width, v.height)\n                }';
        }
      },
      {
        test: function(data) {
          return data.type === "vec4" && data.size === 1;
        },
        code: function(name) {
          return '\n                cv = ud["' + name + '"].value;\n                v = uv["' + name + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name + '"].location, v[0], v[1], v[2], v[3])\n                }';
        }
      }
    ];
    var GLSL_TO_SINGLE_SETTERS_CACHED = {
      float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",
      vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",
      vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
      vec4: "gl.uniform4f(location, v[0], v[1], v[2], v[3])",
      int: "gl.uniform1i(location, v)",
      ivec2: "gl.uniform2i(location, v[0], v[1])",
      ivec3: "gl.uniform3i(location, v[0], v[1], v[2])",
      ivec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
      bool: "gl.uniform1i(location, v)",
      bvec2: "gl.uniform2i(location, v[0], v[1])",
      bvec3: "gl.uniform3i(location, v[0], v[1], v[2])",
      bvec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      sampler2D: "gl.uniform1i(location, v)",
      samplerCube: "gl.uniform1i(location, v)",
      sampler2DArray: "gl.uniform1i(location, v)"
    };
    var GLSL_TO_ARRAY_SETTERS = {
      float: "gl.uniform1fv(location, v)",
      vec2: "gl.uniform2fv(location, v)",
      vec3: "gl.uniform3fv(location, v)",
      vec4: "gl.uniform4fv(location, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      int: "gl.uniform1iv(location, v)",
      ivec2: "gl.uniform2iv(location, v)",
      ivec3: "gl.uniform3iv(location, v)",
      ivec4: "gl.uniform4iv(location, v)",
      bool: "gl.uniform1iv(location, v)",
      bvec2: "gl.uniform2iv(location, v)",
      bvec3: "gl.uniform3iv(location, v)",
      bvec4: "gl.uniform4iv(location, v)",
      sampler2D: "gl.uniform1iv(location, v)",
      samplerCube: "gl.uniform1iv(location, v)",
      sampler2DArray: "gl.uniform1iv(location, v)"
    };
    function generateUniformsSync(group2, uniformData) {
      var funcFragments = ["\n        var v = null;\n        var cv = null\n        var t = 0;\n        var gl = renderer.gl\n    "];
      for (var i2 in group2.uniforms) {
        var data = uniformData[i2];
        if (!data) {
          if (group2.uniforms[i2].group) {
            funcFragments.push('\n                    renderer.shader.syncUniformGroup(uv["' + i2 + '"], syncData);\n                ');
          }
          continue;
        }
        var uniform = group2.uniforms[i2];
        var parsed = false;
        for (var j = 0; j < uniformParsers.length; j++) {
          if (uniformParsers[j].test(data, uniform)) {
            funcFragments.push(uniformParsers[j].code(i2, uniform));
            parsed = true;
            break;
          }
        }
        if (!parsed) {
          var templateType = data.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
          var template2 = templateType[data.type].replace("location", 'ud["' + i2 + '"].location');
          funcFragments.push('\n            cv = ud["' + i2 + '"].value;\n            v = uv["' + i2 + '"];\n            ' + template2 + ";");
        }
      }
      return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
    }
    var fragTemplate$1 = [
      "precision mediump float;",
      "void main(void){",
      "float test = 0.1;",
      "%forloop%",
      "gl_FragColor = vec4(0.0);",
      "}"
    ].join("\n");
    function generateIfTestSrc(maxIfs) {
      var src2 = "";
      for (var i2 = 0; i2 < maxIfs; ++i2) {
        if (i2 > 0) {
          src2 += "\nelse ";
        }
        if (i2 < maxIfs - 1) {
          src2 += "if(test == " + i2 + ".0){}";
        }
      }
      return src2;
    }
    function checkMaxIfStatementsInShader(maxIfs, gl) {
      if (maxIfs === 0) {
        throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
      }
      var shader = gl.createShader(gl.FRAGMENT_SHADER);
      while (true) {
        var fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
        gl.shaderSource(shader, fragmentSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          maxIfs = maxIfs / 2 | 0;
        } else {
          break;
        }
      }
      return maxIfs;
    }
    var unsafeEval;
    function unsafeEvalSupported() {
      if (typeof unsafeEval === "boolean") {
        return unsafeEval;
      }
      try {
        var func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
        unsafeEval = func({ a: "b" }, "a", "b") === true;
      } catch (e) {
        unsafeEval = false;
      }
      return unsafeEval;
    }
    var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
    var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
    var UID$3 = 0;
    var nameCache = {};
    var Program = function() {
      function Program2(vertexSrc, fragmentSrc, name) {
        if (name === void 0) {
          name = "pixi-shader";
        }
        this.id = UID$3++;
        this.vertexSrc = vertexSrc || Program2.defaultVertexSrc;
        this.fragmentSrc = fragmentSrc || Program2.defaultFragmentSrc;
        this.vertexSrc = this.vertexSrc.trim();
        this.fragmentSrc = this.fragmentSrc.trim();
        if (this.vertexSrc.substring(0, 8) !== "#version") {
          name = name.replace(/\s+/g, "-");
          if (nameCache[name]) {
            nameCache[name]++;
            name += "-" + nameCache[name];
          } else {
            nameCache[name] = 1;
          }
          this.vertexSrc = "#define SHADER_NAME " + name + "\n" + this.vertexSrc;
          this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + this.fragmentSrc;
          this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION$1.HIGH);
          this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());
        }
        this.extractData(this.vertexSrc, this.fragmentSrc);
        this.glPrograms = {};
        this.syncUniforms = null;
      }
      Program2.prototype.extractData = function(vertexSrc, fragmentSrc) {
        var gl = getTestContext();
        if (gl) {
          var program = compileProgram(gl, vertexSrc, fragmentSrc);
          this.attributeData = this.getAttributeData(program, gl);
          this.uniformData = this.getUniformData(program, gl);
          gl.deleteProgram(program);
        } else {
          this.uniformData = {};
          this.attributeData = {};
        }
      };
      Program2.prototype.getAttributeData = function(program, gl) {
        var attributes = {};
        var attributesArray = [];
        var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i2 = 0; i2 < totalAttributes; i2++) {
          var attribData = gl.getActiveAttrib(program, i2);
          var type = mapType(gl, attribData.type);
          var data = {
            type,
            name: attribData.name,
            size: mapSize(type),
            location: 0
          };
          attributes[attribData.name] = data;
          attributesArray.push(data);
        }
        attributesArray.sort(function(a2, b) {
          return a2.name > b.name ? 1 : -1;
        });
        for (var i2 = 0; i2 < attributesArray.length; i2++) {
          attributesArray[i2].location = i2;
        }
        return attributes;
      };
      Program2.prototype.getUniformData = function(program, gl) {
        var uniforms = {};
        var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i2 = 0; i2 < totalUniforms; i2++) {
          var uniformData = gl.getActiveUniform(program, i2);
          var name = uniformData.name.replace(/\[.*?\]$/, "");
          var isArray2 = uniformData.name.match(/\[.*?\]$/);
          var type = mapType(gl, uniformData.type);
          uniforms[name] = {
            type,
            size: uniformData.size,
            isArray: isArray2,
            value: defaultValue(type, uniformData.size)
          };
        }
        return uniforms;
      };
      Object.defineProperty(Program2, "defaultVertexSrc", {
        get: function() {
          return defaultVertex;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Program2, "defaultFragmentSrc", {
        get: function() {
          return defaultFragment;
        },
        enumerable: false,
        configurable: true
      });
      Program2.from = function(vertexSrc, fragmentSrc, name) {
        var key = vertexSrc + fragmentSrc;
        var program = ProgramCache[key];
        if (!program) {
          ProgramCache[key] = program = new Program2(vertexSrc, fragmentSrc, name);
        }
        return program;
      };
      return Program2;
    }();
    var Shader = function() {
      function Shader2(program, uniforms) {
        this.program = program;
        if (uniforms) {
          if (uniforms instanceof UniformGroup) {
            this.uniformGroup = uniforms;
          } else {
            this.uniformGroup = new UniformGroup(uniforms);
          }
        } else {
          this.uniformGroup = new UniformGroup({});
        }
        for (var i2 in program.uniformData) {
          if (this.uniformGroup.uniforms[i2] instanceof Array) {
            this.uniformGroup.uniforms[i2] = new Float32Array(this.uniformGroup.uniforms[i2]);
          }
        }
      }
      Shader2.prototype.checkUniformExists = function(name, group2) {
        if (group2.uniforms[name]) {
          return true;
        }
        for (var i2 in group2.uniforms) {
          var uniform = group2.uniforms[i2];
          if (uniform.group) {
            if (this.checkUniformExists(name, uniform)) {
              return true;
            }
          }
        }
        return false;
      };
      Shader2.prototype.destroy = function() {
        this.uniformGroup = null;
      };
      Object.defineProperty(Shader2.prototype, "uniforms", {
        get: function() {
          return this.uniformGroup.uniforms;
        },
        enumerable: false,
        configurable: true
      });
      Shader2.from = function(vertexSrc, fragmentSrc, uniforms) {
        var program = Program.from(vertexSrc, fragmentSrc);
        return new Shader2(program, uniforms);
      };
      return Shader2;
    }();
    var BLEND = 0;
    var OFFSET = 1;
    var CULLING = 2;
    var DEPTH_TEST = 3;
    var WINDING = 4;
    var State = function() {
      function State2() {
        this.data = 0;
        this.blendMode = BLEND_MODES$1.NORMAL;
        this.polygonOffset = 0;
        this.blend = true;
      }
      Object.defineProperty(State2.prototype, "blend", {
        get: function() {
          return !!(this.data & 1 << BLEND);
        },
        set: function(value2) {
          if (!!(this.data & 1 << BLEND) !== value2) {
            this.data ^= 1 << BLEND;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State2.prototype, "offsets", {
        get: function() {
          return !!(this.data & 1 << OFFSET);
        },
        set: function(value2) {
          if (!!(this.data & 1 << OFFSET) !== value2) {
            this.data ^= 1 << OFFSET;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State2.prototype, "culling", {
        get: function() {
          return !!(this.data & 1 << CULLING);
        },
        set: function(value2) {
          if (!!(this.data & 1 << CULLING) !== value2) {
            this.data ^= 1 << CULLING;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State2.prototype, "depthTest", {
        get: function() {
          return !!(this.data & 1 << DEPTH_TEST);
        },
        set: function(value2) {
          if (!!(this.data & 1 << DEPTH_TEST) !== value2) {
            this.data ^= 1 << DEPTH_TEST;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State2.prototype, "clockwiseFrontFace", {
        get: function() {
          return !!(this.data & 1 << WINDING);
        },
        set: function(value2) {
          if (!!(this.data & 1 << WINDING) !== value2) {
            this.data ^= 1 << WINDING;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State2.prototype, "blendMode", {
        get: function() {
          return this._blendMode;
        },
        set: function(value2) {
          this.blend = value2 !== BLEND_MODES$1.NONE;
          this._blendMode = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(State2.prototype, "polygonOffset", {
        get: function() {
          return this._polygonOffset;
        },
        set: function(value2) {
          this.offsets = !!value2;
          this._polygonOffset = value2;
        },
        enumerable: false,
        configurable: true
      });
      State2.for2d = function() {
        var state = new State2();
        state.depthTest = false;
        state.blend = true;
        return state;
      };
      return State2;
    }();
    var defaultVertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
    var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
    var Filter = function(_super) {
      __extends$h(Filter2, _super);
      function Filter2(vertexSrc, fragmentSrc, uniforms) {
        var _this = this;
        var program = Program.from(vertexSrc || Filter2.defaultVertexSrc, fragmentSrc || Filter2.defaultFragmentSrc);
        _this = _super.call(this, program, uniforms) || this;
        _this.padding = 0;
        _this.resolution = settings.FILTER_RESOLUTION;
        _this.enabled = true;
        _this.autoFit = true;
        _this.legacy = !!_this.program.attributeData.aTextureCoord;
        _this.state = new State();
        return _this;
      }
      Filter2.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {
        filterManager.applyFilter(this, input, output, clearMode);
      };
      Object.defineProperty(Filter2.prototype, "blendMode", {
        get: function() {
          return this.state.blendMode;
        },
        set: function(value2) {
          this.state.blendMode = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Filter2, "defaultVertexSrc", {
        get: function() {
          return defaultVertex$1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Filter2, "defaultFragmentSrc", {
        get: function() {
          return defaultFragment$1;
        },
        enumerable: false,
        configurable: true
      });
      return Filter2;
    }(Shader);
    var vertex$5 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
    var fragment$8 = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
    var tempMat$1 = new Matrix();
    var TextureMatrix = function() {
      function TextureMatrix2(texture, clampMargin) {
        this._texture = texture;
        this.mapCoord = new Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        this._textureID = -1;
        this._updateID = 0;
        this.clampOffset = 0;
        this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
        this.isSimple = false;
      }
      Object.defineProperty(TextureMatrix2.prototype, "texture", {
        get: function() {
          return this._texture;
        },
        set: function(value2) {
          this._texture = value2;
          this._textureID = -1;
        },
        enumerable: false,
        configurable: true
      });
      TextureMatrix2.prototype.multiplyUvs = function(uvs, out) {
        if (out === void 0) {
          out = uvs;
        }
        var mat = this.mapCoord;
        for (var i2 = 0; i2 < uvs.length; i2 += 2) {
          var x2 = uvs[i2];
          var y2 = uvs[i2 + 1];
          out[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
          out[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
        }
        return out;
      };
      TextureMatrix2.prototype.update = function(forceUpdate) {
        var tex = this._texture;
        if (!tex || !tex.valid) {
          return false;
        }
        if (!forceUpdate && this._textureID === tex._updateID) {
          return false;
        }
        this._textureID = tex._updateID;
        this._updateID++;
        var uvs = tex._uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        var orig = tex.orig;
        var trim2 = tex.trim;
        if (trim2) {
          tempMat$1.set(orig.width / trim2.width, 0, 0, orig.height / trim2.height, -trim2.x / trim2.width, -trim2.y / trim2.height);
          this.mapCoord.append(tempMat$1);
        }
        var texBase = tex.baseTexture;
        var frame = this.uClampFrame;
        var margin = this.clampMargin / texBase.resolution;
        var offset2 = this.clampOffset;
        frame[0] = (tex._frame.x + margin + offset2) / texBase.width;
        frame[1] = (tex._frame.y + margin + offset2) / texBase.height;
        frame[2] = (tex._frame.x + tex._frame.width - margin + offset2) / texBase.width;
        frame[3] = (tex._frame.y + tex._frame.height - margin + offset2) / texBase.height;
        this.uClampOffset[0] = offset2 / texBase.realWidth;
        this.uClampOffset[1] = offset2 / texBase.realHeight;
        this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
        return true;
      };
      return TextureMatrix2;
    }();
    var SpriteMaskFilter = function(_super) {
      __extends$h(SpriteMaskFilter2, _super);
      function SpriteMaskFilter2(sprite) {
        var _this = this;
        var maskMatrix = new Matrix();
        _this = _super.call(this, vertex$5, fragment$8) || this;
        sprite.renderable = false;
        _this.maskSprite = sprite;
        _this.maskMatrix = maskMatrix;
        return _this;
      }
      SpriteMaskFilter2.prototype.apply = function(filterManager, input, output, clearMode) {
        var maskSprite = this.maskSprite;
        var tex = maskSprite._texture;
        if (!tex.valid) {
          return;
        }
        if (!tex.uvMatrix) {
          tex.uvMatrix = new TextureMatrix(tex, 0);
        }
        tex.uvMatrix.update();
        this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
        this.uniforms.mask = tex;
        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
        this.uniforms.alpha = maskSprite.worldAlpha;
        this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
        filterManager.applyFilter(this, input, output, clearMode);
      };
      return SpriteMaskFilter2;
    }(Filter);
    var MaskSystem = function(_super) {
      __extends$h(MaskSystem2, _super);
      function MaskSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.enableScissor = false;
        _this.alphaMaskPool = [];
        _this.maskDataPool = [];
        _this.maskStack = [];
        _this.alphaMaskIndex = 0;
        return _this;
      }
      MaskSystem2.prototype.setMaskStack = function(maskStack) {
        this.maskStack = maskStack;
        this.renderer.scissor.setMaskStack(maskStack);
        this.renderer.stencil.setMaskStack(maskStack);
      };
      MaskSystem2.prototype.push = function(target, maskDataOrTarget) {
        var maskData = maskDataOrTarget;
        if (!maskData.isMaskData) {
          var d = this.maskDataPool.pop() || new MaskData();
          d.pooled = true;
          d.maskObject = maskDataOrTarget;
          maskData = d;
        }
        if (maskData.autoDetect) {
          this.detect(maskData);
        }
        maskData.copyCountersOrReset(this.maskStack[this.maskStack.length - 1]);
        maskData._target = target;
        switch (maskData.type) {
          case MASK_TYPES$1.SCISSOR:
            this.maskStack.push(maskData);
            this.renderer.scissor.push(maskData);
            break;
          case MASK_TYPES$1.STENCIL:
            this.maskStack.push(maskData);
            this.renderer.stencil.push(maskData);
            break;
          case MASK_TYPES$1.SPRITE:
            maskData.copyCountersOrReset(null);
            this.pushSpriteMask(maskData);
            this.maskStack.push(maskData);
            break;
        }
      };
      MaskSystem2.prototype.pop = function(target) {
        var maskData = this.maskStack.pop();
        if (!maskData || maskData._target !== target) {
          return;
        }
        switch (maskData.type) {
          case MASK_TYPES$1.SCISSOR:
            this.renderer.scissor.pop();
            break;
          case MASK_TYPES$1.STENCIL:
            this.renderer.stencil.pop(maskData.maskObject);
            break;
          case MASK_TYPES$1.SPRITE:
            this.popSpriteMask();
            break;
        }
        maskData.reset();
        if (maskData.pooled) {
          this.maskDataPool.push(maskData);
        }
      };
      MaskSystem2.prototype.detect = function(maskData) {
        var maskObject = maskData.maskObject;
        if (maskObject.isSprite) {
          maskData.type = MASK_TYPES$1.SPRITE;
          return;
        }
        maskData.type = MASK_TYPES$1.STENCIL;
        if (this.enableScissor && maskObject.isFastRect && maskObject.isFastRect()) {
          var matrix = maskObject.worldTransform;
          var rotX = Math.atan2(matrix.b, matrix.a);
          var rotXY = Math.atan2(matrix.d, matrix.c);
          rotX = Math.round(rotX * (180 / Math.PI) * 100);
          rotXY = Math.round(rotXY * (180 / Math.PI) * 100) - rotX;
          rotX = (rotX % 9e3 + 9e3) % 9e3;
          rotXY = (rotXY % 18e3 + 18e3) % 18e3;
          if (rotX === 0 && rotXY === 9e3) {
            maskData.type = MASK_TYPES$1.SCISSOR;
          }
        }
      };
      MaskSystem2.prototype.pushSpriteMask = function(maskData) {
        var maskObject = maskData.maskObject;
        var target = maskData._target;
        var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
        if (!alphaMaskFilter) {
          alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter(maskObject)];
        }
        alphaMaskFilter[0].resolution = this.renderer.resolution;
        alphaMaskFilter[0].maskSprite = maskObject;
        var stashFilterArea = target.filterArea;
        target.filterArea = maskObject.getBounds(true);
        this.renderer.filter.push(target, alphaMaskFilter);
        target.filterArea = stashFilterArea;
        this.alphaMaskIndex++;
      };
      MaskSystem2.prototype.popSpriteMask = function() {
        this.renderer.filter.pop();
        this.alphaMaskIndex--;
      };
      return MaskSystem2;
    }(System);
    var AbstractMaskSystem = function(_super) {
      __extends$h(AbstractMaskSystem2, _super);
      function AbstractMaskSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.maskStack = [];
        _this.glConst = 0;
        return _this;
      }
      AbstractMaskSystem2.prototype.getStackLength = function() {
        return this.maskStack.length;
      };
      AbstractMaskSystem2.prototype.setMaskStack = function(maskStack) {
        var gl = this.renderer.gl;
        var curStackLen = this.getStackLength();
        this.maskStack = maskStack;
        var newStackLen = this.getStackLength();
        if (newStackLen !== curStackLen) {
          if (newStackLen === 0) {
            gl.disable(this.glConst);
          } else {
            gl.enable(this.glConst);
            this._useCurrent();
          }
        }
      };
      AbstractMaskSystem2.prototype._useCurrent = function() {
      };
      AbstractMaskSystem2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        this.maskStack = null;
      };
      return AbstractMaskSystem2;
    }(System);
    var ScissorSystem = function(_super) {
      __extends$h(ScissorSystem2, _super);
      function ScissorSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.glConst = WebGLRenderingContext.SCISSOR_TEST;
        return _this;
      }
      ScissorSystem2.prototype.getStackLength = function() {
        var maskData = this.maskStack[this.maskStack.length - 1];
        if (maskData) {
          return maskData._scissorCounter;
        }
        return 0;
      };
      ScissorSystem2.prototype.push = function(maskData) {
        var maskObject = maskData.maskObject;
        maskObject.renderable = true;
        var prevData = maskData._scissorRect;
        var bounds = maskObject.getBounds(true);
        var gl = this.renderer.gl;
        maskObject.renderable = false;
        if (prevData) {
          bounds.fit(prevData);
        } else {
          gl.enable(gl.SCISSOR_TEST);
        }
        maskData._scissorCounter++;
        maskData._scissorRect = bounds;
        this._useCurrent();
      };
      ScissorSystem2.prototype.pop = function() {
        var gl = this.renderer.gl;
        if (this.getStackLength() > 0) {
          this._useCurrent();
        } else {
          gl.disable(gl.SCISSOR_TEST);
        }
      };
      ScissorSystem2.prototype._useCurrent = function() {
        var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
        var rt = this.renderer.renderTexture.current;
        var _a2 = this.renderer.projection, transform = _a2.transform, sourceFrame = _a2.sourceFrame, destinationFrame = _a2.destinationFrame;
        var resolution = rt ? rt.resolution : this.renderer.resolution;
        var x2 = (rect.x - sourceFrame.x) * resolution + destinationFrame.x;
        var y2 = (rect.y - sourceFrame.y) * resolution + destinationFrame.y;
        var width2 = rect.width * resolution;
        var height2 = rect.height * resolution;
        if (transform) {
          x2 += transform.tx * resolution;
          y2 += transform.ty * resolution;
        }
        if (!rt) {
          y2 = this.renderer.height - height2 - y2;
        }
        this.renderer.gl.scissor(x2, y2, width2, height2);
      };
      return ScissorSystem2;
    }(AbstractMaskSystem);
    var StencilSystem = function(_super) {
      __extends$h(StencilSystem2, _super);
      function StencilSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.glConst = WebGLRenderingContext.STENCIL_TEST;
        return _this;
      }
      StencilSystem2.prototype.getStackLength = function() {
        var maskData = this.maskStack[this.maskStack.length - 1];
        if (maskData) {
          return maskData._stencilCounter;
        }
        return 0;
      };
      StencilSystem2.prototype.push = function(maskData) {
        var maskObject = maskData.maskObject;
        var gl = this.renderer.gl;
        var prevMaskCount = maskData._stencilCounter;
        if (prevMaskCount === 0) {
          this.renderer.framebuffer.forceStencil();
          gl.enable(gl.STENCIL_TEST);
        }
        maskData._stencilCounter++;
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
        maskObject.renderable = true;
        maskObject.render(this.renderer);
        this.renderer.batch.flush();
        maskObject.renderable = false;
        this._useCurrent();
      };
      StencilSystem2.prototype.pop = function(maskObject) {
        var gl = this.renderer.gl;
        if (this.getStackLength() === 0) {
          gl.disable(gl.STENCIL_TEST);
          gl.clear(gl.STENCIL_BUFFER_BIT);
          gl.clearStencil(0);
        } else {
          gl.colorMask(false, false, false, false);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
          maskObject.renderable = true;
          maskObject.render(this.renderer);
          this.renderer.batch.flush();
          maskObject.renderable = false;
          this._useCurrent();
        }
      };
      StencilSystem2.prototype._useCurrent = function() {
        var gl = this.renderer.gl;
        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.EQUAL, this.getStackLength(), this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      };
      StencilSystem2.prototype._getBitwiseMask = function() {
        return (1 << this.getStackLength()) - 1;
      };
      return StencilSystem2;
    }(AbstractMaskSystem);
    var ProjectionSystem = function(_super) {
      __extends$h(ProjectionSystem2, _super);
      function ProjectionSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.destinationFrame = null;
        _this.sourceFrame = null;
        _this.defaultFrame = null;
        _this.projectionMatrix = new Matrix();
        _this.transform = null;
        return _this;
      }
      ProjectionSystem2.prototype.update = function(destinationFrame, sourceFrame, resolution, root2) {
        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
        this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
        this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root2);
        if (this.transform) {
          this.projectionMatrix.append(this.transform);
        }
        var renderer = this.renderer;
        renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
        renderer.globalUniforms.update();
        if (renderer.shader.shader) {
          renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
        }
      };
      ProjectionSystem2.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root2) {
        var pm = this.projectionMatrix;
        var sign2 = !root2 ? 1 : -1;
        pm.identity();
        pm.a = 1 / sourceFrame.width * 2;
        pm.d = sign2 * (1 / sourceFrame.height * 2);
        pm.tx = -1 - sourceFrame.x * pm.a;
        pm.ty = -sign2 - sourceFrame.y * pm.d;
      };
      ProjectionSystem2.prototype.setTransform = function(_matrix) {
      };
      return ProjectionSystem2;
    }(System);
    var tempRect = new Rectangle();
    var tempRect2 = new Rectangle();
    var viewportFrame = new Rectangle();
    var RenderTextureSystem = function(_super) {
      __extends$h(RenderTextureSystem2, _super);
      function RenderTextureSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.clearColor = renderer._backgroundColorRgba;
        _this.defaultMaskStack = [];
        _this.current = null;
        _this.sourceFrame = new Rectangle();
        _this.destinationFrame = new Rectangle();
        return _this;
      }
      RenderTextureSystem2.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
        if (renderTexture === void 0) {
          renderTexture = null;
        }
        var renderer = this.renderer;
        this.current = renderTexture;
        var baseTexture;
        var framebuffer;
        var resolution;
        if (renderTexture) {
          baseTexture = renderTexture.baseTexture;
          resolution = baseTexture.resolution;
          if (!sourceFrame) {
            tempRect.width = renderTexture.frame.width;
            tempRect.height = renderTexture.frame.height;
            sourceFrame = tempRect;
          }
          if (!destinationFrame) {
            tempRect2.x = renderTexture.frame.x;
            tempRect2.y = renderTexture.frame.y;
            tempRect2.width = sourceFrame.width;
            tempRect2.height = sourceFrame.height;
            destinationFrame = tempRect2;
          }
          framebuffer = baseTexture.framebuffer;
        } else {
          resolution = renderer.resolution;
          if (!sourceFrame) {
            tempRect.width = renderer.screen.width;
            tempRect.height = renderer.screen.height;
            sourceFrame = tempRect;
          }
          if (!destinationFrame) {
            destinationFrame = tempRect;
            destinationFrame.width = sourceFrame.width;
            destinationFrame.height = sourceFrame.height;
          }
        }
        viewportFrame.x = destinationFrame.x * resolution;
        viewportFrame.y = destinationFrame.y * resolution;
        viewportFrame.width = destinationFrame.width * resolution;
        viewportFrame.height = destinationFrame.height * resolution;
        this.renderer.framebuffer.bind(framebuffer, viewportFrame);
        this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
        if (renderTexture) {
          this.renderer.mask.setMaskStack(baseTexture.maskStack);
        } else {
          this.renderer.mask.setMaskStack(this.defaultMaskStack);
        }
        this.sourceFrame.copyFrom(sourceFrame);
        this.destinationFrame.copyFrom(destinationFrame);
      };
      RenderTextureSystem2.prototype.clear = function(clearColor, mask) {
        if (this.current) {
          clearColor = clearColor || this.current.baseTexture.clearColor;
        } else {
          clearColor = clearColor || this.clearColor;
        }
        this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
      };
      RenderTextureSystem2.prototype.resize = function() {
        this.bind(null);
      };
      RenderTextureSystem2.prototype.reset = function() {
        this.bind(null);
      };
      return RenderTextureSystem2;
    }(System);
    var GLProgram = function() {
      function GLProgram2(program, uniformData) {
        this.program = program;
        this.uniformData = uniformData;
        this.uniformGroups = {};
      }
      GLProgram2.prototype.destroy = function() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.program = null;
      };
      return GLProgram2;
    }();
    var UID$4 = 0;
    var defaultSyncData = { textureCount: 0 };
    var ShaderSystem = function(_super) {
      __extends$h(ShaderSystem2, _super);
      function ShaderSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.destroyed = false;
        _this.systemCheck();
        _this.gl = null;
        _this.shader = null;
        _this.program = null;
        _this.cache = {};
        _this.id = UID$4++;
        return _this;
      }
      ShaderSystem2.prototype.systemCheck = function() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
        }
      };
      ShaderSystem2.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.reset();
      };
      ShaderSystem2.prototype.bind = function(shader, dontSync) {
        shader.uniforms.globals = this.renderer.globalUniforms;
        var program = shader.program;
        var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(shader);
        this.shader = shader;
        if (this.program !== program) {
          this.program = program;
          this.gl.useProgram(glProgram.program);
        }
        if (!dontSync) {
          defaultSyncData.textureCount = 0;
          this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
        }
        return glProgram;
      };
      ShaderSystem2.prototype.setUniforms = function(uniforms) {
        var shader = this.shader.program;
        var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
        shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
      };
      ShaderSystem2.prototype.syncUniformGroup = function(group2, syncData) {
        var glProgram = this.getglProgram();
        if (!group2.static || group2.dirtyId !== glProgram.uniformGroups[group2.id]) {
          glProgram.uniformGroups[group2.id] = group2.dirtyId;
          this.syncUniforms(group2, glProgram, syncData);
        }
      };
      ShaderSystem2.prototype.syncUniforms = function(group2, glProgram, syncData) {
        var syncFunc = group2.syncUniforms[this.shader.program.id] || this.createSyncGroups(group2);
        syncFunc(glProgram.uniformData, group2.uniforms, this.renderer, syncData);
      };
      ShaderSystem2.prototype.createSyncGroups = function(group2) {
        var id2 = this.getSignature(group2, this.shader.program.uniformData);
        if (!this.cache[id2]) {
          this.cache[id2] = generateUniformsSync(group2, this.shader.program.uniformData);
        }
        group2.syncUniforms[this.shader.program.id] = this.cache[id2];
        return group2.syncUniforms[this.shader.program.id];
      };
      ShaderSystem2.prototype.getSignature = function(group2, uniformData) {
        var uniforms = group2.uniforms;
        var strings = [];
        for (var i2 in uniforms) {
          strings.push(i2);
          if (uniformData[i2]) {
            strings.push(uniformData[i2].type);
          }
        }
        return strings.join("-");
      };
      ShaderSystem2.prototype.getglProgram = function() {
        if (this.shader) {
          return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
        }
        return null;
      };
      ShaderSystem2.prototype.generateShader = function(shader) {
        var gl = this.gl;
        var program = shader.program;
        var attribMap = {};
        for (var i2 in program.attributeData) {
          attribMap[i2] = program.attributeData[i2].location;
        }
        var shaderProgram = compileProgram(gl, program.vertexSrc, program.fragmentSrc, attribMap);
        var uniformData = {};
        for (var i2 in program.uniformData) {
          var data = program.uniformData[i2];
          uniformData[i2] = {
            location: gl.getUniformLocation(shaderProgram, i2),
            value: defaultValue(data.type, data.size)
          };
        }
        var glProgram = new GLProgram(shaderProgram, uniformData);
        program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
        return glProgram;
      };
      ShaderSystem2.prototype.reset = function() {
        this.program = null;
        this.shader = null;
      };
      ShaderSystem2.prototype.destroy = function() {
        this.destroyed = true;
      };
      return ShaderSystem2;
    }(System);
    function mapWebGLBlendModesToPixi(gl, array) {
      if (array === void 0) {
        array = [];
      }
      array[BLEND_MODES$1.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.ADD] = [gl.ONE, gl.ONE];
      array[BLEND_MODES$1.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.NONE] = [0, 0];
      array[BLEND_MODES$1.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
      array[BLEND_MODES$1.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
      array[BLEND_MODES$1.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
      array[BLEND_MODES$1.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
      array[BLEND_MODES$1.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
      array[BLEND_MODES$1.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
      array[BLEND_MODES$1.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
      array[BLEND_MODES$1.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
      return array;
    }
    var BLEND$1 = 0;
    var OFFSET$1 = 1;
    var CULLING$1 = 2;
    var DEPTH_TEST$1 = 3;
    var WINDING$1 = 4;
    var StateSystem = function(_super) {
      __extends$h(StateSystem2, _super);
      function StateSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.gl = null;
        _this.stateId = 0;
        _this.polygonOffset = 0;
        _this.blendMode = BLEND_MODES$1.NONE;
        _this._blendEq = false;
        _this.map = [];
        _this.map[BLEND$1] = _this.setBlend;
        _this.map[OFFSET$1] = _this.setOffset;
        _this.map[CULLING$1] = _this.setCullFace;
        _this.map[DEPTH_TEST$1] = _this.setDepthTest;
        _this.map[WINDING$1] = _this.setFrontFace;
        _this.checks = [];
        _this.defaultState = new State();
        _this.defaultState.blend = true;
        return _this;
      }
      StateSystem2.prototype.contextChange = function(gl) {
        this.gl = gl;
        this.blendModes = mapWebGLBlendModesToPixi(gl);
        this.set(this.defaultState);
        this.reset();
      };
      StateSystem2.prototype.set = function(state) {
        state = state || this.defaultState;
        if (this.stateId !== state.data) {
          var diff2 = this.stateId ^ state.data;
          var i2 = 0;
          while (diff2) {
            if (diff2 & 1) {
              this.map[i2].call(this, !!(state.data & 1 << i2));
            }
            diff2 = diff2 >> 1;
            i2++;
          }
          this.stateId = state.data;
        }
        for (var i2 = 0; i2 < this.checks.length; i2++) {
          this.checks[i2](this, state);
        }
      };
      StateSystem2.prototype.forceState = function(state) {
        state = state || this.defaultState;
        for (var i2 = 0; i2 < this.map.length; i2++) {
          this.map[i2].call(this, !!(state.data & 1 << i2));
        }
        for (var i2 = 0; i2 < this.checks.length; i2++) {
          this.checks[i2](this, state);
        }
        this.stateId = state.data;
      };
      StateSystem2.prototype.setBlend = function(value2) {
        this.updateCheck(StateSystem2.checkBlendMode, value2);
        this.gl[value2 ? "enable" : "disable"](this.gl.BLEND);
      };
      StateSystem2.prototype.setOffset = function(value2) {
        this.updateCheck(StateSystem2.checkPolygonOffset, value2);
        this.gl[value2 ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      };
      StateSystem2.prototype.setDepthTest = function(value2) {
        this.gl[value2 ? "enable" : "disable"](this.gl.DEPTH_TEST);
      };
      StateSystem2.prototype.setCullFace = function(value2) {
        this.gl[value2 ? "enable" : "disable"](this.gl.CULL_FACE);
      };
      StateSystem2.prototype.setFrontFace = function(value2) {
        this.gl.frontFace(this.gl[value2 ? "CW" : "CCW"]);
      };
      StateSystem2.prototype.setBlendMode = function(value2) {
        if (value2 === this.blendMode) {
          return;
        }
        this.blendMode = value2;
        var mode = this.blendModes[value2];
        var gl = this.gl;
        if (mode.length === 2) {
          gl.blendFunc(mode[0], mode[1]);
        } else {
          gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
          this._blendEq = true;
          gl.blendEquationSeparate(mode[4], mode[5]);
        } else if (this._blendEq) {
          this._blendEq = false;
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
      };
      StateSystem2.prototype.setPolygonOffset = function(value2, scale) {
        this.gl.polygonOffset(value2, scale);
      };
      StateSystem2.prototype.reset = function() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(this.defaultState);
        this._blendEq = true;
        this.blendMode = -1;
        this.setBlendMode(0);
      };
      StateSystem2.prototype.updateCheck = function(func, value2) {
        var index2 = this.checks.indexOf(func);
        if (value2 && index2 === -1) {
          this.checks.push(func);
        } else if (!value2 && index2 !== -1) {
          this.checks.splice(index2, 1);
        }
      };
      StateSystem2.checkBlendMode = function(system, state) {
        system.setBlendMode(state.blendMode);
      };
      StateSystem2.checkPolygonOffset = function(system, state) {
        system.setPolygonOffset(1, state.polygonOffset);
      };
      return StateSystem2;
    }(System);
    var TextureGCSystem = function(_super) {
      __extends$h(TextureGCSystem2, _super);
      function TextureGCSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.count = 0;
        _this.checkCount = 0;
        _this.maxIdle = settings.GC_MAX_IDLE;
        _this.checkCountMax = settings.GC_MAX_CHECK_COUNT;
        _this.mode = settings.GC_MODE;
        return _this;
      }
      TextureGCSystem2.prototype.postrender = function() {
        if (!this.renderer.renderingToScreen) {
          return;
        }
        this.count++;
        if (this.mode === GC_MODES$1.MANUAL) {
          return;
        }
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
          this.checkCount = 0;
          this.run();
        }
      };
      TextureGCSystem2.prototype.run = function() {
        var tm = this.renderer.texture;
        var managedTextures = tm.managedTextures;
        var wasRemoved = false;
        for (var i2 = 0; i2 < managedTextures.length; i2++) {
          var texture = managedTextures[i2];
          if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
            tm.destroyTexture(texture, true);
            managedTextures[i2] = null;
            wasRemoved = true;
          }
        }
        if (wasRemoved) {
          var j = 0;
          for (var i2 = 0; i2 < managedTextures.length; i2++) {
            if (managedTextures[i2] !== null) {
              managedTextures[j++] = managedTextures[i2];
            }
          }
          managedTextures.length = j;
        }
      };
      TextureGCSystem2.prototype.unload = function(displayObject) {
        var tm = this.renderer.texture;
        var texture = displayObject._texture;
        if (texture && !texture.framebuffer) {
          tm.destroyTexture(texture);
        }
        for (var i2 = displayObject.children.length - 1; i2 >= 0; i2--) {
          this.unload(displayObject.children[i2]);
        }
      };
      return TextureGCSystem2;
    }(System);
    var GLTexture = function() {
      function GLTexture2(texture) {
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        this.dirtyId = -1;
        this.dirtyStyleId = -1;
        this.mipmap = false;
        this.wrapMode = 33071;
        this.type = 6408;
        this.internalFormat = 5121;
      }
      return GLTexture2;
    }();
    var TextureSystem = function(_super) {
      __extends$h(TextureSystem2, _super);
      function TextureSystem2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.boundTextures = [];
        _this.currentLocation = -1;
        _this.managedTextures = [];
        _this._unknownBoundTextures = false;
        _this.unknownTexture = new BaseTexture();
        return _this;
      }
      TextureSystem2.prototype.contextChange = function() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.webGLVersion = this.renderer.context.webGLVersion;
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = maxTextures;
        for (var i2 = 0; i2 < maxTextures; i2++) {
          this.boundTextures[i2] = null;
        }
        this.emptyTextures = {};
        var emptyTexture2D = new GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
        for (var i2 = 0; i2 < 6; i2++) {
          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        for (var i2 = 0; i2 < this.boundTextures.length; i2++) {
          this.bind(null, i2);
        }
      };
      TextureSystem2.prototype.bind = function(texture, location) {
        if (location === void 0) {
          location = 0;
        }
        var gl = this.gl;
        if (texture) {
          texture = texture.castToBaseTexture();
          if (texture.parentTextureArray) {
            return;
          }
          if (texture.valid) {
            texture.touched = this.renderer.textureGC.count;
            var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
            if (this.boundTextures[location] !== texture) {
              if (this.currentLocation !== location) {
                this.currentLocation = location;
                gl.activeTexture(gl.TEXTURE0 + location);
              }
              gl.bindTexture(texture.target, glTexture.texture);
            }
            if (glTexture.dirtyId !== texture.dirtyId) {
              if (this.currentLocation !== location) {
                this.currentLocation = location;
                gl.activeTexture(gl.TEXTURE0 + location);
              }
              this.updateTexture(texture);
            }
            this.boundTextures[location] = texture;
          }
        } else {
          if (this.currentLocation !== location) {
            this.currentLocation = location;
            gl.activeTexture(gl.TEXTURE0 + location);
          }
          gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
          this.boundTextures[location] = null;
        }
      };
      TextureSystem2.prototype.reset = function() {
        this._unknownBoundTextures = true;
        this.currentLocation = -1;
        for (var i2 = 0; i2 < this.boundTextures.length; i2++) {
          this.boundTextures[i2] = this.unknownTexture;
        }
      };
      TextureSystem2.prototype.unbind = function(texture) {
        var _a2 = this, gl = _a2.gl, boundTextures = _a2.boundTextures;
        if (this._unknownBoundTextures) {
          this._unknownBoundTextures = false;
          for (var i2 = 0; i2 < boundTextures.length; i2++) {
            if (boundTextures[i2] === this.unknownTexture) {
              this.bind(null, i2);
            }
          }
        }
        for (var i2 = 0; i2 < boundTextures.length; i2++) {
          if (boundTextures[i2] === texture) {
            if (this.currentLocation !== i2) {
              gl.activeTexture(gl.TEXTURE0 + i2);
              this.currentLocation = i2;
            }
            gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
            boundTextures[i2] = null;
          }
        }
      };
      TextureSystem2.prototype.initTexture = function(texture) {
        var glTexture = new GLTexture(this.gl.createTexture());
        glTexture.dirtyId = -1;
        texture._glTextures[this.CONTEXT_UID] = glTexture;
        this.managedTextures.push(texture);
        texture.on("dispose", this.destroyTexture, this);
        return glTexture;
      };
      TextureSystem2.prototype.initTextureType = function(texture, glTexture) {
        glTexture.internalFormat = texture.format;
        glTexture.type = texture.type;
        if (this.webGLVersion !== 2) {
          return;
        }
        var gl = this.renderer.gl;
        if (texture.type === gl.FLOAT && texture.format === gl.RGBA) {
          glTexture.internalFormat = gl.RGBA32F;
        }
        if (texture.type === TYPES$1.HALF_FLOAT) {
          glTexture.type = gl.HALF_FLOAT;
        }
        if (glTexture.type === gl.HALF_FLOAT && texture.format === gl.RGBA) {
          glTexture.internalFormat = gl.RGBA16F;
        }
      };
      TextureSystem2.prototype.updateTexture = function(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
          return;
        }
        var renderer = this.renderer;
        this.initTextureType(texture, glTexture);
        if (texture.resource && texture.resource.upload(renderer, texture, glTexture))
          ;
        else {
          var width2 = texture.realWidth;
          var height2 = texture.realHeight;
          var gl = renderer.gl;
          if (glTexture.width !== width2 || glTexture.height !== height2 || glTexture.dirtyId < 0) {
            glTexture.width = width2;
            glTexture.height = height2;
            gl.texImage2D(texture.target, 0, glTexture.internalFormat, width2, height2, 0, texture.format, glTexture.type, null);
          }
        }
        if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
          this.updateTextureStyle(texture);
        }
        glTexture.dirtyId = texture.dirtyId;
      };
      TextureSystem2.prototype.destroyTexture = function(texture, skipRemove) {
        var gl = this.gl;
        texture = texture.castToBaseTexture();
        if (texture._glTextures[this.CONTEXT_UID]) {
          this.unbind(texture);
          gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
          texture.off("dispose", this.destroyTexture, this);
          delete texture._glTextures[this.CONTEXT_UID];
          if (!skipRemove) {
            var i2 = this.managedTextures.indexOf(texture);
            if (i2 !== -1) {
              removeItems(this.managedTextures, i2, 1);
            }
          }
        }
      };
      TextureSystem2.prototype.updateTextureStyle = function(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
          return;
        }
        if ((texture.mipmap === MIPMAP_MODES$1.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
          glTexture.mipmap = false;
        } else {
          glTexture.mipmap = texture.mipmap >= 1;
        }
        if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
          glTexture.wrapMode = WRAP_MODES$1.CLAMP;
        } else {
          glTexture.wrapMode = texture.wrapMode;
        }
        if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
          ;
        else {
          this.setStyle(texture, glTexture);
        }
        glTexture.dirtyStyleId = texture.dirtyStyleId;
      };
      TextureSystem2.prototype.setStyle = function(texture, glTexture) {
        var gl = this.gl;
        if (glTexture.mipmap) {
          gl.generateMipmap(texture.target);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
        if (glTexture.mipmap) {
          gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES$1.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
          var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
          if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES$1.LINEAR) {
            var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
          }
        } else {
          gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES$1.LINEAR ? gl.LINEAR : gl.NEAREST);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES$1.LINEAR ? gl.LINEAR : gl.NEAREST);
      };
      return TextureSystem2;
    }(System);
    var tempMatrix = new Matrix();
    var AbstractRenderer = function(_super) {
      __extends$h(AbstractRenderer2, _super);
      function AbstractRenderer2(type, options) {
        if (type === void 0) {
          type = RENDERER_TYPE$1.UNKNOWN;
        }
        var _this = _super.call(this) || this;
        options = Object.assign({}, settings.RENDER_OPTIONS, options);
        if (options.roundPixels) {
          settings.ROUND_PIXELS = options.roundPixels;
          deprecation("5.0.0", "Renderer roundPixels option is deprecated, please use PIXI.settings.ROUND_PIXELS", 2);
        }
        _this.options = options;
        _this.type = type;
        _this.screen = new Rectangle(0, 0, options.width, options.height);
        _this.view = options.view || document.createElement("canvas");
        _this.resolution = options.resolution || settings.RESOLUTION;
        _this.transparent = options.transparent;
        _this.autoDensity = options.autoDensity || options.autoResize || false;
        _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        _this.clearBeforeRender = options.clearBeforeRender;
        _this._backgroundColor = 0;
        _this._backgroundColorRgba = [0, 0, 0, 0];
        _this._backgroundColorString = "#000000";
        _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
        _this._lastObjectRendered = null;
        _this.plugins = {};
        return _this;
      }
      AbstractRenderer2.prototype.initPlugins = function(staticMap) {
        for (var o in staticMap) {
          this.plugins[o] = new staticMap[o](this);
        }
      };
      Object.defineProperty(AbstractRenderer2.prototype, "width", {
        get: function() {
          return this.view.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AbstractRenderer2.prototype, "height", {
        get: function() {
          return this.view.height;
        },
        enumerable: false,
        configurable: true
      });
      AbstractRenderer2.prototype.resize = function(screenWidth, screenHeight) {
        this.screen.width = screenWidth;
        this.screen.height = screenHeight;
        this.view.width = screenWidth * this.resolution;
        this.view.height = screenHeight * this.resolution;
        if (this.autoDensity) {
          this.view.style.width = screenWidth + "px";
          this.view.style.height = screenHeight + "px";
        }
        this.emit("resize", screenWidth, screenHeight);
      };
      AbstractRenderer2.prototype.generateTexture = function(displayObject, scaleMode, resolution, region) {
        region = region || displayObject.getLocalBounds(null, true);
        if (region.width === 0) {
          region.width = 1;
        }
        if (region.height === 0) {
          region.height = 1;
        }
        var renderTexture = RenderTexture.create({
          width: region.width | 0,
          height: region.height | 0,
          scaleMode,
          resolution
        });
        tempMatrix.tx = -region.x;
        tempMatrix.ty = -region.y;
        this.render(displayObject, renderTexture, false, tempMatrix, !!displayObject.parent);
        return renderTexture;
      };
      AbstractRenderer2.prototype.destroy = function(removeView) {
        for (var o in this.plugins) {
          this.plugins[o].destroy();
          this.plugins[o] = null;
        }
        if (removeView && this.view.parentNode) {
          this.view.parentNode.removeChild(this.view);
        }
        var thisAny = this;
        thisAny.plugins = null;
        thisAny.type = RENDERER_TYPE$1.UNKNOWN;
        thisAny.view = null;
        thisAny.screen = null;
        thisAny._tempDisplayObjectParent = null;
        thisAny.options = null;
        this._backgroundColorRgba = null;
        this._backgroundColorString = null;
        this._lastObjectRendered = null;
      };
      Object.defineProperty(AbstractRenderer2.prototype, "backgroundColor", {
        get: function() {
          return this._backgroundColor;
        },
        set: function(value2) {
          this._backgroundColor = value2;
          this._backgroundColorString = hex2string(value2);
          hex2rgb(value2, this._backgroundColorRgba);
        },
        enumerable: false,
        configurable: true
      });
      return AbstractRenderer2;
    }(EventEmitter);
    var Renderer = function(_super) {
      __extends$h(Renderer2, _super);
      function Renderer2(options) {
        var _this = _super.call(this, RENDERER_TYPE$1.WEBGL, options) || this;
        options = _this.options;
        _this.gl = null;
        _this.CONTEXT_UID = 0;
        _this.runners = {
          destroy: new Runner("destroy"),
          contextChange: new Runner("contextChange"),
          reset: new Runner("reset"),
          update: new Runner("update"),
          postrender: new Runner("postrender"),
          prerender: new Runner("prerender"),
          resize: new Runner("resize")
        };
        _this.globalUniforms = new UniformGroup({
          projectionMatrix: new Matrix()
        }, true);
        _this.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch");
        _this.initPlugins(Renderer2.__plugins);
        if (options.context) {
          _this.context.initFromContext(options.context);
        } else {
          _this.context.initFromOptions({
            alpha: !!_this.transparent,
            antialias: options.antialias,
            premultipliedAlpha: _this.transparent && _this.transparent !== "notMultiplied",
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer,
            powerPreference: _this.options.powerPreference
          });
        }
        _this.renderingToScreen = true;
        sayHello(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
        _this.resize(_this.options.width, _this.options.height);
        return _this;
      }
      Renderer2.create = function(options) {
        if (isWebGLSupported()) {
          return new Renderer2(options);
        }
        throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
      };
      Renderer2.prototype.addSystem = function(ClassRef, name) {
        if (!name) {
          name = ClassRef.name;
        }
        var system = new ClassRef(this);
        if (this[name]) {
          throw new Error('Whoops! The name "' + name + '" is already in use');
        }
        this[name] = system;
        for (var i2 in this.runners) {
          this.runners[i2].add(system);
        }
        return this;
      };
      Renderer2.prototype.render = function(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
        this.renderingToScreen = !renderTexture;
        this.runners.prerender.emit();
        this.emit("prerender");
        this.projection.transform = transform;
        if (this.context.isLost) {
          return;
        }
        if (!renderTexture) {
          this._lastObjectRendered = displayObject;
        }
        if (!skipUpdateTransform) {
          var cacheParent = displayObject.enableTempParent();
          displayObject.updateTransform();
          displayObject.disableTempParent(cacheParent);
        }
        this.renderTexture.bind(renderTexture);
        this.batch.currentRenderer.start();
        if (clear !== void 0 ? clear : this.clearBeforeRender) {
          this.renderTexture.clear();
        }
        displayObject.render(this);
        this.batch.currentRenderer.flush();
        if (renderTexture) {
          renderTexture.baseTexture.update();
        }
        this.runners.postrender.emit();
        this.projection.transform = null;
        this.emit("postrender");
      };
      Renderer2.prototype.resize = function(screenWidth, screenHeight) {
        _super.prototype.resize.call(this, screenWidth, screenHeight);
        this.runners.resize.emit(screenWidth, screenHeight);
      };
      Renderer2.prototype.reset = function() {
        this.runners.reset.emit();
        return this;
      };
      Renderer2.prototype.clear = function() {
        this.renderTexture.bind();
        this.renderTexture.clear();
      };
      Renderer2.prototype.destroy = function(removeView) {
        this.runners.destroy.emit();
        for (var r2 in this.runners) {
          this.runners[r2].destroy();
        }
        _super.prototype.destroy.call(this, removeView);
        this.gl = null;
      };
      Renderer2.registerPlugin = function(pluginName, ctor2) {
        Renderer2.__plugins = Renderer2.__plugins || {};
        Renderer2.__plugins[pluginName] = ctor2;
      };
      return Renderer2;
    }(AbstractRenderer);
    function autoDetectRenderer(options) {
      return Renderer.create(options);
    }
    var _default = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
    var defaultFilter = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
    var BatchDrawCall = function() {
      function BatchDrawCall2() {
        this.texArray = null;
        this.blend = 0;
        this.type = DRAW_MODES$1.TRIANGLES;
        this.start = 0;
        this.size = 0;
        this.data = null;
      }
      return BatchDrawCall2;
    }();
    var BatchTextureArray = function() {
      function BatchTextureArray2() {
        this.elements = [];
        this.ids = [];
        this.count = 0;
      }
      BatchTextureArray2.prototype.clear = function() {
        for (var i2 = 0; i2 < this.count; i2++) {
          this.elements[i2] = null;
        }
        this.count = 0;
      };
      return BatchTextureArray2;
    }();
    var ViewableBuffer = function() {
      function ViewableBuffer2(size2) {
        this.rawBinaryData = new ArrayBuffer(size2);
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
      }
      Object.defineProperty(ViewableBuffer2.prototype, "int8View", {
        get: function() {
          if (!this._int8View) {
            this._int8View = new Int8Array(this.rawBinaryData);
          }
          return this._int8View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer2.prototype, "uint8View", {
        get: function() {
          if (!this._uint8View) {
            this._uint8View = new Uint8Array(this.rawBinaryData);
          }
          return this._uint8View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer2.prototype, "int16View", {
        get: function() {
          if (!this._int16View) {
            this._int16View = new Int16Array(this.rawBinaryData);
          }
          return this._int16View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer2.prototype, "uint16View", {
        get: function() {
          if (!this._uint16View) {
            this._uint16View = new Uint16Array(this.rawBinaryData);
          }
          return this._uint16View;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ViewableBuffer2.prototype, "int32View", {
        get: function() {
          if (!this._int32View) {
            this._int32View = new Int32Array(this.rawBinaryData);
          }
          return this._int32View;
        },
        enumerable: false,
        configurable: true
      });
      ViewableBuffer2.prototype.view = function(type) {
        return this[type + "View"];
      };
      ViewableBuffer2.prototype.destroy = function() {
        this.rawBinaryData = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this._uint16View = null;
        this._int32View = null;
        this.uint32View = null;
        this.float32View = null;
      };
      ViewableBuffer2.sizeOf = function(type) {
        switch (type) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(type + " isn't a valid view type");
        }
      };
      return ViewableBuffer2;
    }();
    var AbstractBatchRenderer = function(_super) {
      __extends$h(AbstractBatchRenderer2, _super);
      function AbstractBatchRenderer2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.shaderGenerator = null;
        _this.geometryClass = null;
        _this.vertexSize = null;
        _this.state = State.for2d();
        _this.size = settings.SPRITE_BATCH_SIZE * 4;
        _this._vertexCount = 0;
        _this._indexCount = 0;
        _this._bufferedElements = [];
        _this._bufferedTextures = [];
        _this._bufferSize = 0;
        _this._shader = null;
        _this._packedGeometries = [];
        _this._packedGeometryPoolSize = 2;
        _this._flushId = 0;
        _this._aBuffers = {};
        _this._iBuffers = {};
        _this.MAX_TEXTURES = 1;
        _this.renderer.on("prerender", _this.onPrerender, _this);
        renderer.runners.contextChange.add(_this);
        _this._dcIndex = 0;
        _this._aIndex = 0;
        _this._iIndex = 0;
        _this._attributeBuffer = null;
        _this._indexBuffer = null;
        _this._tempBoundTextures = [];
        return _this;
      }
      AbstractBatchRenderer2.prototype.contextChange = function() {
        var gl = this.renderer.gl;
        if (settings.PREFER_ENV === ENV$1.WEBGL_LEGACY) {
          this.MAX_TEXTURES = 1;
        } else {
          this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);
          this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
        }
        this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
        for (var i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {
          this._packedGeometries[i2] = new this.geometryClass();
        }
        this.initFlushBuffers();
      };
      AbstractBatchRenderer2.prototype.initFlushBuffers = function() {
        var _drawCallPool = AbstractBatchRenderer2._drawCallPool, _textureArrayPool = AbstractBatchRenderer2._textureArrayPool;
        var MAX_SPRITES = this.size / 4;
        var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
        while (_drawCallPool.length < MAX_SPRITES) {
          _drawCallPool.push(new BatchDrawCall());
        }
        while (_textureArrayPool.length < MAX_TA) {
          _textureArrayPool.push(new BatchTextureArray());
        }
        for (var i2 = 0; i2 < this.MAX_TEXTURES; i2++) {
          this._tempBoundTextures[i2] = null;
        }
      };
      AbstractBatchRenderer2.prototype.onPrerender = function() {
        this._flushId = 0;
      };
      AbstractBatchRenderer2.prototype.render = function(element) {
        if (!element._texture.valid) {
          return;
        }
        if (this._vertexCount + element.vertexData.length / 2 > this.size) {
          this.flush();
        }
        this._vertexCount += element.vertexData.length / 2;
        this._indexCount += element.indices.length;
        this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
        this._bufferedElements[this._bufferSize++] = element;
      };
      AbstractBatchRenderer2.prototype.buildTexturesAndDrawCalls = function() {
        var _a2 = this, textures = _a2._bufferedTextures, MAX_TEXTURES = _a2.MAX_TEXTURES;
        var textureArrays = AbstractBatchRenderer2._textureArrayPool;
        var batch = this.renderer.batch;
        var boundTextures = this._tempBoundTextures;
        var touch = this.renderer.textureGC.count;
        var TICK = ++BaseTexture._globalBatch;
        var countTexArrays = 0;
        var texArray = textureArrays[0];
        var start = 0;
        batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
        for (var i2 = 0; i2 < this._bufferSize; ++i2) {
          var tex = textures[i2];
          textures[i2] = null;
          if (tex._batchEnabled === TICK) {
            continue;
          }
          if (texArray.count >= MAX_TEXTURES) {
            batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
            this.buildDrawCalls(texArray, start, i2);
            start = i2;
            texArray = textureArrays[++countTexArrays];
            ++TICK;
          }
          tex._batchEnabled = TICK;
          tex.touched = touch;
          texArray.elements[texArray.count++] = tex;
        }
        if (texArray.count > 0) {
          batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
          this.buildDrawCalls(texArray, start, this._bufferSize);
          ++countTexArrays;
          ++TICK;
        }
        for (var i2 = 0; i2 < boundTextures.length; i2++) {
          boundTextures[i2] = null;
        }
        BaseTexture._globalBatch = TICK;
      };
      AbstractBatchRenderer2.prototype.buildDrawCalls = function(texArray, start, finish) {
        var _a2 = this, elements = _a2._bufferedElements, _attributeBuffer = _a2._attributeBuffer, _indexBuffer = _a2._indexBuffer, vertexSize = _a2.vertexSize;
        var drawCalls = AbstractBatchRenderer2._drawCallPool;
        var dcIndex = this._dcIndex;
        var aIndex = this._aIndex;
        var iIndex = this._iIndex;
        var drawCall = drawCalls[dcIndex];
        drawCall.start = this._iIndex;
        drawCall.texArray = texArray;
        for (var i2 = start; i2 < finish; ++i2) {
          var sprite = elements[i2];
          var tex = sprite._texture.baseTexture;
          var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
          elements[i2] = null;
          if (start < i2 && drawCall.blend !== spriteBlendMode) {
            drawCall.size = iIndex - drawCall.start;
            start = i2;
            drawCall = drawCalls[++dcIndex];
            drawCall.texArray = texArray;
            drawCall.start = iIndex;
          }
          this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
          aIndex += sprite.vertexData.length / 2 * vertexSize;
          iIndex += sprite.indices.length;
          drawCall.blend = spriteBlendMode;
        }
        if (start < finish) {
          drawCall.size = iIndex - drawCall.start;
          ++dcIndex;
        }
        this._dcIndex = dcIndex;
        this._aIndex = aIndex;
        this._iIndex = iIndex;
      };
      AbstractBatchRenderer2.prototype.bindAndClearTexArray = function(texArray) {
        var textureSystem = this.renderer.texture;
        for (var j = 0; j < texArray.count; j++) {
          textureSystem.bind(texArray.elements[j], texArray.ids[j]);
          texArray.elements[j] = null;
        }
        texArray.count = 0;
      };
      AbstractBatchRenderer2.prototype.updateGeometry = function() {
        var _a2 = this, packedGeometries = _a2._packedGeometries, attributeBuffer = _a2._attributeBuffer, indexBuffer = _a2._indexBuffer;
        if (!settings.CAN_UPLOAD_SAME_BUFFER) {
          if (this._packedGeometryPoolSize <= this._flushId) {
            this._packedGeometryPoolSize++;
            packedGeometries[this._flushId] = new this.geometryClass();
          }
          packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
          packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
          this.renderer.geometry.bind(packedGeometries[this._flushId]);
          this.renderer.geometry.updateBuffers();
          this._flushId++;
        } else {
          packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
          packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
          this.renderer.geometry.updateBuffers();
        }
      };
      AbstractBatchRenderer2.prototype.drawBatches = function() {
        var dcCount = this._dcIndex;
        var _a2 = this.renderer, gl = _a2.gl, stateSystem = _a2.state;
        var drawCalls = AbstractBatchRenderer2._drawCallPool;
        var curTexArray = null;
        for (var i2 = 0; i2 < dcCount; i2++) {
          var _b = drawCalls[i2], texArray = _b.texArray, type = _b.type, size2 = _b.size, start = _b.start, blend = _b.blend;
          if (curTexArray !== texArray) {
            curTexArray = texArray;
            this.bindAndClearTexArray(texArray);
          }
          this.state.blendMode = blend;
          stateSystem.set(this.state);
          gl.drawElements(type, size2, gl.UNSIGNED_SHORT, start * 2);
        }
      };
      AbstractBatchRenderer2.prototype.flush = function() {
        if (this._vertexCount === 0) {
          return;
        }
        this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
        this._indexBuffer = this.getIndexBuffer(this._indexCount);
        this._aIndex = 0;
        this._iIndex = 0;
        this._dcIndex = 0;
        this.buildTexturesAndDrawCalls();
        this.updateGeometry();
        this.drawBatches();
        this._bufferSize = 0;
        this._vertexCount = 0;
        this._indexCount = 0;
      };
      AbstractBatchRenderer2.prototype.start = function() {
        this.renderer.state.set(this.state);
        this.renderer.shader.bind(this._shader);
        if (settings.CAN_UPLOAD_SAME_BUFFER) {
          this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
        }
      };
      AbstractBatchRenderer2.prototype.stop = function() {
        this.flush();
      };
      AbstractBatchRenderer2.prototype.destroy = function() {
        for (var i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {
          if (this._packedGeometries[i2]) {
            this._packedGeometries[i2].destroy();
          }
        }
        this.renderer.off("prerender", this.onPrerender, this);
        this._aBuffers = null;
        this._iBuffers = null;
        this._packedGeometries = null;
        this._attributeBuffer = null;
        this._indexBuffer = null;
        if (this._shader) {
          this._shader.destroy();
          this._shader = null;
        }
        _super.prototype.destroy.call(this);
      };
      AbstractBatchRenderer2.prototype.getAttributeBuffer = function(size2) {
        var roundedP2 = nextPow2(Math.ceil(size2 / 8));
        var roundedSizeIndex = log2(roundedP2);
        var roundedSize = roundedP2 * 8;
        if (this._aBuffers.length <= roundedSizeIndex) {
          this._iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this._aBuffers[roundedSize];
        if (!buffer) {
          this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
        }
        return buffer;
      };
      AbstractBatchRenderer2.prototype.getIndexBuffer = function(size2) {
        var roundedP2 = nextPow2(Math.ceil(size2 / 12));
        var roundedSizeIndex = log2(roundedP2);
        var roundedSize = roundedP2 * 12;
        if (this._iBuffers.length <= roundedSizeIndex) {
          this._iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this._iBuffers[roundedSizeIndex];
        if (!buffer) {
          this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
        }
        return buffer;
      };
      AbstractBatchRenderer2.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
        var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
        var packedVertices = aIndex / this.vertexSize;
        var uvs = element.uvs;
        var indicies = element.indices;
        var vertexData = element.vertexData;
        var textureId = element._texture.baseTexture._batchLocation;
        var alpha = Math.min(element.worldAlpha, 1);
        var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
        for (var i2 = 0; i2 < vertexData.length; i2 += 2) {
          float32View[aIndex++] = vertexData[i2];
          float32View[aIndex++] = vertexData[i2 + 1];
          float32View[aIndex++] = uvs[i2];
          float32View[aIndex++] = uvs[i2 + 1];
          uint32View[aIndex++] = argb;
          float32View[aIndex++] = textureId;
        }
        for (var i2 = 0; i2 < indicies.length; i2++) {
          indexBuffer[iIndex++] = packedVertices + indicies[i2];
        }
      };
      AbstractBatchRenderer2._drawCallPool = [];
      AbstractBatchRenderer2._textureArrayPool = [];
      return AbstractBatchRenderer2;
    }(ObjectRenderer);
    var BatchShaderGenerator = function() {
      function BatchShaderGenerator2(vertexSrc, fragTemplate2) {
        this.vertexSrc = vertexSrc;
        this.fragTemplate = fragTemplate2;
        this.programCache = {};
        this.defaultGroupCache = {};
        if (fragTemplate2.indexOf("%count%") < 0) {
          throw new Error('Fragment template must contain "%count%".');
        }
        if (fragTemplate2.indexOf("%forloop%") < 0) {
          throw new Error('Fragment template must contain "%forloop%".');
        }
      }
      BatchShaderGenerator2.prototype.generateShader = function(maxTextures) {
        if (!this.programCache[maxTextures]) {
          var sampleValues = new Int32Array(maxTextures);
          for (var i2 = 0; i2 < maxTextures; i2++) {
            sampleValues[i2] = i2;
          }
          this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
          var fragmentSrc = this.fragTemplate;
          fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
          fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
          this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
        }
        var uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: this.defaultGroupCache[maxTextures]
        };
        return new Shader(this.programCache[maxTextures], uniforms);
      };
      BatchShaderGenerator2.prototype.generateSampleSrc = function(maxTextures) {
        var src2 = "";
        src2 += "\n";
        src2 += "\n";
        for (var i2 = 0; i2 < maxTextures; i2++) {
          if (i2 > 0) {
            src2 += "\nelse ";
          }
          if (i2 < maxTextures - 1) {
            src2 += "if(vTextureId < " + i2 + ".5)";
          }
          src2 += "\n{";
          src2 += "\n	color = texture2D(uSamplers[" + i2 + "], vTextureCoord);";
          src2 += "\n}";
        }
        src2 += "\n";
        src2 += "\n";
        return src2;
      };
      return BatchShaderGenerator2;
    }();
    var BatchGeometry = function(_super) {
      __extends$h(BatchGeometry2, _super);
      function BatchGeometry2(_static) {
        if (_static === void 0) {
          _static = false;
        }
        var _this = _super.call(this) || this;
        _this._buffer = new Buffer$1(null, _static, false);
        _this._indexBuffer = new Buffer$1(null, _static, true);
        _this.addAttribute("aVertexPosition", _this._buffer, 2, false, TYPES$1.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, TYPES$1.FLOAT).addAttribute("aColor", _this._buffer, 4, true, TYPES$1.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, TYPES$1.FLOAT).addIndex(_this._indexBuffer);
        return _this;
      }
      return BatchGeometry2;
    }(Geometry);
    var defaultVertex$2 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
    var defaultFragment$2 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
    var BatchPluginFactory = function() {
      function BatchPluginFactory2() {
      }
      BatchPluginFactory2.create = function(options) {
        var _a2 = Object.assign({
          vertex: defaultVertex$2,
          fragment: defaultFragment$2,
          geometryClass: BatchGeometry,
          vertexSize: 6
        }, options), vertex2 = _a2.vertex, fragment2 = _a2.fragment, vertexSize = _a2.vertexSize, geometryClass = _a2.geometryClass;
        return function(_super) {
          __extends$h(BatchPlugin, _super);
          function BatchPlugin(renderer) {
            var _this = _super.call(this, renderer) || this;
            _this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
            _this.geometryClass = geometryClass;
            _this.vertexSize = vertexSize;
            return _this;
          }
          return BatchPlugin;
        }(AbstractBatchRenderer);
      };
      Object.defineProperty(BatchPluginFactory2, "defaultVertexSrc", {
        get: function() {
          return defaultVertex$2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BatchPluginFactory2, "defaultFragmentTemplate", {
        get: function() {
          return defaultFragment$2;
        },
        enumerable: false,
        configurable: true
      });
      return BatchPluginFactory2;
    }();
    var BatchRenderer = BatchPluginFactory.create();
    /*!
     * @pixi/app - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/app is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var Application = function() {
      function Application2(options) {
        var _this = this;
        options = Object.assign({
          forceCanvas: false
        }, options);
        this.renderer = autoDetectRenderer(options);
        this.stage = new Container();
        Application2._plugins.forEach(function(plugin) {
          plugin.init.call(_this, options);
        });
      }
      Application2.registerPlugin = function(plugin) {
        Application2._plugins.push(plugin);
      };
      Application2.prototype.render = function() {
        this.renderer.render(this.stage);
      };
      Object.defineProperty(Application2.prototype, "view", {
        get: function() {
          return this.renderer.view;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Application2.prototype, "screen", {
        get: function() {
          return this.renderer.screen;
        },
        enumerable: false,
        configurable: true
      });
      Application2.prototype.destroy = function(removeView, stageOptions) {
        var _this = this;
        var plugins = Application2._plugins.slice(0);
        plugins.reverse();
        plugins.forEach(function(plugin) {
          plugin.destroy.call(_this);
        });
        this.stage.destroy(stageOptions);
        this.stage = null;
        this.renderer.destroy(removeView);
        this.renderer = null;
      };
      return Application2;
    }();
    Application._plugins = [];
    var ResizePlugin = function() {
      function ResizePlugin2() {
      }
      ResizePlugin2.init = function(options) {
        var _this = this;
        Object.defineProperty(this, "resizeTo", {
          set: function(dom) {
            window.removeEventListener("resize", this.queueResize);
            this._resizeTo = dom;
            if (dom) {
              window.addEventListener("resize", this.queueResize);
              this.resize();
            }
          },
          get: function() {
            return this._resizeTo;
          }
        });
        this.queueResize = function() {
          if (!_this._resizeTo) {
            return;
          }
          _this.cancelResize();
          _this._resizeId = requestAnimationFrame(function() {
            return _this.resize();
          });
        };
        this.cancelResize = function() {
          if (_this._resizeId) {
            cancelAnimationFrame(_this._resizeId);
            _this._resizeId = null;
          }
        };
        this.resize = function() {
          if (!_this._resizeTo) {
            return;
          }
          _this.cancelResize();
          var width2;
          var height2;
          if (_this._resizeTo === window) {
            width2 = window.innerWidth;
            height2 = window.innerHeight;
          } else {
            var _a2 = _this._resizeTo, clientWidth = _a2.clientWidth, clientHeight = _a2.clientHeight;
            width2 = clientWidth;
            height2 = clientHeight;
          }
          _this.renderer.resize(width2, height2);
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
      };
      ResizePlugin2.destroy = function() {
        window.removeEventListener("resize", this.queueResize);
        this.cancelResize();
        this.cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
      };
      return ResizePlugin2;
    }();
    Application.registerPlugin(ResizePlugin);
    /*!
     * @pixi/extract - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/extract is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var TEMP_RECT = new Rectangle();
    var BYTES_PER_PIXEL = 4;
    var Extract = function() {
      function Extract2(renderer) {
        this.renderer = renderer;
        renderer.extract = this;
      }
      Extract2.prototype.image = function(target, format2, quality) {
        var image = new Image();
        image.src = this.base64(target, format2, quality);
        return image;
      };
      Extract2.prototype.base64 = function(target, format2, quality) {
        return this.canvas(target).toDataURL(format2, quality);
      };
      Extract2.prototype.canvas = function(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var flipY = false;
        var renderTexture;
        var generated = false;
        if (target) {
          if (target instanceof RenderTexture) {
            renderTexture = target;
          } else {
            renderTexture = this.renderer.generateTexture(target);
            generated = true;
          }
        }
        if (renderTexture) {
          resolution = renderTexture.baseTexture.resolution;
          frame = renderTexture.frame;
          flipY = false;
          renderer.renderTexture.bind(renderTexture);
        } else {
          resolution = this.renderer.resolution;
          flipY = true;
          frame = TEMP_RECT;
          frame.width = this.renderer.width;
          frame.height = this.renderer.height;
          renderer.renderTexture.bind(null);
        }
        var width2 = Math.floor(frame.width * resolution + 1e-4);
        var height2 = Math.floor(frame.height * resolution + 1e-4);
        var canvasBuffer = new CanvasRenderTarget(width2, height2, 1);
        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width2 * height2);
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width2, height2, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        var canvasData = canvasBuffer.context.getImageData(0, 0, width2, height2);
        Extract2.arrayPostDivide(webglPixels, canvasData.data);
        canvasBuffer.context.putImageData(canvasData, 0, 0);
        if (flipY) {
          var target_1 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
          target_1.context.scale(1, -1);
          target_1.context.drawImage(canvasBuffer.canvas, 0, -height2);
          canvasBuffer.destroy();
          canvasBuffer = target_1;
        }
        if (generated) {
          renderTexture.destroy(true);
        }
        return canvasBuffer.canvas;
      };
      Extract2.prototype.pixels = function(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var renderTexture;
        var generated = false;
        if (target) {
          if (target instanceof RenderTexture) {
            renderTexture = target;
          } else {
            renderTexture = this.renderer.generateTexture(target);
            generated = true;
          }
        }
        if (renderTexture) {
          resolution = renderTexture.baseTexture.resolution;
          frame = renderTexture.frame;
          renderer.renderTexture.bind(renderTexture);
        } else {
          resolution = renderer.resolution;
          frame = TEMP_RECT;
          frame.width = renderer.width;
          frame.height = renderer.height;
          renderer.renderTexture.bind(null);
        }
        var width2 = frame.width * resolution;
        var height2 = frame.height * resolution;
        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width2 * height2);
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width2, height2, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        if (generated) {
          renderTexture.destroy(true);
        }
        Extract2.arrayPostDivide(webglPixels, webglPixels);
        return webglPixels;
      };
      Extract2.prototype.destroy = function() {
        this.renderer.extract = null;
        this.renderer = null;
      };
      Extract2.arrayPostDivide = function(pixels, out) {
        for (var i2 = 0; i2 < pixels.length; i2 += 4) {
          var alpha = out[i2 + 3] = pixels[i2 + 3];
          if (alpha !== 0) {
            out[i2] = Math.round(Math.min(pixels[i2] * 255 / alpha, 255));
            out[i2 + 1] = Math.round(Math.min(pixels[i2 + 1] * 255 / alpha, 255));
            out[i2 + 2] = Math.round(Math.min(pixels[i2 + 2] * 255 / alpha, 255));
          } else {
            out[i2] = pixels[i2];
            out[i2 + 1] = pixels[i2 + 1];
            out[i2 + 2] = pixels[i2 + 2];
          }
        }
      };
      return Extract2;
    }();
    var src = (str, opts = {}) => {
      if (!str)
        return void 0;
      const o = {
        key: [
          "source",
          "protocol",
          "authority",
          "userInfo",
          "user",
          "password",
          "host",
          "port",
          "relative",
          "path",
          "directory",
          "file",
          "query",
          "anchor"
        ],
        q: {
          name: "queryKey",
          parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
          strict: /^(?:([^:/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?))?((((?:[^?#/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
          loose: /^(?:(?![^:@]+:[^:@/]*@)([^:/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#/]*\.[^?#/.]+(?:[?#]|$)))*\/?)?([^?#/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
      };
      const m2 = o.parser[opts.strictMode ? "strict" : "loose"].exec(str);
      const uri = {};
      let i2 = 14;
      while (i2--)
        uri[o.key[i2]] = m2[i2] || "";
      uri[o.q.name] = {};
      uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
        if ($1)
          uri[o.q.name][$1] = $2;
      });
      return uri;
    };
    class MiniSignalBinding {
      constructor(fn, once2 = false, thisArg) {
        this._fn = fn;
        this._once = once2;
        this._thisArg = thisArg;
        this._next = this._prev = this._owner = null;
      }
      detach() {
        if (this._owner === null)
          return false;
        this._owner.detach(this);
        return true;
      }
    }
    function _addMiniSignalBinding(self2, node) {
      if (!self2._head) {
        self2._head = node;
        self2._tail = node;
      } else {
        self2._tail._next = node;
        node._prev = self2._tail;
        self2._tail = node;
      }
      node._owner = self2;
      return node;
    }
    class MiniSignal {
      constructor() {
        this._head = this._tail = void 0;
      }
      handlers(exists = false) {
        let node = this._head;
        if (exists)
          return !!node;
        const ee2 = [];
        while (node) {
          ee2.push(node);
          node = node._next;
        }
        return ee2;
      }
      has(node) {
        if (!(node instanceof MiniSignalBinding)) {
          throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");
        }
        return node._owner === this;
      }
      dispatch() {
        let node = this._head;
        if (!node)
          return false;
        while (node) {
          if (node._once)
            this.detach(node);
          node._fn.apply(node._thisArg, arguments);
          node = node._next;
        }
        return true;
      }
      add(fn, thisArg = null) {
        if (typeof fn !== "function") {
          throw new Error("MiniSignal#add(): First arg must be a Function.");
        }
        return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));
      }
      once(fn, thisArg = null) {
        if (typeof fn !== "function") {
          throw new Error("MiniSignal#once(): First arg must be a Function.");
        }
        return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));
      }
      detach(node) {
        if (!(node instanceof MiniSignalBinding)) {
          throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");
        }
        if (node._owner !== this)
          return this;
        if (node._prev)
          node._prev._next = node._next;
        if (node._next)
          node._next._prev = node._prev;
        if (node === this._head) {
          this._head = node._next;
          if (node._next === null) {
            this._tail = null;
          }
        } else if (node === this._tail) {
          this._tail = node._prev;
          this._tail._next = null;
        }
        node._owner = null;
        return this;
      }
      detachAll() {
        let node = this._head;
        if (!node)
          return this;
        this._head = this._tail = null;
        while (node) {
          node._owner = null;
          node = node._next;
        }
        return this;
      }
    }
    /*!
     * resource-loader - v3.0.1
     * https://github.com/pixijs/pixi-sound
     * Compiled Tue, 02 Jul 2019 14:06:18 UTC
     *
     * resource-loader is licensed under the MIT license.
     * http://www.opensource.org/licenses/mit-license
     */
    function _noop() {
    }
    function eachSeries(array, iterator, callback, deferNext) {
      var i2 = 0;
      var len = array.length;
      (function next(err) {
        if (err || i2 === len) {
          if (callback) {
            callback(err);
          }
          return;
        }
        if (deferNext) {
          setTimeout(function() {
            iterator(array[i2++], next);
          }, 1);
        } else {
          iterator(array[i2++], next);
        }
      })();
    }
    function onlyOnce(fn) {
      return function onceWrapper() {
        if (fn === null) {
          throw new Error("Callback was already called.");
        }
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    function queue(worker, concurrency) {
      if (concurrency == null) {
        concurrency = 1;
      } else if (concurrency === 0) {
        throw new Error("Concurrency must not be zero");
      }
      var workers = 0;
      var q2 = {
        _tasks: [],
        concurrency,
        saturated: _noop,
        unsaturated: _noop,
        buffer: concurrency / 4,
        empty: _noop,
        drain: _noop,
        error: _noop,
        started: false,
        paused: false,
        push: function push2(data, callback) {
          _insert(data, false, callback);
        },
        kill: function kill() {
          workers = 0;
          q2.drain = _noop;
          q2.started = false;
          q2._tasks = [];
        },
        unshift: function unshift(data, callback) {
          _insert(data, true, callback);
        },
        process: function process() {
          while (!q2.paused && workers < q2.concurrency && q2._tasks.length) {
            var task = q2._tasks.shift();
            if (q2._tasks.length === 0) {
              q2.empty();
            }
            workers += 1;
            if (workers === q2.concurrency) {
              q2.saturated();
            }
            worker(task.data, onlyOnce(_next(task)));
          }
        },
        length: function length() {
          return q2._tasks.length;
        },
        running: function running() {
          return workers;
        },
        idle: function idle() {
          return q2._tasks.length + workers === 0;
        },
        pause: function pause() {
          if (q2.paused === true) {
            return;
          }
          q2.paused = true;
        },
        resume: function resume() {
          if (q2.paused === false) {
            return;
          }
          q2.paused = false;
          for (var w2 = 1; w2 <= q2.concurrency; w2++) {
            q2.process();
          }
        }
      };
      function _insert(data, insertAtFront, callback) {
        if (callback != null && typeof callback !== "function") {
          throw new Error("task callback must be a function");
        }
        q2.started = true;
        if (data == null && q2.idle()) {
          setTimeout(function() {
            return q2.drain();
          }, 1);
          return;
        }
        var item = {
          data,
          callback: typeof callback === "function" ? callback : _noop
        };
        if (insertAtFront) {
          q2._tasks.unshift(item);
        } else {
          q2._tasks.push(item);
        }
        setTimeout(function() {
          return q2.process();
        }, 1);
      }
      function _next(task) {
        return function next() {
          workers -= 1;
          task.callback.apply(task, arguments);
          if (arguments[0] != null) {
            q2.error(arguments[0], task.data);
          }
          if (workers <= q2.concurrency - q2.buffer) {
            q2.unsaturated();
          }
          if (q2.idle()) {
            q2.drain();
          }
          q2.process();
        };
      }
      return q2;
    }
    var cache$1 = {};
    function caching(resource, next) {
      var _this = this;
      if (cache$1[resource.url]) {
        resource.data = cache$1[resource.url];
        resource.complete();
      } else {
        resource.onComplete.once(function() {
          return cache$1[_this.url] = _this.data;
        });
      }
      next();
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var useXdr = !!(window.XDomainRequest && !("withCredentials" in new XMLHttpRequest()));
    var tempAnchor = null;
    var STATUS_NONE = 0;
    var STATUS_OK = 200;
    var STATUS_EMPTY = 204;
    var STATUS_IE_BUG_EMPTY = 1223;
    var STATUS_TYPE_OK = 2;
    function _noop$1() {
    }
    var Resource = /* @__PURE__ */ function() {
      Resource2.setExtensionLoadType = function setExtensionLoadType(extname, loadType) {
        setExtMap(Resource2._loadTypeMap, extname, loadType);
      };
      Resource2.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) {
        setExtMap(Resource2._xhrTypeMap, extname, xhrType);
      };
      function Resource2(name, url2, options) {
        if (typeof name !== "string" || typeof url2 !== "string") {
          throw new Error("Both name and url are required for constructing a resource.");
        }
        options = options || {};
        this._flags = 0;
        this._setFlag(Resource2.STATUS_FLAGS.DATA_URL, url2.indexOf("data:") === 0);
        this.name = name;
        this.url = url2;
        this.extension = this._getExtension();
        this.data = null;
        this.crossOrigin = options.crossOrigin === true ? "anonymous" : options.crossOrigin;
        this.timeout = options.timeout || 0;
        this.loadType = options.loadType || this._determineLoadType();
        this.xhrType = options.xhrType;
        this.metadata = options.metadata || {};
        this.error = null;
        this.xhr = null;
        this.children = [];
        this.type = Resource2.TYPE.UNKNOWN;
        this.progressChunk = 0;
        this._dequeue = _noop$1;
        this._onLoadBinding = null;
        this._elementTimer = 0;
        this._boundComplete = this.complete.bind(this);
        this._boundOnError = this._onError.bind(this);
        this._boundOnProgress = this._onProgress.bind(this);
        this._boundOnTimeout = this._onTimeout.bind(this);
        this._boundXhrOnError = this._xhrOnError.bind(this);
        this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);
        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
        this.onStart = new MiniSignal();
        this.onProgress = new MiniSignal();
        this.onComplete = new MiniSignal();
        this.onAfterMiddleware = new MiniSignal();
      }
      var _proto = Resource2.prototype;
      _proto.complete = function complete() {
        this._clearEvents();
        this._finish();
      };
      _proto.abort = function abort(message) {
        if (this.error) {
          return;
        }
        this.error = new Error(message);
        this._clearEvents();
        if (this.xhr) {
          this.xhr.abort();
        } else if (this.xdr) {
          this.xdr.abort();
        } else if (this.data) {
          if (this.data.src) {
            this.data.src = Resource2.EMPTY_GIF;
          } else {
            while (this.data.firstChild) {
              this.data.removeChild(this.data.firstChild);
            }
          }
        }
        this._finish();
      };
      _proto.load = function load(cb2) {
        var _this = this;
        if (this.isLoading) {
          return;
        }
        if (this.isComplete) {
          if (cb2) {
            setTimeout(function() {
              return cb2(_this);
            }, 1);
          }
          return;
        } else if (cb2) {
          this.onComplete.once(cb2);
        }
        this._setFlag(Resource2.STATUS_FLAGS.LOADING, true);
        this.onStart.dispatch(this);
        if (this.crossOrigin === false || typeof this.crossOrigin !== "string") {
          this.crossOrigin = this._determineCrossOrigin(this.url);
        }
        switch (this.loadType) {
          case Resource2.LOAD_TYPE.IMAGE:
            this.type = Resource2.TYPE.IMAGE;
            this._loadElement("image");
            break;
          case Resource2.LOAD_TYPE.AUDIO:
            this.type = Resource2.TYPE.AUDIO;
            this._loadSourceElement("audio");
            break;
          case Resource2.LOAD_TYPE.VIDEO:
            this.type = Resource2.TYPE.VIDEO;
            this._loadSourceElement("video");
            break;
          case Resource2.LOAD_TYPE.XHR:
          default:
            if (useXdr && this.crossOrigin) {
              this._loadXdr();
            } else {
              this._loadXhr();
            }
            break;
        }
      };
      _proto._hasFlag = function _hasFlag(flag) {
        return (this._flags & flag) !== 0;
      };
      _proto._setFlag = function _setFlag(flag, value2) {
        this._flags = value2 ? this._flags | flag : this._flags & ~flag;
      };
      _proto._clearEvents = function _clearEvents() {
        clearTimeout(this._elementTimer);
        if (this.data && this.data.removeEventListener) {
          this.data.removeEventListener("error", this._boundOnError, false);
          this.data.removeEventListener("load", this._boundComplete, false);
          this.data.removeEventListener("progress", this._boundOnProgress, false);
          this.data.removeEventListener("canplaythrough", this._boundComplete, false);
        }
        if (this.xhr) {
          if (this.xhr.removeEventListener) {
            this.xhr.removeEventListener("error", this._boundXhrOnError, false);
            this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false);
            this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false);
            this.xhr.removeEventListener("progress", this._boundOnProgress, false);
            this.xhr.removeEventListener("load", this._boundXhrOnLoad, false);
          } else {
            this.xhr.onerror = null;
            this.xhr.ontimeout = null;
            this.xhr.onprogress = null;
            this.xhr.onload = null;
          }
        }
      };
      _proto._finish = function _finish() {
        if (this.isComplete) {
          throw new Error("Complete called again for an already completed resource.");
        }
        this._setFlag(Resource2.STATUS_FLAGS.COMPLETE, true);
        this._setFlag(Resource2.STATUS_FLAGS.LOADING, false);
        this.onComplete.dispatch(this);
      };
      _proto._loadElement = function _loadElement(type) {
        if (this.metadata.loadElement) {
          this.data = this.metadata.loadElement;
        } else if (type === "image" && typeof window.Image !== "undefined") {
          this.data = new Image();
        } else {
          this.data = document.createElement(type);
        }
        if (this.crossOrigin) {
          this.data.crossOrigin = this.crossOrigin;
        }
        if (!this.metadata.skipSource) {
          this.data.src = this.url;
        }
        this.data.addEventListener("error", this._boundOnError, false);
        this.data.addEventListener("load", this._boundComplete, false);
        this.data.addEventListener("progress", this._boundOnProgress, false);
        if (this.timeout) {
          this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
        }
      };
      _proto._loadSourceElement = function _loadSourceElement(type) {
        if (this.metadata.loadElement) {
          this.data = this.metadata.loadElement;
        } else if (type === "audio" && typeof window.Audio !== "undefined") {
          this.data = new Audio();
        } else {
          this.data = document.createElement(type);
        }
        if (this.data === null) {
          this.abort("Unsupported element: " + type);
          return;
        }
        if (this.crossOrigin) {
          this.data.crossOrigin = this.crossOrigin;
        }
        if (!this.metadata.skipSource) {
          if (navigator.isCocoonJS) {
            this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
          } else if (Array.isArray(this.url)) {
            var mimeTypes = this.metadata.mimeType;
            for (var i2 = 0; i2 < this.url.length; ++i2) {
              this.data.appendChild(this._createSource(type, this.url[i2], Array.isArray(mimeTypes) ? mimeTypes[i2] : mimeTypes));
            }
          } else {
            var _mimeTypes = this.metadata.mimeType;
            this.data.appendChild(this._createSource(type, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));
          }
        }
        this.data.addEventListener("error", this._boundOnError, false);
        this.data.addEventListener("load", this._boundComplete, false);
        this.data.addEventListener("progress", this._boundOnProgress, false);
        this.data.addEventListener("canplaythrough", this._boundComplete, false);
        this.data.load();
        if (this.timeout) {
          this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
        }
      };
      _proto._loadXhr = function _loadXhr() {
        if (typeof this.xhrType !== "string") {
          this.xhrType = this._determineXhrType();
        }
        var xhr = this.xhr = new XMLHttpRequest();
        xhr.open("GET", this.url, true);
        xhr.timeout = this.timeout;
        if (this.xhrType === Resource2.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource2.XHR_RESPONSE_TYPE.DOCUMENT) {
          xhr.responseType = Resource2.XHR_RESPONSE_TYPE.TEXT;
        } else {
          xhr.responseType = this.xhrType;
        }
        xhr.addEventListener("error", this._boundXhrOnError, false);
        xhr.addEventListener("timeout", this._boundXhrOnTimeout, false);
        xhr.addEventListener("abort", this._boundXhrOnAbort, false);
        xhr.addEventListener("progress", this._boundOnProgress, false);
        xhr.addEventListener("load", this._boundXhrOnLoad, false);
        xhr.send();
      };
      _proto._loadXdr = function _loadXdr() {
        if (typeof this.xhrType !== "string") {
          this.xhrType = this._determineXhrType();
        }
        var xdr = this.xhr = new XDomainRequest();
        xdr.timeout = this.timeout || 5e3;
        xdr.onerror = this._boundXhrOnError;
        xdr.ontimeout = this._boundXhrOnTimeout;
        xdr.onprogress = this._boundOnProgress;
        xdr.onload = this._boundXhrOnLoad;
        xdr.open("GET", this.url, true);
        setTimeout(function() {
          return xdr.send();
        }, 1);
      };
      _proto._createSource = function _createSource(type, url2, mime) {
        if (!mime) {
          mime = type + "/" + this._getExtension(url2);
        }
        var source = document.createElement("source");
        source.src = url2;
        source.type = mime;
        return source;
      };
      _proto._onError = function _onError(event) {
        this.abort("Failed to load element using: " + event.target.nodeName);
      };
      _proto._onProgress = function _onProgress(event) {
        if (event && event.lengthComputable) {
          this.onProgress.dispatch(this, event.loaded / event.total);
        }
      };
      _proto._onTimeout = function _onTimeout() {
        this.abort("Load timed out.");
      };
      _proto._xhrOnError = function _xhrOnError() {
        var xhr = this.xhr;
        this.abort(reqType(xhr) + " Request failed. Status: " + xhr.status + ', text: "' + xhr.statusText + '"');
      };
      _proto._xhrOnTimeout = function _xhrOnTimeout() {
        var xhr = this.xhr;
        this.abort(reqType(xhr) + " Request timed out.");
      };
      _proto._xhrOnAbort = function _xhrOnAbort() {
        var xhr = this.xhr;
        this.abort(reqType(xhr) + " Request was aborted by the user.");
      };
      _proto._xhrOnLoad = function _xhrOnLoad() {
        var xhr = this.xhr;
        var text = "";
        var status = typeof xhr.status === "undefined" ? STATUS_OK : xhr.status;
        if (xhr.responseType === "" || xhr.responseType === "text" || typeof xhr.responseType === "undefined") {
          text = xhr.responseText;
        }
        if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource2.XHR_RESPONSE_TYPE.BUFFER)) {
          status = STATUS_OK;
        } else if (status === STATUS_IE_BUG_EMPTY) {
          status = STATUS_EMPTY;
        }
        var statusType = status / 100 | 0;
        if (statusType === STATUS_TYPE_OK) {
          if (this.xhrType === Resource2.XHR_RESPONSE_TYPE.TEXT) {
            this.data = text;
            this.type = Resource2.TYPE.TEXT;
          } else if (this.xhrType === Resource2.XHR_RESPONSE_TYPE.JSON) {
            try {
              this.data = JSON.parse(text);
              this.type = Resource2.TYPE.JSON;
            } catch (e) {
              this.abort("Error trying to parse loaded json: " + e);
              return;
            }
          } else if (this.xhrType === Resource2.XHR_RESPONSE_TYPE.DOCUMENT) {
            try {
              if (window.DOMParser) {
                var domparser = new DOMParser();
                this.data = domparser.parseFromString(text, "text/xml");
              } else {
                var div = document.createElement("div");
                div.innerHTML = text;
                this.data = div;
              }
              this.type = Resource2.TYPE.XML;
            } catch (e) {
              this.abort("Error trying to parse loaded xml: " + e);
              return;
            }
          } else {
            this.data = xhr.response || text;
          }
        } else {
          this.abort("[" + xhr.status + "] " + xhr.statusText + ": " + xhr.responseURL);
          return;
        }
        this.complete();
      };
      _proto._determineCrossOrigin = function _determineCrossOrigin(url2, loc) {
        if (url2.indexOf("data:") === 0) {
          return "";
        }
        if (window.origin !== window.location.origin) {
          return "anonymous";
        }
        loc = loc || window.location;
        if (!tempAnchor) {
          tempAnchor = document.createElement("a");
        }
        tempAnchor.href = url2;
        url2 = src(tempAnchor.href, {
          strictMode: true
        });
        var samePort = !url2.port && loc.port === "" || url2.port === loc.port;
        var protocol = url2.protocol ? url2.protocol + ":" : "";
        if (url2.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
          return "anonymous";
        }
        return "";
      };
      _proto._determineXhrType = function _determineXhrType() {
        return Resource2._xhrTypeMap[this.extension] || Resource2.XHR_RESPONSE_TYPE.TEXT;
      };
      _proto._determineLoadType = function _determineLoadType() {
        return Resource2._loadTypeMap[this.extension] || Resource2.LOAD_TYPE.XHR;
      };
      _proto._getExtension = function _getExtension() {
        var url2 = this.url;
        var ext = "";
        if (this.isDataUrl) {
          var slashIndex = url2.indexOf("/");
          ext = url2.substring(slashIndex + 1, url2.indexOf(";", slashIndex));
        } else {
          var queryStart = url2.indexOf("?");
          var hashStart = url2.indexOf("#");
          var index2 = Math.min(queryStart > -1 ? queryStart : url2.length, hashStart > -1 ? hashStart : url2.length);
          url2 = url2.substring(0, index2);
          ext = url2.substring(url2.lastIndexOf(".") + 1);
        }
        return ext.toLowerCase();
      };
      _proto._getMimeFromXhrType = function _getMimeFromXhrType(type) {
        switch (type) {
          case Resource2.XHR_RESPONSE_TYPE.BUFFER:
            return "application/octet-binary";
          case Resource2.XHR_RESPONSE_TYPE.BLOB:
            return "application/blob";
          case Resource2.XHR_RESPONSE_TYPE.DOCUMENT:
            return "application/xml";
          case Resource2.XHR_RESPONSE_TYPE.JSON:
            return "application/json";
          case Resource2.XHR_RESPONSE_TYPE.DEFAULT:
          case Resource2.XHR_RESPONSE_TYPE.TEXT:
          default:
            return "text/plain";
        }
      };
      _createClass(Resource2, [{
        key: "isDataUrl",
        get: function get2() {
          return this._hasFlag(Resource2.STATUS_FLAGS.DATA_URL);
        }
      }, {
        key: "isComplete",
        get: function get2() {
          return this._hasFlag(Resource2.STATUS_FLAGS.COMPLETE);
        }
      }, {
        key: "isLoading",
        get: function get2() {
          return this._hasFlag(Resource2.STATUS_FLAGS.LOADING);
        }
      }]);
      return Resource2;
    }();
    Resource.STATUS_FLAGS = {
      NONE: 0,
      DATA_URL: 1 << 0,
      COMPLETE: 1 << 1,
      LOADING: 1 << 2
    };
    Resource.TYPE = {
      UNKNOWN: 0,
      JSON: 1,
      XML: 2,
      IMAGE: 3,
      AUDIO: 4,
      VIDEO: 5,
      TEXT: 6
    };
    Resource.LOAD_TYPE = {
      XHR: 1,
      IMAGE: 2,
      AUDIO: 3,
      VIDEO: 4
    };
    Resource.XHR_RESPONSE_TYPE = {
      DEFAULT: "text",
      BUFFER: "arraybuffer",
      BLOB: "blob",
      DOCUMENT: "document",
      JSON: "json",
      TEXT: "text"
    };
    Resource._loadTypeMap = {
      gif: Resource.LOAD_TYPE.IMAGE,
      png: Resource.LOAD_TYPE.IMAGE,
      bmp: Resource.LOAD_TYPE.IMAGE,
      jpg: Resource.LOAD_TYPE.IMAGE,
      jpeg: Resource.LOAD_TYPE.IMAGE,
      tif: Resource.LOAD_TYPE.IMAGE,
      tiff: Resource.LOAD_TYPE.IMAGE,
      webp: Resource.LOAD_TYPE.IMAGE,
      tga: Resource.LOAD_TYPE.IMAGE,
      svg: Resource.LOAD_TYPE.IMAGE,
      "svg+xml": Resource.LOAD_TYPE.IMAGE,
      mp3: Resource.LOAD_TYPE.AUDIO,
      ogg: Resource.LOAD_TYPE.AUDIO,
      wav: Resource.LOAD_TYPE.AUDIO,
      mp4: Resource.LOAD_TYPE.VIDEO,
      webm: Resource.LOAD_TYPE.VIDEO
    };
    Resource._xhrTypeMap = {
      xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
      gif: Resource.XHR_RESPONSE_TYPE.BLOB,
      png: Resource.XHR_RESPONSE_TYPE.BLOB,
      bmp: Resource.XHR_RESPONSE_TYPE.BLOB,
      jpg: Resource.XHR_RESPONSE_TYPE.BLOB,
      jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,
      tif: Resource.XHR_RESPONSE_TYPE.BLOB,
      tiff: Resource.XHR_RESPONSE_TYPE.BLOB,
      webp: Resource.XHR_RESPONSE_TYPE.BLOB,
      tga: Resource.XHR_RESPONSE_TYPE.BLOB,
      json: Resource.XHR_RESPONSE_TYPE.JSON,
      text: Resource.XHR_RESPONSE_TYPE.TEXT,
      txt: Resource.XHR_RESPONSE_TYPE.TEXT,
      ttf: Resource.XHR_RESPONSE_TYPE.BUFFER,
      otf: Resource.XHR_RESPONSE_TYPE.BUFFER
    };
    Resource.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
    function setExtMap(map2, extname, val) {
      if (extname && extname.indexOf(".") === 0) {
        extname = extname.substring(1);
      }
      if (!extname) {
        return;
      }
      map2[extname] = val;
    }
    function reqType(xhr) {
      return xhr.toString().replace("object ", "");
    }
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    function encodeBinary(input) {
      var output = "";
      var inx = 0;
      while (inx < input.length) {
        var bytebuffer = [0, 0, 0];
        var encodedCharIndexes = [0, 0, 0, 0];
        for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
          if (inx < input.length) {
            bytebuffer[jnx] = input.charCodeAt(inx++) & 255;
          } else {
            bytebuffer[jnx] = 0;
          }
        }
        encodedCharIndexes[0] = bytebuffer[0] >> 2;
        encodedCharIndexes[1] = (bytebuffer[0] & 3) << 4 | bytebuffer[1] >> 4;
        encodedCharIndexes[2] = (bytebuffer[1] & 15) << 2 | bytebuffer[2] >> 6;
        encodedCharIndexes[3] = bytebuffer[2] & 63;
        var paddingBytes = inx - (input.length - 1);
        switch (paddingBytes) {
          case 2:
            encodedCharIndexes[3] = 64;
            encodedCharIndexes[2] = 64;
            break;
          case 1:
            encodedCharIndexes[3] = 64;
            break;
        }
        for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) {
          output += _keyStr.charAt(encodedCharIndexes[_jnx]);
        }
      }
      return output;
    }
    var Url = window.URL || window.webkitURL;
    function parsing(resource, next) {
      if (!resource.data) {
        next();
        return;
      }
      if (resource.xhr && resource.xhrType === Resource.XHR_RESPONSE_TYPE.BLOB) {
        if (!window.Blob || typeof resource.data === "string") {
          var type = resource.xhr.getResponseHeader("content-type");
          if (type && type.indexOf("image") === 0) {
            resource.data = new Image();
            resource.data.src = "data:" + type + ";base64," + encodeBinary(resource.xhr.responseText);
            resource.type = Resource.TYPE.IMAGE;
            resource.data.onload = function() {
              resource.data.onload = null;
              next();
            };
            return;
          }
        } else if (resource.data.type.indexOf("image") === 0) {
          var src2 = Url.createObjectURL(resource.data);
          resource.blob = resource.data;
          resource.data = new Image();
          resource.data.src = src2;
          resource.type = Resource.TYPE.IMAGE;
          resource.data.onload = function() {
            Url.revokeObjectURL(src2);
            resource.data.onload = null;
            next();
          };
          return;
        }
      }
      next();
    }
    var index = {
      caching,
      parsing
    };
    var MAX_PROGRESS = 100;
    var rgxExtractUrlHash = /(#[\w-]+)?$/;
    var Loader$1 = /* @__PURE__ */ function() {
      function Loader2(baseUrl, concurrency) {
        var _this = this;
        if (baseUrl === void 0) {
          baseUrl = "";
        }
        if (concurrency === void 0) {
          concurrency = 10;
        }
        this.baseUrl = baseUrl;
        this.progress = 0;
        this.loading = false;
        this.defaultQueryString = "";
        this._beforeMiddleware = [];
        this._afterMiddleware = [];
        this._resourcesParsing = [];
        this._boundLoadResource = function(r2, d) {
          return _this._loadResource(r2, d);
        };
        this._queue = queue(this._boundLoadResource, concurrency);
        this._queue.pause();
        this.resources = {};
        this.onProgress = new MiniSignal();
        this.onError = new MiniSignal();
        this.onLoad = new MiniSignal();
        this.onStart = new MiniSignal();
        this.onComplete = new MiniSignal();
        for (var i2 = 0; i2 < Loader2._defaultBeforeMiddleware.length; ++i2) {
          this.pre(Loader2._defaultBeforeMiddleware[i2]);
        }
        for (var _i = 0; _i < Loader2._defaultAfterMiddleware.length; ++_i) {
          this.use(Loader2._defaultAfterMiddleware[_i]);
        }
      }
      var _proto = Loader2.prototype;
      _proto.add = function add2(name, url2, options, cb2) {
        if (Array.isArray(name)) {
          for (var i2 = 0; i2 < name.length; ++i2) {
            this.add(name[i2]);
          }
          return this;
        }
        if (typeof name === "object") {
          cb2 = url2 || name.callback || name.onComplete;
          options = name;
          url2 = name.url;
          name = name.name || name.key || name.url;
        }
        if (typeof url2 !== "string") {
          cb2 = options;
          options = url2;
          url2 = name;
        }
        if (typeof url2 !== "string") {
          throw new Error("No url passed to add resource to loader.");
        }
        if (typeof options === "function") {
          cb2 = options;
          options = null;
        }
        if (this.loading && (!options || !options.parentResource)) {
          throw new Error("Cannot add resources while the loader is running.");
        }
        if (this.resources[name]) {
          throw new Error('Resource named "' + name + '" already exists.');
        }
        url2 = this._prepareUrl(url2);
        this.resources[name] = new Resource(name, url2, options);
        if (typeof cb2 === "function") {
          this.resources[name].onAfterMiddleware.once(cb2);
        }
        if (this.loading) {
          var parent = options.parentResource;
          var incompleteChildren = [];
          for (var _i2 = 0; _i2 < parent.children.length; ++_i2) {
            if (!parent.children[_i2].isComplete) {
              incompleteChildren.push(parent.children[_i2]);
            }
          }
          var fullChunk = parent.progressChunk * (incompleteChildren.length + 1);
          var eachChunk = fullChunk / (incompleteChildren.length + 2);
          parent.children.push(this.resources[name]);
          parent.progressChunk = eachChunk;
          for (var _i3 = 0; _i3 < incompleteChildren.length; ++_i3) {
            incompleteChildren[_i3].progressChunk = eachChunk;
          }
          this.resources[name].progressChunk = eachChunk;
        }
        this._queue.push(this.resources[name]);
        return this;
      };
      _proto.pre = function pre(fn) {
        this._beforeMiddleware.push(fn);
        return this;
      };
      _proto.use = function use(fn) {
        this._afterMiddleware.push(fn);
        return this;
      };
      _proto.reset = function reset() {
        this.progress = 0;
        this.loading = false;
        this._queue.kill();
        this._queue.pause();
        for (var k in this.resources) {
          var res = this.resources[k];
          if (res._onLoadBinding) {
            res._onLoadBinding.detach();
          }
          if (res.isLoading) {
            res.abort();
          }
        }
        this.resources = {};
        return this;
      };
      _proto.load = function load(cb2) {
        if (typeof cb2 === "function") {
          this.onComplete.once(cb2);
        }
        if (this.loading) {
          return this;
        }
        if (this._queue.idle()) {
          this._onStart();
          this._onComplete();
        } else {
          var numTasks = this._queue._tasks.length;
          var chunk2 = MAX_PROGRESS / numTasks;
          for (var i2 = 0; i2 < this._queue._tasks.length; ++i2) {
            this._queue._tasks[i2].data.progressChunk = chunk2;
          }
          this._onStart();
          this._queue.resume();
        }
        return this;
      };
      _proto._prepareUrl = function _prepareUrl(url2) {
        var parsedUrl = src(url2, {
          strictMode: true
        });
        var result2;
        if (parsedUrl.protocol || !parsedUrl.path || url2.indexOf("//") === 0) {
          result2 = url2;
        } else if (this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && url2.charAt(0) !== "/") {
          result2 = this.baseUrl + "/" + url2;
        } else {
          result2 = this.baseUrl + url2;
        }
        if (this.defaultQueryString) {
          var hash = rgxExtractUrlHash.exec(result2)[0];
          result2 = result2.substr(0, result2.length - hash.length);
          if (result2.indexOf("?") !== -1) {
            result2 += "&" + this.defaultQueryString;
          } else {
            result2 += "?" + this.defaultQueryString;
          }
          result2 += hash;
        }
        return result2;
      };
      _proto._loadResource = function _loadResource(resource, dequeue) {
        var _this2 = this;
        resource._dequeue = dequeue;
        eachSeries(this._beforeMiddleware, function(fn, next) {
          fn.call(_this2, resource, function() {
            next(resource.isComplete ? {} : null);
          });
        }, function() {
          if (resource.isComplete) {
            _this2._onLoad(resource);
          } else {
            resource._onLoadBinding = resource.onComplete.once(_this2._onLoad, _this2);
            resource.load();
          }
        }, true);
      };
      _proto._onStart = function _onStart() {
        this.progress = 0;
        this.loading = true;
        this.onStart.dispatch(this);
      };
      _proto._onComplete = function _onComplete() {
        this.progress = MAX_PROGRESS;
        this.loading = false;
        this.onComplete.dispatch(this, this.resources);
      };
      _proto._onLoad = function _onLoad(resource) {
        var _this3 = this;
        resource._onLoadBinding = null;
        this._resourcesParsing.push(resource);
        resource._dequeue();
        eachSeries(this._afterMiddleware, function(fn, next) {
          fn.call(_this3, resource, next);
        }, function() {
          resource.onAfterMiddleware.dispatch(resource);
          _this3.progress = Math.min(MAX_PROGRESS, _this3.progress + resource.progressChunk);
          _this3.onProgress.dispatch(_this3, resource);
          if (resource.error) {
            _this3.onError.dispatch(resource.error, _this3, resource);
          } else {
            _this3.onLoad.dispatch(_this3, resource);
          }
          _this3._resourcesParsing.splice(_this3._resourcesParsing.indexOf(resource), 1);
          if (_this3._queue.idle() && _this3._resourcesParsing.length === 0) {
            _this3._onComplete();
          }
        }, true);
      };
      _createClass(Loader2, [{
        key: "concurrency",
        get: function get2() {
          return this._queue.concurrency;
        },
        set: function set2(concurrency) {
          this._queue.concurrency = concurrency;
        }
      }]);
      return Loader2;
    }();
    Loader$1._defaultBeforeMiddleware = [];
    Loader$1._defaultAfterMiddleware = [];
    Loader$1.pre = function LoaderPreStatic(fn) {
      Loader$1._defaultBeforeMiddleware.push(fn);
      return Loader$1;
    };
    Loader$1.use = function LoaderUseStatic(fn) {
      Loader$1._defaultAfterMiddleware.push(fn);
      return Loader$1;
    };
    /*!
     * @pixi/loaders - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/loaders is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var LoaderResource = Resource;
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$g = function(d, b) {
      extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$g(d, b);
    };
    function __extends$g(d, b) {
      extendStatics$g(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var TextureLoader = function() {
      function TextureLoader2() {
      }
      TextureLoader2.use = function(resource, next) {
        if (resource.data && resource.type === Resource.TYPE.IMAGE) {
          resource.texture = Texture.fromLoader(resource.data, resource.url, resource.name);
        }
        next();
      };
      return TextureLoader2;
    }();
    var Loader = function(_super) {
      __extends$g(Loader2, _super);
      function Loader2(baseUrl, concurrency) {
        var _this = _super.call(this, baseUrl, concurrency) || this;
        for (var i2 = 0; i2 < Loader2._plugins.length; ++i2) {
          var plugin = Loader2._plugins[i2];
          var pre = plugin.pre, use = plugin.use;
          if (pre) {
            _this.pre(pre);
          }
          if (use) {
            _this.use(use);
          }
        }
        _this._protected = false;
        return _this;
      }
      Loader2.prototype.destroy = function() {
        if (!this._protected) {
          this.reset();
        }
      };
      Object.defineProperty(Loader2, "shared", {
        get: function() {
          var shared = Loader2._shared;
          if (!shared) {
            shared = new Loader2();
            shared._protected = true;
            Loader2._shared = shared;
          }
          return shared;
        },
        enumerable: false,
        configurable: true
      });
      Loader2.registerPlugin = function(plugin) {
        Loader2._plugins.push(plugin);
        if (plugin.add) {
          plugin.add();
        }
        return Loader2;
      };
      Loader2._plugins = [];
      return Loader2;
    }(Loader$1);
    Loader.registerPlugin({ use: index.parsing });
    Loader.registerPlugin(TextureLoader);
    var AppLoaderPlugin = function() {
      function AppLoaderPlugin2() {
      }
      AppLoaderPlugin2.init = function(options) {
        options = Object.assign({
          sharedLoader: false
        }, options);
        this.loader = options.sharedLoader ? Loader.shared : new Loader();
      };
      AppLoaderPlugin2.destroy = function() {
        if (this.loader) {
          this.loader.destroy();
          this.loader = null;
        }
      };
      return AppLoaderPlugin2;
    }();
    /*!
     * @pixi/particles - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/particles is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$f = function(d, b) {
      extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$f(d, b);
    };
    function __extends$f(d, b) {
      extendStatics$f(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    (function(_super) {
      __extends$f(ParticleContainer, _super);
      function ParticleContainer(maxSize, properties, batchSize, autoResize) {
        if (maxSize === void 0) {
          maxSize = 1500;
        }
        if (batchSize === void 0) {
          batchSize = 16384;
        }
        if (autoResize === void 0) {
          autoResize = false;
        }
        var _this = _super.call(this) || this;
        var maxBatchSize = 16384;
        if (batchSize > maxBatchSize) {
          batchSize = maxBatchSize;
        }
        _this._properties = [false, true, false, false, false];
        _this._maxSize = maxSize;
        _this._batchSize = batchSize;
        _this._buffers = null;
        _this._bufferUpdateIDs = [];
        _this._updateID = 0;
        _this.interactiveChildren = false;
        _this.blendMode = BLEND_MODES$1.NORMAL;
        _this.autoResize = autoResize;
        _this.roundPixels = true;
        _this.baseTexture = null;
        _this.setProperties(properties);
        _this._tint = 0;
        _this.tintRgb = new Float32Array(4);
        _this.tint = 16777215;
        return _this;
      }
      ParticleContainer.prototype.setProperties = function(properties) {
        if (properties) {
          this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
          this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
          this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
          this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
          this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
        }
      };
      ParticleContainer.prototype.updateTransform = function() {
        this.displayObjectUpdateTransform();
      };
      Object.defineProperty(ParticleContainer.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value2) {
          this._tint = value2;
          hex2rgb(value2, this.tintRgb);
        },
        enumerable: false,
        configurable: true
      });
      ParticleContainer.prototype.render = function(renderer) {
        var _this = this;
        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
          return;
        }
        if (!this.baseTexture) {
          this.baseTexture = this.children[0]._texture.baseTexture;
          if (!this.baseTexture.valid) {
            this.baseTexture.once("update", function() {
              return _this.onChildrenChange(0);
            });
          }
        }
        renderer.batch.setObjectRenderer(renderer.plugins.particle);
        renderer.plugins.particle.render(this);
      };
      ParticleContainer.prototype.onChildrenChange = function(smallestChildIndex) {
        var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
        while (this._bufferUpdateIDs.length < bufferIndex) {
          this._bufferUpdateIDs.push(0);
        }
        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
      };
      ParticleContainer.prototype.dispose = function() {
        if (this._buffers) {
          for (var i2 = 0; i2 < this._buffers.length; ++i2) {
            this._buffers[i2].destroy();
          }
          this._buffers = null;
        }
      };
      ParticleContainer.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this.dispose();
        this._properties = null;
        this._buffers = null;
        this._bufferUpdateIDs = null;
      };
      return ParticleContainer;
    })(Container);
    var ParticleBuffer = function() {
      function ParticleBuffer2(properties, dynamicPropertyFlags, size2) {
        this.geometry = new Geometry();
        this.indexBuffer = null;
        this.size = size2;
        this.dynamicProperties = [];
        this.staticProperties = [];
        for (var i2 = 0; i2 < properties.length; ++i2) {
          var property2 = properties[i2];
          property2 = {
            attributeName: property2.attributeName,
            size: property2.size,
            uploadFunction: property2.uploadFunction,
            type: property2.type || TYPES$1.FLOAT,
            offset: property2.offset
          };
          if (dynamicPropertyFlags[i2]) {
            this.dynamicProperties.push(property2);
          } else {
            this.staticProperties.push(property2);
          }
        }
        this.staticStride = 0;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        this.dynamicStride = 0;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this._updateID = 0;
        this.initBuffers();
      }
      ParticleBuffer2.prototype.initBuffers = function() {
        var geometry = this.geometry;
        var dynamicOffset = 0;
        this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), true, true);
        geometry.addIndex(this.indexBuffer);
        this.dynamicStride = 0;
        for (var i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
          var property2 = this.dynamicProperties[i2];
          property2.offset = dynamicOffset;
          dynamicOffset += property2.size;
          this.dynamicStride += property2.size;
        }
        var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(dynBuffer);
        this.dynamicDataUint32 = new Uint32Array(dynBuffer);
        this.dynamicBuffer = new Buffer$1(this.dynamicData, false, false);
        var staticOffset = 0;
        this.staticStride = 0;
        for (var i2 = 0; i2 < this.staticProperties.length; ++i2) {
          var property2 = this.staticProperties[i2];
          property2.offset = staticOffset;
          staticOffset += property2.size;
          this.staticStride += property2.size;
        }
        var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(statBuffer);
        this.staticDataUint32 = new Uint32Array(statBuffer);
        this.staticBuffer = new Buffer$1(this.staticData, true, false);
        for (var i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
          var property2 = this.dynamicProperties[i2];
          geometry.addAttribute(property2.attributeName, this.dynamicBuffer, 0, property2.type === TYPES$1.UNSIGNED_BYTE, property2.type, this.dynamicStride * 4, property2.offset * 4);
        }
        for (var i2 = 0; i2 < this.staticProperties.length; ++i2) {
          var property2 = this.staticProperties[i2];
          geometry.addAttribute(property2.attributeName, this.staticBuffer, 0, property2.type === TYPES$1.UNSIGNED_BYTE, property2.type, this.staticStride * 4, property2.offset * 4);
        }
      };
      ParticleBuffer2.prototype.uploadDynamic = function(children, startIndex, amount) {
        for (var i2 = 0; i2 < this.dynamicProperties.length; i2++) {
          var property2 = this.dynamicProperties[i2];
          property2.uploadFunction(children, startIndex, amount, property2.type === TYPES$1.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property2.offset);
        }
        this.dynamicBuffer._updateID++;
      };
      ParticleBuffer2.prototype.uploadStatic = function(children, startIndex, amount) {
        for (var i2 = 0; i2 < this.staticProperties.length; i2++) {
          var property2 = this.staticProperties[i2];
          property2.uploadFunction(children, startIndex, amount, property2.type === TYPES$1.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property2.offset);
        }
        this.staticBuffer._updateID++;
      };
      ParticleBuffer2.prototype.destroy = function() {
        this.indexBuffer = null;
        this.dynamicProperties = null;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this.staticProperties = null;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        this.geometry.destroy();
      };
      return ParticleBuffer2;
    }();
    var fragment$7 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
    var vertex$4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
    var ParticleRenderer = function(_super) {
      __extends$f(ParticleRenderer2, _super);
      function ParticleRenderer2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.shader = null;
        _this.properties = null;
        _this.tempMatrix = new Matrix();
        _this.properties = [
          {
            attributeName: "aVertexPosition",
            size: 2,
            uploadFunction: _this.uploadVertices,
            offset: 0
          },
          {
            attributeName: "aPositionCoord",
            size: 2,
            uploadFunction: _this.uploadPosition,
            offset: 0
          },
          {
            attributeName: "aRotation",
            size: 1,
            uploadFunction: _this.uploadRotation,
            offset: 0
          },
          {
            attributeName: "aTextureCoord",
            size: 2,
            uploadFunction: _this.uploadUvs,
            offset: 0
          },
          {
            attributeName: "aColor",
            size: 1,
            type: TYPES$1.UNSIGNED_BYTE,
            uploadFunction: _this.uploadTint,
            offset: 0
          }
        ];
        _this.shader = Shader.from(vertex$4, fragment$7, {});
        _this.state = State.for2d();
        return _this;
      }
      ParticleRenderer2.prototype.render = function(container) {
        var children = container.children;
        var maxSize = container._maxSize;
        var batchSize = container._batchSize;
        var renderer = this.renderer;
        var totalChildren = children.length;
        if (totalChildren === 0) {
          return;
        } else if (totalChildren > maxSize && !container.autoResize) {
          totalChildren = maxSize;
        }
        var buffers = container._buffers;
        if (!buffers) {
          buffers = container._buffers = this.generateBuffers(container);
        }
        var baseTexture = children[0]._texture.baseTexture;
        this.state.blendMode = correctBlendMode(container.blendMode, baseTexture.alphaMode);
        renderer.state.set(this.state);
        var gl = renderer.gl;
        var m2 = container.worldTransform.copyTo(this.tempMatrix);
        m2.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
        this.shader.uniforms.translationMatrix = m2.toArray(true);
        this.shader.uniforms.uColor = premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.alphaMode);
        this.shader.uniforms.uSampler = baseTexture;
        this.renderer.shader.bind(this.shader);
        var updateStatic = false;
        for (var i2 = 0, j = 0; i2 < totalChildren; i2 += batchSize, j += 1) {
          var amount = totalChildren - i2;
          if (amount > batchSize) {
            amount = batchSize;
          }
          if (j >= buffers.length) {
            buffers.push(this._generateOneMoreBuffer(container));
          }
          var buffer = buffers[j];
          buffer.uploadDynamic(children, i2, amount);
          var bid = container._bufferUpdateIDs[j] || 0;
          updateStatic = updateStatic || buffer._updateID < bid;
          if (updateStatic) {
            buffer._updateID = container._updateID;
            buffer.uploadStatic(children, i2, amount);
          }
          renderer.geometry.bind(buffer.geometry);
          gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
        }
      };
      ParticleRenderer2.prototype.generateBuffers = function(container) {
        var buffers = [];
        var size2 = container._maxSize;
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        for (var i2 = 0; i2 < size2; i2 += batchSize) {
          buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
        }
        return buffers;
      };
      ParticleRenderer2.prototype._generateOneMoreBuffer = function(container) {
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
      };
      ParticleRenderer2.prototype.uploadVertices = function(children, startIndex, amount, array, stride, offset2) {
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        for (var i2 = 0; i2 < amount; ++i2) {
          var sprite = children[startIndex + i2];
          var texture = sprite._texture;
          var sx = sprite.scale.x;
          var sy = sprite.scale.y;
          var trim2 = texture.trim;
          var orig = texture.orig;
          if (trim2) {
            w1 = trim2.x - sprite.anchor.x * orig.width;
            w0 = w1 + trim2.width;
            h1 = trim2.y - sprite.anchor.y * orig.height;
            h0 = h1 + trim2.height;
          } else {
            w0 = orig.width * (1 - sprite.anchor.x);
            w1 = orig.width * -sprite.anchor.x;
            h0 = orig.height * (1 - sprite.anchor.y);
            h1 = orig.height * -sprite.anchor.y;
          }
          array[offset2] = w1 * sx;
          array[offset2 + 1] = h1 * sy;
          array[offset2 + stride] = w0 * sx;
          array[offset2 + stride + 1] = h1 * sy;
          array[offset2 + stride * 2] = w0 * sx;
          array[offset2 + stride * 2 + 1] = h0 * sy;
          array[offset2 + stride * 3] = w1 * sx;
          array[offset2 + stride * 3 + 1] = h0 * sy;
          offset2 += stride * 4;
        }
      };
      ParticleRenderer2.prototype.uploadPosition = function(children, startIndex, amount, array, stride, offset2) {
        for (var i2 = 0; i2 < amount; i2++) {
          var spritePosition = children[startIndex + i2].position;
          array[offset2] = spritePosition.x;
          array[offset2 + 1] = spritePosition.y;
          array[offset2 + stride] = spritePosition.x;
          array[offset2 + stride + 1] = spritePosition.y;
          array[offset2 + stride * 2] = spritePosition.x;
          array[offset2 + stride * 2 + 1] = spritePosition.y;
          array[offset2 + stride * 3] = spritePosition.x;
          array[offset2 + stride * 3 + 1] = spritePosition.y;
          offset2 += stride * 4;
        }
      };
      ParticleRenderer2.prototype.uploadRotation = function(children, startIndex, amount, array, stride, offset2) {
        for (var i2 = 0; i2 < amount; i2++) {
          var spriteRotation = children[startIndex + i2].rotation;
          array[offset2] = spriteRotation;
          array[offset2 + stride] = spriteRotation;
          array[offset2 + stride * 2] = spriteRotation;
          array[offset2 + stride * 3] = spriteRotation;
          offset2 += stride * 4;
        }
      };
      ParticleRenderer2.prototype.uploadUvs = function(children, startIndex, amount, array, stride, offset2) {
        for (var i2 = 0; i2 < amount; ++i2) {
          var textureUvs = children[startIndex + i2]._texture._uvs;
          if (textureUvs) {
            array[offset2] = textureUvs.x0;
            array[offset2 + 1] = textureUvs.y0;
            array[offset2 + stride] = textureUvs.x1;
            array[offset2 + stride + 1] = textureUvs.y1;
            array[offset2 + stride * 2] = textureUvs.x2;
            array[offset2 + stride * 2 + 1] = textureUvs.y2;
            array[offset2 + stride * 3] = textureUvs.x3;
            array[offset2 + stride * 3 + 1] = textureUvs.y3;
            offset2 += stride * 4;
          } else {
            array[offset2] = 0;
            array[offset2 + 1] = 0;
            array[offset2 + stride] = 0;
            array[offset2 + stride + 1] = 0;
            array[offset2 + stride * 2] = 0;
            array[offset2 + stride * 2 + 1] = 0;
            array[offset2 + stride * 3] = 0;
            array[offset2 + stride * 3 + 1] = 0;
            offset2 += stride * 4;
          }
        }
      };
      ParticleRenderer2.prototype.uploadTint = function(children, startIndex, amount, array, stride, offset2) {
        for (var i2 = 0; i2 < amount; ++i2) {
          var sprite = children[startIndex + i2];
          var premultiplied = sprite._texture.baseTexture.alphaMode > 0;
          var alpha = sprite.alpha;
          var argb = alpha < 1 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);
          array[offset2] = argb;
          array[offset2 + stride] = argb;
          array[offset2 + stride * 2] = argb;
          array[offset2 + stride * 3] = argb;
          offset2 += stride * 4;
        }
      };
      ParticleRenderer2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        if (this.shader) {
          this.shader.destroy();
          this.shader = null;
        }
        this.tempMatrix = null;
      };
      return ParticleRenderer2;
    }(ObjectRenderer);
    /*!
     * @pixi/graphics - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/graphics is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var LINE_JOIN;
    (function(LINE_JOIN2) {
      LINE_JOIN2["MITER"] = "miter";
      LINE_JOIN2["BEVEL"] = "bevel";
      LINE_JOIN2["ROUND"] = "round";
    })(LINE_JOIN || (LINE_JOIN = {}));
    var LINE_CAP;
    (function(LINE_CAP2) {
      LINE_CAP2["BUTT"] = "butt";
      LINE_CAP2["ROUND"] = "round";
      LINE_CAP2["SQUARE"] = "square";
    })(LINE_CAP || (LINE_CAP = {}));
    var GRAPHICS_CURVES = {
      adaptive: true,
      maxLength: 10,
      minSegments: 8,
      maxSegments: 2048,
      epsilon: 1e-4,
      _segmentsCount: function(length, defaultSegments) {
        if (defaultSegments === void 0) {
          defaultSegments = 20;
        }
        if (!this.adaptive || !length || isNaN(length)) {
          return defaultSegments;
        }
        var result2 = Math.ceil(length / this.maxLength);
        if (result2 < this.minSegments) {
          result2 = this.minSegments;
        } else if (result2 > this.maxSegments) {
          result2 = this.maxSegments;
        }
        return result2;
      }
    };
    var FillStyle = function() {
      function FillStyle2() {
        this.color = 16777215;
        this.alpha = 1;
        this.texture = Texture.WHITE;
        this.matrix = null;
        this.visible = false;
        this.reset();
      }
      FillStyle2.prototype.clone = function() {
        var obj = new FillStyle2();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        return obj;
      };
      FillStyle2.prototype.reset = function() {
        this.color = 16777215;
        this.alpha = 1;
        this.texture = Texture.WHITE;
        this.matrix = null;
        this.visible = false;
      };
      FillStyle2.prototype.destroy = function() {
        this.texture = null;
        this.matrix = null;
      };
      return FillStyle2;
    }();
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$e = function(d, b) {
      extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$e(d, b);
    };
    function __extends$e(d, b) {
      extendStatics$e(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var buildPoly = {
      build: function(graphicsData) {
        graphicsData.points = graphicsData.shape.points.slice();
      },
      triangulate: function(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var holes = graphicsData.holes;
        var verts = graphicsGeometry.points;
        var indices2 = graphicsGeometry.indices;
        if (points.length >= 6) {
          var holeArray = [];
          for (var i2 = 0; i2 < holes.length; i2++) {
            var hole = holes[i2];
            holeArray.push(points.length / 2);
            points = points.concat(hole.points);
          }
          var triangles = earcut$1.exports(points, holeArray, 2);
          if (!triangles) {
            return;
          }
          var vertPos = verts.length / 2;
          for (var i2 = 0; i2 < triangles.length; i2 += 3) {
            indices2.push(triangles[i2] + vertPos);
            indices2.push(triangles[i2 + 1] + vertPos);
            indices2.push(triangles[i2 + 2] + vertPos);
          }
          for (var i2 = 0; i2 < points.length; i2++) {
            verts.push(points[i2]);
          }
        }
      }
    };
    var buildCircle = {
      build: function(graphicsData) {
        var circleData = graphicsData.shape;
        var points = graphicsData.points;
        var x2 = circleData.x;
        var y2 = circleData.y;
        var width2;
        var height2;
        points.length = 0;
        if (graphicsData.type === SHAPES.CIRC) {
          width2 = circleData.radius;
          height2 = circleData.radius;
        } else {
          var ellipseData = graphicsData.shape;
          width2 = ellipseData.width;
          height2 = ellipseData.height;
        }
        if (width2 === 0 || height2 === 0) {
          return;
        }
        var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(width2 + height2));
        totalSegs /= 2.3;
        var seg = Math.PI * 2 / totalSegs;
        for (var i2 = 0; i2 < totalSegs - 0.5; i2++) {
          points.push(x2 + Math.sin(-seg * i2) * width2, y2 + Math.cos(-seg * i2) * height2);
        }
        points.push(points[0], points[1]);
      },
      triangulate: function(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices2 = graphicsGeometry.indices;
        var vertPos = verts.length / 2;
        var center = vertPos;
        var circle = graphicsData.shape;
        var matrix = graphicsData.matrix;
        var x2 = circle.x;
        var y2 = circle.y;
        verts.push(graphicsData.matrix ? matrix.a * x2 + matrix.c * y2 + matrix.tx : x2, graphicsData.matrix ? matrix.b * x2 + matrix.d * y2 + matrix.ty : y2);
        for (var i2 = 0; i2 < points.length; i2 += 2) {
          verts.push(points[i2], points[i2 + 1]);
          indices2.push(vertPos++, center, vertPos);
        }
      }
    };
    var buildRectangle = {
      build: function(graphicsData) {
        var rectData = graphicsData.shape;
        var x2 = rectData.x;
        var y2 = rectData.y;
        var width2 = rectData.width;
        var height2 = rectData.height;
        var points = graphicsData.points;
        points.length = 0;
        points.push(x2, y2, x2 + width2, y2, x2 + width2, y2 + height2, x2, y2 + height2);
      },
      triangulate: function(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var vertPos = verts.length / 2;
        verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
      }
    };
    function getPt(n1, n2, perc) {
      var diff2 = n2 - n1;
      return n1 + diff2 * perc;
    }
    function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
      if (out === void 0) {
        out = [];
      }
      var n2 = 20;
      var points = out;
      var xa2 = 0;
      var ya2 = 0;
      var xb2 = 0;
      var yb2 = 0;
      var x2 = 0;
      var y2 = 0;
      for (var i2 = 0, j = 0; i2 <= n2; ++i2) {
        j = i2 / n2;
        xa2 = getPt(fromX, cpX, j);
        ya2 = getPt(fromY, cpY, j);
        xb2 = getPt(cpX, toX, j);
        yb2 = getPt(cpY, toY, j);
        x2 = getPt(xa2, xb2, j);
        y2 = getPt(ya2, yb2, j);
        points.push(x2, y2);
      }
      return points;
    }
    var buildRoundedRectangle = {
      build: function(graphicsData) {
        var rrectData = graphicsData.shape;
        var points = graphicsData.points;
        var x2 = rrectData.x;
        var y2 = rrectData.y;
        var width2 = rrectData.width;
        var height2 = rrectData.height;
        var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width2, height2) / 2));
        points.length = 0;
        if (!radius) {
          points.push(x2, y2, x2 + width2, y2, x2 + width2, y2 + height2, x2, y2 + height2);
        } else {
          quadraticBezierCurve(x2, y2 + radius, x2, y2, x2 + radius, y2, points);
          quadraticBezierCurve(x2 + width2 - radius, y2, x2 + width2, y2, x2 + width2, y2 + radius, points);
          quadraticBezierCurve(x2 + width2, y2 + height2 - radius, x2 + width2, y2 + height2, x2 + width2 - radius, y2 + height2, points);
          quadraticBezierCurve(x2 + radius, y2 + height2, x2, y2 + height2, x2, y2 + height2 - radius, points);
        }
      },
      triangulate: function(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices2 = graphicsGeometry.indices;
        var vecPos = verts.length / 2;
        var triangles = earcut$1.exports(points, null, 2);
        for (var i2 = 0, j = triangles.length; i2 < j; i2 += 3) {
          indices2.push(triangles[i2] + vecPos);
          indices2.push(triangles[i2 + 1] + vecPos);
          indices2.push(triangles[i2 + 2] + vecPos);
        }
        for (var i2 = 0, j = points.length; i2 < j; i2++) {
          verts.push(points[i2], points[++i2]);
        }
      }
    };
    function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
      var ix = x2 - nx * innerWeight;
      var iy = y2 - ny * innerWeight;
      var ox = x2 + nx * outerWeight;
      var oy = y2 + ny * outerWeight;
      var exx;
      var eyy;
      if (clockwise) {
        exx = ny;
        eyy = -nx;
      } else {
        exx = -ny;
        eyy = nx;
      }
      var eix = ix + exx;
      var eiy = iy + eyy;
      var eox = ox + exx;
      var eoy = oy + eyy;
      verts.push(eix, eiy);
      verts.push(eox, eoy);
      return 2;
    }
    function round$1(cx, cy, sx, sy, ex, ey, verts, clockwise) {
      var cx2p0x = sx - cx;
      var cy2p0y = sy - cy;
      var angle0 = Math.atan2(cx2p0x, cy2p0y);
      var angle1 = Math.atan2(ex - cx, ey - cy);
      if (clockwise && angle0 < angle1) {
        angle0 += Math.PI * 2;
      } else if (!clockwise && angle0 > angle1) {
        angle1 += Math.PI * 2;
      }
      var startAngle = angle0;
      var angleDiff = angle1 - angle0;
      var absAngleDiff = Math.abs(angleDiff);
      var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
      var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
      var angleInc = angleDiff / segCount;
      startAngle += angleInc;
      if (clockwise) {
        verts.push(cx, cy);
        verts.push(sx, sy);
        for (var i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
          verts.push(cx, cy);
          verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
        }
        verts.push(cx, cy);
        verts.push(ex, ey);
      } else {
        verts.push(sx, sy);
        verts.push(cx, cy);
        for (var i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
          verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
          verts.push(cx, cy);
        }
        verts.push(ex, ey);
        verts.push(cx, cy);
      }
      return segCount * 2;
    }
    function buildNonNativeLine(graphicsData, graphicsGeometry) {
      var shape = graphicsData.shape;
      var points = graphicsData.points || shape.points.slice();
      var eps = graphicsGeometry.closePointEps;
      if (points.length === 0) {
        return;
      }
      var style = graphicsData.lineStyle;
      var firstPoint = new Point(points[0], points[1]);
      var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
      var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
      var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
      if (closedShape) {
        points = points.slice();
        if (closedPath) {
          points.pop();
          points.pop();
          lastPoint.set(points[points.length - 2], points[points.length - 1]);
        }
        var midPointX = (firstPoint.x + lastPoint.x) * 0.5;
        var midPointY = (lastPoint.y + firstPoint.y) * 0.5;
        points.unshift(midPointX, midPointY);
        points.push(midPointX, midPointY);
      }
      var verts = graphicsGeometry.points;
      var length = points.length / 2;
      var indexCount = points.length;
      var indexStart = verts.length / 2;
      var width2 = style.width / 2;
      var widthSquared = width2 * width2;
      var miterLimitSquared = style.miterLimit * style.miterLimit;
      var x0 = points[0];
      var y0 = points[1];
      var x1 = points[2];
      var y1 = points[3];
      var x2 = 0;
      var y2 = 0;
      var perpx = -(y0 - y1);
      var perpy = x0 - x1;
      var perp1x = 0;
      var perp1y = 0;
      var dist = Math.sqrt(perpx * perpx + perpy * perpy);
      perpx /= dist;
      perpy /= dist;
      perpx *= width2;
      perpy *= width2;
      var ratio = style.alignment;
      var innerWeight = (1 - ratio) * 2;
      var outerWeight = ratio * 2;
      if (!closedShape) {
        if (style.cap === LINE_CAP.ROUND) {
          indexCount += round$1(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
        } else if (style.cap === LINE_CAP.SQUARE) {
          indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
        }
      }
      verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);
      verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);
      for (var i2 = 1; i2 < length - 1; ++i2) {
        x0 = points[(i2 - 1) * 2];
        y0 = points[(i2 - 1) * 2 + 1];
        x1 = points[i2 * 2];
        y1 = points[i2 * 2 + 1];
        x2 = points[(i2 + 1) * 2];
        y2 = points[(i2 + 1) * 2 + 1];
        perpx = -(y0 - y1);
        perpy = x0 - x1;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width2;
        perpy *= width2;
        perp1x = -(y1 - y2);
        perp1y = x1 - x2;
        dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
        perp1x /= dist;
        perp1y /= dist;
        perp1x *= width2;
        perp1y *= width2;
        var dx0 = x1 - x0;
        var dy0 = y0 - y1;
        var dx1 = x1 - x2;
        var dy1 = y2 - y1;
        var cross = dy0 * dx1 - dy1 * dx0;
        var clockwise = cross < 0;
        if (Math.abs(cross) < 0.1) {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          continue;
        }
        var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
        var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
        var px = (dx0 * c2 - dx1 * c1) / cross;
        var py = (dy1 * c1 - dy0 * c2) / cross;
        var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
        var imx = x1 + (px - x1) * innerWeight;
        var imy = y1 + (py - y1) * innerWeight;
        var omx = x1 - (px - x1) * outerWeight;
        var omy = y1 - (py - y1) * outerWeight;
        var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
        var insideWeight = clockwise ? innerWeight : outerWeight;
        var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
        var insideMiterOk = pdist <= smallerInsideDiagonalSq;
        if (insideMiterOk) {
          if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {
            if (clockwise) {
              verts.push(imx, imy);
              verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
              verts.push(imx, imy);
              verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
            } else {
              verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
              verts.push(omx, omy);
              verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
              verts.push(omx, omy);
            }
            indexCount += 2;
          } else if (style.join === LINE_JOIN.ROUND) {
            if (clockwise) {
              verts.push(imx, imy);
              verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
              indexCount += round$1(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
              verts.push(imx, imy);
              verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
            } else {
              verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
              verts.push(omx, omy);
              indexCount += round$1(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
              verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
              verts.push(omx, omy);
            }
          } else {
            verts.push(imx, imy);
            verts.push(omx, omy);
          }
        } else {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)
            ;
          else if (style.join === LINE_JOIN.ROUND) {
            if (clockwise) {
              indexCount += round$1(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
            } else {
              indexCount += round$1(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
            }
          } else {
            if (clockwise) {
              verts.push(omx, omy);
              verts.push(omx, omy);
            } else {
              verts.push(imx, imy);
              verts.push(imx, imy);
            }
            indexCount += 2;
          }
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          indexCount += 2;
        }
      }
      x0 = points[(length - 2) * 2];
      y0 = points[(length - 2) * 2 + 1];
      x1 = points[(length - 1) * 2];
      y1 = points[(length - 1) * 2 + 1];
      perpx = -(y0 - y1);
      perpy = x0 - x1;
      dist = Math.sqrt(perpx * perpx + perpy * perpy);
      perpx /= dist;
      perpy /= dist;
      perpx *= width2;
      perpy *= width2;
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (!closedShape) {
        if (style.cap === LINE_CAP.ROUND) {
          indexCount += round$1(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
        } else if (style.cap === LINE_CAP.SQUARE) {
          indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
        }
      }
      var indices2 = graphicsGeometry.indices;
      var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;
      for (var i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
        x0 = verts[i2 * 2];
        y0 = verts[i2 * 2 + 1];
        x1 = verts[(i2 + 1) * 2];
        y1 = verts[(i2 + 1) * 2 + 1];
        x2 = verts[(i2 + 2) * 2];
        y2 = verts[(i2 + 2) * 2 + 1];
        if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
          continue;
        }
        indices2.push(i2, i2 + 1, i2 + 2);
      }
    }
    function buildNativeLine(graphicsData, graphicsGeometry) {
      var i2 = 0;
      var shape = graphicsData.shape;
      var points = graphicsData.points || shape.points;
      var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
      if (points.length === 0) {
        return;
      }
      var verts = graphicsGeometry.points;
      var indices2 = graphicsGeometry.indices;
      var length = points.length / 2;
      var startIndex = verts.length / 2;
      var currentIndex = startIndex;
      verts.push(points[0], points[1]);
      for (i2 = 1; i2 < length; i2++) {
        verts.push(points[i2 * 2], points[i2 * 2 + 1]);
        indices2.push(currentIndex, currentIndex + 1);
        currentIndex++;
      }
      if (closedShape) {
        indices2.push(currentIndex, startIndex);
      }
    }
    function buildLine(graphicsData, graphicsGeometry) {
      if (graphicsData.lineStyle.native) {
        buildNativeLine(graphicsData, graphicsGeometry);
      } else {
        buildNonNativeLine(graphicsData, graphicsGeometry);
      }
    }
    var Star = function(_super) {
      __extends$e(Star2, _super);
      function Star2(x2, y2, points, radius, innerRadius, rotation) {
        if (rotation === void 0) {
          rotation = 0;
        }
        var _this = this;
        innerRadius = innerRadius || radius / 2;
        var startAngle = -1 * Math.PI / 2 + rotation;
        var len = points * 2;
        var delta = PI_2 / len;
        var polygon = [];
        for (var i2 = 0; i2 < len; i2++) {
          var r2 = i2 % 2 ? innerRadius : radius;
          var angle = i2 * delta + startAngle;
          polygon.push(x2 + r2 * Math.cos(angle), y2 + r2 * Math.sin(angle));
        }
        _this = _super.call(this, polygon) || this;
        return _this;
      }
      return Star2;
    }(Polygon);
    var ArcUtils = function() {
      function ArcUtils2() {
      }
      ArcUtils2.curveTo = function(x1, y1, x2, y2, radius, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var a1 = fromY - y1;
        var b1 = fromX - x1;
        var a2 = y2 - y1;
        var b2 = x2 - x1;
        var mm = Math.abs(a1 * b2 - b1 * a2);
        if (mm < 1e-8 || radius === 0) {
          if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
            points.push(x1, y1);
          }
          return null;
        }
        var dd2 = a1 * a1 + b1 * b1;
        var cc2 = a2 * a2 + b2 * b2;
        var tt = a1 * a2 + b1 * b2;
        var k1 = radius * Math.sqrt(dd2) / mm;
        var k2 = radius * Math.sqrt(cc2) / mm;
        var j1 = k1 * tt / dd2;
        var j2 = k2 * tt / cc2;
        var cx = k1 * b2 + k2 * b1;
        var cy = k1 * a2 + k2 * a1;
        var px = b1 * (k2 + j1);
        var py = a1 * (k2 + j1);
        var qx = b2 * (k1 + j2);
        var qy = a2 * (k1 + j2);
        var startAngle = Math.atan2(py - cy, px - cx);
        var endAngle = Math.atan2(qy - cy, qx - cx);
        return {
          cx: cx + x1,
          cy: cy + y1,
          radius,
          startAngle,
          endAngle,
          anticlockwise: b1 * a2 > b2 * a1
        };
      };
      ArcUtils2.arc = function(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
        var sweep = endAngle - startAngle;
        var n2 = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
        var theta = sweep / (n2 * 2);
        var theta2 = theta * 2;
        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);
        var segMinus = n2 - 1;
        var remainder = segMinus % 1 / segMinus;
        for (var i2 = 0; i2 <= segMinus; ++i2) {
          var real = i2 + remainder * i2;
          var angle = theta + startAngle + theta2 * real;
          var c = Math.cos(angle);
          var s2 = -Math.sin(angle);
          points.push((cTheta * c + sTheta * s2) * radius + cx, (cTheta * -s2 + sTheta * c) * radius + cy);
        }
      };
      return ArcUtils2;
    }();
    var BezierUtils = function() {
      function BezierUtils2() {
      }
      BezierUtils2.curveLength = function(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
        var n2 = 10;
        var result2 = 0;
        var t2 = 0;
        var t22 = 0;
        var t3 = 0;
        var nt = 0;
        var nt2 = 0;
        var nt3 = 0;
        var x2 = 0;
        var y2 = 0;
        var dx = 0;
        var dy = 0;
        var prevX = fromX;
        var prevY = fromY;
        for (var i2 = 1; i2 <= n2; ++i2) {
          t2 = i2 / n2;
          t22 = t2 * t2;
          t3 = t22 * t2;
          nt = 1 - t2;
          nt2 = nt * nt;
          nt3 = nt2 * nt;
          x2 = nt3 * fromX + 3 * nt2 * t2 * cpX + 3 * nt * t22 * cpX2 + t3 * toX;
          y2 = nt3 * fromY + 3 * nt2 * t2 * cpY + 3 * nt * t22 * cpY2 + t3 * toY;
          dx = prevX - x2;
          dy = prevY - y2;
          prevX = x2;
          prevY = y2;
          result2 += Math.sqrt(dx * dx + dy * dy);
        }
        return result2;
      };
      BezierUtils2.curveTo = function(cpX, cpY, cpX2, cpY2, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        points.length -= 2;
        var n2 = GRAPHICS_CURVES._segmentsCount(BezierUtils2.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
        var dt = 0;
        var dt2 = 0;
        var dt3 = 0;
        var t2 = 0;
        var t3 = 0;
        points.push(fromX, fromY);
        for (var i2 = 1, j = 0; i2 <= n2; ++i2) {
          j = i2 / n2;
          dt = 1 - j;
          dt2 = dt * dt;
          dt3 = dt2 * dt;
          t2 = j * j;
          t3 = t2 * j;
          points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        }
      };
      return BezierUtils2;
    }();
    var QuadraticUtils = function() {
      function QuadraticUtils2() {
      }
      QuadraticUtils2.curveLength = function(fromX, fromY, cpX, cpY, toX, toY) {
        var ax = fromX - 2 * cpX + toX;
        var ay = fromY - 2 * cpY + toY;
        var bx = 2 * cpX - 2 * fromX;
        var by = 2 * cpY - 2 * fromY;
        var a2 = 4 * (ax * ax + ay * ay);
        var b = 4 * (ax * bx + ay * by);
        var c = bx * bx + by * by;
        var s2 = 2 * Math.sqrt(a2 + b + c);
        var a22 = Math.sqrt(a2);
        var a32 = 2 * a2 * a22;
        var c2 = 2 * Math.sqrt(c);
        var ba2 = b / a22;
        return (a32 * s2 + a22 * b * (s2 - c2) + (4 * c * a2 - b * b) * Math.log((2 * a22 + ba2 + s2) / (ba2 + c2))) / (4 * a32);
      };
      QuadraticUtils2.curveTo = function(cpX, cpY, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var n2 = GRAPHICS_CURVES._segmentsCount(QuadraticUtils2.curveLength(fromX, fromY, cpX, cpY, toX, toY));
        var xa2 = 0;
        var ya2 = 0;
        for (var i2 = 1; i2 <= n2; ++i2) {
          var j = i2 / n2;
          xa2 = fromX + (cpX - fromX) * j;
          ya2 = fromY + (cpY - fromY) * j;
          points.push(xa2 + (cpX + (toX - cpX) * j - xa2) * j, ya2 + (cpY + (toY - cpY) * j - ya2) * j);
        }
      };
      return QuadraticUtils2;
    }();
    var BatchPart = function() {
      function BatchPart2() {
        this.reset();
      }
      BatchPart2.prototype.begin = function(style, startIndex, attribStart) {
        this.reset();
        this.style = style;
        this.start = startIndex;
        this.attribStart = attribStart;
      };
      BatchPart2.prototype.end = function(endIndex, endAttrib) {
        this.attribSize = endAttrib - this.attribStart;
        this.size = endIndex - this.start;
      };
      BatchPart2.prototype.reset = function() {
        this.style = null;
        this.size = 0;
        this.start = 0;
        this.attribStart = 0;
        this.attribSize = 0;
      };
      return BatchPart2;
    }();
    var _a;
    var FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);
    var BATCH_POOL = [];
    var DRAW_CALL_POOL = [];
    var GraphicsData = function() {
      function GraphicsData2(shape, fillStyle, lineStyle, matrix) {
        if (fillStyle === void 0) {
          fillStyle = null;
        }
        if (lineStyle === void 0) {
          lineStyle = null;
        }
        if (matrix === void 0) {
          matrix = null;
        }
        this.shape = shape;
        this.lineStyle = lineStyle;
        this.fillStyle = fillStyle;
        this.matrix = matrix;
        this.type = shape.type;
        this.points = [];
        this.holes = [];
      }
      GraphicsData2.prototype.clone = function() {
        return new GraphicsData2(this.shape, this.fillStyle, this.lineStyle, this.matrix);
      };
      GraphicsData2.prototype.destroy = function() {
        this.shape = null;
        this.holes.length = 0;
        this.holes = null;
        this.points.length = 0;
        this.points = null;
        this.lineStyle = null;
        this.fillStyle = null;
      };
      return GraphicsData2;
    }();
    var tmpPoint = new Point();
    var tmpBounds = new Bounds();
    var GraphicsGeometry = function(_super) {
      __extends$e(GraphicsGeometry2, _super);
      function GraphicsGeometry2() {
        var _this = _super.call(this) || this;
        _this.uvsFloat32 = null;
        _this.indicesUint16 = null;
        _this.points = [];
        _this.colors = [];
        _this.uvs = [];
        _this.indices = [];
        _this.textureIds = [];
        _this.graphicsData = [];
        _this.dirty = 0;
        _this.batchDirty = -1;
        _this.cacheDirty = -1;
        _this.clearDirty = 0;
        _this.drawCalls = [];
        _this.batches = [];
        _this.shapeIndex = 0;
        _this._bounds = new Bounds();
        _this.boundsDirty = -1;
        _this.boundsPadding = 0;
        _this.batchable = false;
        _this.indicesUint16 = null;
        _this.uvsFloat32 = null;
        _this.closePointEps = 1e-4;
        return _this;
      }
      Object.defineProperty(GraphicsGeometry2.prototype, "bounds", {
        get: function() {
          if (this.boundsDirty !== this.dirty) {
            this.boundsDirty = this.dirty;
            this.calculateBounds();
          }
          return this._bounds;
        },
        enumerable: false,
        configurable: true
      });
      GraphicsGeometry2.prototype.invalidate = function() {
        this.boundsDirty = -1;
        this.dirty++;
        this.batchDirty++;
        this.shapeIndex = 0;
        this.points.length = 0;
        this.colors.length = 0;
        this.uvs.length = 0;
        this.indices.length = 0;
        this.textureIds.length = 0;
        for (var i2 = 0; i2 < this.drawCalls.length; i2++) {
          this.drawCalls[i2].texArray.clear();
          DRAW_CALL_POOL.push(this.drawCalls[i2]);
        }
        this.drawCalls.length = 0;
        for (var i2 = 0; i2 < this.batches.length; i2++) {
          var batchPart = this.batches[i2];
          batchPart.reset();
          BATCH_POOL.push(batchPart);
        }
        this.batches.length = 0;
      };
      GraphicsGeometry2.prototype.clear = function() {
        if (this.graphicsData.length > 0) {
          this.invalidate();
          this.clearDirty++;
          this.graphicsData.length = 0;
        }
        return this;
      };
      GraphicsGeometry2.prototype.drawShape = function(shape, fillStyle, lineStyle, matrix) {
        if (fillStyle === void 0) {
          fillStyle = null;
        }
        if (lineStyle === void 0) {
          lineStyle = null;
        }
        if (matrix === void 0) {
          matrix = null;
        }
        var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
        this.graphicsData.push(data);
        this.dirty++;
        return this;
      };
      GraphicsGeometry2.prototype.drawHole = function(shape, matrix) {
        if (matrix === void 0) {
          matrix = null;
        }
        if (!this.graphicsData.length) {
          return null;
        }
        var data = new GraphicsData(shape, null, null, matrix);
        var lastShape = this.graphicsData[this.graphicsData.length - 1];
        data.lineStyle = lastShape.lineStyle;
        lastShape.holes.push(data);
        this.dirty++;
        return this;
      };
      GraphicsGeometry2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        for (var i2 = 0; i2 < this.graphicsData.length; ++i2) {
          this.graphicsData[i2].destroy();
        }
        this.points.length = 0;
        this.points = null;
        this.colors.length = 0;
        this.colors = null;
        this.uvs.length = 0;
        this.uvs = null;
        this.indices.length = 0;
        this.indices = null;
        this.indexBuffer.destroy();
        this.indexBuffer = null;
        this.graphicsData.length = 0;
        this.graphicsData = null;
        this.drawCalls.length = 0;
        this.drawCalls = null;
        this.batches.length = 0;
        this.batches = null;
        this._bounds = null;
      };
      GraphicsGeometry2.prototype.containsPoint = function(point) {
        var graphicsData = this.graphicsData;
        for (var i2 = 0; i2 < graphicsData.length; ++i2) {
          var data = graphicsData[i2];
          if (!data.fillStyle.visible) {
            continue;
          }
          if (data.shape) {
            if (data.matrix) {
              data.matrix.applyInverse(point, tmpPoint);
            } else {
              tmpPoint.copyFrom(point);
            }
            if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
              var hitHole = false;
              if (data.holes) {
                for (var i_1 = 0; i_1 < data.holes.length; i_1++) {
                  var hole = data.holes[i_1];
                  if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                    hitHole = true;
                    break;
                  }
                }
              }
              if (!hitHole) {
                return true;
              }
            }
          }
        }
        return false;
      };
      GraphicsGeometry2.prototype.updateBatches = function(allow32Indices) {
        if (!this.graphicsData.length) {
          this.batchable = true;
          return;
        }
        if (!this.validateBatching()) {
          return;
        }
        this.cacheDirty = this.dirty;
        var uvs = this.uvs;
        var graphicsData = this.graphicsData;
        var batchPart = null;
        var currentStyle = null;
        if (this.batches.length > 0) {
          batchPart = this.batches[this.batches.length - 1];
          currentStyle = batchPart.style;
        }
        for (var i2 = this.shapeIndex; i2 < graphicsData.length; i2++) {
          this.shapeIndex++;
          var data = graphicsData[i2];
          var fillStyle = data.fillStyle;
          var lineStyle = data.lineStyle;
          var command = FILL_COMMANDS[data.type];
          command.build(data);
          if (data.matrix) {
            this.transformPoints(data.points, data.matrix);
          }
          for (var j = 0; j < 2; j++) {
            var style = j === 0 ? fillStyle : lineStyle;
            if (!style.visible) {
              continue;
            }
            var nextTexture = style.texture.baseTexture;
            var index_1 = this.indices.length;
            var attribIndex = this.points.length / 2;
            nextTexture.wrapMode = WRAP_MODES$1.REPEAT;
            if (j === 0) {
              this.processFill(data);
            } else {
              this.processLine(data);
            }
            var size2 = this.points.length / 2 - attribIndex;
            if (size2 === 0) {
              continue;
            }
            if (batchPart && !this._compareStyles(currentStyle, style)) {
              batchPart.end(index_1, attribIndex);
              batchPart = null;
            }
            if (!batchPart) {
              batchPart = BATCH_POOL.pop() || new BatchPart();
              batchPart.begin(style, index_1, attribIndex);
              this.batches.push(batchPart);
              currentStyle = style;
            }
            this.addUvs(this.points, uvs, style.texture, attribIndex, size2, style.matrix);
          }
        }
        var index2 = this.indices.length;
        var attrib = this.points.length / 2;
        if (batchPart) {
          batchPart.end(index2, attrib);
        }
        if (this.batches.length === 0) {
          this.batchable = true;
          return;
        }
        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) {
          this.indicesUint16.set(this.indices);
        } else {
          var need32 = attrib > 65535 && allow32Indices;
          this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
        }
        this.batchable = this.isBatchable();
        if (this.batchable) {
          this.packBatches();
        } else {
          this.buildDrawCalls();
        }
      };
      GraphicsGeometry2.prototype._compareStyles = function(styleA, styleB) {
        if (!styleA || !styleB) {
          return false;
        }
        if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
          return false;
        }
        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
          return false;
        }
        if (!!styleA.native !== !!styleB.native) {
          return false;
        }
        return true;
      };
      GraphicsGeometry2.prototype.validateBatching = function() {
        if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
          return false;
        }
        for (var i2 = 0, l2 = this.graphicsData.length; i2 < l2; i2++) {
          var data = this.graphicsData[i2];
          var fill = data.fillStyle;
          var line = data.lineStyle;
          if (fill && !fill.texture.baseTexture.valid) {
            return false;
          }
          if (line && !line.texture.baseTexture.valid) {
            return false;
          }
        }
        return true;
      };
      GraphicsGeometry2.prototype.packBatches = function() {
        this.batchDirty++;
        this.uvsFloat32 = new Float32Array(this.uvs);
        var batches = this.batches;
        for (var i2 = 0, l2 = batches.length; i2 < l2; i2++) {
          var batch = batches[i2];
          for (var j = 0; j < batch.size; j++) {
            var index2 = batch.start + j;
            this.indicesUint16[index2] = this.indicesUint16[index2] - batch.attribStart;
          }
        }
      };
      GraphicsGeometry2.prototype.isBatchable = function() {
        if (this.points.length > 65535 * 2) {
          return false;
        }
        var batches = this.batches;
        for (var i2 = 0; i2 < batches.length; i2++) {
          if (batches[i2].style.native) {
            return false;
          }
        }
        return this.points.length < GraphicsGeometry2.BATCHABLE_SIZE * 2;
      };
      GraphicsGeometry2.prototype.buildDrawCalls = function() {
        var TICK = ++BaseTexture._globalBatch;
        for (var i2 = 0; i2 < this.drawCalls.length; i2++) {
          this.drawCalls[i2].texArray.clear();
          DRAW_CALL_POOL.push(this.drawCalls[i2]);
        }
        this.drawCalls.length = 0;
        var colors = this.colors;
        var textureIds = this.textureIds;
        var currentGroup = DRAW_CALL_POOL.pop();
        if (!currentGroup) {
          currentGroup = new BatchDrawCall();
          currentGroup.texArray = new BatchTextureArray();
        }
        currentGroup.texArray.count = 0;
        currentGroup.start = 0;
        currentGroup.size = 0;
        currentGroup.type = DRAW_MODES$1.TRIANGLES;
        var textureCount = 0;
        var currentTexture = null;
        var textureId = 0;
        var native = false;
        var drawMode = DRAW_MODES$1.TRIANGLES;
        var index2 = 0;
        this.drawCalls.push(currentGroup);
        for (var i2 = 0; i2 < this.batches.length; i2++) {
          var data = this.batches[i2];
          var MAX_TEXTURES = 8;
          var style = data.style;
          var nextTexture = style.texture.baseTexture;
          if (native !== !!style.native) {
            native = !!style.native;
            drawMode = native ? DRAW_MODES$1.LINES : DRAW_MODES$1.TRIANGLES;
            currentTexture = null;
            textureCount = MAX_TEXTURES;
            TICK++;
          }
          if (currentTexture !== nextTexture) {
            currentTexture = nextTexture;
            if (nextTexture._batchEnabled !== TICK) {
              if (textureCount === MAX_TEXTURES) {
                TICK++;
                textureCount = 0;
                if (currentGroup.size > 0) {
                  currentGroup = DRAW_CALL_POOL.pop();
                  if (!currentGroup) {
                    currentGroup = new BatchDrawCall();
                    currentGroup.texArray = new BatchTextureArray();
                  }
                  this.drawCalls.push(currentGroup);
                }
                currentGroup.start = index2;
                currentGroup.size = 0;
                currentGroup.texArray.count = 0;
                currentGroup.type = drawMode;
              }
              nextTexture.touched = 1;
              nextTexture._batchEnabled = TICK;
              nextTexture._batchLocation = textureCount;
              nextTexture.wrapMode = 10497;
              currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
              textureCount++;
            }
          }
          currentGroup.size += data.size;
          index2 += data.size;
          textureId = nextTexture._batchLocation;
          this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
          this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
        }
        BaseTexture._globalBatch = TICK;
        this.packAttributes();
      };
      GraphicsGeometry2.prototype.packAttributes = function() {
        var verts = this.points;
        var uvs = this.uvs;
        var colors = this.colors;
        var textureIds = this.textureIds;
        var glPoints = new ArrayBuffer(verts.length * 3 * 4);
        var f32 = new Float32Array(glPoints);
        var u32 = new Uint32Array(glPoints);
        var p2 = 0;
        for (var i2 = 0; i2 < verts.length / 2; i2++) {
          f32[p2++] = verts[i2 * 2];
          f32[p2++] = verts[i2 * 2 + 1];
          f32[p2++] = uvs[i2 * 2];
          f32[p2++] = uvs[i2 * 2 + 1];
          u32[p2++] = colors[i2];
          f32[p2++] = textureIds[i2];
        }
        this._buffer.update(glPoints);
        this._indexBuffer.update(this.indicesUint16);
      };
      GraphicsGeometry2.prototype.processFill = function(data) {
        if (data.holes.length) {
          this.processHoles(data.holes);
          buildPoly.triangulate(data, this);
        } else {
          var command = FILL_COMMANDS[data.type];
          command.triangulate(data, this);
        }
      };
      GraphicsGeometry2.prototype.processLine = function(data) {
        buildLine(data, this);
        for (var i2 = 0; i2 < data.holes.length; i2++) {
          buildLine(data.holes[i2], this);
        }
      };
      GraphicsGeometry2.prototype.processHoles = function(holes) {
        for (var i2 = 0; i2 < holes.length; i2++) {
          var hole = holes[i2];
          var command = FILL_COMMANDS[hole.type];
          command.build(hole);
          if (hole.matrix) {
            this.transformPoints(hole.points, hole.matrix);
          }
        }
      };
      GraphicsGeometry2.prototype.calculateBounds = function() {
        var bounds = this._bounds;
        var sequenceBounds = tmpBounds;
        var curMatrix = Matrix.IDENTITY;
        this._bounds.clear();
        sequenceBounds.clear();
        for (var i2 = 0; i2 < this.graphicsData.length; i2++) {
          var data = this.graphicsData[i2];
          var shape = data.shape;
          var type = data.type;
          var lineStyle = data.lineStyle;
          var nextMatrix = data.matrix || Matrix.IDENTITY;
          var lineWidth = 0;
          if (lineStyle && lineStyle.visible) {
            var alignment = lineStyle.alignment;
            lineWidth = lineStyle.width;
            if (type === SHAPES.POLY) {
              lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));
            } else {
              lineWidth = lineWidth * Math.max(0, alignment);
            }
          }
          if (curMatrix !== nextMatrix) {
            if (!sequenceBounds.isEmpty()) {
              bounds.addBoundsMatrix(sequenceBounds, curMatrix);
              sequenceBounds.clear();
            }
            curMatrix = nextMatrix;
          }
          if (type === SHAPES.RECT || type === SHAPES.RREC) {
            var rect = shape;
            sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);
          } else if (type === SHAPES.CIRC) {
            var circle = shape;
            sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);
          } else if (type === SHAPES.ELIP) {
            var ellipse = shape;
            sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);
          } else {
            var poly = shape;
            bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);
          }
        }
        if (!sequenceBounds.isEmpty()) {
          bounds.addBoundsMatrix(sequenceBounds, curMatrix);
        }
        bounds.pad(this.boundsPadding, this.boundsPadding);
      };
      GraphicsGeometry2.prototype.transformPoints = function(points, matrix) {
        for (var i2 = 0; i2 < points.length / 2; i2++) {
          var x2 = points[i2 * 2];
          var y2 = points[i2 * 2 + 1];
          points[i2 * 2] = matrix.a * x2 + matrix.c * y2 + matrix.tx;
          points[i2 * 2 + 1] = matrix.b * x2 + matrix.d * y2 + matrix.ty;
        }
      };
      GraphicsGeometry2.prototype.addColors = function(colors, color, alpha, size2, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        var rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);
        var rgba = premultiplyTint(rgb, alpha);
        colors.length = Math.max(colors.length, offset2 + size2);
        for (var i2 = 0; i2 < size2; i2++) {
          colors[offset2 + i2] = rgba;
        }
      };
      GraphicsGeometry2.prototype.addTextureIds = function(textureIds, id2, size2, offset2) {
        if (offset2 === void 0) {
          offset2 = 0;
        }
        textureIds.length = Math.max(textureIds.length, offset2 + size2);
        for (var i2 = 0; i2 < size2; i2++) {
          textureIds[offset2 + i2] = id2;
        }
      };
      GraphicsGeometry2.prototype.addUvs = function(verts, uvs, texture, start, size2, matrix) {
        if (matrix === void 0) {
          matrix = null;
        }
        var index2 = 0;
        var uvsStart = uvs.length;
        var frame = texture.frame;
        while (index2 < size2) {
          var x2 = verts[(start + index2) * 2];
          var y2 = verts[(start + index2) * 2 + 1];
          if (matrix) {
            var nx = matrix.a * x2 + matrix.c * y2 + matrix.tx;
            y2 = matrix.b * x2 + matrix.d * y2 + matrix.ty;
            x2 = nx;
          }
          index2++;
          uvs.push(x2 / frame.width, y2 / frame.height);
        }
        var baseTexture = texture.baseTexture;
        if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
          this.adjustUvs(uvs, texture, uvsStart, size2);
        }
      };
      GraphicsGeometry2.prototype.adjustUvs = function(uvs, texture, start, size2) {
        var baseTexture = texture.baseTexture;
        var eps = 1e-6;
        var finish = start + size2 * 2;
        var frame = texture.frame;
        var scaleX = frame.width / baseTexture.width;
        var scaleY = frame.height / baseTexture.height;
        var offsetX = frame.x / frame.width;
        var offsetY = frame.y / frame.height;
        var minX = Math.floor(uvs[start] + eps);
        var minY = Math.floor(uvs[start + 1] + eps);
        for (var i2 = start + 2; i2 < finish; i2 += 2) {
          minX = Math.min(minX, Math.floor(uvs[i2] + eps));
          minY = Math.min(minY, Math.floor(uvs[i2 + 1] + eps));
        }
        offsetX -= minX;
        offsetY -= minY;
        for (var i2 = start; i2 < finish; i2 += 2) {
          uvs[i2] = (uvs[i2] + offsetX) * scaleX;
          uvs[i2 + 1] = (uvs[i2 + 1] + offsetY) * scaleY;
        }
      };
      GraphicsGeometry2.BATCHABLE_SIZE = 100;
      return GraphicsGeometry2;
    }(BatchGeometry);
    var LineStyle = function(_super) {
      __extends$e(LineStyle2, _super);
      function LineStyle2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.width = 0;
        _this.alignment = 0.5;
        _this.native = false;
        _this.cap = LINE_CAP.BUTT;
        _this.join = LINE_JOIN.MITER;
        _this.miterLimit = 10;
        return _this;
      }
      LineStyle2.prototype.clone = function() {
        var obj = new LineStyle2();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        obj.width = this.width;
        obj.alignment = this.alignment;
        obj.native = this.native;
        obj.cap = this.cap;
        obj.join = this.join;
        obj.miterLimit = this.miterLimit;
        return obj;
      };
      LineStyle2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this.color = 0;
        this.alignment = 0.5;
        this.width = 0;
        this.native = false;
      };
      return LineStyle2;
    }(FillStyle);
    var temp = new Float32Array(3);
    var DEFAULT_SHADERS = {};
    var Graphics = function(_super) {
      __extends$e(Graphics2, _super);
      function Graphics2(geometry) {
        if (geometry === void 0) {
          geometry = null;
        }
        var _this = _super.call(this) || this;
        _this._geometry = geometry || new GraphicsGeometry();
        _this._geometry.refCount++;
        _this.shader = null;
        _this.state = State.for2d();
        _this._fillStyle = new FillStyle();
        _this._lineStyle = new LineStyle();
        _this._matrix = null;
        _this._holeMode = false;
        _this.currentPath = null;
        _this.batches = [];
        _this.batchTint = -1;
        _this.batchDirty = -1;
        _this.vertexData = null;
        _this.pluginName = "batch";
        _this._transformID = -1;
        _this.tint = 16777215;
        _this.blendMode = BLEND_MODES$1.NORMAL;
        return _this;
      }
      Object.defineProperty(Graphics2.prototype, "geometry", {
        get: function() {
          return this._geometry;
        },
        enumerable: false,
        configurable: true
      });
      Graphics2.prototype.clone = function() {
        this.finishPoly();
        return new Graphics2(this._geometry);
      };
      Object.defineProperty(Graphics2.prototype, "blendMode", {
        get: function() {
          return this.state.blendMode;
        },
        set: function(value2) {
          this.state.blendMode = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Graphics2.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value2) {
          this._tint = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Graphics2.prototype, "fill", {
        get: function() {
          return this._fillStyle;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Graphics2.prototype, "line", {
        get: function() {
          return this._lineStyle;
        },
        enumerable: false,
        configurable: true
      });
      Graphics2.prototype.lineStyle = function(options) {
        if (options === void 0) {
          options = null;
        }
        if (typeof options === "number") {
          var args = arguments;
          options = {
            width: args[0] || 0,
            color: args[1] || 0,
            alpha: args[2] !== void 0 ? args[2] : 1,
            alignment: args[3] !== void 0 ? args[3] : 0.5,
            native: !!args[4]
          };
        }
        return this.lineTextureStyle(options);
      };
      Graphics2.prototype.lineTextureStyle = function(options) {
        if (typeof options === "number") {
          deprecation("v5.2.0", "Please use object-based options for Graphics#lineTextureStyle");
          var _a2 = arguments, width2 = _a2[0], texture = _a2[1], color = _a2[2], alpha = _a2[3], matrix = _a2[4], alignment = _a2[5], native = _a2[6];
          options = { width: width2, texture, color, alpha, matrix, alignment, native };
          Object.keys(options).forEach(function(key) {
            return options[key] === void 0 && delete options[key];
          });
        }
        options = Object.assign({
          width: 0,
          texture: Texture.WHITE,
          color: options && options.texture ? 16777215 : 0,
          alpha: 1,
          matrix: null,
          alignment: 0.5,
          native: false,
          cap: LINE_CAP.BUTT,
          join: LINE_JOIN.MITER,
          miterLimit: 10
        }, options);
        if (this.currentPath) {
          this.startPoly();
        }
        var visible = options.width > 0 && options.alpha > 0;
        if (!visible) {
          this._lineStyle.reset();
        } else {
          if (options.matrix) {
            options.matrix = options.matrix.clone();
            options.matrix.invert();
          }
          Object.assign(this._lineStyle, { visible }, options);
        }
        return this;
      };
      Graphics2.prototype.startPoly = function() {
        if (this.currentPath) {
          var points = this.currentPath.points;
          var len = this.currentPath.points.length;
          if (len > 2) {
            this.drawShape(this.currentPath);
            this.currentPath = new Polygon();
            this.currentPath.closeStroke = false;
            this.currentPath.points.push(points[len - 2], points[len - 1]);
          }
        } else {
          this.currentPath = new Polygon();
          this.currentPath.closeStroke = false;
        }
      };
      Graphics2.prototype.finishPoly = function() {
        if (this.currentPath) {
          if (this.currentPath.points.length > 2) {
            this.drawShape(this.currentPath);
            this.currentPath = null;
          } else {
            this.currentPath.points.length = 0;
          }
        }
      };
      Graphics2.prototype.moveTo = function(x2, y2) {
        this.startPoly();
        this.currentPath.points[0] = x2;
        this.currentPath.points[1] = y2;
        return this;
      };
      Graphics2.prototype.lineTo = function(x2, y2) {
        if (!this.currentPath) {
          this.moveTo(0, 0);
        }
        var points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        if (fromX !== x2 || fromY !== y2) {
          points.push(x2, y2);
        }
        return this;
      };
      Graphics2.prototype._initCurve = function(x2, y2) {
        if (x2 === void 0) {
          x2 = 0;
        }
        if (y2 === void 0) {
          y2 = 0;
        }
        if (this.currentPath) {
          if (this.currentPath.points.length === 0) {
            this.currentPath.points = [x2, y2];
          }
        } else {
          this.moveTo(x2, y2);
        }
      };
      Graphics2.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
        this._initCurve();
        var points = this.currentPath.points;
        if (points.length === 0) {
          this.moveTo(0, 0);
        }
        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
        return this;
      };
      Graphics2.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
        this._initCurve();
        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
        return this;
      };
      Graphics2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
        this._initCurve(x1, y1);
        var points = this.currentPath.points;
        var result2 = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
        if (result2) {
          var cx = result2.cx, cy = result2.cy, radius_1 = result2.radius, startAngle = result2.startAngle, endAngle = result2.endAngle, anticlockwise = result2.anticlockwise;
          this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);
        }
        return this;
      };
      Graphics2.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
        if (anticlockwise === void 0) {
          anticlockwise = false;
        }
        if (startAngle === endAngle) {
          return this;
        }
        if (!anticlockwise && endAngle <= startAngle) {
          endAngle += PI_2;
        } else if (anticlockwise && startAngle <= endAngle) {
          startAngle += PI_2;
        }
        var sweep = endAngle - startAngle;
        if (sweep === 0) {
          return this;
        }
        var startX = cx + Math.cos(startAngle) * radius;
        var startY = cy + Math.sin(startAngle) * radius;
        var eps = this._geometry.closePointEps;
        var points = this.currentPath ? this.currentPath.points : null;
        if (points) {
          var xDiff = Math.abs(points[points.length - 2] - startX);
          var yDiff = Math.abs(points[points.length - 1] - startY);
          if (xDiff < eps && yDiff < eps)
            ;
          else {
            points.push(startX, startY);
          }
        } else {
          this.moveTo(startX, startY);
          points = this.currentPath.points;
        }
        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
        return this;
      };
      Graphics2.prototype.beginFill = function(color, alpha) {
        if (color === void 0) {
          color = 0;
        }
        if (alpha === void 0) {
          alpha = 1;
        }
        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
      };
      Graphics2.prototype.beginTextureFill = function(options) {
        if (options instanceof Texture) {
          deprecation("v5.2.0", "Please use object-based options for Graphics#beginTextureFill");
          var _a2 = arguments, texture = _a2[0], color = _a2[1], alpha = _a2[2], matrix = _a2[3];
          options = { texture, color, alpha, matrix };
          Object.keys(options).forEach(function(key) {
            return options[key] === void 0 && delete options[key];
          });
        }
        options = Object.assign({
          texture: Texture.WHITE,
          color: 16777215,
          alpha: 1,
          matrix: null
        }, options);
        if (this.currentPath) {
          this.startPoly();
        }
        var visible = options.alpha > 0;
        if (!visible) {
          this._fillStyle.reset();
        } else {
          if (options.matrix) {
            options.matrix = options.matrix.clone();
            options.matrix.invert();
          }
          Object.assign(this._fillStyle, { visible }, options);
        }
        return this;
      };
      Graphics2.prototype.endFill = function() {
        this.finishPoly();
        this._fillStyle.reset();
        return this;
      };
      Graphics2.prototype.drawRect = function(x2, y2, width2, height2) {
        return this.drawShape(new Rectangle(x2, y2, width2, height2));
      };
      Graphics2.prototype.drawRoundedRect = function(x2, y2, width2, height2, radius) {
        return this.drawShape(new RoundedRectangle(x2, y2, width2, height2, radius));
      };
      Graphics2.prototype.drawCircle = function(x2, y2, radius) {
        return this.drawShape(new Circle(x2, y2, radius));
      };
      Graphics2.prototype.drawEllipse = function(x2, y2, width2, height2) {
        return this.drawShape(new Ellipse(x2, y2, width2, height2));
      };
      Graphics2.prototype.drawPolygon = function() {
        var arguments$1 = arguments;
        var path = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          path[_i] = arguments$1[_i];
        }
        var points;
        var closeStroke = true;
        var poly = path[0];
        if (poly.points) {
          closeStroke = poly.closeStroke;
          points = poly.points;
        } else if (Array.isArray(path[0])) {
          points = path[0];
        } else {
          points = path;
        }
        var shape = new Polygon(points);
        shape.closeStroke = closeStroke;
        this.drawShape(shape);
        return this;
      };
      Graphics2.prototype.drawShape = function(shape) {
        if (!this._holeMode) {
          this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
        } else {
          this._geometry.drawHole(shape, this._matrix);
        }
        return this;
      };
      Graphics2.prototype.drawStar = function(x2, y2, points, radius, innerRadius, rotation) {
        if (rotation === void 0) {
          rotation = 0;
        }
        return this.drawPolygon(new Star(x2, y2, points, radius, innerRadius, rotation));
      };
      Graphics2.prototype.clear = function() {
        this._geometry.clear();
        this._lineStyle.reset();
        this._fillStyle.reset();
        this._boundsID++;
        this._matrix = null;
        this._holeMode = false;
        this.currentPath = null;
        return this;
      };
      Graphics2.prototype.isFastRect = function() {
        var data = this._geometry.graphicsData;
        return data.length === 1 && data[0].shape.type === SHAPES.RECT && !(data[0].lineStyle.visible && data[0].lineStyle.width);
      };
      Graphics2.prototype._render = function(renderer) {
        this.finishPoly();
        var geometry = this._geometry;
        var hasuint32 = renderer.context.supports.uint32Indices;
        geometry.updateBatches(hasuint32);
        if (geometry.batchable) {
          if (this.batchDirty !== geometry.batchDirty) {
            this._populateBatches();
          }
          this._renderBatched(renderer);
        } else {
          renderer.batch.flush();
          this._renderDirect(renderer);
        }
      };
      Graphics2.prototype._populateBatches = function() {
        var geometry = this._geometry;
        var blendMode = this.blendMode;
        var len = geometry.batches.length;
        this.batchTint = -1;
        this._transformID = -1;
        this.batchDirty = geometry.batchDirty;
        this.batches.length = len;
        this.vertexData = new Float32Array(geometry.points);
        for (var i2 = 0; i2 < len; i2++) {
          var gI = geometry.batches[i2];
          var color = gI.style.color;
          var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
          var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
          var indices2 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
          var batch = {
            vertexData,
            blendMode,
            indices: indices2,
            uvs,
            _batchRGB: hex2rgb(color),
            _tintRGB: color,
            _texture: gI.style.texture,
            alpha: gI.style.alpha,
            worldAlpha: 1
          };
          this.batches[i2] = batch;
        }
      };
      Graphics2.prototype._renderBatched = function(renderer) {
        if (!this.batches.length) {
          return;
        }
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        this.calculateVertices();
        this.calculateTints();
        for (var i2 = 0, l2 = this.batches.length; i2 < l2; i2++) {
          var batch = this.batches[i2];
          batch.worldAlpha = this.worldAlpha * batch.alpha;
          renderer.plugins[this.pluginName].render(batch);
        }
      };
      Graphics2.prototype._renderDirect = function(renderer) {
        var shader = this._resolveDirectShader(renderer);
        var geometry = this._geometry;
        var tint = this.tint;
        var worldAlpha = this.worldAlpha;
        var uniforms = shader.uniforms;
        var drawCalls = geometry.drawCalls;
        uniforms.translationMatrix = this.transform.worldTransform;
        uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
        uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
        uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
        uniforms.tint[3] = worldAlpha;
        renderer.shader.bind(shader);
        renderer.geometry.bind(geometry, shader);
        renderer.state.set(this.state);
        for (var i2 = 0, l2 = drawCalls.length; i2 < l2; i2++) {
          this._renderDrawCallDirect(renderer, geometry.drawCalls[i2]);
        }
      };
      Graphics2.prototype._renderDrawCallDirect = function(renderer, drawCall) {
        var texArray = drawCall.texArray, type = drawCall.type, size2 = drawCall.size, start = drawCall.start;
        var groupTextureCount = texArray.count;
        for (var j = 0; j < groupTextureCount; j++) {
          renderer.texture.bind(texArray.elements[j], j);
        }
        renderer.geometry.draw(type, size2, start);
      };
      Graphics2.prototype._resolveDirectShader = function(renderer) {
        var shader = this.shader;
        var pluginName = this.pluginName;
        if (!shader) {
          if (!DEFAULT_SHADERS[pluginName]) {
            var MAX_TEXTURES = renderer.plugins.batch.MAX_TEXTURES;
            var sampleValues = new Int32Array(MAX_TEXTURES);
            for (var i2 = 0; i2 < MAX_TEXTURES; i2++) {
              sampleValues[i2] = i2;
            }
            var uniforms = {
              tint: new Float32Array([1, 1, 1, 1]),
              translationMatrix: new Matrix(),
              default: UniformGroup.from({ uSamplers: sampleValues }, true)
            };
            var program = renderer.plugins[pluginName]._shader.program;
            DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
          }
          shader = DEFAULT_SHADERS[pluginName];
        }
        return shader;
      };
      Graphics2.prototype._calculateBounds = function() {
        this.finishPoly();
        var geometry = this._geometry;
        if (!geometry.graphicsData.length) {
          return;
        }
        var _a2 = geometry.bounds, minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY = _a2.maxY;
        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
      };
      Graphics2.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, Graphics2._TEMP_POINT);
        return this._geometry.containsPoint(Graphics2._TEMP_POINT);
      };
      Graphics2.prototype.calculateTints = function() {
        if (this.batchTint !== this.tint) {
          this.batchTint = this.tint;
          var tintRGB = hex2rgb(this.tint, temp);
          for (var i2 = 0; i2 < this.batches.length; i2++) {
            var batch = this.batches[i2];
            var batchTint = batch._batchRGB;
            var r2 = tintRGB[0] * batchTint[0] * 255;
            var g2 = tintRGB[1] * batchTint[1] * 255;
            var b = tintRGB[2] * batchTint[2] * 255;
            var color = (r2 << 16) + (g2 << 8) + (b | 0);
            batch._tintRGB = (color >> 16) + (color & 65280) + ((color & 255) << 16);
          }
        }
      };
      Graphics2.prototype.calculateVertices = function() {
        var wtID = this.transform._worldID;
        if (this._transformID === wtID) {
          return;
        }
        this._transformID = wtID;
        var wt = this.transform.worldTransform;
        var a2 = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var data = this._geometry.points;
        var vertexData = this.vertexData;
        var count = 0;
        for (var i2 = 0; i2 < data.length; i2 += 2) {
          var x2 = data[i2];
          var y2 = data[i2 + 1];
          vertexData[count++] = a2 * x2 + c * y2 + tx;
          vertexData[count++] = d * y2 + b * x2 + ty;
        }
      };
      Graphics2.prototype.closePath = function() {
        var currentPath = this.currentPath;
        if (currentPath) {
          currentPath.closeStroke = true;
        }
        return this;
      };
      Graphics2.prototype.setMatrix = function(matrix) {
        this._matrix = matrix;
        return this;
      };
      Graphics2.prototype.beginHole = function() {
        this.finishPoly();
        this._holeMode = true;
        return this;
      };
      Graphics2.prototype.endHole = function() {
        this.finishPoly();
        this._holeMode = false;
        return this;
      };
      Graphics2.prototype.destroy = function(options) {
        this._geometry.refCount--;
        if (this._geometry.refCount === 0) {
          this._geometry.dispose();
        }
        this._matrix = null;
        this.currentPath = null;
        this._lineStyle.destroy();
        this._lineStyle = null;
        this._fillStyle.destroy();
        this._fillStyle = null;
        this._geometry = null;
        this.shader = null;
        this.vertexData = null;
        this.batches.length = 0;
        this.batches = null;
        _super.prototype.destroy.call(this, options);
      };
      Graphics2._TEMP_POINT = new Point();
      return Graphics2;
    }(Container);
    /*!
     * @pixi/sprite - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/sprite is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$d = function(d, b) {
      extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$d(d, b);
    };
    function __extends$d(d, b) {
      extendStatics$d(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var tempPoint$2 = new Point();
    var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
    var Sprite = function(_super) {
      __extends$d(Sprite2, _super);
      function Sprite2(texture) {
        var _this = _super.call(this) || this;
        _this._anchor = new ObservablePoint(_this._onAnchorUpdate, _this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
        _this._texture = null;
        _this._width = 0;
        _this._height = 0;
        _this._tint = null;
        _this._tintRGB = null;
        _this.tint = 16777215;
        _this.blendMode = BLEND_MODES$1.NORMAL;
        _this._cachedTint = 16777215;
        _this.uvs = null;
        _this.texture = texture || Texture.EMPTY;
        _this.vertexData = new Float32Array(8);
        _this.vertexTrimmedData = null;
        _this._transformID = -1;
        _this._textureID = -1;
        _this._transformTrimmedID = -1;
        _this._textureTrimmedID = -1;
        _this.indices = indices;
        _this.pluginName = "batch";
        _this.isSprite = true;
        _this._roundPixels = settings.ROUND_PIXELS;
        return _this;
      }
      Sprite2.prototype._onTextureUpdate = function() {
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this._cachedTint = 16777215;
        if (this._width) {
          this.scale.x = sign$1(this.scale.x) * this._width / this._texture.orig.width;
        }
        if (this._height) {
          this.scale.y = sign$1(this.scale.y) * this._height / this._texture.orig.height;
        }
      };
      Sprite2.prototype._onAnchorUpdate = function() {
        this._transformID = -1;
        this._transformTrimmedID = -1;
      };
      Sprite2.prototype.calculateVertices = function() {
        var texture = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
          return;
        }
        if (this._textureID !== texture._updateID) {
          this.uvs = this._texture._uvs.uvsFloat32;
        }
        this._transformID = this.transform._worldID;
        this._textureID = texture._updateID;
        var wt = this.transform.worldTransform;
        var a2 = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        var trim2 = texture.trim;
        var orig = texture.orig;
        var anchor = this._anchor;
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        if (trim2) {
          w1 = trim2.x - anchor._x * orig.width;
          w0 = w1 + trim2.width;
          h1 = trim2.y - anchor._y * orig.height;
          h0 = h1 + trim2.height;
        } else {
          w1 = -anchor._x * orig.width;
          w0 = w1 + orig.width;
          h1 = -anchor._y * orig.height;
          h0 = h1 + orig.height;
        }
        vertexData[0] = a2 * w1 + c * h1 + tx;
        vertexData[1] = d * h1 + b * w1 + ty;
        vertexData[2] = a2 * w0 + c * h1 + tx;
        vertexData[3] = d * h1 + b * w0 + ty;
        vertexData[4] = a2 * w0 + c * h0 + tx;
        vertexData[5] = d * h0 + b * w0 + ty;
        vertexData[6] = a2 * w1 + c * h0 + tx;
        vertexData[7] = d * h0 + b * w1 + ty;
        if (this._roundPixels) {
          var resolution = settings.RESOLUTION;
          for (var i2 = 0; i2 < vertexData.length; ++i2) {
            vertexData[i2] = Math.round((vertexData[i2] * resolution | 0) / resolution);
          }
        }
      };
      Sprite2.prototype.calculateTrimmedVertices = function() {
        if (!this.vertexTrimmedData) {
          this.vertexTrimmedData = new Float32Array(8);
        } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
          return;
        }
        this._transformTrimmedID = this.transform._worldID;
        this._textureTrimmedID = this._texture._updateID;
        var texture = this._texture;
        var vertexData = this.vertexTrimmedData;
        var orig = texture.orig;
        var anchor = this._anchor;
        var wt = this.transform.worldTransform;
        var a2 = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var w1 = -anchor._x * orig.width;
        var w0 = w1 + orig.width;
        var h1 = -anchor._y * orig.height;
        var h0 = h1 + orig.height;
        vertexData[0] = a2 * w1 + c * h1 + tx;
        vertexData[1] = d * h1 + b * w1 + ty;
        vertexData[2] = a2 * w0 + c * h1 + tx;
        vertexData[3] = d * h1 + b * w0 + ty;
        vertexData[4] = a2 * w0 + c * h0 + tx;
        vertexData[5] = d * h0 + b * w0 + ty;
        vertexData[6] = a2 * w1 + c * h0 + tx;
        vertexData[7] = d * h0 + b * w1 + ty;
      };
      Sprite2.prototype._render = function(renderer) {
        this.calculateVertices();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
      };
      Sprite2.prototype._calculateBounds = function() {
        var trim2 = this._texture.trim;
        var orig = this._texture.orig;
        if (!trim2 || trim2.width === orig.width && trim2.height === orig.height) {
          this.calculateVertices();
          this._bounds.addQuad(this.vertexData);
        } else {
          this.calculateTrimmedVertices();
          this._bounds.addQuad(this.vertexTrimmedData);
        }
      };
      Sprite2.prototype.getLocalBounds = function(rect) {
        if (this.children.length === 0) {
          this._bounds.minX = this._texture.orig.width * -this._anchor._x;
          this._bounds.minY = this._texture.orig.height * -this._anchor._y;
          this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
          this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
          if (!rect) {
            if (!this._localBoundsRect) {
              this._localBoundsRect = new Rectangle();
            }
            rect = this._localBoundsRect;
          }
          return this._bounds.getRectangle(rect);
        }
        return _super.prototype.getLocalBounds.call(this, rect);
      };
      Sprite2.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, tempPoint$2);
        var width2 = this._texture.orig.width;
        var height2 = this._texture.orig.height;
        var x1 = -width2 * this.anchor.x;
        var y1 = 0;
        if (tempPoint$2.x >= x1 && tempPoint$2.x < x1 + width2) {
          y1 = -height2 * this.anchor.y;
          if (tempPoint$2.y >= y1 && tempPoint$2.y < y1 + height2) {
            return true;
          }
        }
        return false;
      };
      Sprite2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this._texture.off("update", this._onTextureUpdate, this);
        this._anchor = null;
        var destroyTexture = typeof options === "boolean" ? options : options && options.texture;
        if (destroyTexture) {
          var destroyBaseTexture = typeof options === "boolean" ? options : options && options.baseTexture;
          this._texture.destroy(!!destroyBaseTexture);
        }
        this._texture = null;
      };
      Sprite2.from = function(source, options) {
        var texture = source instanceof Texture ? source : Texture.from(source, options);
        return new Sprite2(texture);
      };
      Object.defineProperty(Sprite2.prototype, "roundPixels", {
        get: function() {
          return this._roundPixels;
        },
        set: function(value2) {
          if (this._roundPixels !== value2) {
            this._transformID = -1;
          }
          this._roundPixels = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "width", {
        get: function() {
          return Math.abs(this.scale.x) * this._texture.orig.width;
        },
        set: function(value2) {
          var s2 = sign$1(this.scale.x) || 1;
          this.scale.x = s2 * value2 / this._texture.orig.width;
          this._width = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "height", {
        get: function() {
          return Math.abs(this.scale.y) * this._texture.orig.height;
        },
        set: function(value2) {
          var s2 = sign$1(this.scale.y) || 1;
          this.scale.y = s2 * value2 / this._texture.orig.height;
          this._height = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "anchor", {
        get: function() {
          return this._anchor;
        },
        set: function(value2) {
          this._anchor.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value2) {
          this._tint = value2;
          this._tintRGB = (value2 >> 16) + (value2 & 65280) + ((value2 & 255) << 16);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sprite2.prototype, "texture", {
        get: function() {
          return this._texture;
        },
        set: function(value2) {
          if (this._texture === value2) {
            return;
          }
          if (this._texture) {
            this._texture.off("update", this._onTextureUpdate, this);
          }
          this._texture = value2 || Texture.EMPTY;
          this._cachedTint = 16777215;
          this._textureID = -1;
          this._textureTrimmedID = -1;
          if (value2) {
            if (value2.baseTexture.valid) {
              this._onTextureUpdate();
            } else {
              value2.once("update", this._onTextureUpdate, this);
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      return Sprite2;
    }(Container);
    /*!
     * @pixi/text - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/text is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$c = function(d, b) {
      extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$c(d, b);
    };
    function __extends$c(d, b) {
      extendStatics$c(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var TEXT_GRADIENT;
    (function(TEXT_GRADIENT2) {
      TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
      TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
    })(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
    var defaultStyle = {
      align: "left",
      breakWords: false,
      dropShadow: false,
      dropShadowAlpha: 1,
      dropShadowAngle: Math.PI / 6,
      dropShadowBlur: 0,
      dropShadowColor: "black",
      dropShadowDistance: 5,
      fill: "black",
      fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
      fillGradientStops: [],
      fontFamily: "Arial",
      fontSize: 26,
      fontStyle: "normal",
      fontVariant: "normal",
      fontWeight: "normal",
      letterSpacing: 0,
      lineHeight: 0,
      lineJoin: "miter",
      miterLimit: 10,
      padding: 0,
      stroke: "black",
      strokeThickness: 0,
      textBaseline: "alphabetic",
      trim: false,
      whiteSpace: "pre",
      wordWrap: false,
      wordWrapWidth: 100,
      leading: 0
    };
    var genericFontFamilies = [
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui"
    ];
    var TextStyle = function() {
      function TextStyle2(style) {
        this.styleID = 0;
        this.reset();
        deepCopyProperties(this, style, style);
      }
      TextStyle2.prototype.clone = function() {
        var clonedProperties = {};
        deepCopyProperties(clonedProperties, this, defaultStyle);
        return new TextStyle2(clonedProperties);
      };
      TextStyle2.prototype.reset = function() {
        deepCopyProperties(this, defaultStyle, defaultStyle);
      };
      Object.defineProperty(TextStyle2.prototype, "align", {
        get: function() {
          return this._align;
        },
        set: function(align) {
          if (this._align !== align) {
            this._align = align;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "breakWords", {
        get: function() {
          return this._breakWords;
        },
        set: function(breakWords) {
          if (this._breakWords !== breakWords) {
            this._breakWords = breakWords;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadow", {
        get: function() {
          return this._dropShadow;
        },
        set: function(dropShadow) {
          if (this._dropShadow !== dropShadow) {
            this._dropShadow = dropShadow;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowAlpha", {
        get: function() {
          return this._dropShadowAlpha;
        },
        set: function(dropShadowAlpha) {
          if (this._dropShadowAlpha !== dropShadowAlpha) {
            this._dropShadowAlpha = dropShadowAlpha;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowAngle", {
        get: function() {
          return this._dropShadowAngle;
        },
        set: function(dropShadowAngle) {
          if (this._dropShadowAngle !== dropShadowAngle) {
            this._dropShadowAngle = dropShadowAngle;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowBlur", {
        get: function() {
          return this._dropShadowBlur;
        },
        set: function(dropShadowBlur) {
          if (this._dropShadowBlur !== dropShadowBlur) {
            this._dropShadowBlur = dropShadowBlur;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowColor", {
        get: function() {
          return this._dropShadowColor;
        },
        set: function(dropShadowColor) {
          var outputColor = getColor(dropShadowColor);
          if (this._dropShadowColor !== outputColor) {
            this._dropShadowColor = outputColor;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "dropShadowDistance", {
        get: function() {
          return this._dropShadowDistance;
        },
        set: function(dropShadowDistance) {
          if (this._dropShadowDistance !== dropShadowDistance) {
            this._dropShadowDistance = dropShadowDistance;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fill", {
        get: function() {
          return this._fill;
        },
        set: function(fill) {
          var outputColor = getColor(fill);
          if (this._fill !== outputColor) {
            this._fill = outputColor;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fillGradientType", {
        get: function() {
          return this._fillGradientType;
        },
        set: function(fillGradientType) {
          if (this._fillGradientType !== fillGradientType) {
            this._fillGradientType = fillGradientType;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fillGradientStops", {
        get: function() {
          return this._fillGradientStops;
        },
        set: function(fillGradientStops) {
          if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
            this._fillGradientStops = fillGradientStops;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontFamily", {
        get: function() {
          return this._fontFamily;
        },
        set: function(fontFamily) {
          if (this.fontFamily !== fontFamily) {
            this._fontFamily = fontFamily;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontSize", {
        get: function() {
          return this._fontSize;
        },
        set: function(fontSize) {
          if (this._fontSize !== fontSize) {
            this._fontSize = fontSize;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontStyle", {
        get: function() {
          return this._fontStyle;
        },
        set: function(fontStyle) {
          if (this._fontStyle !== fontStyle) {
            this._fontStyle = fontStyle;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontVariant", {
        get: function() {
          return this._fontVariant;
        },
        set: function(fontVariant) {
          if (this._fontVariant !== fontVariant) {
            this._fontVariant = fontVariant;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "fontWeight", {
        get: function() {
          return this._fontWeight;
        },
        set: function(fontWeight) {
          if (this._fontWeight !== fontWeight) {
            this._fontWeight = fontWeight;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "letterSpacing", {
        get: function() {
          return this._letterSpacing;
        },
        set: function(letterSpacing) {
          if (this._letterSpacing !== letterSpacing) {
            this._letterSpacing = letterSpacing;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "lineHeight", {
        get: function() {
          return this._lineHeight;
        },
        set: function(lineHeight) {
          if (this._lineHeight !== lineHeight) {
            this._lineHeight = lineHeight;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "leading", {
        get: function() {
          return this._leading;
        },
        set: function(leading) {
          if (this._leading !== leading) {
            this._leading = leading;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "lineJoin", {
        get: function() {
          return this._lineJoin;
        },
        set: function(lineJoin) {
          if (this._lineJoin !== lineJoin) {
            this._lineJoin = lineJoin;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "miterLimit", {
        get: function() {
          return this._miterLimit;
        },
        set: function(miterLimit) {
          if (this._miterLimit !== miterLimit) {
            this._miterLimit = miterLimit;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "padding", {
        get: function() {
          return this._padding;
        },
        set: function(padding) {
          if (this._padding !== padding) {
            this._padding = padding;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "stroke", {
        get: function() {
          return this._stroke;
        },
        set: function(stroke) {
          var outputColor = getColor(stroke);
          if (this._stroke !== outputColor) {
            this._stroke = outputColor;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "strokeThickness", {
        get: function() {
          return this._strokeThickness;
        },
        set: function(strokeThickness) {
          if (this._strokeThickness !== strokeThickness) {
            this._strokeThickness = strokeThickness;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "textBaseline", {
        get: function() {
          return this._textBaseline;
        },
        set: function(textBaseline) {
          if (this._textBaseline !== textBaseline) {
            this._textBaseline = textBaseline;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "trim", {
        get: function() {
          return this._trim;
        },
        set: function(trim2) {
          if (this._trim !== trim2) {
            this._trim = trim2;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "whiteSpace", {
        get: function() {
          return this._whiteSpace;
        },
        set: function(whiteSpace) {
          if (this._whiteSpace !== whiteSpace) {
            this._whiteSpace = whiteSpace;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "wordWrap", {
        get: function() {
          return this._wordWrap;
        },
        set: function(wordWrap) {
          if (this._wordWrap !== wordWrap) {
            this._wordWrap = wordWrap;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TextStyle2.prototype, "wordWrapWidth", {
        get: function() {
          return this._wordWrapWidth;
        },
        set: function(wordWrapWidth) {
          if (this._wordWrapWidth !== wordWrapWidth) {
            this._wordWrapWidth = wordWrapWidth;
            this.styleID++;
          }
        },
        enumerable: false,
        configurable: true
      });
      TextStyle2.prototype.toFontString = function() {
        var fontSizeString = typeof this.fontSize === "number" ? this.fontSize + "px" : this.fontSize;
        var fontFamilies = this.fontFamily;
        if (!Array.isArray(this.fontFamily)) {
          fontFamilies = this.fontFamily.split(",");
        }
        for (var i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
          var fontFamily = fontFamilies[i2].trim();
          if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
            fontFamily = '"' + fontFamily + '"';
          }
          fontFamilies[i2] = fontFamily;
        }
        return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
      };
      return TextStyle2;
    }();
    function getSingleColor(color) {
      if (typeof color === "number") {
        return hex2string(color);
      } else if (typeof color === "string") {
        if (color.indexOf("0x") === 0) {
          color = color.replace("0x", "#");
        }
      }
      return color;
    }
    function getColor(color) {
      if (!Array.isArray(color)) {
        return getSingleColor(color);
      } else {
        for (var i2 = 0; i2 < color.length; ++i2) {
          color[i2] = getSingleColor(color[i2]);
        }
        return color;
      }
    }
    function areArraysEqual(array1, array2) {
      if (!Array.isArray(array1) || !Array.isArray(array2)) {
        return false;
      }
      if (array1.length !== array2.length) {
        return false;
      }
      for (var i2 = 0; i2 < array1.length; ++i2) {
        if (array1[i2] !== array2[i2]) {
          return false;
        }
      }
      return true;
    }
    function deepCopyProperties(target, source, propertyObj) {
      for (var prop in propertyObj) {
        if (Array.isArray(source[prop])) {
          target[prop] = source[prop].slice();
        } else {
          target[prop] = source[prop];
        }
      }
    }
    var TextMetrics = function() {
      function TextMetrics2(text, style, width2, height2, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width2;
        this.height = height2;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
      }
      TextMetrics2.measureText = function(text, style, wordWrap, canvas2) {
        if (canvas2 === void 0) {
          canvas2 = TextMetrics2._canvas;
        }
        wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
        var font = style.toFontString();
        var fontProperties = TextMetrics2.measureFont(font);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = style.fontSize;
          fontProperties.ascent = style.fontSize;
        }
        var context2 = canvas2.getContext("2d");
        context2.font = font;
        var outputText = wordWrap ? TextMetrics2.wordWrap(text, style, canvas2) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        for (var i2 = 0; i2 < lines.length; i2++) {
          var lineWidth = context2.measureText(lines[i2]).width + (lines[i2].length - 1) * style.letterSpacing;
          lineWidths[i2] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width2 = maxLineWidth + style.strokeThickness;
        if (style.dropShadow) {
          width2 += style.dropShadowDistance;
        }
        var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        var height2 = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);
        if (style.dropShadow) {
          height2 += style.dropShadowDistance;
        }
        return new TextMetrics2(text, style, width2, height2, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
      };
      TextMetrics2.wordWrap = function(text, style, canvas2) {
        if (canvas2 === void 0) {
          canvas2 = TextMetrics2._canvas;
        }
        var context2 = canvas2.getContext("2d");
        var width2 = 0;
        var line = "";
        var lines = "";
        var cache2 = /* @__PURE__ */ Object.create(null);
        var letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace;
        var collapseSpaces = TextMetrics2.collapseSpaces(whiteSpace);
        var collapseNewlines = TextMetrics2.collapseNewlines(whiteSpace);
        var canPrependSpaces = !collapseSpaces;
        var wordWrapWidth = style.wordWrapWidth + letterSpacing;
        var tokens2 = TextMetrics2.tokenize(text);
        for (var i2 = 0; i2 < tokens2.length; i2++) {
          var token2 = tokens2[i2];
          if (TextMetrics2.isNewline(token2)) {
            if (!collapseNewlines) {
              lines += TextMetrics2.addLine(line);
              canPrependSpaces = !collapseSpaces;
              line = "";
              width2 = 0;
              continue;
            }
            token2 = " ";
          }
          if (collapseSpaces) {
            var currIsBreakingSpace = TextMetrics2.isBreakingSpace(token2);
            var lastIsBreakingSpace = TextMetrics2.isBreakingSpace(line[line.length - 1]);
            if (currIsBreakingSpace && lastIsBreakingSpace) {
              continue;
            }
          }
          var tokenWidth = TextMetrics2.getFromCache(token2, letterSpacing, cache2, context2);
          if (tokenWidth > wordWrapWidth) {
            if (line !== "") {
              lines += TextMetrics2.addLine(line);
              line = "";
              width2 = 0;
            }
            if (TextMetrics2.canBreakWords(token2, style.breakWords)) {
              var characters = TextMetrics2.wordWrapSplit(token2);
              for (var j = 0; j < characters.length; j++) {
                var char = characters[j];
                var k = 1;
                while (characters[j + k]) {
                  var nextChar = characters[j + k];
                  var lastChar = char[char.length - 1];
                  if (!TextMetrics2.canBreakChars(lastChar, nextChar, token2, j, style.breakWords)) {
                    char += nextChar;
                  } else {
                    break;
                  }
                  k++;
                }
                j += char.length - 1;
                var characterWidth = TextMetrics2.getFromCache(char, letterSpacing, cache2, context2);
                if (characterWidth + width2 > wordWrapWidth) {
                  lines += TextMetrics2.addLine(line);
                  canPrependSpaces = false;
                  line = "";
                  width2 = 0;
                }
                line += char;
                width2 += characterWidth;
              }
            } else {
              if (line.length > 0) {
                lines += TextMetrics2.addLine(line);
                line = "";
                width2 = 0;
              }
              var isLastToken = i2 === tokens2.length - 1;
              lines += TextMetrics2.addLine(token2, !isLastToken);
              canPrependSpaces = false;
              line = "";
              width2 = 0;
            }
          } else {
            if (tokenWidth + width2 > wordWrapWidth) {
              canPrependSpaces = false;
              lines += TextMetrics2.addLine(line);
              line = "";
              width2 = 0;
            }
            if (line.length > 0 || !TextMetrics2.isBreakingSpace(token2) || canPrependSpaces) {
              line += token2;
              width2 += tokenWidth;
            }
          }
        }
        lines += TextMetrics2.addLine(line, false);
        return lines;
      };
      TextMetrics2.addLine = function(line, newLine) {
        if (newLine === void 0) {
          newLine = true;
        }
        line = TextMetrics2.trimRight(line);
        line = newLine ? line + "\n" : line;
        return line;
      };
      TextMetrics2.getFromCache = function(key, letterSpacing, cache2, context2) {
        var width2 = cache2[key];
        if (typeof width2 !== "number") {
          var spacing = key.length * letterSpacing;
          width2 = context2.measureText(key).width + spacing;
          cache2[key] = width2;
        }
        return width2;
      };
      TextMetrics2.collapseSpaces = function(whiteSpace) {
        return whiteSpace === "normal" || whiteSpace === "pre-line";
      };
      TextMetrics2.collapseNewlines = function(whiteSpace) {
        return whiteSpace === "normal";
      };
      TextMetrics2.trimRight = function(text) {
        if (typeof text !== "string") {
          return "";
        }
        for (var i2 = text.length - 1; i2 >= 0; i2--) {
          var char = text[i2];
          if (!TextMetrics2.isBreakingSpace(char)) {
            break;
          }
          text = text.slice(0, -1);
        }
        return text;
      };
      TextMetrics2.isNewline = function(char) {
        if (typeof char !== "string") {
          return false;
        }
        return TextMetrics2._newlines.indexOf(char.charCodeAt(0)) >= 0;
      };
      TextMetrics2.isBreakingSpace = function(char) {
        if (typeof char !== "string") {
          return false;
        }
        return TextMetrics2._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
      };
      TextMetrics2.tokenize = function(text) {
        var tokens2 = [];
        var token2 = "";
        if (typeof text !== "string") {
          return tokens2;
        }
        for (var i2 = 0; i2 < text.length; i2++) {
          var char = text[i2];
          if (TextMetrics2.isBreakingSpace(char) || TextMetrics2.isNewline(char)) {
            if (token2 !== "") {
              tokens2.push(token2);
              token2 = "";
            }
            tokens2.push(char);
            continue;
          }
          token2 += char;
        }
        if (token2 !== "") {
          tokens2.push(token2);
        }
        return tokens2;
      };
      TextMetrics2.canBreakWords = function(_token, breakWords) {
        return breakWords;
      };
      TextMetrics2.canBreakChars = function(_char, _nextChar, _token, _index, _breakWords) {
        return true;
      };
      TextMetrics2.wordWrapSplit = function(token2) {
        return token2.split("");
      };
      TextMetrics2.measureFont = function(font) {
        if (TextMetrics2._fonts[font]) {
          return TextMetrics2._fonts[font];
        }
        var properties = {
          ascent: 0,
          descent: 0,
          fontSize: 0
        };
        var canvas2 = TextMetrics2._canvas;
        var context2 = TextMetrics2._context;
        context2.font = font;
        var metricsString = TextMetrics2.METRICS_STRING + TextMetrics2.BASELINE_SYMBOL;
        var width2 = Math.ceil(context2.measureText(metricsString).width);
        var baseline = Math.ceil(context2.measureText(TextMetrics2.BASELINE_SYMBOL).width);
        var height2 = 2 * baseline;
        baseline = baseline * TextMetrics2.BASELINE_MULTIPLIER | 0;
        canvas2.width = width2;
        canvas2.height = height2;
        context2.fillStyle = "#f00";
        context2.fillRect(0, 0, width2, height2);
        context2.font = font;
        context2.textBaseline = "alphabetic";
        context2.fillStyle = "#000";
        context2.fillText(metricsString, 0, baseline);
        var imagedata = context2.getImageData(0, 0, width2, height2).data;
        var pixels = imagedata.length;
        var line = width2 * 4;
        var i2 = 0;
        var idx = 0;
        var stop = false;
        for (i2 = 0; i2 < baseline; ++i2) {
          for (var j = 0; j < line; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx += line;
          } else {
            break;
          }
        }
        properties.ascent = baseline - i2;
        idx = pixels - line;
        stop = false;
        for (i2 = height2; i2 > baseline; --i2) {
          for (var j = 0; j < line; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx -= line;
          } else {
            break;
          }
        }
        properties.descent = i2 - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        TextMetrics2._fonts[font] = properties;
        return properties;
      };
      TextMetrics2.clearMetrics = function(font) {
        if (font === void 0) {
          font = "";
        }
        if (font) {
          delete TextMetrics2._fonts[font];
        } else {
          TextMetrics2._fonts = {};
        }
      };
      return TextMetrics2;
    }();
    var canvas = function() {
      try {
        var c = new OffscreenCanvas(0, 0);
        var context2 = c.getContext("2d");
        if (context2 && context2.measureText) {
          return c;
        }
        return document.createElement("canvas");
      } catch (ex) {
        return document.createElement("canvas");
      }
    }();
    canvas.width = canvas.height = 10;
    TextMetrics._canvas = canvas;
    TextMetrics._context = canvas.getContext("2d");
    TextMetrics._fonts = {};
    TextMetrics.METRICS_STRING = "|q";
    TextMetrics.BASELINE_SYMBOL = "M";
    TextMetrics.BASELINE_MULTIPLIER = 1.4;
    TextMetrics._newlines = [
      10,
      13
    ];
    TextMetrics._breakingSpaces = [
      9,
      32,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8200,
      8201,
      8202,
      8287,
      12288
    ];
    var defaultDestroyOptions = {
      texture: true,
      children: false,
      baseTexture: true
    };
    var Text = function(_super) {
      __extends$c(Text2, _super);
      function Text2(text, style, canvas2) {
        var _this = this;
        var ownCanvas = false;
        if (!canvas2) {
          canvas2 = document.createElement("canvas");
          ownCanvas = true;
        }
        canvas2.width = 3;
        canvas2.height = 3;
        var texture = Texture.from(canvas2);
        texture.orig = new Rectangle();
        texture.trim = new Rectangle();
        _this = _super.call(this, texture) || this;
        _this._ownCanvas = ownCanvas;
        _this.canvas = canvas2;
        _this.context = _this.canvas.getContext("2d");
        _this._resolution = settings.RESOLUTION;
        _this._autoResolution = true;
        _this._text = null;
        _this._style = null;
        _this._styleListener = null;
        _this._font = "";
        _this.text = text;
        _this.style = style;
        _this.localStyleID = -1;
        return _this;
      }
      Text2.prototype.updateText = function(respectDirty) {
        var style = this._style;
        if (this.localStyleID !== style.styleID) {
          this.dirty = true;
          this.localStyleID = style.styleID;
        }
        if (!this.dirty && respectDirty) {
          return;
        }
        this._font = this._style.toFontString();
        var context2 = this.context;
        var measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
        var width2 = measured.width;
        var height2 = measured.height;
        var lines = measured.lines;
        var lineHeight = measured.lineHeight;
        var lineWidths = measured.lineWidths;
        var maxLineWidth = measured.maxLineWidth;
        var fontProperties = measured.fontProperties;
        this.canvas.width = Math.ceil((Math.max(1, width2) + style.padding * 2) * this._resolution);
        this.canvas.height = Math.ceil((Math.max(1, height2) + style.padding * 2) * this._resolution);
        context2.scale(this._resolution, this._resolution);
        context2.clearRect(0, 0, this.canvas.width, this.canvas.height);
        context2.font = this._font;
        context2.lineWidth = style.strokeThickness;
        context2.textBaseline = style.textBaseline;
        context2.lineJoin = style.lineJoin;
        context2.miterLimit = style.miterLimit;
        var linePositionX;
        var linePositionY;
        var passesCount = style.dropShadow ? 2 : 1;
        for (var i2 = 0; i2 < passesCount; ++i2) {
          var isShadowPass = style.dropShadow && i2 === 0;
          var dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height2) + style.padding * 2) : 0;
          var dsOffsetShadow = dsOffsetText * this._resolution;
          if (isShadowPass) {
            context2.fillStyle = "black";
            context2.strokeStyle = "black";
            var dropShadowColor = style.dropShadowColor;
            var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
            var dropShadowBlur = style.dropShadowBlur * this._resolution;
            var dropShadowDistance = style.dropShadowDistance * this._resolution;
            context2.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
            context2.shadowBlur = dropShadowBlur;
            context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
            context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
          } else {
            context2.fillStyle = this._generateFillStyle(style, lines, measured);
            context2.strokeStyle = style.stroke;
            context2.shadowColor = "black";
            context2.shadowBlur = 0;
            context2.shadowOffsetX = 0;
            context2.shadowOffsetY = 0;
          }
          for (var i_1 = 0; i_1 < lines.length; i_1++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = style.strokeThickness / 2 + i_1 * lineHeight + fontProperties.ascent;
            if (style.align === "right") {
              linePositionX += maxLineWidth - lineWidths[i_1];
            } else if (style.align === "center") {
              linePositionX += (maxLineWidth - lineWidths[i_1]) / 2;
            }
            if (style.stroke && style.strokeThickness) {
              this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
            }
            if (style.fill) {
              this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
            }
          }
        }
        this.updateTexture();
      };
      Text2.prototype.drawLetterSpacing = function(text, x2, y2, isStroke) {
        if (isStroke === void 0) {
          isStroke = false;
        }
        var style = this._style;
        var letterSpacing = style.letterSpacing;
        if (letterSpacing === 0) {
          if (isStroke) {
            this.context.strokeText(text, x2, y2);
          } else {
            this.context.fillText(text, x2, y2);
          }
          return;
        }
        var currentPosition = x2;
        var stringArray = Array.from ? Array.from(text) : text.split("");
        var previousWidth = this.context.measureText(text).width;
        var currentWidth = 0;
        for (var i2 = 0; i2 < stringArray.length; ++i2) {
          var currentChar = stringArray[i2];
          if (isStroke) {
            this.context.strokeText(currentChar, currentPosition, y2);
          } else {
            this.context.fillText(currentChar, currentPosition, y2);
          }
          currentWidth = this.context.measureText(text.substring(i2 + 1)).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
      };
      Text2.prototype.updateTexture = function() {
        var canvas2 = this.canvas;
        if (this._style.trim) {
          var trimmed = trimCanvas(canvas2);
          if (trimmed.data) {
            canvas2.width = trimmed.width;
            canvas2.height = trimmed.height;
            this.context.putImageData(trimmed.data, 0, 0);
          }
        }
        var texture = this._texture;
        var style = this._style;
        var padding = style.trim ? 0 : style.padding;
        var baseTexture = texture.baseTexture;
        texture.trim.width = texture._frame.width = Math.ceil(canvas2.width / this._resolution);
        texture.trim.height = texture._frame.height = Math.ceil(canvas2.height / this._resolution);
        texture.trim.x = -padding;
        texture.trim.y = -padding;
        texture.orig.width = texture._frame.width - padding * 2;
        texture.orig.height = texture._frame.height - padding * 2;
        this._onTextureUpdate();
        baseTexture.setRealSize(canvas2.width, canvas2.height, this._resolution);
        this._recursivePostUpdateTransform();
        this.dirty = false;
      };
      Text2.prototype._render = function(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
          this._resolution = renderer.resolution;
          this.dirty = true;
        }
        this.updateText(true);
        _super.prototype._render.call(this, renderer);
      };
      Text2.prototype.getLocalBounds = function(rect) {
        this.updateText(true);
        return _super.prototype.getLocalBounds.call(this, rect);
      };
      Text2.prototype._calculateBounds = function() {
        this.updateText(true);
        this.calculateVertices();
        this._bounds.addQuad(this.vertexData);
      };
      Text2.prototype._generateFillStyle = function(style, lines, metrics) {
        var fillStyle = style.fill;
        if (!Array.isArray(fillStyle)) {
          return fillStyle;
        } else if (fillStyle.length === 1) {
          return fillStyle[0];
        }
        var gradient;
        var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
        var padding = style.padding || 0;
        var width2 = Math.ceil(this.canvas.width / this._resolution) - dropShadowCorrection - padding * 2;
        var height2 = Math.ceil(this.canvas.height / this._resolution) - dropShadowCorrection - padding * 2;
        var fill = fillStyle.slice();
        var fillGradientStops = style.fillGradientStops.slice();
        if (!fillGradientStops.length) {
          var lengthPlus1 = fill.length + 1;
          for (var i2 = 1; i2 < lengthPlus1; ++i2) {
            fillGradientStops.push(i2 / lengthPlus1);
          }
        }
        fill.unshift(fillStyle[0]);
        fillGradientStops.unshift(0);
        fill.push(fillStyle[fillStyle.length - 1]);
        fillGradientStops.push(1);
        if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
          gradient = this.context.createLinearGradient(width2 / 2, padding, width2 / 2, height2 + padding);
          var lastIterationStop = 0;
          var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
          var gradStopLineHeight = textHeight / height2;
          for (var i2 = 0; i2 < lines.length; i2++) {
            var thisLineTop = metrics.lineHeight * i2;
            for (var j = 0; j < fill.length; j++) {
              var lineStop = 0;
              if (typeof fillGradientStops[j] === "number") {
                lineStop = fillGradientStops[j];
              } else {
                lineStop = j / fill.length;
              }
              var globalStop = thisLineTop / height2 + lineStop * gradStopLineHeight;
              var clampedStop = Math.max(lastIterationStop, globalStop);
              clampedStop = Math.min(clampedStop, 1);
              gradient.addColorStop(clampedStop, fill[j]);
              lastIterationStop = clampedStop;
            }
          }
        } else {
          gradient = this.context.createLinearGradient(padding, height2 / 2, width2 + padding, height2 / 2);
          var totalIterations = fill.length + 1;
          var currentIteration = 1;
          for (var i2 = 0; i2 < fill.length; i2++) {
            var stop = void 0;
            if (typeof fillGradientStops[i2] === "number") {
              stop = fillGradientStops[i2];
            } else {
              stop = currentIteration / totalIterations;
            }
            gradient.addColorStop(stop, fill[i2]);
            currentIteration++;
          }
        }
        return gradient;
      };
      Text2.prototype.destroy = function(options) {
        if (typeof options === "boolean") {
          options = { children: options };
        }
        options = Object.assign({}, defaultDestroyOptions, options);
        _super.prototype.destroy.call(this, options);
        if (this._ownCanvas) {
          this.canvas.height = this.canvas.width = 0;
        }
        this.context = null;
        this.canvas = null;
        this._style = null;
      };
      Object.defineProperty(Text2.prototype, "width", {
        get: function() {
          this.updateText(true);
          return Math.abs(this.scale.x) * this._texture.orig.width;
        },
        set: function(value2) {
          this.updateText(true);
          var s2 = sign$1(this.scale.x) || 1;
          this.scale.x = s2 * value2 / this._texture.orig.width;
          this._width = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text2.prototype, "height", {
        get: function() {
          this.updateText(true);
          return Math.abs(this.scale.y) * this._texture.orig.height;
        },
        set: function(value2) {
          this.updateText(true);
          var s2 = sign$1(this.scale.y) || 1;
          this.scale.y = s2 * value2 / this._texture.orig.height;
          this._height = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text2.prototype, "style", {
        get: function() {
          return this._style;
        },
        set: function(style) {
          style = style || {};
          if (style instanceof TextStyle) {
            this._style = style;
          } else {
            this._style = new TextStyle(style);
          }
          this.localStyleID = -1;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text2.prototype, "text", {
        get: function() {
          return this._text;
        },
        set: function(text) {
          text = String(text === null || text === void 0 ? "" : text);
          if (this._text === text) {
            return;
          }
          this._text = text;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Text2.prototype, "resolution", {
        get: function() {
          return this._resolution;
        },
        set: function(value2) {
          this._autoResolution = false;
          if (this._resolution === value2) {
            return;
          }
          this._resolution = value2;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      return Text2;
    }(Sprite);
    /*!
     * @pixi/prepare - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/prepare is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    settings.UPLOADS_PER_FRAME = 4;
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$b = function(d, b) {
      extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$b(d, b);
    };
    function __extends$b(d, b) {
      extendStatics$b(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var CountLimiter = function() {
      function CountLimiter2(maxItemsPerFrame) {
        this.maxItemsPerFrame = maxItemsPerFrame;
        this.itemsLeft = 0;
      }
      CountLimiter2.prototype.beginFrame = function() {
        this.itemsLeft = this.maxItemsPerFrame;
      };
      CountLimiter2.prototype.allowedToUpload = function() {
        return this.itemsLeft-- > 0;
      };
      return CountLimiter2;
    }();
    function findMultipleBaseTextures(item, queue2) {
      var result2 = false;
      if (item && item._textures && item._textures.length) {
        for (var i2 = 0; i2 < item._textures.length; i2++) {
          if (item._textures[i2] instanceof Texture) {
            var baseTexture = item._textures[i2].baseTexture;
            if (queue2.indexOf(baseTexture) === -1) {
              queue2.push(baseTexture);
              result2 = true;
            }
          }
        }
      }
      return result2;
    }
    function findBaseTexture(item, queue2) {
      if (item.baseTexture instanceof BaseTexture) {
        var texture = item.baseTexture;
        if (queue2.indexOf(texture) === -1) {
          queue2.push(texture);
        }
        return true;
      }
      return false;
    }
    function findTexture(item, queue2) {
      if (item._texture && item._texture instanceof Texture) {
        var texture = item._texture.baseTexture;
        if (queue2.indexOf(texture) === -1) {
          queue2.push(texture);
        }
        return true;
      }
      return false;
    }
    function drawText(_helper, item) {
      if (item instanceof Text) {
        item.updateText(true);
        return true;
      }
      return false;
    }
    function calculateTextStyle(_helper, item) {
      if (item instanceof TextStyle) {
        var font = item.toFontString();
        TextMetrics.measureFont(font);
        return true;
      }
      return false;
    }
    function findText(item, queue2) {
      if (item instanceof Text) {
        if (queue2.indexOf(item.style) === -1) {
          queue2.push(item.style);
        }
        if (queue2.indexOf(item) === -1) {
          queue2.push(item);
        }
        var texture = item._texture.baseTexture;
        if (queue2.indexOf(texture) === -1) {
          queue2.push(texture);
        }
        return true;
      }
      return false;
    }
    function findTextStyle(item, queue2) {
      if (item instanceof TextStyle) {
        if (queue2.indexOf(item) === -1) {
          queue2.push(item);
        }
        return true;
      }
      return false;
    }
    var BasePrepare = function() {
      function BasePrepare2(renderer) {
        var _this = this;
        this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);
        this.renderer = renderer;
        this.uploadHookHelper = null;
        this.queue = [];
        this.addHooks = [];
        this.uploadHooks = [];
        this.completes = [];
        this.ticking = false;
        this.delayedTick = function() {
          if (!_this.queue) {
            return;
          }
          _this.prepareItems();
        };
        this.registerFindHook(findText);
        this.registerFindHook(findTextStyle);
        this.registerFindHook(findMultipleBaseTextures);
        this.registerFindHook(findBaseTexture);
        this.registerFindHook(findTexture);
        this.registerUploadHook(drawText);
        this.registerUploadHook(calculateTextStyle);
      }
      BasePrepare2.prototype.upload = function(item, done) {
        if (typeof item === "function") {
          done = item;
          item = null;
        }
        if (item) {
          this.add(item);
        }
        if (this.queue.length) {
          if (done) {
            this.completes.push(done);
          }
          if (!this.ticking) {
            this.ticking = true;
            Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
          }
        } else if (done) {
          done();
        }
      };
      BasePrepare2.prototype.tick = function() {
        setTimeout(this.delayedTick, 0);
      };
      BasePrepare2.prototype.prepareItems = function() {
        this.limiter.beginFrame();
        while (this.queue.length && this.limiter.allowedToUpload()) {
          var item = this.queue[0];
          var uploaded = false;
          if (item && !item._destroyed) {
            for (var i2 = 0, len = this.uploadHooks.length; i2 < len; i2++) {
              if (this.uploadHooks[i2](this.uploadHookHelper, item)) {
                this.queue.shift();
                uploaded = true;
                break;
              }
            }
          }
          if (!uploaded) {
            this.queue.shift();
          }
        }
        if (!this.queue.length) {
          this.ticking = false;
          var completes = this.completes.slice(0);
          this.completes.length = 0;
          for (var i2 = 0, len = completes.length; i2 < len; i2++) {
            completes[i2]();
          }
        } else {
          Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
        }
      };
      BasePrepare2.prototype.registerFindHook = function(addHook) {
        if (addHook) {
          this.addHooks.push(addHook);
        }
        return this;
      };
      BasePrepare2.prototype.registerUploadHook = function(uploadHook) {
        if (uploadHook) {
          this.uploadHooks.push(uploadHook);
        }
        return this;
      };
      BasePrepare2.prototype.add = function(item) {
        for (var i2 = 0, len = this.addHooks.length; i2 < len; i2++) {
          if (this.addHooks[i2](item, this.queue)) {
            break;
          }
        }
        if (item instanceof Container) {
          for (var i2 = item.children.length - 1; i2 >= 0; i2--) {
            this.add(item.children[i2]);
          }
        }
        return this;
      };
      BasePrepare2.prototype.destroy = function() {
        if (this.ticking) {
          Ticker.system.remove(this.tick, this);
        }
        this.ticking = false;
        this.addHooks = null;
        this.uploadHooks = null;
        this.renderer = null;
        this.completes = null;
        this.queue = null;
        this.limiter = null;
        this.uploadHookHelper = null;
      };
      return BasePrepare2;
    }();
    function uploadBaseTextures(renderer, item) {
      if (item instanceof BaseTexture) {
        if (!item._glTextures[renderer.CONTEXT_UID]) {
          renderer.texture.bind(item);
        }
        return true;
      }
      return false;
    }
    function uploadGraphics(renderer, item) {
      if (!(item instanceof Graphics)) {
        return false;
      }
      var geometry = item.geometry;
      item.finishPoly();
      geometry.updateBatches();
      var batches = geometry.batches;
      for (var i2 = 0; i2 < batches.length; i2++) {
        var texture = batches[i2].style.texture;
        if (texture) {
          uploadBaseTextures(renderer, texture.baseTexture);
        }
      }
      if (!geometry.batchable) {
        renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
      }
      return true;
    }
    function findGraphics(item, queue2) {
      if (item instanceof Graphics) {
        queue2.push(item);
        return true;
      }
      return false;
    }
    var Prepare = function(_super) {
      __extends$b(Prepare2, _super);
      function Prepare2(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.uploadHookHelper = _this.renderer;
        _this.registerFindHook(findGraphics);
        _this.registerUploadHook(uploadBaseTextures);
        _this.registerUploadHook(uploadGraphics);
        return _this;
      }
      return Prepare2;
    }(BasePrepare);
    /*!
     * @pixi/spritesheet - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/spritesheet is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var Spritesheet = function() {
      function Spritesheet2(texture, data, resolutionFilename) {
        if (resolutionFilename === void 0) {
          resolutionFilename = null;
        }
        this._texture = texture instanceof Texture ? texture : null;
        this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;
        this.textures = {};
        this.animations = {};
        this.data = data;
        var resource = this.baseTexture.resource;
        this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
        this._frames = this.data.frames;
        this._frameKeys = Object.keys(this._frames);
        this._batchIndex = 0;
        this._callback = null;
      }
      Spritesheet2.prototype._updateResolution = function(resolutionFilename) {
        if (resolutionFilename === void 0) {
          resolutionFilename = null;
        }
        var scale = this.data.meta.scale;
        var resolution = getResolutionOfUrl(resolutionFilename, null);
        if (resolution === null) {
          resolution = scale !== void 0 ? parseFloat(scale) : 1;
        }
        if (resolution !== 1) {
          this.baseTexture.setResolution(resolution);
        }
        return resolution;
      };
      Spritesheet2.prototype.parse = function(callback) {
        this._batchIndex = 0;
        this._callback = callback;
        if (this._frameKeys.length <= Spritesheet2.BATCH_SIZE) {
          this._processFrames(0);
          this._processAnimations();
          this._parseComplete();
        } else {
          this._nextBatch();
        }
      };
      Spritesheet2.prototype._processFrames = function(initialFrameIndex) {
        var frameIndex = initialFrameIndex;
        var maxFrames = Spritesheet2.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
          var i2 = this._frameKeys[frameIndex];
          var data = this._frames[i2];
          var rect = data.frame;
          if (rect) {
            var frame = null;
            var trim2 = null;
            var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
            var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
            if (data.rotated) {
              frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
            } else {
              frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
            }
            if (data.trimmed !== false && data.spriteSourceSize) {
              trim2 = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
            }
            this.textures[i2] = new Texture(this.baseTexture, frame, orig, trim2, data.rotated ? 2 : 0, data.anchor);
            Texture.addToCache(this.textures[i2], i2);
          }
          frameIndex++;
        }
      };
      Spritesheet2.prototype._processAnimations = function() {
        var animations = this.data.animations || {};
        for (var animName in animations) {
          this.animations[animName] = [];
          for (var i2 = 0; i2 < animations[animName].length; i2++) {
            var frameName = animations[animName][i2];
            this.animations[animName].push(this.textures[frameName]);
          }
        }
      };
      Spritesheet2.prototype._parseComplete = function() {
        var callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
      };
      Spritesheet2.prototype._nextBatch = function() {
        var _this = this;
        this._processFrames(this._batchIndex * Spritesheet2.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(function() {
          if (_this._batchIndex * Spritesheet2.BATCH_SIZE < _this._frameKeys.length) {
            _this._nextBatch();
          } else {
            _this._processAnimations();
            _this._parseComplete();
          }
        }, 0);
      };
      Spritesheet2.prototype.destroy = function(destroyBase) {
        var _a2;
        if (destroyBase === void 0) {
          destroyBase = false;
        }
        for (var i2 in this.textures) {
          this.textures[i2].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
          (_a2 = this._texture) === null || _a2 === void 0 ? void 0 : _a2.destroy();
          this.baseTexture.destroy();
        }
        this._texture = null;
        this.baseTexture = null;
      };
      Spritesheet2.BATCH_SIZE = 1e3;
      return Spritesheet2;
    }();
    var SpritesheetLoader = function() {
      function SpritesheetLoader2() {
      }
      SpritesheetLoader2.use = function(resource, next) {
        var loader = this;
        var imageResourceName = resource.name + "_image";
        if (!resource.data || resource.type !== LoaderResource.TYPE.JSON || !resource.data.frames || loader.resources[imageResourceName]) {
          next();
          return;
        }
        var loadOptions = {
          crossOrigin: resource.crossOrigin,
          metadata: resource.metadata.imageMetadata,
          parentResource: resource
        };
        var resourcePath = SpritesheetLoader2.getResourcePath(resource, loader.baseUrl);
        loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {
          if (res.error) {
            next(res.error);
            return;
          }
          var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);
          spritesheet.parse(function() {
            resource.spritesheet = spritesheet;
            resource.textures = spritesheet.textures;
            next();
          });
        });
      };
      SpritesheetLoader2.getResourcePath = function(resource, baseUrl) {
        if (resource.isDataUrl) {
          return resource.data.meta.image;
        }
        return url.resolve(resource.url.replace(baseUrl, ""), resource.data.meta.image);
      };
      return SpritesheetLoader2;
    }();
    /*!
     * @pixi/sprite-tiling - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/sprite-tiling is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$a = function(d, b) {
      extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$a(d, b);
    };
    function __extends$a(d, b) {
      extendStatics$a(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var tempPoint$1 = new Point();
    (function(_super) {
      __extends$a(TilingSprite, _super);
      function TilingSprite(texture, width2, height2) {
        if (width2 === void 0) {
          width2 = 100;
        }
        if (height2 === void 0) {
          height2 = 100;
        }
        var _this = _super.call(this, texture) || this;
        _this.tileTransform = new Transform();
        _this._width = width2;
        _this._height = height2;
        _this.uvMatrix = _this.texture.uvMatrix || new TextureMatrix(texture);
        _this.pluginName = "tilingSprite";
        _this.uvRespectAnchor = false;
        return _this;
      }
      Object.defineProperty(TilingSprite.prototype, "clampMargin", {
        get: function() {
          return this.uvMatrix.clampMargin;
        },
        set: function(value2) {
          this.uvMatrix.clampMargin = value2;
          this.uvMatrix.update(true);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TilingSprite.prototype, "tileScale", {
        get: function() {
          return this.tileTransform.scale;
        },
        set: function(value2) {
          this.tileTransform.scale.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TilingSprite.prototype, "tilePosition", {
        get: function() {
          return this.tileTransform.position;
        },
        set: function(value2) {
          this.tileTransform.position.copyFrom(value2);
        },
        enumerable: false,
        configurable: true
      });
      TilingSprite.prototype._onTextureUpdate = function() {
        if (this.uvMatrix) {
          this.uvMatrix.texture = this._texture;
        }
        this._cachedTint = 16777215;
      };
      TilingSprite.prototype._render = function(renderer) {
        var texture = this._texture;
        if (!texture || !texture.valid) {
          return;
        }
        this.tileTransform.updateLocalTransform();
        this.uvMatrix.update();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
      };
      TilingSprite.prototype._calculateBounds = function() {
        var minX = this._width * -this._anchor._x;
        var minY = this._height * -this._anchor._y;
        var maxX = this._width * (1 - this._anchor._x);
        var maxY = this._height * (1 - this._anchor._y);
        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
      };
      TilingSprite.prototype.getLocalBounds = function(rect) {
        if (this.children.length === 0) {
          this._bounds.minX = this._width * -this._anchor._x;
          this._bounds.minY = this._height * -this._anchor._y;
          this._bounds.maxX = this._width * (1 - this._anchor._x);
          this._bounds.maxY = this._height * (1 - this._anchor._y);
          if (!rect) {
            if (!this._localBoundsRect) {
              this._localBoundsRect = new Rectangle();
            }
            rect = this._localBoundsRect;
          }
          return this._bounds.getRectangle(rect);
        }
        return _super.prototype.getLocalBounds.call(this, rect);
      };
      TilingSprite.prototype.containsPoint = function(point) {
        this.worldTransform.applyInverse(point, tempPoint$1);
        var width2 = this._width;
        var height2 = this._height;
        var x1 = -width2 * this.anchor._x;
        if (tempPoint$1.x >= x1 && tempPoint$1.x < x1 + width2) {
          var y1 = -height2 * this.anchor._y;
          if (tempPoint$1.y >= y1 && tempPoint$1.y < y1 + height2) {
            return true;
          }
        }
        return false;
      };
      TilingSprite.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this.tileTransform = null;
        this.uvMatrix = null;
      };
      TilingSprite.from = function(source, options) {
        if (typeof options === "number") {
          deprecation("5.3.0", "TilingSprite.from use options instead of width and height args");
          options = { width: options, height: arguments[2] };
        }
        return new TilingSprite(Texture.from(source, options), options.width, options.height);
      };
      Object.defineProperty(TilingSprite.prototype, "width", {
        get: function() {
          return this._width;
        },
        set: function(value2) {
          this._width = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TilingSprite.prototype, "height", {
        get: function() {
          return this._height;
        },
        set: function(value2) {
          this._height = value2;
        },
        enumerable: false,
        configurable: true
      });
      return TilingSprite;
    })(Sprite);
    var vertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
    var fragment$6 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture2D(uSampler, coord);\n    gl_FragColor = texSample * uColor;\n}\n";
    var fragmentSimple = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";
    var tempMat = new Matrix();
    var TilingSpriteRenderer = function(_super) {
      __extends$a(TilingSpriteRenderer2, _super);
      function TilingSpriteRenderer2(renderer) {
        var _this = _super.call(this, renderer) || this;
        var uniforms = { globals: _this.renderer.globalUniforms };
        _this.shader = Shader.from(vertex$3, fragment$6, uniforms);
        _this.simpleShader = Shader.from(vertex$3, fragmentSimple, uniforms);
        _this.quad = new QuadUv();
        _this.state = State.for2d();
        return _this;
      }
      TilingSpriteRenderer2.prototype.render = function(ts) {
        var renderer = this.renderer;
        var quad = this.quad;
        var vertices = quad.vertices;
        vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
        vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
        vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
        if (ts.uvRespectAnchor) {
          vertices = quad.uvs;
          vertices[0] = vertices[6] = -ts.anchor.x;
          vertices[1] = vertices[3] = -ts.anchor.y;
          vertices[2] = vertices[4] = 1 - ts.anchor.x;
          vertices[5] = vertices[7] = 1 - ts.anchor.y;
        }
        quad.invalidate();
        var tex = ts._texture;
        var baseTex = tex.baseTexture;
        var lt = ts.tileTransform.localTransform;
        var uv = ts.uvMatrix;
        var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
        if (isSimple) {
          if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
            if (baseTex.wrapMode === WRAP_MODES$1.CLAMP) {
              baseTex.wrapMode = WRAP_MODES$1.REPEAT;
            }
          } else {
            isSimple = baseTex.wrapMode !== WRAP_MODES$1.CLAMP;
          }
        }
        var shader = isSimple ? this.simpleShader : this.shader;
        var w2 = tex.width;
        var h2 = tex.height;
        var W2 = ts._width;
        var H2 = ts._height;
        tempMat.set(lt.a * w2 / W2, lt.b * w2 / H2, lt.c * h2 / W2, lt.d * h2 / H2, lt.tx / W2, lt.ty / H2);
        tempMat.invert();
        if (isSimple) {
          tempMat.prepend(uv.mapCoord);
        } else {
          shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
          shader.uniforms.uClampFrame = uv.uClampFrame;
          shader.uniforms.uClampOffset = uv.uClampOffset;
        }
        shader.uniforms.uTransform = tempMat.toArray(true);
        shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.alphaMode);
        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
        shader.uniforms.uSampler = tex;
        renderer.shader.bind(shader);
        renderer.geometry.bind(quad);
        this.state.blendMode = correctBlendMode(ts.blendMode, baseTex.alphaMode);
        renderer.state.set(this.state);
        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
      };
      return TilingSpriteRenderer2;
    }(ObjectRenderer);
    /*!
     * @pixi/mesh - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/mesh is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$9 = function(d, b) {
      extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$9(d, b);
    };
    function __extends$9(d, b) {
      extendStatics$9(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var MeshBatchUvs = function() {
      function MeshBatchUvs2(uvBuffer, uvMatrix) {
        this.uvBuffer = uvBuffer;
        this.uvMatrix = uvMatrix;
        this.data = null;
        this._bufferUpdateId = -1;
        this._textureUpdateId = -1;
        this._updateID = 0;
      }
      MeshBatchUvs2.prototype.update = function(forceUpdate) {
        if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
          return;
        }
        this._bufferUpdateId = this.uvBuffer._updateID;
        this._textureUpdateId = this.uvMatrix._updateID;
        var data = this.uvBuffer.data;
        if (!this.data || this.data.length !== data.length) {
          this.data = new Float32Array(data.length);
        }
        this.uvMatrix.multiplyUvs(data, this.data);
        this._updateID++;
      };
      return MeshBatchUvs2;
    }();
    var tempPoint = new Point();
    var tempPolygon = new Polygon();
    var Mesh = function(_super) {
      __extends$9(Mesh2, _super);
      function Mesh2(geometry, shader, state, drawMode) {
        if (drawMode === void 0) {
          drawMode = DRAW_MODES$1.TRIANGLES;
        }
        var _this = _super.call(this) || this;
        _this.geometry = geometry;
        geometry.refCount++;
        _this.shader = shader;
        _this.state = state || State.for2d();
        _this.drawMode = drawMode;
        _this.start = 0;
        _this.size = 0;
        _this.uvs = null;
        _this.indices = null;
        _this.vertexData = new Float32Array(1);
        _this.vertexDirty = 0;
        _this._transformID = -1;
        _this._roundPixels = settings.ROUND_PIXELS;
        _this.batchUvs = null;
        return _this;
      }
      Object.defineProperty(Mesh2.prototype, "uvBuffer", {
        get: function() {
          return this.geometry.buffers[1];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "verticesBuffer", {
        get: function() {
          return this.geometry.buffers[0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "material", {
        get: function() {
          return this.shader;
        },
        set: function(value2) {
          this.shader = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "blendMode", {
        get: function() {
          return this.state.blendMode;
        },
        set: function(value2) {
          this.state.blendMode = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "roundPixels", {
        get: function() {
          return this._roundPixels;
        },
        set: function(value2) {
          if (this._roundPixels !== value2) {
            this._transformID = -1;
          }
          this._roundPixels = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "tint", {
        get: function() {
          return this.shader.tint;
        },
        set: function(value2) {
          this.shader.tint = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Mesh2.prototype, "texture", {
        get: function() {
          return this.shader.texture;
        },
        set: function(value2) {
          this.shader.texture = value2;
        },
        enumerable: false,
        configurable: true
      });
      Mesh2.prototype._render = function(renderer) {
        var vertices = this.geometry.buffers[0].data;
        if (this.shader.batchable && this.drawMode === DRAW_MODES$1.TRIANGLES && vertices.length < Mesh2.BATCHABLE_SIZE * 2) {
          this._renderToBatch(renderer);
        } else {
          this._renderDefault(renderer);
        }
      };
      Mesh2.prototype._renderDefault = function(renderer) {
        var shader = this.shader;
        shader.alpha = this.worldAlpha;
        if (shader.update) {
          shader.update();
        }
        renderer.batch.flush();
        if (shader.program.uniformData.translationMatrix) {
          shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
        }
        renderer.shader.bind(shader);
        renderer.state.set(this.state);
        renderer.geometry.bind(this.geometry, shader);
        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
      };
      Mesh2.prototype._renderToBatch = function(renderer) {
        var geometry = this.geometry;
        if (this.shader.uvMatrix) {
          this.shader.uvMatrix.update();
          this.calculateUvs();
        }
        this.calculateVertices();
        this.indices = geometry.indexBuffer.data;
        this._tintRGB = this.shader._tintRGB;
        this._texture = this.shader.texture;
        var pluginName = this.material.pluginName;
        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
        renderer.plugins[pluginName].render(this);
      };
      Mesh2.prototype.calculateVertices = function() {
        var geometry = this.geometry;
        var vertices = geometry.buffers[0].data;
        if (geometry.vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
          return;
        }
        this._transformID = this.transform._worldID;
        if (this.vertexData.length !== vertices.length) {
          this.vertexData = new Float32Array(vertices.length);
        }
        var wt = this.transform.worldTransform;
        var a2 = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        for (var i2 = 0; i2 < vertexData.length / 2; i2++) {
          var x2 = vertices[i2 * 2];
          var y2 = vertices[i2 * 2 + 1];
          vertexData[i2 * 2] = a2 * x2 + c * y2 + tx;
          vertexData[i2 * 2 + 1] = b * x2 + d * y2 + ty;
        }
        if (this._roundPixels) {
          var resolution = settings.RESOLUTION;
          for (var i2 = 0; i2 < vertexData.length; ++i2) {
            vertexData[i2] = Math.round((vertexData[i2] * resolution | 0) / resolution);
          }
        }
        this.vertexDirty = geometry.vertexDirtyId;
      };
      Mesh2.prototype.calculateUvs = function() {
        var geomUvs = this.geometry.buffers[1];
        if (!this.shader.uvMatrix.isSimple) {
          if (!this.batchUvs) {
            this.batchUvs = new MeshBatchUvs(geomUvs, this.shader.uvMatrix);
          }
          this.batchUvs.update();
          this.uvs = this.batchUvs.data;
        } else {
          this.uvs = geomUvs.data;
        }
      };
      Mesh2.prototype._calculateBounds = function() {
        this.calculateVertices();
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
      };
      Mesh2.prototype.containsPoint = function(point) {
        if (!this.getBounds().contains(point.x, point.y)) {
          return false;
        }
        this.worldTransform.applyInverse(point, tempPoint);
        var vertices = this.geometry.getBuffer("aVertexPosition").data;
        var points = tempPolygon.points;
        var indices2 = this.geometry.getIndex().data;
        var len = indices2.length;
        var step = this.drawMode === 4 ? 3 : 1;
        for (var i2 = 0; i2 + 2 < len; i2 += step) {
          var ind0 = indices2[i2] * 2;
          var ind1 = indices2[i2 + 1] * 2;
          var ind2 = indices2[i2 + 2] * 2;
          points[0] = vertices[ind0];
          points[1] = vertices[ind0 + 1];
          points[2] = vertices[ind1];
          points[3] = vertices[ind1 + 1];
          points[4] = vertices[ind2];
          points[5] = vertices[ind2 + 1];
          if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
            return true;
          }
        }
        return false;
      };
      Mesh2.prototype.destroy = function(options) {
        _super.prototype.destroy.call(this, options);
        this.geometry.refCount--;
        if (this.geometry.refCount === 0) {
          this.geometry.dispose();
        }
        this.geometry = null;
        this.shader = null;
        this.state = null;
        this.uvs = null;
        this.indices = null;
        this.vertexData = null;
      };
      Mesh2.BATCHABLE_SIZE = 100;
      return Mesh2;
    }(Container);
    var fragment$5 = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
    var vertex$2 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
    var MeshMaterial = function(_super) {
      __extends$9(MeshMaterial2, _super);
      function MeshMaterial2(uSampler, options) {
        var _this = this;
        var uniforms = {
          uSampler,
          alpha: 1,
          uTextureMatrix: Matrix.IDENTITY,
          uColor: new Float32Array([1, 1, 1, 1])
        };
        options = Object.assign({
          tint: 16777215,
          alpha: 1,
          pluginName: "batch"
        }, options);
        if (options.uniforms) {
          Object.assign(uniforms, options.uniforms);
        }
        _this = _super.call(this, options.program || Program.from(vertex$2, fragment$5), uniforms) || this;
        _this._colorDirty = false;
        _this.uvMatrix = new TextureMatrix(uSampler);
        _this.batchable = options.program === void 0;
        _this.pluginName = options.pluginName;
        _this.tint = options.tint;
        _this.alpha = options.alpha;
        return _this;
      }
      Object.defineProperty(MeshMaterial2.prototype, "texture", {
        get: function() {
          return this.uniforms.uSampler;
        },
        set: function(value2) {
          if (this.uniforms.uSampler !== value2) {
            this.uniforms.uSampler = value2;
            this.uvMatrix.texture = value2;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MeshMaterial2.prototype, "alpha", {
        get: function() {
          return this._alpha;
        },
        set: function(value2) {
          if (value2 === this._alpha) {
            return;
          }
          this._alpha = value2;
          this._colorDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MeshMaterial2.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value2) {
          if (value2 === this._tint) {
            return;
          }
          this._tint = value2;
          this._tintRGB = (value2 >> 16) + (value2 & 65280) + ((value2 & 255) << 16);
          this._colorDirty = true;
        },
        enumerable: false,
        configurable: true
      });
      MeshMaterial2.prototype.update = function() {
        if (this._colorDirty) {
          this._colorDirty = false;
          var baseTexture = this.texture.baseTexture;
          premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);
        }
        if (this.uvMatrix.update()) {
          this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
        }
      };
      return MeshMaterial2;
    }(Shader);
    var MeshGeometry = function(_super) {
      __extends$9(MeshGeometry2, _super);
      function MeshGeometry2(vertices, uvs, index2) {
        var _this = _super.call(this) || this;
        var verticesBuffer = new Buffer$1(vertices);
        var uvsBuffer = new Buffer$1(uvs, true);
        var indexBuffer = new Buffer$1(index2, true, true);
        _this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES$1.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES$1.FLOAT).addIndex(indexBuffer);
        _this._updateId = -1;
        return _this;
      }
      Object.defineProperty(MeshGeometry2.prototype, "vertexDirtyId", {
        get: function() {
          return this.buffers[0]._updateID;
        },
        enumerable: false,
        configurable: true
      });
      return MeshGeometry2;
    }(Geometry);
    /*!
     * @pixi/text-bitmap - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/text-bitmap is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$8 = function(d, b) {
      extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$8(d, b);
    };
    function __extends$8(d, b) {
      extendStatics$8(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var BitmapFontData = function() {
      function BitmapFontData2() {
        this.info = [];
        this.common = [];
        this.page = [];
        this.char = [];
        this.kerning = [];
      }
      return BitmapFontData2;
    }();
    var TextFormat = function() {
      function TextFormat2() {
      }
      TextFormat2.test = function(data) {
        return typeof data === "string" && data.indexOf("info face=") === 0;
      };
      TextFormat2.parse = function(txt) {
        var items2 = txt.match(/^[a-z]+\s+.+$/gm);
        var rawData = {
          info: [],
          common: [],
          page: [],
          char: [],
          chars: [],
          kerning: [],
          kernings: []
        };
        for (var i2 in items2) {
          var name = items2[i2].match(/^[a-z]+/gm)[0];
          var attributeList = items2[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
          var itemData = {};
          for (var i_1 in attributeList) {
            var split = attributeList[i_1].split("=");
            var key = split[0];
            var strValue = split[1].replace(/"/gm, "");
            var floatValue = parseFloat(strValue);
            var value2 = isNaN(floatValue) ? strValue : floatValue;
            itemData[key] = value2;
          }
          rawData[name].push(itemData);
        }
        var font = new BitmapFontData();
        rawData.info.forEach(function(info) {
          return font.info.push({
            face: info.face,
            size: parseInt(info.size, 10)
          });
        });
        rawData.common.forEach(function(common) {
          return font.common.push({
            lineHeight: parseInt(common.lineHeight, 10)
          });
        });
        rawData.page.forEach(function(page) {
          return font.page.push({
            id: parseInt(page.id, 10),
            file: page.file
          });
        });
        rawData.char.forEach(function(char) {
          return font.char.push({
            id: parseInt(char.id, 10),
            page: parseInt(char.page, 10),
            x: parseInt(char.x, 10),
            y: parseInt(char.y, 10),
            width: parseInt(char.width, 10),
            height: parseInt(char.height, 10),
            xoffset: parseInt(char.xoffset, 10),
            yoffset: parseInt(char.yoffset, 10),
            xadvance: parseInt(char.xadvance, 10)
          });
        });
        rawData.kerning.forEach(function(kerning) {
          return font.kerning.push({
            first: parseInt(kerning.first, 10),
            second: parseInt(kerning.second, 10),
            amount: parseInt(kerning.amount, 10)
          });
        });
        return font;
      };
      return TextFormat2;
    }();
    var XMLFormat = function() {
      function XMLFormat2() {
      }
      XMLFormat2.test = function(data) {
        return data instanceof XMLDocument && data.getElementsByTagName("page").length && data.getElementsByTagName("info")[0].getAttribute("face") !== null;
      };
      XMLFormat2.parse = function(xml) {
        var data = new BitmapFontData();
        var info = xml.getElementsByTagName("info");
        var common = xml.getElementsByTagName("common");
        var page = xml.getElementsByTagName("page");
        var char = xml.getElementsByTagName("char");
        var kerning = xml.getElementsByTagName("kerning");
        for (var i2 = 0; i2 < info.length; i2++) {
          data.info.push({
            face: info[i2].getAttribute("face"),
            size: parseInt(info[i2].getAttribute("size"), 10)
          });
        }
        for (var i2 = 0; i2 < common.length; i2++) {
          data.common.push({
            lineHeight: parseInt(common[i2].getAttribute("lineHeight"), 10)
          });
        }
        for (var i2 = 0; i2 < page.length; i2++) {
          data.page.push({
            id: parseInt(page[i2].getAttribute("id"), 10) || 0,
            file: page[i2].getAttribute("file")
          });
        }
        for (var i2 = 0; i2 < char.length; i2++) {
          var letter = char[i2];
          data.char.push({
            id: parseInt(letter.getAttribute("id"), 10),
            page: parseInt(letter.getAttribute("page"), 10) || 0,
            x: parseInt(letter.getAttribute("x"), 10),
            y: parseInt(letter.getAttribute("y"), 10),
            width: parseInt(letter.getAttribute("width"), 10),
            height: parseInt(letter.getAttribute("height"), 10),
            xoffset: parseInt(letter.getAttribute("xoffset"), 10),
            yoffset: parseInt(letter.getAttribute("yoffset"), 10),
            xadvance: parseInt(letter.getAttribute("xadvance"), 10)
          });
        }
        for (var i2 = 0; i2 < kerning.length; i2++) {
          data.kerning.push({
            first: parseInt(kerning[i2].getAttribute("first"), 10),
            second: parseInt(kerning[i2].getAttribute("second"), 10),
            amount: parseInt(kerning[i2].getAttribute("amount"), 10)
          });
        }
        return data;
      };
      return XMLFormat2;
    }();
    var XMLStringFormat = function() {
      function XMLStringFormat2() {
      }
      XMLStringFormat2.test = function(data) {
        if (typeof data === "string" && data.indexOf("<font>") > -1) {
          var xml = new self.DOMParser().parseFromString(data, "text/xml");
          return XMLFormat.test(xml);
        }
        return false;
      };
      XMLStringFormat2.parse = function(xmlTxt) {
        var xml = new window.DOMParser().parseFromString(xmlTxt, "text/xml");
        return XMLFormat.parse(xml);
      };
      return XMLStringFormat2;
    }();
    var formats = [
      TextFormat,
      XMLFormat,
      XMLStringFormat
    ];
    function autoDetectFormat(data) {
      for (var i2 = 0; i2 < formats.length; i2++) {
        if (formats[i2].test(data)) {
          return formats[i2];
        }
      }
      return null;
    }
    function generateFillStyle(canvas2, context2, style, resolution, lines, metrics) {
      var fillStyle = style.fill;
      if (!Array.isArray(fillStyle)) {
        return fillStyle;
      } else if (fillStyle.length === 1) {
        return fillStyle[0];
      }
      var gradient;
      var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
      var padding = style.padding || 0;
      var width2 = Math.ceil(canvas2.width / resolution) - dropShadowCorrection - padding * 2;
      var height2 = Math.ceil(canvas2.height / resolution) - dropShadowCorrection - padding * 2;
      var fill = fillStyle.slice();
      var fillGradientStops = style.fillGradientStops.slice();
      if (!fillGradientStops.length) {
        var lengthPlus1 = fill.length + 1;
        for (var i2 = 1; i2 < lengthPlus1; ++i2) {
          fillGradientStops.push(i2 / lengthPlus1);
        }
      }
      fill.unshift(fillStyle[0]);
      fillGradientStops.unshift(0);
      fill.push(fillStyle[fillStyle.length - 1]);
      fillGradientStops.push(1);
      if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
        gradient = context2.createLinearGradient(width2 / 2, padding, width2 / 2, height2 + padding);
        var lastIterationStop = 0;
        var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
        var gradStopLineHeight = textHeight / height2;
        for (var i2 = 0; i2 < lines.length; i2++) {
          var thisLineTop = metrics.lineHeight * i2;
          for (var j = 0; j < fill.length; j++) {
            var lineStop = 0;
            if (typeof fillGradientStops[j] === "number") {
              lineStop = fillGradientStops[j];
            } else {
              lineStop = j / fill.length;
            }
            var globalStop = thisLineTop / height2 + lineStop * gradStopLineHeight;
            var clampedStop = Math.max(lastIterationStop, globalStop);
            clampedStop = Math.min(clampedStop, 1);
            gradient.addColorStop(clampedStop, fill[j]);
            lastIterationStop = clampedStop;
          }
        }
      } else {
        gradient = context2.createLinearGradient(padding, height2 / 2, width2 + padding, height2 / 2);
        var totalIterations = fill.length + 1;
        var currentIteration = 1;
        for (var i2 = 0; i2 < fill.length; i2++) {
          var stop = void 0;
          if (typeof fillGradientStops[i2] === "number") {
            stop = fillGradientStops[i2];
          } else {
            stop = currentIteration / totalIterations;
          }
          gradient.addColorStop(stop, fill[i2]);
          currentIteration++;
        }
      }
      return gradient;
    }
    function drawGlyph(canvas2, context2, metrics, x2, y2, resolution, style) {
      var char = metrics.text;
      var fontProperties = metrics.fontProperties;
      context2.translate(x2, y2);
      context2.scale(resolution, resolution);
      var tx = style.strokeThickness / 2;
      var ty = -(style.strokeThickness / 2);
      context2.font = style.toFontString();
      context2.lineWidth = style.strokeThickness;
      context2.textBaseline = style.textBaseline;
      context2.lineJoin = style.lineJoin;
      context2.miterLimit = style.miterLimit;
      context2.fillStyle = generateFillStyle(canvas2, context2, style, resolution, [char], metrics);
      context2.strokeStyle = style.stroke;
      if (style.dropShadow) {
        var dropShadowColor = style.dropShadowColor;
        var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
        var dropShadowBlur = style.dropShadowBlur * resolution;
        var dropShadowDistance = style.dropShadowDistance * resolution;
        context2.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
        context2.shadowBlur = dropShadowBlur;
        context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
        context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
      } else {
        context2.shadowColor = "black";
        context2.shadowBlur = 0;
        context2.shadowOffsetX = 0;
        context2.shadowOffsetY = 0;
      }
      if (style.stroke && style.strokeThickness) {
        context2.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
      }
      if (style.fill) {
        context2.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
      }
      context2.setTransform(1, 0, 0, 1, 0, 0);
      context2.fillStyle = "rgba(0, 0, 0, 0)";
    }
    function resolveCharacters(chars) {
      if (typeof chars === "string") {
        chars = [chars];
      }
      var result2 = [];
      for (var i2 = 0, j = chars.length; i2 < j; i2++) {
        var item = chars[i2];
        if (Array.isArray(item)) {
          if (item.length !== 2) {
            throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + item.length + ".");
          }
          var startCode = item[0].charCodeAt(0);
          var endCode = item[1].charCodeAt(0);
          if (endCode < startCode) {
            throw new Error("[BitmapFont]: Invalid character range.");
          }
          for (var i_1 = startCode, j_1 = endCode; i_1 <= j_1; i_1++) {
            result2.push(String.fromCharCode(i_1));
          }
        } else {
          result2.push.apply(result2, item.split(""));
        }
      }
      if (result2.length === 0) {
        throw new Error("[BitmapFont]: Empty set when resolving characters.");
      }
      return result2;
    }
    var BitmapFont = function() {
      function BitmapFont2(data, textures, ownsTextures) {
        var info = data.info[0];
        var common = data.common[0];
        var page = data.page[0];
        var res = getResolutionOfUrl(page.file);
        var pageTextures = {};
        this._ownsTextures = ownsTextures;
        this.font = info.face;
        this.size = info.size;
        this.lineHeight = common.lineHeight / res;
        this.chars = {};
        this.pageTextures = pageTextures;
        for (var i2 = 0; i2 < data.page.length; i2++) {
          var _a2 = data.page[i2], id2 = _a2.id, file = _a2.file;
          pageTextures[id2] = textures instanceof Array ? textures[i2] : textures[file];
        }
        for (var i2 = 0; i2 < data.char.length; i2++) {
          var _b = data.char[i2], id2 = _b.id, page_1 = _b.page;
          var _c = data.char[i2], x2 = _c.x, y2 = _c.y, width2 = _c.width, height2 = _c.height, xoffset = _c.xoffset, yoffset = _c.yoffset, xadvance = _c.xadvance;
          x2 /= res;
          y2 /= res;
          width2 /= res;
          height2 /= res;
          xoffset /= res;
          yoffset /= res;
          xadvance /= res;
          var rect = new Rectangle(x2 + pageTextures[page_1].frame.x / res, y2 + pageTextures[page_1].frame.y / res, width2, height2);
          this.chars[id2] = {
            xOffset: xoffset,
            yOffset: yoffset,
            xAdvance: xadvance,
            kerning: {},
            texture: new Texture(pageTextures[page_1].baseTexture, rect),
            page: page_1
          };
        }
        for (var i2 = 0; i2 < data.kerning.length; i2++) {
          var _d = data.kerning[i2], first2 = _d.first, second = _d.second, amount = _d.amount;
          first2 /= res;
          second /= res;
          amount /= res;
          if (this.chars[second]) {
            this.chars[second].kerning[first2] = amount;
          }
        }
      }
      BitmapFont2.prototype.destroy = function() {
        for (var id2 in this.chars) {
          this.chars[id2].texture.destroy();
          this.chars[id2].texture = null;
        }
        for (var id2 in this.pageTextures) {
          if (this._ownsTextures) {
            this.pageTextures[id2].destroy(true);
          }
          this.pageTextures[id2] = null;
        }
        this.chars = null;
        this.pageTextures = null;
      };
      BitmapFont2.install = function(data, textures, ownsTextures) {
        var fontData;
        if (data instanceof BitmapFontData) {
          fontData = data;
        } else {
          var format2 = autoDetectFormat(data);
          if (!format2) {
            throw new Error("Unrecognized data format for font.");
          }
          fontData = format2.parse(data);
        }
        if (textures instanceof Texture) {
          textures = [textures];
        }
        var font = new BitmapFont2(fontData, textures, ownsTextures);
        BitmapFont2.available[font.font] = font;
        return font;
      };
      BitmapFont2.uninstall = function(name) {
        var font = BitmapFont2.available[name];
        if (!font) {
          throw new Error("No font found named '" + name + "'");
        }
        font.destroy();
        delete BitmapFont2.available[name];
      };
      BitmapFont2.from = function(name, textStyle, options) {
        if (!name) {
          throw new Error("[BitmapFont] Property `name` is required.");
        }
        var _a2 = Object.assign({}, BitmapFont2.defaultOptions, options), chars = _a2.chars, padding = _a2.padding, resolution = _a2.resolution, textureWidth = _a2.textureWidth, textureHeight = _a2.textureHeight;
        var charsList = resolveCharacters(chars);
        var style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
        var lineWidth = textureWidth;
        var fontData = new BitmapFontData();
        fontData.info[0] = {
          face: style.fontFamily,
          size: style.fontSize
        };
        fontData.common[0] = {
          lineHeight: style.fontSize
        };
        var positionX = 0;
        var positionY = 0;
        var canvas2;
        var context2;
        var baseTexture;
        var maxCharHeight = 0;
        var textures = [];
        for (var i2 = 0; i2 < charsList.length; i2++) {
          if (!canvas2) {
            canvas2 = document.createElement("canvas");
            canvas2.width = textureWidth;
            canvas2.height = textureHeight;
            context2 = canvas2.getContext("2d");
            baseTexture = new BaseTexture(canvas2, { resolution });
            textures.push(new Texture(baseTexture));
            fontData.page.push({
              id: textures.length - 1,
              file: ""
            });
          }
          var metrics = TextMetrics.measureText(charsList[i2], style, false, canvas2);
          var width2 = metrics.width;
          var height2 = Math.ceil(metrics.height);
          var textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width2);
          if (positionY >= textureHeight - height2 * resolution) {
            if (positionY === 0) {
              throw new Error("[BitmapFont] textureHeight " + textureHeight + "px is " + ("too small for " + style.fontSize + "px fonts"));
            }
            --i2;
            canvas2 = null;
            context2 = null;
            baseTexture = null;
            positionY = 0;
            positionX = 0;
            maxCharHeight = 0;
            continue;
          }
          maxCharHeight = Math.max(height2 + metrics.fontProperties.descent, maxCharHeight);
          if (textureGlyphWidth * resolution + positionX >= lineWidth) {
            --i2;
            positionY += maxCharHeight * resolution;
            positionY = Math.ceil(positionY);
            positionX = 0;
            maxCharHeight = 0;
            continue;
          }
          drawGlyph(canvas2, context2, metrics, positionX, positionY, resolution, style);
          var id2 = metrics.text.charCodeAt(0);
          fontData.char.push({
            id: id2,
            page: textures.length - 1,
            x: positionX / resolution,
            y: positionY / resolution,
            width: textureGlyphWidth,
            height: height2,
            xoffset: 0,
            yoffset: 0,
            xadvance: Math.ceil(width2 - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))
          });
          positionX += (textureGlyphWidth + 2 * padding) * resolution;
          positionX = Math.ceil(positionX);
        }
        var font = new BitmapFont2(fontData, textures, true);
        if (BitmapFont2.available[name] !== void 0) {
          BitmapFont2.uninstall(name);
        }
        BitmapFont2.available[name] = font;
        return font;
      };
      BitmapFont2.ALPHA = [["a", "z"], ["A", "Z"], " "];
      BitmapFont2.NUMERIC = [["0", "9"]];
      BitmapFont2.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
      BitmapFont2.ASCII = [[" ", "~"]];
      BitmapFont2.defaultOptions = {
        resolution: 1,
        textureWidth: 512,
        textureHeight: 512,
        padding: 4,
        chars: BitmapFont2.ALPHANUMERIC
      };
      BitmapFont2.available = {};
      return BitmapFont2;
    }();
    var pageMeshDataPool = [];
    var charRenderDataPool = [];
    (function(_super) {
      __extends$8(BitmapText, _super);
      function BitmapText(text, style) {
        if (style === void 0) {
          style = {};
        }
        var _this = _super.call(this) || this;
        _this._tint = 16777215;
        if (style.font) {
          deprecation("5.3.0", "PIXI.BitmapText constructor style.font property is deprecated.");
          _this._upgradeStyle(style);
        }
        var _a2 = Object.assign({}, BitmapText.styleDefaults, style), align = _a2.align, tint = _a2.tint, maxWidth = _a2.maxWidth, letterSpacing = _a2.letterSpacing, fontName = _a2.fontName, fontSize = _a2.fontSize;
        if (!BitmapFont.available[fontName]) {
          throw new Error('Missing BitmapFont "' + fontName + '"');
        }
        _this._activePagesMeshData = [];
        _this._textWidth = 0;
        _this._textHeight = 0;
        _this._align = align;
        _this._tint = tint;
        _this._fontName = fontName;
        _this._fontSize = fontSize || BitmapFont.available[fontName].size;
        _this._text = text;
        _this._maxWidth = maxWidth;
        _this._maxLineHeight = 0;
        _this._letterSpacing = letterSpacing;
        _this._anchor = new ObservablePoint(function() {
          _this.dirty = true;
        }, _this, 0, 0);
        _this._roundPixels = settings.ROUND_PIXELS;
        _this.dirty = true;
        _this._textureCache = {};
        return _this;
      }
      BitmapText.prototype.updateText = function() {
        var _a2;
        var data = BitmapFont.available[this._fontName];
        var scale = this._fontSize / data.size;
        var pos = new Point();
        var chars = [];
        var lineWidths = [];
        var text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
        var textLength = text.length;
        var maxWidth = this._maxWidth * data.size / this._fontSize;
        var prevCharCode = null;
        var lastLineWidth = 0;
        var maxLineWidth = 0;
        var line = 0;
        var lastBreakPos = -1;
        var lastBreakWidth = 0;
        var spacesRemoved = 0;
        var maxLineHeight = 0;
        for (var i2 = 0; i2 < textLength; i2++) {
          var charCode = text.charCodeAt(i2);
          var char = text.charAt(i2);
          if (/(?:\s)/.test(char)) {
            lastBreakPos = i2;
            lastBreakWidth = lastLineWidth;
          }
          if (char === "\r" || char === "\n") {
            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
            ++line;
            ++spacesRemoved;
            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
            continue;
          }
          var charData = data.chars[charCode];
          if (!charData) {
            continue;
          }
          if (prevCharCode && charData.kerning[prevCharCode]) {
            pos.x += charData.kerning[prevCharCode];
          }
          var charRenderData = charRenderDataPool.pop() || {
            texture: Texture.EMPTY,
            line: 0,
            charCode: 0,
            position: new Point()
          };
          charRenderData.texture = charData.texture;
          charRenderData.line = line;
          charRenderData.charCode = charCode;
          charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;
          charRenderData.position.y = pos.y + charData.yOffset;
          chars.push(charRenderData);
          pos.x += charData.xAdvance + this._letterSpacing;
          lastLineWidth = pos.x;
          maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
          prevCharCode = charCode;
          if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
            ++spacesRemoved;
            removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i2 - lastBreakPos);
            i2 = lastBreakPos;
            lastBreakPos = -1;
            lineWidths.push(lastBreakWidth);
            maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
            line++;
            pos.x = 0;
            pos.y += data.lineHeight;
            prevCharCode = null;
          }
        }
        var lastChar = text.charAt(text.length - 1);
        if (lastChar !== "\r" && lastChar !== "\n") {
          if (/(?:\s)/.test(lastChar)) {
            lastLineWidth = lastBreakWidth;
          }
          lineWidths.push(lastLineWidth);
          maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        }
        var lineAlignOffsets = [];
        for (var i2 = 0; i2 <= line; i2++) {
          var alignOffset = 0;
          if (this._align === "right") {
            alignOffset = maxLineWidth - lineWidths[i2];
          } else if (this._align === "center") {
            alignOffset = (maxLineWidth - lineWidths[i2]) / 2;
          }
          lineAlignOffsets.push(alignOffset);
        }
        var lenChars = chars.length;
        var pagesMeshData = {};
        var newPagesMeshData = [];
        var activePagesMeshData = this._activePagesMeshData;
        for (var i2 = 0; i2 < activePagesMeshData.length; i2++) {
          pageMeshDataPool.push(activePagesMeshData[i2]);
        }
        for (var i2 = 0; i2 < lenChars; i2++) {
          var texture = chars[i2].texture;
          var baseTextureUid = texture.baseTexture.uid;
          if (!pagesMeshData[baseTextureUid]) {
            var pageMeshData = pageMeshDataPool.pop();
            if (!pageMeshData) {
              var geometry = new MeshGeometry();
              var material = new MeshMaterial(Texture.EMPTY);
              var mesh = new Mesh(geometry, material);
              pageMeshData = {
                index: 0,
                indexCount: 0,
                vertexCount: 0,
                uvsCount: 0,
                total: 0,
                mesh,
                vertices: null,
                uvs: null,
                indices: null
              };
            }
            pageMeshData.index = 0;
            pageMeshData.indexCount = 0;
            pageMeshData.vertexCount = 0;
            pageMeshData.uvsCount = 0;
            pageMeshData.total = 0;
            var _textureCache = this._textureCache;
            _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
            pageMeshData.mesh.texture = _textureCache[baseTextureUid];
            pageMeshData.mesh.tint = this._tint;
            newPagesMeshData.push(pageMeshData);
            pagesMeshData[baseTextureUid] = pageMeshData;
          }
          pagesMeshData[baseTextureUid].total++;
        }
        for (var i2 = 0; i2 < activePagesMeshData.length; i2++) {
          if (newPagesMeshData.indexOf(activePagesMeshData[i2]) === -1) {
            this.removeChild(activePagesMeshData[i2].mesh);
          }
        }
        for (var i2 = 0; i2 < newPagesMeshData.length; i2++) {
          if (newPagesMeshData[i2].mesh.parent !== this) {
            this.addChild(newPagesMeshData[i2].mesh);
          }
        }
        this._activePagesMeshData = newPagesMeshData;
        for (var i2 in pagesMeshData) {
          var pageMeshData = pagesMeshData[i2];
          var total = pageMeshData.total;
          if (!(((_a2 = pageMeshData.indices) === null || _a2 === void 0 ? void 0 : _a2.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
            pageMeshData.vertices = new Float32Array(4 * 2 * total);
            pageMeshData.uvs = new Float32Array(4 * 2 * total);
            pageMeshData.indices = new Uint16Array(6 * total);
          } else {
            var total_1 = pageMeshData.total;
            var vertices = pageMeshData.vertices;
            for (var i_1 = total_1 * 4 * 2; i_1 < vertices.length; i_1++) {
              vertices[i_1] = 0;
            }
          }
          pageMeshData.mesh.size = 6 * total;
        }
        for (var i2 = 0; i2 < lenChars; i2++) {
          var char = chars[i2];
          var offset2 = char.position.x + lineAlignOffsets[char.line];
          if (this._roundPixels) {
            offset2 = Math.round(offset2);
          }
          var xPos = offset2 * scale;
          var yPos = char.position.y * scale;
          var texture = char.texture;
          var pageMesh = pagesMeshData[texture.baseTexture.uid];
          var textureFrame = texture.frame;
          var textureUvs = texture._uvs;
          var index2 = pageMesh.index++;
          pageMesh.indices[index2 * 6 + 0] = 0 + index2 * 4;
          pageMesh.indices[index2 * 6 + 1] = 1 + index2 * 4;
          pageMesh.indices[index2 * 6 + 2] = 2 + index2 * 4;
          pageMesh.indices[index2 * 6 + 3] = 0 + index2 * 4;
          pageMesh.indices[index2 * 6 + 4] = 2 + index2 * 4;
          pageMesh.indices[index2 * 6 + 5] = 3 + index2 * 4;
          pageMesh.vertices[index2 * 8 + 0] = xPos;
          pageMesh.vertices[index2 * 8 + 1] = yPos;
          pageMesh.vertices[index2 * 8 + 2] = xPos + textureFrame.width * scale;
          pageMesh.vertices[index2 * 8 + 3] = yPos;
          pageMesh.vertices[index2 * 8 + 4] = xPos + textureFrame.width * scale;
          pageMesh.vertices[index2 * 8 + 5] = yPos + textureFrame.height * scale;
          pageMesh.vertices[index2 * 8 + 6] = xPos;
          pageMesh.vertices[index2 * 8 + 7] = yPos + textureFrame.height * scale;
          pageMesh.uvs[index2 * 8 + 0] = textureUvs.x0;
          pageMesh.uvs[index2 * 8 + 1] = textureUvs.y0;
          pageMesh.uvs[index2 * 8 + 2] = textureUvs.x1;
          pageMesh.uvs[index2 * 8 + 3] = textureUvs.y1;
          pageMesh.uvs[index2 * 8 + 4] = textureUvs.x2;
          pageMesh.uvs[index2 * 8 + 5] = textureUvs.y2;
          pageMesh.uvs[index2 * 8 + 6] = textureUvs.x3;
          pageMesh.uvs[index2 * 8 + 7] = textureUvs.y3;
        }
        this._textWidth = maxLineWidth * scale;
        this._textHeight = (pos.y + data.lineHeight) * scale;
        for (var i2 in pagesMeshData) {
          var pageMeshData = pagesMeshData[i2];
          if (this.anchor.x !== 0 || this.anchor.y !== 0) {
            var vertexCount = 0;
            var anchorOffsetX = this._textWidth * this.anchor.x;
            var anchorOffsetY = this._textHeight * this.anchor.y;
            for (var i_2 = 0; i_2 < pageMeshData.total; i_2++) {
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
              pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
            }
          }
          this._maxLineHeight = maxLineHeight * scale;
          var vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
          var textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
          var indexBuffer = pageMeshData.mesh.geometry.getIndex();
          vertexBuffer.data = pageMeshData.vertices;
          textureBuffer.data = pageMeshData.uvs;
          indexBuffer.data = pageMeshData.indices;
          vertexBuffer.update();
          textureBuffer.update();
          indexBuffer.update();
        }
        for (var i2 = 0; i2 < chars.length; i2++) {
          charRenderDataPool.push(chars[i2]);
        }
      };
      BitmapText.prototype.updateTransform = function() {
        this.validate();
        this.containerUpdateTransform();
      };
      BitmapText.prototype.getLocalBounds = function() {
        this.validate();
        return _super.prototype.getLocalBounds.call(this);
      };
      BitmapText.prototype.validate = function() {
        if (this.dirty) {
          this.updateText();
          this.dirty = false;
        }
      };
      Object.defineProperty(BitmapText.prototype, "tint", {
        get: function() {
          return this._tint;
        },
        set: function(value2) {
          if (this._tint === value2) {
            return;
          }
          this._tint = value2;
          for (var i2 = 0; i2 < this._activePagesMeshData.length; i2++) {
            this._activePagesMeshData[i2].mesh.tint = value2;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "align", {
        get: function() {
          return this._align;
        },
        set: function(value2) {
          if (this._align !== value2) {
            this._align = value2;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "fontName", {
        get: function() {
          return this._fontName;
        },
        set: function(value2) {
          if (!BitmapFont.available[value2]) {
            throw new Error('Missing BitmapFont "' + value2 + '"');
          }
          if (this._fontName !== value2) {
            this._fontName = value2;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "fontSize", {
        get: function() {
          return this._fontSize;
        },
        set: function(value2) {
          if (this._fontSize !== value2) {
            this._fontSize = value2;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "anchor", {
        get: function() {
          return this._anchor;
        },
        set: function(value2) {
          if (typeof value2 === "number") {
            this._anchor.set(value2);
          } else {
            this._anchor.copyFrom(value2);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "text", {
        get: function() {
          return this._text;
        },
        set: function(text) {
          text = String(text === null || text === void 0 ? "" : text);
          if (this._text === text) {
            return;
          }
          this._text = text;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "maxWidth", {
        get: function() {
          return this._maxWidth;
        },
        set: function(value2) {
          if (this._maxWidth === value2) {
            return;
          }
          this._maxWidth = value2;
          this.dirty = true;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "maxLineHeight", {
        get: function() {
          this.validate();
          return this._maxLineHeight;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "textWidth", {
        get: function() {
          this.validate();
          return this._textWidth;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "letterSpacing", {
        get: function() {
          return this._letterSpacing;
        },
        set: function(value2) {
          if (this._letterSpacing !== value2) {
            this._letterSpacing = value2;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "roundPixels", {
        get: function() {
          return this._roundPixels;
        },
        set: function(value2) {
          if (value2 !== this._roundPixels) {
            this._roundPixels = value2;
            this.dirty = true;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BitmapText.prototype, "textHeight", {
        get: function() {
          this.validate();
          return this._textHeight;
        },
        enumerable: false,
        configurable: true
      });
      BitmapText.prototype._upgradeStyle = function(style) {
        if (typeof style.font === "string") {
          var valueSplit = style.font.split(" ");
          style.fontName = valueSplit.length === 1 ? valueSplit[0] : valueSplit.slice(1).join(" ");
          if (valueSplit.length >= 2) {
            style.fontSize = parseInt(valueSplit[0], 10);
          }
        } else {
          style.fontName = style.font.name;
          style.fontSize = typeof style.font.size === "number" ? style.font.size : parseInt(style.font.size, 10);
        }
      };
      BitmapText.prototype.destroy = function(options) {
        var _textureCache = this._textureCache;
        for (var id2 in _textureCache) {
          var texture = _textureCache[id2];
          texture.destroy();
          delete _textureCache[id2];
        }
        this._textureCache = null;
        _super.prototype.destroy.call(this, options);
      };
      BitmapText.registerFont = function(data, textures) {
        deprecation("5.3.0", "PIXI.BitmapText.registerFont is deprecated, use PIXI.BitmapFont.install");
        return BitmapFont.install(data, textures);
      };
      Object.defineProperty(BitmapText, "fonts", {
        get: function() {
          deprecation("5.3.0", "PIXI.BitmapText.fonts is deprecated, use PIXI.BitmapFont.available");
          return BitmapFont.available;
        },
        enumerable: false,
        configurable: true
      });
      BitmapText.styleDefaults = {
        align: "left",
        tint: 16777215,
        maxWidth: 0,
        letterSpacing: 0
      };
      return BitmapText;
    })(Container);
    var BitmapFontLoader = function() {
      function BitmapFontLoader2() {
      }
      BitmapFontLoader2.add = function() {
        LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
      };
      BitmapFontLoader2.use = function(resource, next) {
        var format2 = autoDetectFormat(resource.data);
        if (!format2) {
          next();
          return;
        }
        var baseUrl = BitmapFontLoader2.getBaseUrl(this, resource);
        var data = format2.parse(resource.data);
        var textures = {};
        var completed = function(page) {
          textures[page.metadata.pageFile] = page.texture;
          if (Object.keys(textures).length === data.page.length) {
            resource.bitmapFont = BitmapFont.install(data, textures, true);
            next();
          }
        };
        for (var i2 = 0; i2 < data.page.length; ++i2) {
          var pageFile = data.page[i2].file;
          var url2 = baseUrl + pageFile;
          var exists = false;
          for (var name in this.resources) {
            var bitmapResource = this.resources[name];
            if (bitmapResource.url === url2) {
              bitmapResource.metadata.pageFile = pageFile;
              if (bitmapResource.texture) {
                completed(bitmapResource);
              } else {
                bitmapResource.onAfterMiddleware.add(completed);
              }
              exists = true;
              break;
            }
          }
          if (!exists) {
            var options = {
              crossOrigin: resource.crossOrigin,
              loadType: LoaderResource.LOAD_TYPE.IMAGE,
              metadata: Object.assign({ pageFile }, resource.metadata.imageMetadata),
              parentResource: resource
            };
            this.add(url2, options, completed);
          }
        }
      };
      BitmapFontLoader2.getBaseUrl = function(loader, resource) {
        var resUrl = !resource.isDataUrl ? BitmapFontLoader2.dirname(resource.url) : "";
        if (resource.isDataUrl) {
          if (resUrl === ".") {
            resUrl = "";
          }
          if (loader.baseUrl && resUrl) {
            if (loader.baseUrl.charAt(loader.baseUrl.length - 1) === "/") {
              resUrl += "/";
            }
          }
        }
        resUrl = resUrl.replace(loader.baseUrl, "");
        if (resUrl && resUrl.charAt(resUrl.length - 1) !== "/") {
          resUrl += "/";
        }
        return resUrl;
      };
      BitmapFontLoader2.dirname = function(url2) {
        var dir = url2.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
        if (dir === url2) {
          return ".";
        } else if (dir === "") {
          return "/";
        }
        return dir;
      };
      return BitmapFontLoader2;
    }();
    /*!
     * @pixi/filter-alpha - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/filter-alpha is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$7 = function(d, b) {
      extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$7(d, b);
    };
    function __extends$7(d, b) {
      extendStatics$7(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var fragment$4 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";
    (function(_super) {
      __extends$7(AlphaFilter, _super);
      function AlphaFilter(alpha) {
        if (alpha === void 0) {
          alpha = 1;
        }
        var _this = _super.call(this, _default, fragment$4, { uAlpha: 1 }) || this;
        _this.alpha = alpha;
        return _this;
      }
      Object.defineProperty(AlphaFilter.prototype, "alpha", {
        get: function() {
          return this.uniforms.uAlpha;
        },
        set: function(value2) {
          this.uniforms.uAlpha = value2;
        },
        enumerable: false,
        configurable: true
      });
      return AlphaFilter;
    })(Filter);
    /*!
     * @pixi/filter-blur - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/filter-blur is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$6 = function(d, b) {
      extendStatics$6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$6(d, b);
    };
    function __extends$6(d, b) {
      extendStatics$6(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
    function generateBlurVertSource(kernelSize, x2) {
      var halfLength = Math.ceil(kernelSize / 2);
      var vertSource = vertTemplate;
      var blurLoop = "";
      var template2;
      if (x2) {
        template2 = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
      } else {
        template2 = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
      }
      for (var i2 = 0; i2 < kernelSize; i2++) {
        var blur = template2.replace("%index%", i2.toString());
        blur = blur.replace("%sampleIndex%", i2 - (halfLength - 1) + ".0");
        blurLoop += blur;
        blurLoop += "\n";
      }
      vertSource = vertSource.replace("%blur%", blurLoop);
      vertSource = vertSource.replace("%size%", kernelSize.toString());
      return vertSource;
    }
    var GAUSSIAN_VALUES = {
      5: [0.153388, 0.221461, 0.250301],
      7: [0.071303, 0.131514, 0.189879, 0.214607],
      9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
      11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
      13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
      15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
    };
    var fragTemplate = [
      "varying vec2 vBlurTexCoords[%size%];",
      "uniform sampler2D uSampler;",
      "void main(void)",
      "{",
      "    gl_FragColor = vec4(0.0);",
      "    %blur%",
      "}"
    ].join("\n");
    function generateBlurFragSource(kernelSize) {
      var kernel = GAUSSIAN_VALUES[kernelSize];
      var halfLength = kernel.length;
      var fragSource = fragTemplate;
      var blurLoop = "";
      var template2 = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
      var value2;
      for (var i2 = 0; i2 < kernelSize; i2++) {
        var blur = template2.replace("%index%", i2.toString());
        value2 = i2;
        if (i2 >= halfLength) {
          value2 = kernelSize - i2 - 1;
        }
        blur = blur.replace("%value%", kernel[value2].toString());
        blurLoop += blur;
        blurLoop += "\n";
      }
      fragSource = fragSource.replace("%blur%", blurLoop);
      fragSource = fragSource.replace("%size%", kernelSize.toString());
      return fragSource;
    }
    var ENV;
    (function(ENV2) {
      ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
      ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
      ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
    })(ENV || (ENV = {}));
    var RENDERER_TYPE;
    (function(RENDERER_TYPE2) {
      RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
      RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
      RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
    })(RENDERER_TYPE || (RENDERER_TYPE = {}));
    var BUFFER_BITS;
    (function(BUFFER_BITS2) {
      BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
      BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
      BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
    })(BUFFER_BITS || (BUFFER_BITS = {}));
    var BLEND_MODES;
    (function(BLEND_MODES2) {
      BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
      BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
      BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
      BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
      BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
      BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
      BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
      BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
      BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
      BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
      BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
      BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
      BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
      BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
      BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
      BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
      BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
      BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
      BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
      BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
      BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
      BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
      BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
      BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
      BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
      BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
      BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
      BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
      BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
      BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
      BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
      BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
    })(BLEND_MODES || (BLEND_MODES = {}));
    var DRAW_MODES;
    (function(DRAW_MODES2) {
      DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
      DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
      DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
      DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
      DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
      DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
      DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    })(DRAW_MODES || (DRAW_MODES = {}));
    var FORMATS;
    (function(FORMATS2) {
      FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
      FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
      FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
      FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
      FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    })(FORMATS || (FORMATS = {}));
    var TARGETS;
    (function(TARGETS2) {
      TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    })(TARGETS || (TARGETS = {}));
    var TYPES;
    (function(TYPES2) {
      TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
      TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
    })(TYPES || (TYPES = {}));
    var SCALE_MODES;
    (function(SCALE_MODES2) {
      SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
      SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
    })(SCALE_MODES || (SCALE_MODES = {}));
    var WRAP_MODES;
    (function(WRAP_MODES2) {
      WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
      WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
      WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    })(WRAP_MODES || (WRAP_MODES = {}));
    var MIPMAP_MODES;
    (function(MIPMAP_MODES2) {
      MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
      MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
      MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
    })(MIPMAP_MODES || (MIPMAP_MODES = {}));
    var ALPHA_MODES;
    (function(ALPHA_MODES2) {
      ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
      ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
      ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
      ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
      ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
      ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
    })(ALPHA_MODES || (ALPHA_MODES = {}));
    var CLEAR_MODES;
    (function(CLEAR_MODES2) {
      CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
      CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
      CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
      CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
      CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
      CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
    })(CLEAR_MODES || (CLEAR_MODES = {}));
    var GC_MODES;
    (function(GC_MODES2) {
      GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
      GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
    })(GC_MODES || (GC_MODES = {}));
    var PRECISION;
    (function(PRECISION2) {
      PRECISION2["LOW"] = "lowp";
      PRECISION2["MEDIUM"] = "mediump";
      PRECISION2["HIGH"] = "highp";
    })(PRECISION || (PRECISION = {}));
    var MASK_TYPES;
    (function(MASK_TYPES2) {
      MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
      MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
      MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
      MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
    })(MASK_TYPES || (MASK_TYPES = {}));
    var MSAA_QUALITY;
    (function(MSAA_QUALITY2) {
      MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
      MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
      MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
      MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
    })(MSAA_QUALITY || (MSAA_QUALITY = {}));
    var BlurFilterPass = function(_super) {
      __extends$6(BlurFilterPass2, _super);
      function BlurFilterPass2(horizontal, strength, quality, resolution, kernelSize) {
        if (strength === void 0) {
          strength = 8;
        }
        if (quality === void 0) {
          quality = 4;
        }
        if (resolution === void 0) {
          resolution = settings.FILTER_RESOLUTION;
        }
        if (kernelSize === void 0) {
          kernelSize = 5;
        }
        var _this = this;
        var vertSrc = generateBlurVertSource(kernelSize, horizontal);
        var fragSrc = generateBlurFragSource(kernelSize);
        _this = _super.call(
          this,
          vertSrc,
          fragSrc
        ) || this;
        _this.horizontal = horizontal;
        _this.resolution = resolution;
        _this._quality = 0;
        _this.quality = quality;
        _this.blur = strength;
        return _this;
      }
      BlurFilterPass2.prototype.apply = function(filterManager, input, output, clearMode) {
        if (output) {
          if (this.horizontal) {
            this.uniforms.strength = 1 / output.width * (output.width / input.width);
          } else {
            this.uniforms.strength = 1 / output.height * (output.height / input.height);
          }
        } else {
          if (this.horizontal) {
            this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
          } else {
            this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
          }
        }
        this.uniforms.strength *= this.strength;
        this.uniforms.strength /= this.passes;
        if (this.passes === 1) {
          filterManager.applyFilter(this, input, output, clearMode);
        } else {
          var renderTarget = filterManager.getFilterTexture();
          var renderer = filterManager.renderer;
          var flip = input;
          var flop = renderTarget;
          this.state.blend = false;
          filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);
          for (var i2 = 1; i2 < this.passes - 1; i2++) {
            filterManager.bindAndClear(flip, CLEAR_MODES.BLIT);
            this.uniforms.uSampler = flop;
            var temp2 = flop;
            flop = flip;
            flip = temp2;
            renderer.shader.bind(this);
            renderer.geometry.draw(5);
          }
          this.state.blend = true;
          filterManager.applyFilter(this, flop, output, clearMode);
          filterManager.returnFilterTexture(renderTarget);
        }
      };
      Object.defineProperty(BlurFilterPass2.prototype, "blur", {
        get: function() {
          return this.strength;
        },
        set: function(value2) {
          this.padding = 1 + Math.abs(value2) * 2;
          this.strength = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilterPass2.prototype, "quality", {
        get: function() {
          return this._quality;
        },
        set: function(value2) {
          this._quality = value2;
          this.passes = value2;
        },
        enumerable: false,
        configurable: true
      });
      return BlurFilterPass2;
    }(Filter);
    (function(_super) {
      __extends$6(BlurFilter, _super);
      function BlurFilter(strength, quality, resolution, kernelSize) {
        if (strength === void 0) {
          strength = 8;
        }
        if (quality === void 0) {
          quality = 4;
        }
        if (resolution === void 0) {
          resolution = settings.FILTER_RESOLUTION;
        }
        if (kernelSize === void 0) {
          kernelSize = 5;
        }
        var _this = _super.call(this) || this;
        _this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
        _this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
        _this.resolution = resolution;
        _this.quality = quality;
        _this.blur = strength;
        _this.repeatEdgePixels = false;
        return _this;
      }
      BlurFilter.prototype.apply = function(filterManager, input, output, clearMode) {
        var xStrength = Math.abs(this.blurXFilter.strength);
        var yStrength = Math.abs(this.blurYFilter.strength);
        if (xStrength && yStrength) {
          var renderTarget = filterManager.getFilterTexture();
          this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES.CLEAR);
          this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
          filterManager.returnFilterTexture(renderTarget);
        } else if (yStrength) {
          this.blurYFilter.apply(filterManager, input, output, clearMode);
        } else {
          this.blurXFilter.apply(filterManager, input, output, clearMode);
        }
      };
      BlurFilter.prototype.updatePadding = function() {
        if (this._repeatEdgePixels) {
          this.padding = 0;
        } else {
          this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
        }
      };
      Object.defineProperty(BlurFilter.prototype, "blur", {
        get: function() {
          return this.blurXFilter.blur;
        },
        set: function(value2) {
          this.blurXFilter.blur = this.blurYFilter.blur = value2;
          this.updatePadding();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter.prototype, "quality", {
        get: function() {
          return this.blurXFilter.quality;
        },
        set: function(value2) {
          this.blurXFilter.quality = this.blurYFilter.quality = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter.prototype, "blurX", {
        get: function() {
          return this.blurXFilter.blur;
        },
        set: function(value2) {
          this.blurXFilter.blur = value2;
          this.updatePadding();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter.prototype, "blurY", {
        get: function() {
          return this.blurYFilter.blur;
        },
        set: function(value2) {
          this.blurYFilter.blur = value2;
          this.updatePadding();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter.prototype, "blendMode", {
        get: function() {
          return this.blurYFilter.blendMode;
        },
        set: function(value2) {
          this.blurYFilter.blendMode = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BlurFilter.prototype, "repeatEdgePixels", {
        get: function() {
          return this._repeatEdgePixels;
        },
        set: function(value2) {
          this._repeatEdgePixels = value2;
          this.updatePadding();
        },
        enumerable: false,
        configurable: true
      });
      return BlurFilter;
    })(Filter);
    /*!
     * @pixi/filter-color-matrix - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/filter-color-matrix is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$5 = function(d, b) {
      extendStatics$5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$5(d, b);
    };
    function __extends$5(d, b) {
      extendStatics$5(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var fragment$3 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
    var ColorMatrixFilter = function(_super) {
      __extends$5(ColorMatrixFilter2, _super);
      function ColorMatrixFilter2() {
        var _this = this;
        var uniforms = {
          m: new Float32Array([
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ]),
          uAlpha: 1
        };
        _this = _super.call(this, defaultFilter, fragment$3, uniforms) || this;
        _this.alpha = 1;
        return _this;
      }
      ColorMatrixFilter2.prototype._loadMatrix = function(matrix, multiply) {
        if (multiply === void 0) {
          multiply = false;
        }
        var newMatrix = matrix;
        if (multiply) {
          this._multiply(newMatrix, this.uniforms.m, matrix);
          newMatrix = this._colorMatrix(newMatrix);
        }
        this.uniforms.m = newMatrix;
      };
      ColorMatrixFilter2.prototype._multiply = function(out, a2, b) {
        out[0] = a2[0] * b[0] + a2[1] * b[5] + a2[2] * b[10] + a2[3] * b[15];
        out[1] = a2[0] * b[1] + a2[1] * b[6] + a2[2] * b[11] + a2[3] * b[16];
        out[2] = a2[0] * b[2] + a2[1] * b[7] + a2[2] * b[12] + a2[3] * b[17];
        out[3] = a2[0] * b[3] + a2[1] * b[8] + a2[2] * b[13] + a2[3] * b[18];
        out[4] = a2[0] * b[4] + a2[1] * b[9] + a2[2] * b[14] + a2[3] * b[19] + a2[4];
        out[5] = a2[5] * b[0] + a2[6] * b[5] + a2[7] * b[10] + a2[8] * b[15];
        out[6] = a2[5] * b[1] + a2[6] * b[6] + a2[7] * b[11] + a2[8] * b[16];
        out[7] = a2[5] * b[2] + a2[6] * b[7] + a2[7] * b[12] + a2[8] * b[17];
        out[8] = a2[5] * b[3] + a2[6] * b[8] + a2[7] * b[13] + a2[8] * b[18];
        out[9] = a2[5] * b[4] + a2[6] * b[9] + a2[7] * b[14] + a2[8] * b[19] + a2[9];
        out[10] = a2[10] * b[0] + a2[11] * b[5] + a2[12] * b[10] + a2[13] * b[15];
        out[11] = a2[10] * b[1] + a2[11] * b[6] + a2[12] * b[11] + a2[13] * b[16];
        out[12] = a2[10] * b[2] + a2[11] * b[7] + a2[12] * b[12] + a2[13] * b[17];
        out[13] = a2[10] * b[3] + a2[11] * b[8] + a2[12] * b[13] + a2[13] * b[18];
        out[14] = a2[10] * b[4] + a2[11] * b[9] + a2[12] * b[14] + a2[13] * b[19] + a2[14];
        out[15] = a2[15] * b[0] + a2[16] * b[5] + a2[17] * b[10] + a2[18] * b[15];
        out[16] = a2[15] * b[1] + a2[16] * b[6] + a2[17] * b[11] + a2[18] * b[16];
        out[17] = a2[15] * b[2] + a2[16] * b[7] + a2[17] * b[12] + a2[18] * b[17];
        out[18] = a2[15] * b[3] + a2[16] * b[8] + a2[17] * b[13] + a2[18] * b[18];
        out[19] = a2[15] * b[4] + a2[16] * b[9] + a2[17] * b[14] + a2[18] * b[19] + a2[19];
        return out;
      };
      ColorMatrixFilter2.prototype._colorMatrix = function(matrix) {
        var m2 = new Float32Array(matrix);
        m2[4] /= 255;
        m2[9] /= 255;
        m2[14] /= 255;
        m2[19] /= 255;
        return m2;
      };
      ColorMatrixFilter2.prototype.brightness = function(b, multiply) {
        var matrix = [
          b,
          0,
          0,
          0,
          0,
          0,
          b,
          0,
          0,
          0,
          0,
          0,
          b,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.greyscale = function(scale, multiply) {
        var matrix = [
          scale,
          scale,
          scale,
          0,
          0,
          scale,
          scale,
          scale,
          0,
          0,
          scale,
          scale,
          scale,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.blackAndWhite = function(multiply) {
        var matrix = [
          0.3,
          0.6,
          0.1,
          0,
          0,
          0.3,
          0.6,
          0.1,
          0,
          0,
          0.3,
          0.6,
          0.1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.hue = function(rotation, multiply) {
        rotation = (rotation || 0) / 180 * Math.PI;
        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);
        var sqrt = Math.sqrt;
        var w2 = 1 / 3;
        var sqrW = sqrt(w2);
        var a00 = cosR + (1 - cosR) * w2;
        var a01 = w2 * (1 - cosR) - sqrW * sinR;
        var a02 = w2 * (1 - cosR) + sqrW * sinR;
        var a10 = w2 * (1 - cosR) + sqrW * sinR;
        var a11 = cosR + w2 * (1 - cosR);
        var a12 = w2 * (1 - cosR) - sqrW * sinR;
        var a20 = w2 * (1 - cosR) - sqrW * sinR;
        var a21 = w2 * (1 - cosR) + sqrW * sinR;
        var a22 = cosR + w2 * (1 - cosR);
        var matrix = [
          a00,
          a01,
          a02,
          0,
          0,
          a10,
          a11,
          a12,
          0,
          0,
          a20,
          a21,
          a22,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.contrast = function(amount, multiply) {
        var v2 = (amount || 0) + 1;
        var o = -0.5 * (v2 - 1);
        var matrix = [
          v2,
          0,
          0,
          0,
          o,
          0,
          v2,
          0,
          0,
          o,
          0,
          0,
          v2,
          0,
          o,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.saturate = function(amount, multiply) {
        if (amount === void 0) {
          amount = 0;
        }
        var x2 = amount * 2 / 3 + 1;
        var y2 = (x2 - 1) * -0.5;
        var matrix = [
          x2,
          y2,
          y2,
          0,
          0,
          y2,
          x2,
          y2,
          0,
          0,
          y2,
          y2,
          x2,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.desaturate = function() {
        this.saturate(-1);
      };
      ColorMatrixFilter2.prototype.negative = function(multiply) {
        var matrix = [
          -1,
          0,
          0,
          1,
          0,
          0,
          -1,
          0,
          1,
          0,
          0,
          0,
          -1,
          1,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.sepia = function(multiply) {
        var matrix = [
          0.393,
          0.7689999,
          0.18899999,
          0,
          0,
          0.349,
          0.6859999,
          0.16799999,
          0,
          0,
          0.272,
          0.5339999,
          0.13099999,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.technicolor = function(multiply) {
        var matrix = [
          1.9125277891456083,
          -0.8545344976951645,
          -0.09155508482755585,
          0,
          11.793603434377337,
          -0.3087833385928097,
          1.7658908555458428,
          -0.10601743074722245,
          0,
          -70.35205161461398,
          -0.231103377548616,
          -0.7501899197440212,
          1.847597816108189,
          0,
          30.950940869491138,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.polaroid = function(multiply) {
        var matrix = [
          1.438,
          -0.062,
          -0.062,
          0,
          0,
          -0.122,
          1.378,
          -0.122,
          0,
          0,
          -0.016,
          -0.016,
          1.483,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.toBGR = function(multiply) {
        var matrix = [
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.kodachrome = function(multiply) {
        var matrix = [
          1.1285582396593525,
          -0.3967382283601348,
          -0.03992559172921793,
          0,
          63.72958762196502,
          -0.16404339962244616,
          1.0835251566291304,
          -0.05498805115633132,
          0,
          24.732407896706203,
          -0.16786010706155763,
          -0.5603416277695248,
          1.6014850761964943,
          0,
          35.62982807460946,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.browni = function(multiply) {
        var matrix = [
          0.5997023498159715,
          0.34553243048391263,
          -0.2708298674538042,
          0,
          47.43192855600873,
          -0.037703249837783157,
          0.8609577587992641,
          0.15059552388459913,
          0,
          -36.96841498319127,
          0.24113635128153335,
          -0.07441037908422492,
          0.44972182064877153,
          0,
          -7.562075277591283,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.vintage = function(multiply) {
        var matrix = [
          0.6279345635605994,
          0.3202183420819367,
          -0.03965408211312453,
          0,
          9.651285835294123,
          0.02578397704808868,
          0.6441188644374771,
          0.03259127616149294,
          0,
          7.462829176470591,
          0.0466055556782719,
          -0.0851232987247891,
          0.5241648018700465,
          0,
          5.159190588235296,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.colorTone = function(desaturation, toned, lightColor, darkColor, multiply) {
        desaturation = desaturation || 0.2;
        toned = toned || 0.15;
        lightColor = lightColor || 16770432;
        darkColor = darkColor || 3375104;
        var lR = (lightColor >> 16 & 255) / 255;
        var lG = (lightColor >> 8 & 255) / 255;
        var lB = (lightColor & 255) / 255;
        var dR = (darkColor >> 16 & 255) / 255;
        var dG = (darkColor >> 8 & 255) / 255;
        var dB = (darkColor & 255) / 255;
        var matrix = [
          0.3,
          0.59,
          0.11,
          0,
          0,
          lR,
          lG,
          lB,
          desaturation,
          0,
          dR,
          dG,
          dB,
          toned,
          0,
          lR - dR,
          lG - dG,
          lB - dB,
          0,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.night = function(intensity, multiply) {
        intensity = intensity || 0.1;
        var matrix = [
          intensity * -2,
          -intensity,
          0,
          0,
          0,
          -intensity,
          0,
          intensity,
          0,
          0,
          0,
          intensity,
          intensity * 2,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.predator = function(amount, multiply) {
        var matrix = [
          11.224130630493164 * amount,
          -4.794486999511719 * amount,
          -2.8746118545532227 * amount,
          0 * amount,
          0.40342438220977783 * amount,
          -3.6330697536468506 * amount,
          9.193157196044922 * amount,
          -2.951810836791992 * amount,
          0 * amount,
          -1.316135048866272 * amount,
          -3.2184197902679443 * amount,
          -4.2375030517578125 * amount,
          7.476448059082031 * amount,
          0 * amount,
          0.8044459223747253 * amount,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.lsd = function(multiply) {
        var matrix = [
          2,
          -0.4,
          0.5,
          0,
          0,
          -0.5,
          2,
          -0.4,
          0,
          0,
          -0.4,
          -0.5,
          3,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      };
      ColorMatrixFilter2.prototype.reset = function() {
        var matrix = [
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, false);
      };
      Object.defineProperty(ColorMatrixFilter2.prototype, "matrix", {
        get: function() {
          return this.uniforms.m;
        },
        set: function(value2) {
          this.uniforms.m = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ColorMatrixFilter2.prototype, "alpha", {
        get: function() {
          return this.uniforms.uAlpha;
        },
        set: function(value2) {
          this.uniforms.uAlpha = value2;
        },
        enumerable: false,
        configurable: true
      });
      return ColorMatrixFilter2;
    }(Filter);
    ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
    /*!
     * @pixi/filter-displacement - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/filter-displacement is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$4 = function(d, b) {
      extendStatics$4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$4(d, b);
    };
    function __extends$4(d, b) {
      extendStatics$4(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var fragment$2 = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";
    var vertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";
    (function(_super) {
      __extends$4(DisplacementFilter, _super);
      function DisplacementFilter(sprite, scale) {
        var _this = this;
        var maskMatrix = new Matrix();
        sprite.renderable = false;
        _this = _super.call(this, vertex$1, fragment$2, {
          mapSampler: sprite._texture,
          filterMatrix: maskMatrix,
          scale: { x: 1, y: 1 },
          rotation: new Float32Array([1, 0, 0, 1])
        }) || this;
        _this.maskSprite = sprite;
        _this.maskMatrix = maskMatrix;
        if (scale === null || scale === void 0) {
          scale = 20;
        }
        _this.scale = new Point(scale, scale);
        return _this;
      }
      DisplacementFilter.prototype.apply = function(filterManager, input, output, clearMode) {
        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
        this.uniforms.scale.x = this.scale.x;
        this.uniforms.scale.y = this.scale.y;
        var wt = this.maskSprite.worldTransform;
        var lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
        var lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
        if (lenX !== 0 && lenY !== 0) {
          this.uniforms.rotation[0] = wt.a / lenX;
          this.uniforms.rotation[1] = wt.b / lenX;
          this.uniforms.rotation[2] = wt.c / lenY;
          this.uniforms.rotation[3] = wt.d / lenY;
        }
        filterManager.applyFilter(this, input, output, clearMode);
      };
      Object.defineProperty(DisplacementFilter.prototype, "map", {
        get: function() {
          return this.uniforms.mapSampler;
        },
        set: function(value2) {
          this.uniforms.mapSampler = value2;
        },
        enumerable: false,
        configurable: true
      });
      return DisplacementFilter;
    })(Filter);
    /*!
     * @pixi/filter-fxaa - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/filter-fxaa is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$3 = function(d, b) {
      extendStatics$3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$3(d, b);
    };
    function __extends$3(d, b) {
      extendStatics$3(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var vertex = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputPixel;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";
    var fragment$1 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputPixel;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
    (function(_super) {
      __extends$3(FXAAFilter, _super);
      function FXAAFilter() {
        return _super.call(this, vertex, fragment$1) || this;
      }
      return FXAAFilter;
    })(Filter);
    /*!
     * @pixi/filter-noise - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/filter-noise is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$2 = function(d, b) {
      extendStatics$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$2(d, b);
    };
    function __extends$2(d, b) {
      extendStatics$2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var fragment = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";
    (function(_super) {
      __extends$2(NoiseFilter, _super);
      function NoiseFilter(noise, seed) {
        if (noise === void 0) {
          noise = 0.5;
        }
        if (seed === void 0) {
          seed = Math.random();
        }
        var _this = _super.call(this, defaultFilter, fragment, {
          uNoise: 0,
          uSeed: 0
        }) || this;
        _this.noise = noise;
        _this.seed = seed;
        return _this;
      }
      Object.defineProperty(NoiseFilter.prototype, "noise", {
        get: function() {
          return this.uniforms.uNoise;
        },
        set: function(value2) {
          this.uniforms.uNoise = value2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NoiseFilter.prototype, "seed", {
        get: function() {
          return this.uniforms.uSeed;
        },
        set: function(value2) {
          this.uniforms.uSeed = value2;
        },
        enumerable: false,
        configurable: true
      });
      return NoiseFilter;
    })(Filter);
    /*!
     * @pixi/mixin-cache-as-bitmap - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    var _tempMatrix = new Matrix();
    DisplayObject.prototype._cacheAsBitmap = false;
    DisplayObject.prototype._cacheData = null;
    var CacheData = function() {
      function CacheData2() {
        this.textureCacheId = null;
        this.originalRender = null;
        this.originalRenderCanvas = null;
        this.originalCalculateBounds = null;
        this.originalGetLocalBounds = null;
        this.originalUpdateTransform = null;
        this.originalDestroy = null;
        this.originalMask = null;
        this.originalFilterArea = null;
        this.originalContainsPoint = null;
        this.sprite = null;
      }
      return CacheData2;
    }();
    Object.defineProperties(DisplayObject.prototype, {
      cacheAsBitmap: {
        get: function() {
          return this._cacheAsBitmap;
        },
        set: function(value2) {
          if (this._cacheAsBitmap === value2) {
            return;
          }
          this._cacheAsBitmap = value2;
          var data;
          if (value2) {
            if (!this._cacheData) {
              this._cacheData = new CacheData();
            }
            data = this._cacheData;
            data.originalRender = this.render;
            data.originalRenderCanvas = this.renderCanvas;
            data.originalUpdateTransform = this.updateTransform;
            data.originalCalculateBounds = this.calculateBounds;
            data.originalGetLocalBounds = this.getLocalBounds;
            data.originalDestroy = this.destroy;
            data.originalContainsPoint = this.containsPoint;
            data.originalMask = this._mask;
            data.originalFilterArea = this.filterArea;
            this.render = this._renderCached;
            this.renderCanvas = this._renderCachedCanvas;
            this.destroy = this._cacheAsBitmapDestroy;
          } else {
            data = this._cacheData;
            if (data.sprite) {
              this._destroyCachedDisplayObject();
            }
            this.render = data.originalRender;
            this.renderCanvas = data.originalRenderCanvas;
            this.calculateBounds = data.originalCalculateBounds;
            this.getLocalBounds = data.originalGetLocalBounds;
            this.destroy = data.originalDestroy;
            this.updateTransform = data.originalUpdateTransform;
            this.containsPoint = data.originalContainsPoint;
            this._mask = data.originalMask;
            this.filterArea = data.originalFilterArea;
          }
        }
      }
    });
    DisplayObject.prototype._renderCached = function _renderCached(renderer) {
      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
      }
      this._initCachedDisplayObject(renderer);
      this._cacheData.sprite.transform._worldID = this.transform._worldID;
      this._cacheData.sprite.worldAlpha = this.worldAlpha;
      this._cacheData.sprite._render(renderer);
    };
    DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
      if (this._cacheData && this._cacheData.sprite) {
        return;
      }
      var cacheAlpha = this.alpha;
      this.alpha = 1;
      renderer.batch.flush();
      var bounds = this.getLocalBounds(null, true).clone();
      if (this.filters) {
        var padding = this.filters[0].padding;
        bounds.pad(padding);
      }
      bounds.ceil(settings.RESOLUTION);
      var cachedRenderTexture = renderer.renderTexture.current;
      var cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
      var cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
      var cachedProjectionTransform = renderer.projection.transform;
      var renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
      var textureCacheId = "cacheAsBitmap_" + uid();
      this._cacheData.textureCacheId = textureCacheId;
      BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
      Texture.addToCache(renderTexture, textureCacheId);
      var m2 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
      this.render = this._cacheData.originalRender;
      renderer.render(this, renderTexture, true, m2, false);
      renderer.projection.transform = cachedProjectionTransform;
      renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
      this.render = this._renderCached;
      this.updateTransform = this.displayObjectUpdateTransform;
      this.calculateBounds = this._calculateCachedBounds;
      this.getLocalBounds = this._getCachedLocalBounds;
      this._mask = null;
      this.filterArea = null;
      var cachedSprite = new Sprite(renderTexture);
      cachedSprite.transform.worldTransform = this.transform.worldTransform;
      cachedSprite.anchor.x = -(bounds.x / bounds.width);
      cachedSprite.anchor.y = -(bounds.y / bounds.height);
      cachedSprite.alpha = cacheAlpha;
      cachedSprite._bounds = this._bounds;
      this._cacheData.sprite = cachedSprite;
      this.transform._parentID = -1;
      if (!this.parent) {
        this.enableTempParent();
        this.updateTransform();
        this.disableTempParent(null);
      } else {
        this.updateTransform();
      }
      this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    };
    DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
        return;
      }
      this._initCachedDisplayObjectCanvas(renderer);
      this._cacheData.sprite.worldAlpha = this.worldAlpha;
      this._cacheData.sprite._renderCanvas(renderer);
    };
    DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
      if (this._cacheData && this._cacheData.sprite) {
        return;
      }
      var bounds = this.getLocalBounds(null, true);
      var cacheAlpha = this.alpha;
      this.alpha = 1;
      var cachedRenderTarget = renderer.context;
      var cachedProjectionTransform = renderer._projTransform;
      bounds.ceil(settings.RESOLUTION);
      var renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
      var textureCacheId = "cacheAsBitmap_" + uid();
      this._cacheData.textureCacheId = textureCacheId;
      BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
      Texture.addToCache(renderTexture, textureCacheId);
      var m2 = _tempMatrix;
      this.transform.localTransform.copyTo(m2);
      m2.invert();
      m2.tx -= bounds.x;
      m2.ty -= bounds.y;
      this.renderCanvas = this._cacheData.originalRenderCanvas;
      renderer.render(this, renderTexture, true, m2, false);
      renderer.context = cachedRenderTarget;
      renderer._projTransform = cachedProjectionTransform;
      this.renderCanvas = this._renderCachedCanvas;
      this.updateTransform = this.displayObjectUpdateTransform;
      this.calculateBounds = this._calculateCachedBounds;
      this.getLocalBounds = this._getCachedLocalBounds;
      this._mask = null;
      this.filterArea = null;
      var cachedSprite = new Sprite(renderTexture);
      cachedSprite.transform.worldTransform = this.transform.worldTransform;
      cachedSprite.anchor.x = -(bounds.x / bounds.width);
      cachedSprite.anchor.y = -(bounds.y / bounds.height);
      cachedSprite.alpha = cacheAlpha;
      cachedSprite._bounds = this._bounds;
      this._cacheData.sprite = cachedSprite;
      this.transform._parentID = -1;
      if (!this.parent) {
        this.parent = renderer._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this.updateTransform();
      }
      this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    };
    DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
      this._bounds.clear();
      this._cacheData.sprite.transform._worldID = this.transform._worldID;
      this._cacheData.sprite._calculateBounds();
      this._bounds.updateID = this._boundsID;
    };
    DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
      return this._cacheData.sprite.getLocalBounds(null);
    };
    DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
      this._cacheData.sprite._texture.destroy(true);
      this._cacheData.sprite = null;
      BaseTexture.removeFromCache(this._cacheData.textureCacheId);
      Texture.removeFromCache(this._cacheData.textureCacheId);
      this._cacheData.textureCacheId = null;
    };
    DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
      this.cacheAsBitmap = false;
      this.destroy(options);
    };
    /*!
     * @pixi/mixin-get-child-by-name - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/mixin-get-child-by-name is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    DisplayObject.prototype.name = null;
    Container.prototype.getChildByName = function getChildByName(name, deep) {
      for (var i2 = 0, j = this.children.length; i2 < j; i2++) {
        if (this.children[i2].name === name) {
          return this.children[i2];
        }
      }
      if (deep) {
        for (var i2 = 0, j = this.children.length; i2 < j; i2++) {
          var child = this.children[i2];
          if (!child.getChildByName) {
            continue;
          }
          var target = this.children[i2].getChildByName(name, true);
          if (target) {
            return target;
          }
        }
      }
      return null;
    };
    /*!
     * @pixi/mixin-get-global-position - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/mixin-get-global-position is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point, skipUpdate) {
      if (point === void 0) {
        point = new Point();
      }
      if (skipUpdate === void 0) {
        skipUpdate = false;
      }
      if (this.parent) {
        this.parent.toGlobal(this.position, point, skipUpdate);
      } else {
        point.x = this.position.x;
        point.y = this.position.y;
      }
      return point;
    };
    /*!
     * @pixi/mesh-extras - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/mesh-extras is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics$1 = function(d, b) {
      extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics$1(d, b);
    };
    function __extends$1(d, b) {
      extendStatics$1(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var PlaneGeometry = function(_super) {
      __extends$1(PlaneGeometry2, _super);
      function PlaneGeometry2(width2, height2, segWidth, segHeight) {
        if (width2 === void 0) {
          width2 = 100;
        }
        if (height2 === void 0) {
          height2 = 100;
        }
        if (segWidth === void 0) {
          segWidth = 10;
        }
        if (segHeight === void 0) {
          segHeight = 10;
        }
        var _this = _super.call(this) || this;
        _this.segWidth = segWidth;
        _this.segHeight = segHeight;
        _this.width = width2;
        _this.height = height2;
        _this.build();
        return _this;
      }
      PlaneGeometry2.prototype.build = function() {
        var total = this.segWidth * this.segHeight;
        var verts = [];
        var uvs = [];
        var indices2 = [];
        var segmentsX = this.segWidth - 1;
        var segmentsY = this.segHeight - 1;
        var sizeX = this.width / segmentsX;
        var sizeY = this.height / segmentsY;
        for (var i2 = 0; i2 < total; i2++) {
          var x2 = i2 % this.segWidth;
          var y2 = i2 / this.segWidth | 0;
          verts.push(x2 * sizeX, y2 * sizeY);
          uvs.push(x2 / segmentsX, y2 / segmentsY);
        }
        var totalSub = segmentsX * segmentsY;
        for (var i2 = 0; i2 < totalSub; i2++) {
          var xpos = i2 % segmentsX;
          var ypos = i2 / segmentsX | 0;
          var value2 = ypos * this.segWidth + xpos;
          var value22 = ypos * this.segWidth + xpos + 1;
          var value3 = (ypos + 1) * this.segWidth + xpos;
          var value4 = (ypos + 1) * this.segWidth + xpos + 1;
          indices2.push(value2, value22, value3, value22, value4, value3);
        }
        this.buffers[0].data = new Float32Array(verts);
        this.buffers[1].data = new Float32Array(uvs);
        this.indexBuffer.data = new Uint16Array(indices2);
        this.buffers[0].update();
        this.buffers[1].update();
        this.indexBuffer.update();
      };
      return PlaneGeometry2;
    }(MeshGeometry);
    var RopeGeometry = function(_super) {
      __extends$1(RopeGeometry2, _super);
      function RopeGeometry2(width2, points, textureScale) {
        if (width2 === void 0) {
          width2 = 200;
        }
        if (textureScale === void 0) {
          textureScale = 0;
        }
        var _this = _super.call(this, new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6)) || this;
        _this.points = points;
        _this._width = width2;
        _this.textureScale = textureScale;
        _this.build();
        return _this;
      }
      Object.defineProperty(RopeGeometry2.prototype, "width", {
        get: function() {
          return this._width;
        },
        enumerable: false,
        configurable: true
      });
      RopeGeometry2.prototype.build = function() {
        var points = this.points;
        if (!points) {
          return;
        }
        var vertexBuffer = this.getBuffer("aVertexPosition");
        var uvBuffer = this.getBuffer("aTextureCoord");
        var indexBuffer = this.getIndex();
        if (points.length < 1) {
          return;
        }
        if (vertexBuffer.data.length / 4 !== points.length) {
          vertexBuffer.data = new Float32Array(points.length * 4);
          uvBuffer.data = new Float32Array(points.length * 4);
          indexBuffer.data = new Uint16Array((points.length - 1) * 6);
        }
        var uvs = uvBuffer.data;
        var indices2 = indexBuffer.data;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        var amount = 0;
        var prev = points[0];
        var textureWidth = this._width * this.textureScale;
        var total = points.length;
        for (var i2 = 0; i2 < total; i2++) {
          var index2 = i2 * 4;
          if (this.textureScale > 0) {
            var dx = prev.x - points[i2].x;
            var dy = prev.y - points[i2].y;
            var distance = Math.sqrt(dx * dx + dy * dy);
            prev = points[i2];
            amount += distance / textureWidth;
          } else {
            amount = i2 / (total - 1);
          }
          uvs[index2] = amount;
          uvs[index2 + 1] = 0;
          uvs[index2 + 2] = amount;
          uvs[index2 + 3] = 1;
        }
        var indexCount = 0;
        for (var i2 = 0; i2 < total - 1; i2++) {
          var index2 = i2 * 2;
          indices2[indexCount++] = index2;
          indices2[indexCount++] = index2 + 1;
          indices2[indexCount++] = index2 + 2;
          indices2[indexCount++] = index2 + 2;
          indices2[indexCount++] = index2 + 1;
          indices2[indexCount++] = index2 + 3;
        }
        uvBuffer.update();
        indexBuffer.update();
        this.updateVertices();
      };
      RopeGeometry2.prototype.updateVertices = function() {
        var points = this.points;
        if (points.length < 1) {
          return;
        }
        var lastPoint = points[0];
        var nextPoint;
        var perpX = 0;
        var perpY = 0;
        var vertices = this.buffers[0].data;
        var total = points.length;
        for (var i2 = 0; i2 < total; i2++) {
          var point = points[i2];
          var index2 = i2 * 4;
          if (i2 < points.length - 1) {
            nextPoint = points[i2 + 1];
          } else {
            nextPoint = point;
          }
          perpY = -(nextPoint.x - lastPoint.x);
          perpX = nextPoint.y - lastPoint.y;
          var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
          var num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
          perpX /= perpLength;
          perpY /= perpLength;
          perpX *= num;
          perpY *= num;
          vertices[index2] = point.x + perpX;
          vertices[index2 + 1] = point.y + perpY;
          vertices[index2 + 2] = point.x - perpX;
          vertices[index2 + 3] = point.y - perpY;
          lastPoint = point;
        }
        this.buffers[0].update();
      };
      RopeGeometry2.prototype.update = function() {
        if (this.textureScale > 0) {
          this.build();
        } else {
          this.updateVertices();
        }
      };
      return RopeGeometry2;
    }(MeshGeometry);
    (function(_super) {
      __extends$1(SimpleRope, _super);
      function SimpleRope(texture, points, textureScale) {
        if (textureScale === void 0) {
          textureScale = 0;
        }
        var _this = this;
        var ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
        var meshMaterial = new MeshMaterial(texture);
        if (textureScale > 0) {
          texture.baseTexture.wrapMode = WRAP_MODES$1.REPEAT;
        }
        _this = _super.call(this, ropeGeometry, meshMaterial) || this;
        _this.autoUpdate = true;
        return _this;
      }
      SimpleRope.prototype._render = function(renderer) {
        var geometry = this.geometry;
        if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
          geometry._width = this.shader.texture.height;
          geometry.update();
        }
        _super.prototype._render.call(this, renderer);
      };
      return SimpleRope;
    })(Mesh);
    var SimplePlane = function(_super) {
      __extends$1(SimplePlane2, _super);
      function SimplePlane2(texture, verticesX, verticesY) {
        var _this = this;
        var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
        var meshMaterial = new MeshMaterial(Texture.WHITE);
        _this = _super.call(this, planeGeometry, meshMaterial) || this;
        _this.texture = texture;
        return _this;
      }
      SimplePlane2.prototype.textureUpdated = function() {
        this._textureID = this.shader.texture._updateID;
        var geometry = this.geometry;
        geometry.width = this.shader.texture.width;
        geometry.height = this.shader.texture.height;
        geometry.build();
      };
      Object.defineProperty(SimplePlane2.prototype, "texture", {
        get: function() {
          return this.shader.texture;
        },
        set: function(value2) {
          if (this.shader.texture === value2) {
            return;
          }
          this.shader.texture = value2;
          this._textureID = -1;
          if (value2.baseTexture.valid) {
            this.textureUpdated();
          } else {
            value2.once("update", this.textureUpdated, this);
          }
        },
        enumerable: false,
        configurable: true
      });
      SimplePlane2.prototype._render = function(renderer) {
        if (this._textureID !== this.shader.texture._updateID) {
          this.textureUpdated();
        }
        _super.prototype._render.call(this, renderer);
      };
      SimplePlane2.prototype.destroy = function(options) {
        this.shader.texture.off("update", this.textureUpdated, this);
        _super.prototype.destroy.call(this, options);
      };
      return SimplePlane2;
    }(Mesh);
    (function(_super) {
      __extends$1(SimpleMesh, _super);
      function SimpleMesh(texture, vertices, uvs, indices2, drawMode) {
        if (texture === void 0) {
          texture = Texture.EMPTY;
        }
        var _this = this;
        var geometry = new MeshGeometry(vertices, uvs, indices2);
        geometry.getBuffer("aVertexPosition").static = false;
        var meshMaterial = new MeshMaterial(texture);
        _this = _super.call(this, geometry, meshMaterial, null, drawMode) || this;
        _this.autoUpdate = true;
        return _this;
      }
      Object.defineProperty(SimpleMesh.prototype, "vertices", {
        get: function() {
          return this.geometry.getBuffer("aVertexPosition").data;
        },
        set: function(value2) {
          this.geometry.getBuffer("aVertexPosition").data = value2;
        },
        enumerable: false,
        configurable: true
      });
      SimpleMesh.prototype._render = function(renderer) {
        if (this.autoUpdate) {
          this.geometry.getBuffer("aVertexPosition").update();
        }
        _super.prototype._render.call(this, renderer);
      };
      return SimpleMesh;
    })(Mesh);
    var DEFAULT_BORDER_SIZE = 10;
    (function(_super) {
      __extends$1(NineSlicePlane, _super);
      function NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
        if (leftWidth === void 0) {
          leftWidth = DEFAULT_BORDER_SIZE;
        }
        if (topHeight === void 0) {
          topHeight = DEFAULT_BORDER_SIZE;
        }
        if (rightWidth === void 0) {
          rightWidth = DEFAULT_BORDER_SIZE;
        }
        if (bottomHeight === void 0) {
          bottomHeight = DEFAULT_BORDER_SIZE;
        }
        var _this = _super.call(this, Texture.WHITE, 4, 4) || this;
        _this._origWidth = texture.orig.width;
        _this._origHeight = texture.orig.height;
        _this._width = _this._origWidth;
        _this._height = _this._origHeight;
        _this._leftWidth = leftWidth;
        _this._rightWidth = rightWidth;
        _this._topHeight = topHeight;
        _this._bottomHeight = bottomHeight;
        _this.texture = texture;
        return _this;
      }
      NineSlicePlane.prototype.textureUpdated = function() {
        this._textureID = this.shader.texture._updateID;
        this._refresh();
      };
      Object.defineProperty(NineSlicePlane.prototype, "vertices", {
        get: function() {
          return this.geometry.getBuffer("aVertexPosition").data;
        },
        set: function(value2) {
          this.geometry.getBuffer("aVertexPosition").data = value2;
        },
        enumerable: false,
        configurable: true
      });
      NineSlicePlane.prototype.updateHorizontalVertices = function() {
        var vertices = this.vertices;
        var scale = this._getMinScale();
        vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
        vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
        vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
      };
      NineSlicePlane.prototype.updateVerticalVertices = function() {
        var vertices = this.vertices;
        var scale = this._getMinScale();
        vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
        vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
        vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
      };
      NineSlicePlane.prototype._getMinScale = function() {
        var w2 = this._leftWidth + this._rightWidth;
        var scaleW = this._width > w2 ? 1 : this._width / w2;
        var h2 = this._topHeight + this._bottomHeight;
        var scaleH = this._height > h2 ? 1 : this._height / h2;
        var scale = Math.min(scaleW, scaleH);
        return scale;
      };
      Object.defineProperty(NineSlicePlane.prototype, "width", {
        get: function() {
          return this._width;
        },
        set: function(value2) {
          this._width = value2;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane.prototype, "height", {
        get: function() {
          return this._height;
        },
        set: function(value2) {
          this._height = value2;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane.prototype, "leftWidth", {
        get: function() {
          return this._leftWidth;
        },
        set: function(value2) {
          this._leftWidth = value2;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane.prototype, "rightWidth", {
        get: function() {
          return this._rightWidth;
        },
        set: function(value2) {
          this._rightWidth = value2;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane.prototype, "topHeight", {
        get: function() {
          return this._topHeight;
        },
        set: function(value2) {
          this._topHeight = value2;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(NineSlicePlane.prototype, "bottomHeight", {
        get: function() {
          return this._bottomHeight;
        },
        set: function(value2) {
          this._bottomHeight = value2;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      NineSlicePlane.prototype._refresh = function() {
        var texture = this.texture;
        var uvs = this.geometry.buffers[1].data;
        this._origWidth = texture.orig.width;
        this._origHeight = texture.orig.height;
        var _uvw = 1 / this._origWidth;
        var _uvh = 1 / this._origHeight;
        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
        this.updateHorizontalVertices();
        this.updateVerticalVertices();
        this.geometry.buffers[0].update();
        this.geometry.buffers[1].update();
      };
      return NineSlicePlane;
    })(SimplePlane);
    /*!
     * @pixi/sprite-animated - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * @pixi/sprite-animated is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2) {
          if (b2.hasOwnProperty(p2)) {
            d2[p2] = b2[p2];
          }
        }
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var AnimatedSprite = function(_super) {
      __extends(AnimatedSprite2, _super);
      function AnimatedSprite2(textures, autoUpdate) {
        if (autoUpdate === void 0) {
          autoUpdate = true;
        }
        var _this = _super.call(this, textures[0] instanceof Texture ? textures[0] : textures[0].texture) || this;
        _this._textures = null;
        _this._durations = null;
        _this._autoUpdate = autoUpdate;
        _this._isConnectedToTicker = false;
        _this.animationSpeed = 1;
        _this.loop = true;
        _this.updateAnchor = false;
        _this.onComplete = null;
        _this.onFrameChange = null;
        _this.onLoop = null;
        _this._currentTime = 0;
        _this._playing = false;
        _this._previousFrame = null;
        _this.textures = textures;
        return _this;
      }
      AnimatedSprite2.prototype.stop = function() {
        if (!this._playing) {
          return;
        }
        this._playing = false;
        if (this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        }
      };
      AnimatedSprite2.prototype.play = function() {
        if (this._playing) {
          return;
        }
        this._playing = true;
        if (this._autoUpdate && !this._isConnectedToTicker) {
          Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
          this._isConnectedToTicker = true;
        }
      };
      AnimatedSprite2.prototype.gotoAndStop = function(frameNumber) {
        this.stop();
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
          this.updateTexture();
        }
      };
      AnimatedSprite2.prototype.gotoAndPlay = function(frameNumber) {
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
          this.updateTexture();
        }
        this.play();
      };
      AnimatedSprite2.prototype.update = function(deltaTime) {
        if (!this._playing) {
          return;
        }
        var elapsed = this.animationSpeed * deltaTime;
        var previousFrame = this.currentFrame;
        if (this._durations !== null) {
          var lag = this._currentTime % 1 * this._durations[this.currentFrame];
          lag += elapsed / 60 * 1e3;
          while (lag < 0) {
            this._currentTime--;
            lag += this._durations[this.currentFrame];
          }
          var sign2 = Math.sign(this.animationSpeed * deltaTime);
          this._currentTime = Math.floor(this._currentTime);
          while (lag >= this._durations[this.currentFrame]) {
            lag -= this._durations[this.currentFrame] * sign2;
            this._currentTime += sign2;
          }
          this._currentTime += lag / this._durations[this.currentFrame];
        } else {
          this._currentTime += elapsed;
        }
        if (this._currentTime < 0 && !this.loop) {
          this.gotoAndStop(0);
          if (this.onComplete) {
            this.onComplete();
          }
        } else if (this._currentTime >= this._textures.length && !this.loop) {
          this.gotoAndStop(this._textures.length - 1);
          if (this.onComplete) {
            this.onComplete();
          }
        } else if (previousFrame !== this.currentFrame) {
          if (this.loop && this.onLoop) {
            if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
              this.onLoop();
            } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
              this.onLoop();
            }
          }
          this.updateTexture();
        }
      };
      AnimatedSprite2.prototype.updateTexture = function() {
        var currentFrame = this.currentFrame;
        if (this._previousFrame === currentFrame) {
          return;
        }
        this._previousFrame = currentFrame;
        this._texture = this._textures[currentFrame];
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this._cachedTint = 16777215;
        this.uvs = this._texture._uvs.uvsFloat32;
        if (this.updateAnchor) {
          this._anchor.copyFrom(this._texture.defaultAnchor);
        }
        if (this.onFrameChange) {
          this.onFrameChange(this.currentFrame);
        }
      };
      AnimatedSprite2.prototype.destroy = function(options) {
        this.stop();
        _super.prototype.destroy.call(this, options);
        this.onComplete = null;
        this.onFrameChange = null;
        this.onLoop = null;
      };
      AnimatedSprite2.fromFrames = function(frames) {
        var textures = [];
        for (var i2 = 0; i2 < frames.length; ++i2) {
          textures.push(Texture.from(frames[i2]));
        }
        return new AnimatedSprite2(textures);
      };
      AnimatedSprite2.fromImages = function(images) {
        var textures = [];
        for (var i2 = 0; i2 < images.length; ++i2) {
          textures.push(Texture.from(images[i2]));
        }
        return new AnimatedSprite2(textures);
      };
      Object.defineProperty(AnimatedSprite2.prototype, "totalFrames", {
        get: function() {
          return this._textures.length;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimatedSprite2.prototype, "textures", {
        get: function() {
          return this._textures;
        },
        set: function(value2) {
          if (value2[0] instanceof Texture) {
            this._textures = value2;
            this._durations = null;
          } else {
            this._textures = [];
            this._durations = [];
            for (var i2 = 0; i2 < value2.length; i2++) {
              this._textures.push(value2[i2].texture);
              this._durations.push(value2[i2].time);
            }
          }
          this._previousFrame = null;
          this.gotoAndStop(0);
          this.updateTexture();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimatedSprite2.prototype, "currentFrame", {
        get: function() {
          var currentFrame = Math.floor(this._currentTime) % this._textures.length;
          if (currentFrame < 0) {
            currentFrame += this._textures.length;
          }
          return currentFrame;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimatedSprite2.prototype, "playing", {
        get: function() {
          return this._playing;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(AnimatedSprite2.prototype, "autoUpdate", {
        get: function() {
          return this._autoUpdate;
        },
        set: function(value2) {
          if (value2 !== this._autoUpdate) {
            this._autoUpdate = value2;
            if (!this._autoUpdate && this._isConnectedToTicker) {
              Ticker.shared.remove(this.update, this);
              this._isConnectedToTicker = false;
            } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
              Ticker.shared.add(this.update, this);
              this._isConnectedToTicker = true;
            }
          }
        },
        enumerable: false,
        configurable: true
      });
      return AnimatedSprite2;
    }(Sprite);
    /*!
     * pixi.js - v5.3.12
     * Compiled Wed, 23 Mar 2022 18:34:28 UTC
     *
     * pixi.js is licensed under the MIT License.
     * http://www.opensource.org/licenses/mit-license
     */
    Renderer.registerPlugin("accessibility", AccessibilityManager);
    Renderer.registerPlugin("extract", Extract);
    Renderer.registerPlugin("interaction", InteractionManager);
    Renderer.registerPlugin("particle", ParticleRenderer);
    Renderer.registerPlugin("prepare", Prepare);
    Renderer.registerPlugin("batch", BatchRenderer);
    Renderer.registerPlugin("tilingSprite", TilingSpriteRenderer);
    Loader.registerPlugin(BitmapFontLoader);
    Loader.registerPlugin(SpritesheetLoader);
    Application.registerPlugin(TickerPlugin);
    Application.registerPlugin(AppLoaderPlugin);
    class Entity {
      constructor(x2, y2) {
        __publicField(this, "container");
        __publicField(this, "parts", {});
        __publicField(this, "spawned");
        __publicField(this, "tag", "entity");
        __publicField(this, "timeSinceSpawned", () => {
          return performance.now() - this.spawned;
        });
        __publicField(this, "sprite", (from2) => {
          let sprite = new Sprite.from(from2);
          sprite.anchor.set(0.5);
          this.parts.sprite = sprite;
          this.container.addChild(this.parts.sprite);
          return this.parts.sprite;
        });
        __publicField(this, "part", (key) => {
          return this.parts[key];
        });
        __publicField(this, "add", (key, value2) => {
          this.parts[key] = value2;
          this.container.addChild(value2);
        });
        __publicField(this, "onUpdate", (delta) => {
        });
        __publicField(this, "onEvent", (eventType, event) => {
        });
        __publicField(this, "draw", (delta) => {
        });
        let container = new Container();
        container.pivot.x = Math.round(container.width / 2);
        container.pivot.y = Math.round(container.height / 2);
        container.x = x2;
        container.y = y2;
        this.container = container;
        this.spawned = performance.now();
      }
    }
    const bulletSprite = createIdenticon("bullet");
    class Bullet extends Entity {
      constructor(x2, y2, target) {
        super(x2, y2);
        __publicField(this, "width", 10);
        __publicField(this, "height", 10);
        __publicField(this, "target");
        __publicField(this, "enemyDelta");
        __publicField(this, "onUpdate", (delta) => {
          let vec = this.enemyDelta.getVector(this.enemyDelta.distance, this.enemyDelta.angle);
          this.container.x += vec.x * (delta / 10);
          this.container.y += vec.y * (delta / 10);
          if (this.hit()) {
            this.target.takeDamage();
            Game$1.remove(this);
          }
        });
        __publicField(this, "hit", () => {
          if (this.container.x >= this.target.container.x - this.target.container.width / 2 && this.container.x <= this.target.container.x + this.target.container.width / 2 && this.container.y >= this.target.container.y - this.target.container.height / 2 && this.container.y <= this.target.container.y + this.target.container.height / 2) {
            return true;
          }
          return false;
        });
        __publicField(this, "draw", () => {
        });
        this.sprite(bulletSprite);
        this.part("sprite").width = this.width;
        this.part("sprite").height = this.height;
        this.target = target;
        this.enemyDelta = new AngleDelta(
          this.container.x,
          this.container.y,
          this.target.container.x,
          this.target.container.y
        );
      }
    }
    class Emitter {
      constructor() {
        __publicField(this, "on", (e, callback) => {
          if (!this.events[e]) {
            this.events[e] = [];
          }
          this.events[e].push(callback);
        });
        __publicField(this, "emit", (e, ...data) => {
          this.events[e].forEach((callback) => {
            callback(...data);
          });
        });
        this.events = {};
      }
      static getInstance() {
        if (!Emitter._instance) {
          Emitter._instance = new Emitter();
        }
        return Emitter._instance;
      }
    }
    const events = function() {
      return Emitter.getInstance();
    }();
    class Player extends Entity {
      constructor(playerName, x2, y2) {
        super(x2, y2);
        __publicField(this, "width", 40);
        __publicField(this, "height", 40);
        __publicField(this, "target");
        __publicField(this, "name");
        __publicField(this, "shouldResetTarget", (key) => {
          return key.toLowerCase() == "backspace" && this.target !== null;
        });
        __publicField(this, "onEvent", (eventType, event) => {
          if (eventType !== "keydown") {
            return;
          }
          const { key } = event;
          if (this.shouldResetTarget(key)) {
            this.target.isTargeted(false);
            this.target = null;
          }
          let target = this.getTarget(key);
          if (target) {
            this.makeAttack(target, key);
          }
        });
        __publicField(this, "getTarget", (key) => {
          if (this.target) {
            return this.target;
          }
          let enemies = Game$1.find("enemy").filter(
            (e) => e.word.toLowerCase().startsWith(key.toLowerCase())
          );
          if (enemies.length === 0) {
            return;
          }
          enemies = enemies.sort((a2, b) => a2.container.y - b.container.y);
          let enemy = enemies.pop();
          this.target = enemy;
          this.target.isTargeted(true);
          return this.target;
        });
        __publicField(this, "makeAttack", (target, key) => {
          let missed = true;
          if (target.word.toLowerCase().startsWith(key.toLowerCase())) {
            Game$1.add(new Bullet(this.container.x, this.container.y, target));
            target.takeHit();
            if (target.isDead()) {
              this.target = null;
            }
            missed = false;
          }
          events.emit("shotFired", missed);
        });
        this.name = playerName;
        this.sprite(createIdenticon(playerName));
        this.part("sprite").width = this.width;
        this.part("sprite").height = this.height;
      }
    }
    class Enemy extends Entity {
      constructor(word, target, wave, velocityCalculator) {
        super(
          Math.random() * (400 - 20) + 20,
          Math.random() * (-100 - 50) + -50
        );
        __publicField(this, "angle", 0);
        __publicField(this, "velocity", 2);
        __publicField(this, "rotationSpeed", 0.01);
        __publicField(this, "maxRotationSpeed", 0.02);
        __publicField(this, "playerDelta");
        __publicField(this, "follow", false);
        __publicField(this, "alertTime", 1e3);
        __publicField(this, "word");
        __publicField(this, "originalWord");
        __publicField(this, "targeted", false);
        __publicField(this, "dead", false);
        __publicField(this, "target", null);
        __publicField(this, "image");
        __publicField(this, "width", 30);
        __publicField(this, "height", 30);
        __publicField(this, "life", 1);
        __publicField(this, "stunned", 0);
        __publicField(this, "velocityCalculator");
        __publicField(this, "draw", (delta) => {
          if (this.targeted) {
            this.part("text").style.fill = 16748288;
          } else {
            this.part("text").style.fill = 16777215;
          }
          this.drawWord();
        });
        __publicField(this, "drawWord", () => {
          let textMetrics = TextMetrics.measureText(this.word, this.part("text").style);
          this.part("blackBar").width = textMetrics.width + 10;
          if (this.word === "") {
            this.part("blackBar").alpha = 0;
          }
          this.part("text").text = this.word;
        });
        __publicField(this, "onUpdate", (delta) => {
          if (this.stunned) {
            this.stunned -= Ticker.shared.elapsedMS;
            if (this.stunned <= 0) {
              this.stunned = 0;
            }
            return;
          }
          if (this.container.x >= this.target.container.x - this.target.container.width / 2 && this.container.x <= this.target.container.x + this.target.container.width / 2 && this.container.y >= this.target.container.y - this.target.container.height / 2 && this.container.y <= this.target.container.y + this.target.container.height / 2) {
            events.emit("playerDeath");
            console.log("Player should be dead now. Killed by word: ", this.word);
          }
          if (!this.follow) {
            this.follow = this.timeSinceSpawned() - this.alertTime > 0;
            if (this.container.x < 150 && this.container.x > 350) {
              this.follow = true;
            }
          }
          let dx = this.container.x - this.target.container.x;
          let dy = this.container.y - this.target.container.y;
          let angle = Math.atan2(dy, dx);
          let dangle = angle - this.angle;
          if (this.follow && dangle !== 0) {
            if (dangle > 0) {
              this.angle += this.rotationSpeed * delta;
            } else {
              this.angle -= this.rotationSpeed * delta;
            }
            if (dangle > -0.01 && dangle < 0.01) {
              this.angle = angle;
            }
          }
          let oldX = this.container.x;
          let oldY = this.container.y;
          this.container.x -= this.velocity * delta * Math.cos(this.angle);
          this.container.y -= this.velocity * delta * Math.sin(this.angle);
          this.part("sprite").angle = Math.atan2(
            oldY - this.container.y,
            oldX - this.container.x
          ) * 180 / Math.PI + 90;
        });
        __publicField(this, "takeDamage", () => {
          this.life--;
          this.stunned = 100;
          this.parts.sprite.tint = 16711680;
          setTimeout(() => {
            this.parts.sprite.tint = 16777215;
          }, 100);
          if (this.life === 0) {
            events.emit("enemyDeath");
            this.deathAnimation(() => {
              Game$1.remove(this);
            });
          }
        });
        __publicField(this, "deathAnimation", (callback) => {
          let rndImages = [
            createIdenticon("asd"),
            createIdenticon("3433"),
            createIdenticon("dsds"),
            createIdenticon("Math.random()"),
            createIdenticon("ssssMath.random()")
          ];
          let textureArray = [];
          for (let i2 = 0; i2 < 4; i2++) {
            let texture = Texture.from(rndImages[i2]);
            textureArray.push(texture);
          }
          this.parts.sprite.removeChild();
          let animation = new AnimatedSprite(textureArray);
          animation.width = 30;
          animation.height = 30;
          animation.anchor.set(0.5);
          animation.onComplete = () => {
            callback();
          };
          animation.loop = false;
          this.container.addChild(animation);
          animation.play();
        });
        __publicField(this, "takeHit", () => {
          this.word = this.word.substring(1);
          if (this.word.length === 0) {
            this.dead = true;
          }
        });
        __publicField(this, "isDead", () => {
          return this.dead;
        });
        __publicField(this, "isTargeted", (status) => {
          if (status) {
            events.emit("enemyTargeted", this);
          }
          this.targeted = status;
        });
        __publicField(this, "createBlackBar", (width2, height2) => {
          let block = new Sprite.from(Texture.WHITE);
          block.anchor.set(0.5);
          block.width = width2;
          block.height = height2;
          block.tint = 0;
          block.y = 30;
          return block;
        });
        __publicField(this, "createWordText", (from2) => {
          let textStyle = new TextStyle({
            fontFamily: "Poppins",
            fontSize: 16,
            align: "center",
            fill: 16777215
          });
          let text = new Text(from2, textStyle);
          text.anchor.set(0.5);
          text.y = 30;
          return text;
        });
        this.sprite(createIdenticon(word));
        this.part("sprite").width = 30;
        this.part("sprite").height = 30;
        this.velocity = velocityCalculator.calculate(wave);
        this.rotationSpeed = (Math.floor(Math.random() * (this.maxRotationSpeed * 1e4)) + 100) / 1e4;
        let text = this.createWordText(word);
        let style = text.style;
        let textMetrics = TextMetrics.measureText(word, style);
        this.add("blackBar", this.createBlackBar(textMetrics.width, textMetrics.height));
        this.add("text", text);
        this.life = word.length;
        this.tag = "enemy";
        this.word = word;
        this.originalWord = word;
        this.target = target;
        this.alertTime = Math.floor(Math.random() * (3e3 - 1e3)) + 1e3;
        let startRotation = Math.floor(Math.random() * 60) - 30;
        this.angle = (-90 + startRotation) * Math.PI / 180;
        this.playerDelta = new AngleDelta(
          this.container.x,
          this.container.y,
          this.target.container.x,
          this.target.container.y
        );
      }
    }
    function bind$1(fn, thisArg) {
      return function wrap2() {
        return fn.apply(thisArg, arguments);
      };
    }
    const { toString: toString$2 } = Object.prototype;
    const { getPrototypeOf } = Object;
    const kindOf = ((cache2) => (thing) => {
      const str = toString$2.call(thing);
      return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    const kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    const typeOfTest = (type) => (thing) => typeof thing === type;
    const { isArray: isArray$2 } = Array;
    const isUndefined$2 = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined$2(val) && val.constructor !== null && !isUndefined$2(val.constructor) && isFunction$3(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    const isArrayBuffer$1 = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result2;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result2 = ArrayBuffer.isView(val);
      } else {
        result2 = val && val.buffer && isArrayBuffer$1(val.buffer);
      }
      return result2;
    }
    const isString$2 = typeOfTest("string");
    const isFunction$3 = typeOfTest("function");
    const isNumber$2 = typeOfTest("number");
    const isObject$2 = (thing) => thing !== null && typeof thing === "object";
    const isBoolean$1 = (thing) => thing === true || thing === false;
    const isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    const isDate$2 = kindOfTest("Date");
    const isFile = kindOfTest("File");
    const isBlob = kindOfTest("Blob");
    const isFileList = kindOfTest("FileList");
    const isStream = (val) => isObject$2(val) && isFunction$3(val.pipe);
    const isFormData = (thing) => {
      const pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString$2.call(thing) === pattern || isFunction$3(thing.toString) && thing.toString() === pattern);
    };
    const isURLSearchParams = kindOfTest("URLSearchParams");
    const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i2;
      let l2;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray$2(obj)) {
        for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys2.length;
        let key;
        for (i2 = 0; i2 < len; i2++) {
          key = keys2[i2];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey$1(obj, key) {
      key = key.toLowerCase();
      const keys2 = Object.keys(obj);
      let i2 = keys2.length;
      let _key;
      while (i2-- > 0) {
        _key = keys2[i2];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    const _global = typeof self === "undefined" ? typeof global === "undefined" ? globalThis : global : self;
    const isContextDefined = (context2) => !isUndefined$2(context2) && context2 !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result2 = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey$1(result2, key) || key;
        if (isPlainObject(result2[targetKey]) && isPlainObject(val)) {
          result2[targetKey] = merge(result2[targetKey], val);
        } else if (isPlainObject(val)) {
          result2[targetKey] = merge({}, val);
        } else if (isArray$2(val)) {
          result2[targetKey] = val.slice();
        } else {
          result2[targetKey] = val;
        }
      };
      for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
        arguments[i2] && forEach(arguments[i2], assignValue);
      }
      return result2;
    }
    const extend$2 = (a2, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction$3(val)) {
          a2[key] = bind$1(val, thisArg);
        } else {
          a2[key] = val;
        }
      }, { allOwnKeys });
      return a2;
    };
    const stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    const inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
      let props;
      let i2;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    const endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    const toArray$3 = (thing) => {
      if (!thing)
        return null;
      if (isArray$2(thing))
        return thing;
      let i2 = thing.length;
      if (!isNumber$2(i2))
        return null;
      const arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    };
    const isTypedArray$2 = ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    const forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result2;
      while ((result2 = iterator.next()) && !result2.done) {
        const pair = result2.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    const matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    const isHTMLForm = kindOfTest("HTMLFormElement");
    const toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[_-\s]([a-z\d])(\w*)/g,
        function replacer(m2, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    const hasOwnProperty$1 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    const isRegExp$1 = kindOfTest("RegExp");
    const reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        if (reducer(descriptor, name, obj) !== false) {
          reducedDescriptors[name] = descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction$3(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value2 = obj[name];
        if (!isFunction$3(value2))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    const toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value2) => {
          obj[value2] = true;
        });
      };
      isArray$2(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    const noop$1 = () => {
    };
    const toFiniteNumber = (value2, defaultValue2) => {
      value2 = +value2;
      return Number.isFinite(value2) ? value2 : defaultValue2;
    };
    const toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i2) => {
        if (isObject$2(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i2] = source;
            const target = isArray$2(source) ? [] : {};
            forEach(source, (value2, key) => {
              const reducedValue = visit(value2, i2 + 1);
              !isUndefined$2(reducedValue) && (target[key] = reducedValue);
            });
            stack[i2] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    const utils = {
      isArray: isArray$2,
      isArrayBuffer: isArrayBuffer$1,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString$2,
      isNumber: isNumber$2,
      isBoolean: isBoolean$1,
      isObject: isObject$2,
      isPlainObject,
      isUndefined: isUndefined$2,
      isDate: isDate$2,
      isFile,
      isBlob,
      isRegExp: isRegExp$1,
      isFunction: isFunction$3,
      isStream,
      isURLSearchParams,
      isTypedArray: isTypedArray$2,
      isFileList,
      forEach,
      merge,
      extend: extend$2,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray: toArray$3,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty: hasOwnProperty$1,
      hasOwnProp: hasOwnProperty$1,
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop: noop$1,
      toFiniteNumber,
      findKey: findKey$1,
      global: _global,
      isContextDefined,
      toJSONObject
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON2() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: utils.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    const prototype$1 = AxiosError.prototype;
    const descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils.toFlatObject(error, axiosError, function filter2(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    var browser = typeof self == "object" ? self.FormData : window.FormData;
    const FormData$2 = browser;
    function isVisitable(thing) {
      return utils.isPlainObject(thing) || utils.isArray(thing);
    }
    function removeBrackets(key) {
      return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each2(token2, i2) {
        token2 = removeBrackets(token2);
        return !dots && i2 ? "[" + token2 + "]" : token2;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils.isArray(arr) && !arr.some(isVisitable);
    }
    const predicates = utils.toFlatObject(utils, {}, null, function filter2(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function isSpecCompliant(thing) {
      return thing && utils.isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator];
    }
    function toFormData(obj, formData, options) {
      if (!utils.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (FormData$2 || FormData)();
      options = utils.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && isSpecCompliant(formData);
      if (!utils.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value2) {
        if (value2 === null)
          return "";
        if (utils.isDate(value2)) {
          return value2.toISOString();
        }
        if (!useBlob && utils.isBlob(value2)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils.isArrayBuffer(value2) || utils.isTypedArray(value2)) {
          return useBlob && typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
        }
        return value2;
      }
      function defaultVisitor(value2, key, path) {
        let arr = value2;
        if (value2 && !path && typeof value2 === "object") {
          if (utils.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value2 = JSON.stringify(value2);
          } else if (utils.isArray(value2) && isFlatArray(value2) || (utils.isFileList(value2) || utils.endsWith(key, "[]") && (arr = utils.toArray(value2)))) {
            key = removeBrackets(key);
            arr.forEach(function each2(el, index2) {
              !(utils.isUndefined(el) || el === null) && formData.append(
                indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value2)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value2));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value2, path) {
        if (utils.isUndefined(value2))
          return;
        if (stack.indexOf(value2) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value2);
        utils.forEach(value2, function each2(el, key) {
          const result2 = !(utils.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result2 === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value2) {
      this._pairs.push([name, value2]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value2) {
        return encoder.call(this, value2, encode$1);
      } : encode$1;
      return this._pairs.map(function each2(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url2, params, options) {
      if (!params) {
        return url2;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url2.indexOf("#");
        if (hashmarkIndex !== -1) {
          url2 = url2.slice(0, hashmarkIndex);
        }
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    }
    class InterceptorManager {
      constructor() {
        this.handlers = [];
      }
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      eject(id2) {
        if (this.handlers[id2]) {
          this.handlers[id2] = null;
        }
      }
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn(h2);
          }
        });
      }
    }
    const InterceptorManager$1 = InterceptorManager;
    const transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    const FormData$1 = FormData;
    const isStandardBrowserEnv = (() => {
      let product;
      if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    })();
    const isStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    const platform = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob
      },
      isStandardBrowserEnv,
      isStandardBrowserWebWorkerEnv,
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value2, key, path, helpers) {
          if (platform.isNode && utils.isBuffer(value2)) {
            this.append(key, value2.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys2 = Object.keys(arr);
      let i2;
      const len = keys2.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys2[i2];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value2, target, index2) {
        let name = path[index2++];
        const isNumericKey = Number.isFinite(+name);
        const isLast = index2 >= path.length;
        name = !name && utils.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils.hasOwnProp(target, name)) {
            target[name] = [target[name], value2];
          } else {
            target[name] = value2;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils.isObject(target[name])) {
          target[name] = [];
        }
        const result2 = buildPath(path, value2, target[name], index2);
        if (result2 && utils.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
        const obj = {};
        utils.forEachEntry(formData, (name, value2) => {
          buildPath(parsePropPath(name), value2, obj, 0);
        });
        return obj;
      }
      return null;
    }
    const DEFAULT_CONTENT_TYPE = {
      "Content-Type": void 0
    };
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    const defaults$2 = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils.isObject(data);
        if (isObjectPayload && utils.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils.isFormData(data);
        if (isFormData2) {
          if (!hasJSONContentType) {
            return data;
          }
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults$2.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults$2.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults$2.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    const defaults$3 = defaults$2;
    const ignoreDuplicateOf = utils.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    const parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i2;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i2 = line.indexOf(":");
        key = line.substring(0, i2).trim().toLowerCase();
        val = line.substring(i2 + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    const $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value2) {
      if (value2 === false || value2 == null) {
        return value2;
      }
      return utils.isArray(value2) ? value2.map(normalizeValue) : String(value2);
    }
    function parseTokens(str) {
      const tokens2 = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens2[match[1]] = match[2];
      }
      return tokens2;
    }
    function isValidHeaderName(str) {
      return /^[-_a-zA-Z]+$/.test(str.trim());
    }
    function matchHeaderValue(context2, value2, header, filter2) {
      if (utils.isFunction(filter2)) {
        return filter2.call(this, value2, header);
      }
      if (!utils.isString(value2))
        return;
      if (utils.isString(filter2)) {
        return value2.indexOf(filter2) !== -1;
      }
      if (utils.isRegExp(filter2)) {
        return filter2.test(value2);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils.findKey(this, header);
          if (key) {
            const value2 = this[key];
            if (!parser) {
              return value2;
            }
            if (parser === true) {
              return parseTokens(value2);
            }
            if (utils.isFunction(parser)) {
              return parser.call(this, value2, key);
            }
            if (utils.isRegExp(parser)) {
              return parser.exec(value2);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher2) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils.findKey(this, header);
          return !!(key && (!matcher2 || matchHeaderValue(this, this[key], key, matcher2)));
        }
        return false;
      }
      delete(header, matcher2) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils.findKey(self2, _header);
            if (key && (!matcher2 || matchHeaderValue(self2, self2[key], key, matcher2))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear() {
        return Object.keys(this).forEach(this.delete.bind(this));
      }
      normalize(format2) {
        const self2 = this;
        const headers = {};
        utils.forEach(this, (value2, header) => {
          const key = utils.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value2);
            delete self2[header];
            return;
          }
          const normalized = format2 ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value2);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils.forEach(this, (value2, header) => {
          value2 != null && value2 !== false && (obj[header] = asStrings && utils.isArray(value2) ? value2.join(", ") : value2);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value2]) => header + ": " + value2).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first2, ...targets) {
        const computed = new this(first2);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    }
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
    utils.freezeMethods(AxiosHeaders.prototype);
    utils.freezeMethods(AxiosHeaders);
    const AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$3;
      const context2 = response || config;
      const headers = AxiosHeaders$1.from(context2.headers);
      let data = context2.data;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value2) {
      return !!(value2 && value2.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    const httpAdapter = null;
    function settle(resolve, reject2, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject2(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    const cookies = platform.isStandardBrowserEnv ? function standardBrowserEnv() {
      return {
        write: function write(name, value2, expires, path, domain, secure) {
          const cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value2));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
    function isAbsoluteURL(url2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    const isURLSameOrigin = platform.isStandardBrowserEnv ? function standardBrowserEnv() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url2) {
        let href = url2;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }();
    function parseProtocol(url2) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min2) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min2 = min2 !== void 0 ? min2 : 1e3;
      return function push2(chunkLength) {
        const now2 = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now2;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now2;
        let i2 = tail;
        let bytesCount = 0;
        while (i2 !== head) {
          bytesCount += bytes[i2++];
          i2 = i2 % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now2 - firstSampleTS < min2) {
          return;
        }
        const passed = startedAt && now2 - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    const xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject2) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        const responseType = config.responseType;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
          requestHeaders.setContentType(false);
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value2) {
            resolve(value2);
            done();
          }, function _reject(err) {
            reject2(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject2(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject2(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject2(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.isStandardBrowserEnv) {
          const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
          if (xsrfValue) {
            requestHeaders.set(config.xsrfHeaderName, xsrfValue);
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject2(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject2(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils.forEach(knownAdapters, (fn, value2) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value: value2 });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value: value2 });
      }
    });
    const adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        for (let i2 = 0; i2 < length; i2++) {
          nameOrAdapter = adapters2[i2];
          if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
            break;
          }
        }
        if (!adapter) {
          if (adapter === false) {
            throw new AxiosError(
              `Adapter ${nameOrAdapter} is not supported by the environment`,
              "ERR_NOT_SUPPORT"
            );
          }
          throw new Error(
            utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
          );
        }
        if (!utils.isFunction(adapter)) {
          throw new TypeError("adapter is not a function");
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$3.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge.call({ caseless }, target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a2, b, caseless) {
        if (!utils.isUndefined(b)) {
          return getMergedValue(a2, b, caseless);
        } else if (!utils.isUndefined(a2)) {
          return getMergedValue(void 0, a2, caseless);
        }
      }
      function valueFromConfig2(a2, b) {
        if (!utils.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a2, b) {
        if (!utils.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils.isUndefined(a2)) {
          return getMergedValue(void 0, a2);
        }
      }
      function mergeDirectKeys(a2, b, prop) {
        if (prop in config2) {
          return getMergedValue(a2, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a2);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a2, b) => mergeDeepProperties(headersToObject(a2), headersToObject(b), true)
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    const VERSION$1 = "1.2.1";
    const validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
      };
    });
    const deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value2, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value2, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i2 = keys2.length;
      while (i2-- > 0) {
        const opt = keys2[i2];
        const validator2 = schema[opt];
        if (validator2) {
          const value2 = options[opt];
          const result2 = value2 === void 0 || validator2(value2, opt, options);
          if (result2 !== true) {
            throw new AxiosError("option " + opt + " must be " + result2, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    const validator = {
      assertOptions,
      validators: validators$1
    };
    const validators = validator.validators;
    class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer !== void 0) {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders;
        contextHeaders = headers && utils.merge(
          headers.common,
          headers[config.method]
        );
        contextHeaders && utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise2;
        let i2 = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain2 = [dispatchRequest.bind(this), void 0];
          chain2.unshift.apply(chain2, requestInterceptorChain);
          chain2.push.apply(chain2, responseInterceptorChain);
          len = chain2.length;
          promise2 = Promise.resolve(config);
          while (i2 < len) {
            promise2 = promise2.then(chain2[i2++], chain2[i2++]);
          }
          return promise2;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i2 = 0;
        while (i2 < len) {
          const onFulfilled = requestInterceptorChain[i2++];
          const onRejected = requestInterceptorChain[i2++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise2 = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i2 = 0;
        len = responseInterceptorChain.length;
        while (i2 < len) {
          promise2 = promise2.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
        }
        return promise2;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    }
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url: url2,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    const Axios$1 = Axios;
    class CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token2 = this;
        this.promise.then((cancel) => {
          if (!token2._listeners)
            return;
          let i2 = token2._listeners.length;
          while (i2-- > 0) {
            token2._listeners[i2](cancel);
          }
          token2._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise2 = new Promise((resolve) => {
            token2.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise2.cancel = function reject2() {
            token2.unsubscribe(_resolve);
          };
          return promise2;
        };
        executor(function cancel(message, config, request) {
          if (token2.reason) {
            return;
          }
          token2.reason = new CanceledError(message, config, request);
          resolvePromise(token2.reason);
        });
      }
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      }
      static source() {
        let cancel;
        const token2 = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token: token2,
          cancel
        };
      }
    }
    const CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap2(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    }
    function createInstance(defaultConfig) {
      const context2 = new Axios$1(defaultConfig);
      const instance = bind$1(Axios$1.prototype.request, context2);
      utils.extend(instance, Axios$1.prototype, context2, { allOwnKeys: true });
      utils.extend(instance, context2, null, { allOwnKeys: true });
      instance.create = function create2(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    const axios = createInstance(defaults$3);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION$1;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.default = axios;
    const axios$1 = axios;
    var VERSION = "1.13.6";
    var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
    var ArrayProto = Array.prototype, ObjProto = Object.prototype;
    var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
    var push = ArrayProto.push, slice = ArrayProto.slice, toString$1 = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
    var supportsArrayBuffer = typeof ArrayBuffer !== "undefined", supportsDataView = typeof DataView !== "undefined";
    var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
    var _isNaN = isNaN, _isFinite = isFinite;
    var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
    var nonEnumerableProps = [
      "valueOf",
      "isPrototypeOf",
      "toString",
      "propertyIsEnumerable",
      "hasOwnProperty",
      "toLocaleString"
    ];
    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
    function restArguments(func, startIndex) {
      startIndex = startIndex == null ? func.length - 1 : +startIndex;
      return function() {
        var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index2 = 0;
        for (; index2 < length; index2++) {
          rest2[index2] = arguments[index2 + startIndex];
        }
        switch (startIndex) {
          case 0:
            return func.call(this, rest2);
          case 1:
            return func.call(this, arguments[0], rest2);
          case 2:
            return func.call(this, arguments[0], arguments[1], rest2);
        }
        var args = Array(startIndex + 1);
        for (index2 = 0; index2 < startIndex; index2++) {
          args[index2] = arguments[index2];
        }
        args[startIndex] = rest2;
        return func.apply(this, args);
      };
    }
    function isObject$1(obj) {
      var type = typeof obj;
      return type === "function" || type === "object" && !!obj;
    }
    function isNull(obj) {
      return obj === null;
    }
    function isUndefined$1(obj) {
      return obj === void 0;
    }
    function isBoolean(obj) {
      return obj === true || obj === false || toString$1.call(obj) === "[object Boolean]";
    }
    function isElement(obj) {
      return !!(obj && obj.nodeType === 1);
    }
    function tagTester(name) {
      var tag = "[object " + name + "]";
      return function(obj) {
        return toString$1.call(obj) === tag;
      };
    }
    const isString$1 = tagTester("String");
    const isNumber$1 = tagTester("Number");
    const isDate$1 = tagTester("Date");
    const isRegExp = tagTester("RegExp");
    const isError = tagTester("Error");
    const isSymbol = tagTester("Symbol");
    const isArrayBuffer = tagTester("ArrayBuffer");
    var isFunction$1 = tagTester("Function");
    var nodelist = root.document && root.document.childNodes;
    if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
      isFunction$1 = function(obj) {
        return typeof obj == "function" || false;
      };
    }
    const isFunction$2 = isFunction$1;
    const hasObjectTag = tagTester("Object");
    var hasStringTagBug = supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8))), isIE11 = typeof Map !== "undefined" && hasObjectTag(/* @__PURE__ */ new Map());
    var isDataView = tagTester("DataView");
    function ie10IsDataView(obj) {
      return obj != null && isFunction$2(obj.getInt8) && isArrayBuffer(obj.buffer);
    }
    const isDataView$1 = hasStringTagBug ? ie10IsDataView : isDataView;
    const isArray$1 = nativeIsArray || tagTester("Array");
    function has$1(obj, key) {
      return obj != null && hasOwnProperty.call(obj, key);
    }
    var isArguments = tagTester("Arguments");
    (function() {
      if (!isArguments(arguments)) {
        isArguments = function(obj) {
          return has$1(obj, "callee");
        };
      }
    })();
    const isArguments$1 = isArguments;
    function isFinite$1(obj) {
      return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
    }
    function isNaN$1(obj) {
      return isNumber$1(obj) && _isNaN(obj);
    }
    function constant(value2) {
      return function() {
        return value2;
      };
    }
    function createSizePropertyCheck(getSizeProperty) {
      return function(collection) {
        var sizeProperty = getSizeProperty(collection);
        return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
      };
    }
    function shallowProperty(key) {
      return function(obj) {
        return obj == null ? void 0 : obj[key];
      };
    }
    const getByteLength = shallowProperty("byteLength");
    const isBufferLike = createSizePropertyCheck(getByteLength);
    var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    function isTypedArray(obj) {
      return nativeIsView ? nativeIsView(obj) && !isDataView$1(obj) : isBufferLike(obj) && typedArrayPattern.test(toString$1.call(obj));
    }
    const isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);
    const getLength = shallowProperty("length");
    function emulatedSet(keys2) {
      var hash = {};
      for (var l2 = keys2.length, i2 = 0; i2 < l2; ++i2)
        hash[keys2[i2]] = true;
      return {
        contains: function(key) {
          return hash[key] === true;
        },
        push: function(key) {
          hash[key] = true;
          return keys2.push(key);
        }
      };
    }
    function collectNonEnumProps(obj, keys2) {
      keys2 = emulatedSet(keys2);
      var nonEnumIdx = nonEnumerableProps.length;
      var constructor = obj.constructor;
      var proto2 = isFunction$2(constructor) && constructor.prototype || ObjProto;
      var prop = "constructor";
      if (has$1(obj, prop) && !keys2.contains(prop))
        keys2.push(prop);
      while (nonEnumIdx--) {
        prop = nonEnumerableProps[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto2[prop] && !keys2.contains(prop)) {
          keys2.push(prop);
        }
      }
    }
    function keys$1(obj) {
      if (!isObject$1(obj))
        return [];
      if (nativeKeys)
        return nativeKeys(obj);
      var keys2 = [];
      for (var key in obj)
        if (has$1(obj, key))
          keys2.push(key);
      if (hasEnumBug)
        collectNonEnumProps(obj, keys2);
      return keys2;
    }
    function isEmpty(obj) {
      if (obj == null)
        return true;
      var length = getLength(obj);
      if (typeof length == "number" && (isArray$1(obj) || isString$1(obj) || isArguments$1(obj)))
        return length === 0;
      return getLength(keys$1(obj)) === 0;
    }
    function isMatch(object2, attrs) {
      var _keys = keys$1(attrs), length = _keys.length;
      if (object2 == null)
        return !length;
      var obj = Object(object2);
      for (var i2 = 0; i2 < length; i2++) {
        var key = _keys[i2];
        if (attrs[key] !== obj[key] || !(key in obj))
          return false;
      }
      return true;
    }
    function _$1(obj) {
      if (obj instanceof _$1)
        return obj;
      if (!(this instanceof _$1))
        return new _$1(obj);
      this._wrapped = obj;
    }
    _$1.VERSION = VERSION;
    _$1.prototype.value = function() {
      return this._wrapped;
    };
    _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;
    _$1.prototype.toString = function() {
      return String(this._wrapped);
    };
    function toBufferView(bufferSource) {
      return new Uint8Array(
        bufferSource.buffer || bufferSource,
        bufferSource.byteOffset || 0,
        getByteLength(bufferSource)
      );
    }
    var tagDataView = "[object DataView]";
    function eq(a2, b, aStack, bStack) {
      if (a2 === b)
        return a2 !== 0 || 1 / a2 === 1 / b;
      if (a2 == null || b == null)
        return false;
      if (a2 !== a2)
        return b !== b;
      var type = typeof a2;
      if (type !== "function" && type !== "object" && typeof b != "object")
        return false;
      return deepEq(a2, b, aStack, bStack);
    }
    function deepEq(a2, b, aStack, bStack) {
      if (a2 instanceof _$1)
        a2 = a2._wrapped;
      if (b instanceof _$1)
        b = b._wrapped;
      var className = toString$1.call(a2);
      if (className !== toString$1.call(b))
        return false;
      if (hasStringTagBug && className == "[object Object]" && isDataView$1(a2)) {
        if (!isDataView$1(b))
          return false;
        className = tagDataView;
      }
      switch (className) {
        case "[object RegExp]":
        case "[object String]":
          return "" + a2 === "" + b;
        case "[object Number]":
          if (+a2 !== +a2)
            return +b !== +b;
          return +a2 === 0 ? 1 / +a2 === 1 / b : +a2 === +b;
        case "[object Date]":
        case "[object Boolean]":
          return +a2 === +b;
        case "[object Symbol]":
          return SymbolProto.valueOf.call(a2) === SymbolProto.valueOf.call(b);
        case "[object ArrayBuffer]":
        case tagDataView:
          return deepEq(toBufferView(a2), toBufferView(b), aStack, bStack);
      }
      var areArrays = className === "[object Array]";
      if (!areArrays && isTypedArray$1(a2)) {
        var byteLength = getByteLength(a2);
        if (byteLength !== getByteLength(b))
          return false;
        if (a2.buffer === b.buffer && a2.byteOffset === b.byteOffset)
          return true;
        areArrays = true;
      }
      if (!areArrays) {
        if (typeof a2 != "object" || typeof b != "object")
          return false;
        var aCtor = a2.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(isFunction$2(aCtor) && aCtor instanceof aCtor && isFunction$2(bCtor) && bCtor instanceof bCtor) && ("constructor" in a2 && "constructor" in b)) {
          return false;
        }
      }
      aStack = aStack || [];
      bStack = bStack || [];
      var length = aStack.length;
      while (length--) {
        if (aStack[length] === a2)
          return bStack[length] === b;
      }
      aStack.push(a2);
      bStack.push(b);
      if (areArrays) {
        length = a2.length;
        if (length !== b.length)
          return false;
        while (length--) {
          if (!eq(a2[length], b[length], aStack, bStack))
            return false;
        }
      } else {
        var _keys = keys$1(a2), key;
        length = _keys.length;
        if (keys$1(b).length !== length)
          return false;
        while (length--) {
          key = _keys[length];
          if (!(has$1(b, key) && eq(a2[key], b[key], aStack, bStack)))
            return false;
        }
      }
      aStack.pop();
      bStack.pop();
      return true;
    }
    function isEqual(a2, b) {
      return eq(a2, b);
    }
    function allKeys(obj) {
      if (!isObject$1(obj))
        return [];
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      if (hasEnumBug)
        collectNonEnumProps(obj, keys2);
      return keys2;
    }
    function ie11fingerprint(methods) {
      var length = getLength(methods);
      return function(obj) {
        if (obj == null)
          return false;
        var keys2 = allKeys(obj);
        if (getLength(keys2))
          return false;
        for (var i2 = 0; i2 < length; i2++) {
          if (!isFunction$2(obj[methods[i2]]))
            return false;
        }
        return methods !== weakMapMethods || !isFunction$2(obj[forEachName]);
      };
    }
    var forEachName = "forEach", hasName = "has", commonInit = ["clear", "delete"], mapTail = ["get", hasName, "set"];
    var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = ["add"].concat(commonInit, forEachName, hasName);
    const isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
    const isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
    const isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
    const isWeakSet = tagTester("WeakSet");
    function values(obj) {
      var _keys = keys$1(obj);
      var length = _keys.length;
      var values2 = Array(length);
      for (var i2 = 0; i2 < length; i2++) {
        values2[i2] = obj[_keys[i2]];
      }
      return values2;
    }
    function pairs(obj) {
      var _keys = keys$1(obj);
      var length = _keys.length;
      var pairs2 = Array(length);
      for (var i2 = 0; i2 < length; i2++) {
        pairs2[i2] = [_keys[i2], obj[_keys[i2]]];
      }
      return pairs2;
    }
    function invert(obj) {
      var result2 = {};
      var _keys = keys$1(obj);
      for (var i2 = 0, length = _keys.length; i2 < length; i2++) {
        result2[obj[_keys[i2]]] = _keys[i2];
      }
      return result2;
    }
    function functions(obj) {
      var names = [];
      for (var key in obj) {
        if (isFunction$2(obj[key]))
          names.push(key);
      }
      return names.sort();
    }
    function createAssigner(keysFunc, defaults2) {
      return function(obj) {
        var length = arguments.length;
        if (defaults2)
          obj = Object(obj);
        if (length < 2 || obj == null)
          return obj;
        for (var index2 = 1; index2 < length; index2++) {
          var source = arguments[index2], keys2 = keysFunc(source), l2 = keys2.length;
          for (var i2 = 0; i2 < l2; i2++) {
            var key = keys2[i2];
            if (!defaults2 || obj[key] === void 0)
              obj[key] = source[key];
          }
        }
        return obj;
      };
    }
    const extend$1 = createAssigner(allKeys);
    const extendOwn = createAssigner(keys$1);
    const defaults$1 = createAssigner(allKeys, true);
    function ctor() {
      return function() {
      };
    }
    function baseCreate(prototype2) {
      if (!isObject$1(prototype2))
        return {};
      if (nativeCreate)
        return nativeCreate(prototype2);
      var Ctor = ctor();
      Ctor.prototype = prototype2;
      var result2 = new Ctor();
      Ctor.prototype = null;
      return result2;
    }
    function create(prototype2, props) {
      var result2 = baseCreate(prototype2);
      if (props)
        extendOwn(result2, props);
      return result2;
    }
    function clone$2(obj) {
      if (!isObject$1(obj))
        return obj;
      return isArray$1(obj) ? obj.slice() : extend$1({}, obj);
    }
    function tap(obj, interceptor) {
      interceptor(obj);
      return obj;
    }
    function toPath$1(path) {
      return isArray$1(path) ? path : [path];
    }
    _$1.toPath = toPath$1;
    function toPath(path) {
      return _$1.toPath(path);
    }
    function deepGet(obj, path) {
      var length = path.length;
      for (var i2 = 0; i2 < length; i2++) {
        if (obj == null)
          return void 0;
        obj = obj[path[i2]];
      }
      return length ? obj : void 0;
    }
    function get$3(object2, path, defaultValue2) {
      var value2 = deepGet(object2, toPath(path));
      return isUndefined$1(value2) ? defaultValue2 : value2;
    }
    function has(obj, path) {
      path = toPath(path);
      var length = path.length;
      for (var i2 = 0; i2 < length; i2++) {
        var key = path[i2];
        if (!has$1(obj, key))
          return false;
        obj = obj[key];
      }
      return !!length;
    }
    function identity(value2) {
      return value2;
    }
    function matcher(attrs) {
      attrs = extendOwn({}, attrs);
      return function(obj) {
        return isMatch(obj, attrs);
      };
    }
    function property(path) {
      path = toPath(path);
      return function(obj) {
        return deepGet(obj, path);
      };
    }
    function optimizeCb(func, context2, argCount) {
      if (context2 === void 0)
        return func;
      switch (argCount == null ? 3 : argCount) {
        case 1:
          return function(value2) {
            return func.call(context2, value2);
          };
        case 3:
          return function(value2, index2, collection) {
            return func.call(context2, value2, index2, collection);
          };
        case 4:
          return function(accumulator, value2, index2, collection) {
            return func.call(context2, accumulator, value2, index2, collection);
          };
      }
      return function() {
        return func.apply(context2, arguments);
      };
    }
    function baseIteratee(value2, context2, argCount) {
      if (value2 == null)
        return identity;
      if (isFunction$2(value2))
        return optimizeCb(value2, context2, argCount);
      if (isObject$1(value2) && !isArray$1(value2))
        return matcher(value2);
      return property(value2);
    }
    function iteratee(value2, context2) {
      return baseIteratee(value2, context2, Infinity);
    }
    _$1.iteratee = iteratee;
    function cb(value2, context2, argCount) {
      if (_$1.iteratee !== iteratee)
        return _$1.iteratee(value2, context2);
      return baseIteratee(value2, context2, argCount);
    }
    function mapObject(obj, iteratee2, context2) {
      iteratee2 = cb(iteratee2, context2);
      var _keys = keys$1(obj), length = _keys.length, results = {};
      for (var index2 = 0; index2 < length; index2++) {
        var currentKey = _keys[index2];
        results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
      }
      return results;
    }
    function noop() {
    }
    function propertyOf(obj) {
      if (obj == null)
        return noop;
      return function(path) {
        return get$3(obj, path);
      };
    }
    function times(n2, iteratee2, context2) {
      var accum = Array(Math.max(0, n2));
      iteratee2 = optimizeCb(iteratee2, context2, 1);
      for (var i2 = 0; i2 < n2; i2++)
        accum[i2] = iteratee2(i2);
      return accum;
    }
    function random(min2, max2) {
      if (max2 == null) {
        max2 = min2;
        min2 = 0;
      }
      return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
    }
    const now$1 = Date.now || function() {
      return new Date().getTime();
    };
    function createEscaper(map2) {
      var escaper = function(match) {
        return map2[match];
      };
      var source = "(?:" + keys$1(map2).join("|") + ")";
      var testRegexp = RegExp(source);
      var replaceRegexp = RegExp(source, "g");
      return function(string) {
        string = string == null ? "" : "" + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
      };
    }
    const escapeMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
    const escape$1 = createEscaper(escapeMap);
    const unescapeMap = invert(escapeMap);
    const unescape$1 = createEscaper(unescapeMap);
    const templateSettings = _$1.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };
    var noMatch = /(.)^/;
    var escapes = {
      "'": "'",
      "\\": "\\",
      "\r": "r",
      "\n": "n",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
    function escapeChar(match) {
      return "\\" + escapes[match];
    }
    var bareIdentifier = /^\s*(\w|\$)+\s*$/;
    function template(text, settings2, oldSettings) {
      if (!settings2 && oldSettings)
        settings2 = oldSettings;
      settings2 = defaults$1({}, settings2, _$1.templateSettings);
      var matcher2 = RegExp([
        (settings2.escape || noMatch).source,
        (settings2.interpolate || noMatch).source,
        (settings2.evaluate || noMatch).source
      ].join("|") + "|$", "g");
      var index2 = 0;
      var source = "__p+='";
      text.replace(matcher2, function(match, escape2, interpolate, evaluate, offset2) {
        source += text.slice(index2, offset2).replace(escapeRegExp, escapeChar);
        index2 = offset2 + match.length;
        if (escape2) {
          source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
        } else if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        } else if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }
        return match;
      });
      source += "';\n";
      var argument = settings2.variable;
      if (argument) {
        if (!bareIdentifier.test(argument))
          throw new Error(
            "variable is not a bare identifier: " + argument
          );
      } else {
        source = "with(obj||{}){\n" + source + "}\n";
        argument = "obj";
      }
      source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
      var render;
      try {
        render = new Function(argument, "_", source);
      } catch (e) {
        e.source = source;
        throw e;
      }
      var template2 = function(data) {
        return render.call(this, data, _$1);
      };
      template2.source = "function(" + argument + "){\n" + source + "}";
      return template2;
    }
    function result(obj, path, fallback) {
      path = toPath(path);
      var length = path.length;
      if (!length) {
        return isFunction$2(fallback) ? fallback.call(obj) : fallback;
      }
      for (var i2 = 0; i2 < length; i2++) {
        var prop = obj == null ? void 0 : obj[path[i2]];
        if (prop === void 0) {
          prop = fallback;
          i2 = length;
        }
        obj = isFunction$2(prop) ? prop.call(obj) : prop;
      }
      return obj;
    }
    var idCounter = 0;
    function uniqueId(prefix) {
      var id2 = ++idCounter + "";
      return prefix ? prefix + id2 : id2;
    }
    function chain(obj) {
      var instance = _$1(obj);
      instance._chain = true;
      return instance;
    }
    function executeBound(sourceFunc, boundFunc, context2, callingContext, args) {
      if (!(callingContext instanceof boundFunc))
        return sourceFunc.apply(context2, args);
      var self2 = baseCreate(sourceFunc.prototype);
      var result2 = sourceFunc.apply(self2, args);
      if (isObject$1(result2))
        return result2;
      return self2;
    }
    var partial = restArguments(function(func, boundArgs) {
      var placeholder = partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i2 = 0; i2 < length; i2++) {
          args[i2] = boundArgs[i2] === placeholder ? arguments[position++] : boundArgs[i2];
        }
        while (position < arguments.length)
          args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });
    partial.placeholder = _$1;
    const bind = restArguments(function(func, context2, args) {
      if (!isFunction$2(func))
        throw new TypeError("Bind must be called on a function");
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context2, this, args.concat(callArgs));
      });
      return bound;
    });
    const isArrayLike = createSizePropertyCheck(getLength);
    function flatten$1(input, depth, strict, output) {
      output = output || [];
      if (!depth && depth !== 0) {
        depth = Infinity;
      } else if (depth <= 0) {
        return output.concat(input);
      }
      var idx = output.length;
      for (var i2 = 0, length = getLength(input); i2 < length; i2++) {
        var value2 = input[i2];
        if (isArrayLike(value2) && (isArray$1(value2) || isArguments$1(value2))) {
          if (depth > 1) {
            flatten$1(value2, depth - 1, strict, output);
            idx = output.length;
          } else {
            var j = 0, len = value2.length;
            while (j < len)
              output[idx++] = value2[j++];
          }
        } else if (!strict) {
          output[idx++] = value2;
        }
      }
      return output;
    }
    const bindAll = restArguments(function(obj, keys2) {
      keys2 = flatten$1(keys2, false, false);
      var index2 = keys2.length;
      if (index2 < 1)
        throw new Error("bindAll must be passed function names");
      while (index2--) {
        var key = keys2[index2];
        obj[key] = bind(obj[key], obj);
      }
      return obj;
    });
    function memoize(func, hasher) {
      var memoize2 = function(key) {
        var cache2 = memoize2.cache;
        var address = "" + (hasher ? hasher.apply(this, arguments) : key);
        if (!has$1(cache2, address))
          cache2[address] = func.apply(this, arguments);
        return cache2[address];
      };
      memoize2.cache = {};
      return memoize2;
    }
    const delay = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });
    const defer = partial(delay, _$1, 1);
    function throttle(func, wait, options) {
      var timeout, context2, args, result2;
      var previous = 0;
      if (!options)
        options = {};
      var later = function() {
        previous = options.leading === false ? 0 : now$1();
        timeout = null;
        result2 = func.apply(context2, args);
        if (!timeout)
          context2 = args = null;
      };
      var throttled = function() {
        var _now = now$1();
        if (!previous && options.leading === false)
          previous = _now;
        var remaining = wait - (_now - previous);
        context2 = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = _now;
          result2 = func.apply(context2, args);
          if (!timeout)
            context2 = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result2;
      };
      throttled.cancel = function() {
        clearTimeout(timeout);
        previous = 0;
        timeout = context2 = args = null;
      };
      return throttled;
    }
    function debounce(func, wait, immediate) {
      var timeout, previous, args, result2, context2;
      var later = function() {
        var passed = now$1() - previous;
        if (wait > passed) {
          timeout = setTimeout(later, wait - passed);
        } else {
          timeout = null;
          if (!immediate)
            result2 = func.apply(context2, args);
          if (!timeout)
            args = context2 = null;
        }
      };
      var debounced = restArguments(function(_args) {
        context2 = this;
        args = _args;
        previous = now$1();
        if (!timeout) {
          timeout = setTimeout(later, wait);
          if (immediate)
            result2 = func.apply(context2, args);
        }
        return result2;
      });
      debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = args = context2 = null;
      };
      return debounced;
    }
    function wrap(func, wrapper) {
      return partial(wrapper, func);
    }
    function negate(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    }
    function compose() {
      var args = arguments;
      var start = args.length - 1;
      return function() {
        var i2 = start;
        var result2 = args[start].apply(this, arguments);
        while (i2--)
          result2 = args[i2].call(this, result2);
        return result2;
      };
    }
    function after(times2, func) {
      return function() {
        if (--times2 < 1) {
          return func.apply(this, arguments);
        }
      };
    }
    function before(times2, func) {
      var memo;
      return function() {
        if (--times2 > 0) {
          memo = func.apply(this, arguments);
        }
        if (times2 <= 1)
          func = null;
        return memo;
      };
    }
    const once = partial(before, 2);
    function findKey(obj, predicate, context2) {
      predicate = cb(predicate, context2);
      var _keys = keys$1(obj), key;
      for (var i2 = 0, length = _keys.length; i2 < length; i2++) {
        key = _keys[i2];
        if (predicate(obj[key], key, obj))
          return key;
      }
    }
    function createPredicateIndexFinder(dir) {
      return function(array, predicate, context2) {
        predicate = cb(predicate, context2);
        var length = getLength(array);
        var index2 = dir > 0 ? 0 : length - 1;
        for (; index2 >= 0 && index2 < length; index2 += dir) {
          if (predicate(array[index2], index2, array))
            return index2;
        }
        return -1;
      };
    }
    const findIndex = createPredicateIndexFinder(1);
    const findLastIndex = createPredicateIndexFinder(-1);
    function sortedIndex(array, obj, iteratee2, context2) {
      iteratee2 = cb(iteratee2, context2, 1);
      var value2 = iteratee2(obj);
      var low = 0, high = getLength(array);
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (iteratee2(array[mid]) < value2)
          low = mid + 1;
        else
          high = mid;
      }
      return low;
    }
    function createIndexFinder(dir, predicateFind, sortedIndex2) {
      return function(array, item, idx) {
        var i2 = 0, length = getLength(array);
        if (typeof idx == "number") {
          if (dir > 0) {
            i2 = idx >= 0 ? idx : Math.max(idx + length, i2);
          } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
          }
        } else if (sortedIndex2 && idx && length) {
          idx = sortedIndex2(array, item);
          return array[idx] === item ? idx : -1;
        }
        if (item !== item) {
          idx = predicateFind(slice.call(array, i2, length), isNaN$1);
          return idx >= 0 ? idx + i2 : -1;
        }
        for (idx = dir > 0 ? i2 : length - 1; idx >= 0 && idx < length; idx += dir) {
          if (array[idx] === item)
            return idx;
        }
        return -1;
      };
    }
    const indexOf$1 = createIndexFinder(1, findIndex, sortedIndex);
    const lastIndexOf = createIndexFinder(-1, findLastIndex);
    function find(obj, predicate, context2) {
      var keyFinder = isArrayLike(obj) ? findIndex : findKey;
      var key = keyFinder(obj, predicate, context2);
      if (key !== void 0 && key !== -1)
        return obj[key];
    }
    function findWhere(obj, attrs) {
      return find(obj, matcher(attrs));
    }
    function each(obj, iteratee2, context2) {
      iteratee2 = optimizeCb(iteratee2, context2);
      var i2, length;
      if (isArrayLike(obj)) {
        for (i2 = 0, length = obj.length; i2 < length; i2++) {
          iteratee2(obj[i2], i2, obj);
        }
      } else {
        var _keys = keys$1(obj);
        for (i2 = 0, length = _keys.length; i2 < length; i2++) {
          iteratee2(obj[_keys[i2]], _keys[i2], obj);
        }
      }
      return obj;
    }
    function map$1(obj, iteratee2, context2) {
      iteratee2 = cb(iteratee2, context2);
      var _keys = !isArrayLike(obj) && keys$1(obj), length = (_keys || obj).length, results = Array(length);
      for (var index2 = 0; index2 < length; index2++) {
        var currentKey = _keys ? _keys[index2] : index2;
        results[index2] = iteratee2(obj[currentKey], currentKey, obj);
      }
      return results;
    }
    function createReduce(dir) {
      var reducer = function(obj, iteratee2, memo, initial2) {
        var _keys = !isArrayLike(obj) && keys$1(obj), length = (_keys || obj).length, index2 = dir > 0 ? 0 : length - 1;
        if (!initial2) {
          memo = obj[_keys ? _keys[index2] : index2];
          index2 += dir;
        }
        for (; index2 >= 0 && index2 < length; index2 += dir) {
          var currentKey = _keys ? _keys[index2] : index2;
          memo = iteratee2(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
      };
      return function(obj, iteratee2, memo, context2) {
        var initial2 = arguments.length >= 3;
        return reducer(obj, optimizeCb(iteratee2, context2, 4), memo, initial2);
      };
    }
    const reduce = createReduce(1);
    const reduceRight = createReduce(-1);
    function filter(obj, predicate, context2) {
      var results = [];
      predicate = cb(predicate, context2);
      each(obj, function(value2, index2, list) {
        if (predicate(value2, index2, list))
          results.push(value2);
      });
      return results;
    }
    function reject(obj, predicate, context2) {
      return filter(obj, negate(cb(predicate)), context2);
    }
    function every(obj, predicate, context2) {
      predicate = cb(predicate, context2);
      var _keys = !isArrayLike(obj) && keys$1(obj), length = (_keys || obj).length;
      for (var index2 = 0; index2 < length; index2++) {
        var currentKey = _keys ? _keys[index2] : index2;
        if (!predicate(obj[currentKey], currentKey, obj))
          return false;
      }
      return true;
    }
    function some$1(obj, predicate, context2) {
      predicate = cb(predicate, context2);
      var _keys = !isArrayLike(obj) && keys$1(obj), length = (_keys || obj).length;
      for (var index2 = 0; index2 < length; index2++) {
        var currentKey = _keys ? _keys[index2] : index2;
        if (predicate(obj[currentKey], currentKey, obj))
          return true;
      }
      return false;
    }
    function contains(obj, item, fromIndex, guard) {
      if (!isArrayLike(obj))
        obj = values(obj);
      if (typeof fromIndex != "number" || guard)
        fromIndex = 0;
      return indexOf$1(obj, item, fromIndex) >= 0;
    }
    const invoke = restArguments(function(obj, path, args) {
      var contextPath, func;
      if (isFunction$2(path)) {
        func = path;
      } else {
        path = toPath(path);
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
      }
      return map$1(obj, function(context2) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context2 = deepGet(context2, contextPath);
          }
          if (context2 == null)
            return void 0;
          method = context2[path];
        }
        return method == null ? method : method.apply(context2, args);
      });
    });
    function pluck(obj, key) {
      return map$1(obj, property(key));
    }
    function where(obj, attrs) {
      return filter(obj, matcher(attrs));
    }
    function max$1(obj, iteratee2, context2) {
      var result2 = -Infinity, lastComputed = -Infinity, value2, computed;
      if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
        obj = isArrayLike(obj) ? obj : values(obj);
        for (var i2 = 0, length = obj.length; i2 < length; i2++) {
          value2 = obj[i2];
          if (value2 != null && value2 > result2) {
            result2 = value2;
          }
        }
      } else {
        iteratee2 = cb(iteratee2, context2);
        each(obj, function(v2, index2, list) {
          computed = iteratee2(v2, index2, list);
          if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
            result2 = v2;
            lastComputed = computed;
          }
        });
      }
      return result2;
    }
    function min$1(obj, iteratee2, context2) {
      var result2 = Infinity, lastComputed = Infinity, value2, computed;
      if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
        obj = isArrayLike(obj) ? obj : values(obj);
        for (var i2 = 0, length = obj.length; i2 < length; i2++) {
          value2 = obj[i2];
          if (value2 != null && value2 < result2) {
            result2 = value2;
          }
        }
      } else {
        iteratee2 = cb(iteratee2, context2);
        each(obj, function(v2, index2, list) {
          computed = iteratee2(v2, index2, list);
          if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
            result2 = v2;
            lastComputed = computed;
          }
        });
      }
      return result2;
    }
    var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
    function toArray$2(obj) {
      if (!obj)
        return [];
      if (isArray$1(obj))
        return slice.call(obj);
      if (isString$1(obj)) {
        return obj.match(reStrSymbol);
      }
      if (isArrayLike(obj))
        return map$1(obj, identity);
      return values(obj);
    }
    function sample(obj, n2, guard) {
      if (n2 == null || guard) {
        if (!isArrayLike(obj))
          obj = values(obj);
        return obj[random(obj.length - 1)];
      }
      var sample2 = toArray$2(obj);
      var length = getLength(sample2);
      n2 = Math.max(Math.min(n2, length), 0);
      var last2 = length - 1;
      for (var index2 = 0; index2 < n2; index2++) {
        var rand = random(index2, last2);
        var temp2 = sample2[index2];
        sample2[index2] = sample2[rand];
        sample2[rand] = temp2;
      }
      return sample2.slice(0, n2);
    }
    function shuffle(obj) {
      return sample(obj, Infinity);
    }
    function sortBy(obj, iteratee2, context2) {
      var index2 = 0;
      iteratee2 = cb(iteratee2, context2);
      return pluck(map$1(obj, function(value2, key, list) {
        return {
          value: value2,
          index: index2++,
          criteria: iteratee2(value2, key, list)
        };
      }).sort(function(left, right) {
        var a2 = left.criteria;
        var b = right.criteria;
        if (a2 !== b) {
          if (a2 > b || a2 === void 0)
            return 1;
          if (a2 < b || b === void 0)
            return -1;
        }
        return left.index - right.index;
      }), "value");
    }
    function group(behavior, partition2) {
      return function(obj, iteratee2, context2) {
        var result2 = partition2 ? [[], []] : {};
        iteratee2 = cb(iteratee2, context2);
        each(obj, function(value2, index2) {
          var key = iteratee2(value2, index2, obj);
          behavior(result2, value2, key);
        });
        return result2;
      };
    }
    const groupBy = group(function(result2, value2, key) {
      if (has$1(result2, key))
        result2[key].push(value2);
      else
        result2[key] = [value2];
    });
    const indexBy = group(function(result2, value2, key) {
      result2[key] = value2;
    });
    const countBy = group(function(result2, value2, key) {
      if (has$1(result2, key))
        result2[key]++;
      else
        result2[key] = 1;
    });
    const partition = group(function(result2, value2, pass) {
      result2[pass ? 0 : 1].push(value2);
    }, true);
    function size(obj) {
      if (obj == null)
        return 0;
      return isArrayLike(obj) ? obj.length : keys$1(obj).length;
    }
    function keyInObj(value2, key, obj) {
      return key in obj;
    }
    const pick = restArguments(function(obj, keys2) {
      var result2 = {}, iteratee2 = keys2[0];
      if (obj == null)
        return result2;
      if (isFunction$2(iteratee2)) {
        if (keys2.length > 1)
          iteratee2 = optimizeCb(iteratee2, keys2[1]);
        keys2 = allKeys(obj);
      } else {
        iteratee2 = keyInObj;
        keys2 = flatten$1(keys2, false, false);
        obj = Object(obj);
      }
      for (var i2 = 0, length = keys2.length; i2 < length; i2++) {
        var key = keys2[i2];
        var value2 = obj[key];
        if (iteratee2(value2, key, obj))
          result2[key] = value2;
      }
      return result2;
    });
    const omit = restArguments(function(obj, keys2) {
      var iteratee2 = keys2[0], context2;
      if (isFunction$2(iteratee2)) {
        iteratee2 = negate(iteratee2);
        if (keys2.length > 1)
          context2 = keys2[1];
      } else {
        keys2 = map$1(flatten$1(keys2, false, false), String);
        iteratee2 = function(value2, key) {
          return !contains(keys2, key);
        };
      }
      return pick(obj, iteratee2, context2);
    });
    function initial(array, n2, guard) {
      return slice.call(array, 0, Math.max(0, array.length - (n2 == null || guard ? 1 : n2)));
    }
    function first(array, n2, guard) {
      if (array == null || array.length < 1)
        return n2 == null || guard ? void 0 : [];
      if (n2 == null || guard)
        return array[0];
      return initial(array, array.length - n2);
    }
    function rest(array, n2, guard) {
      return slice.call(array, n2 == null || guard ? 1 : n2);
    }
    function last(array, n2, guard) {
      if (array == null || array.length < 1)
        return n2 == null || guard ? void 0 : [];
      if (n2 == null || guard)
        return array[array.length - 1];
      return rest(array, Math.max(0, array.length - n2));
    }
    function compact(array) {
      return filter(array, Boolean);
    }
    function flatten(array, depth) {
      return flatten$1(array, depth, false);
    }
    const difference = restArguments(function(array, rest2) {
      rest2 = flatten$1(rest2, true, true);
      return filter(array, function(value2) {
        return !contains(rest2, value2);
      });
    });
    const without = restArguments(function(array, otherArrays) {
      return difference(array, otherArrays);
    });
    function uniq(array, isSorted, iteratee2, context2) {
      if (!isBoolean(isSorted)) {
        context2 = iteratee2;
        iteratee2 = isSorted;
        isSorted = false;
      }
      if (iteratee2 != null)
        iteratee2 = cb(iteratee2, context2);
      var result2 = [];
      var seen = [];
      for (var i2 = 0, length = getLength(array); i2 < length; i2++) {
        var value2 = array[i2], computed = iteratee2 ? iteratee2(value2, i2, array) : value2;
        if (isSorted && !iteratee2) {
          if (!i2 || seen !== computed)
            result2.push(value2);
          seen = computed;
        } else if (iteratee2) {
          if (!contains(seen, computed)) {
            seen.push(computed);
            result2.push(value2);
          }
        } else if (!contains(result2, value2)) {
          result2.push(value2);
        }
      }
      return result2;
    }
    const union = restArguments(function(arrays) {
      return uniq(flatten$1(arrays, true, true));
    });
    function intersection(array) {
      var result2 = [];
      var argsLength = arguments.length;
      for (var i2 = 0, length = getLength(array); i2 < length; i2++) {
        var item = array[i2];
        if (contains(result2, item))
          continue;
        var j;
        for (j = 1; j < argsLength; j++) {
          if (!contains(arguments[j], item))
            break;
        }
        if (j === argsLength)
          result2.push(item);
      }
      return result2;
    }
    function unzip(array) {
      var length = array && max$1(array, getLength).length || 0;
      var result2 = Array(length);
      for (var index2 = 0; index2 < length; index2++) {
        result2[index2] = pluck(array, index2);
      }
      return result2;
    }
    const zip = restArguments(unzip);
    function object(list, values2) {
      var result2 = {};
      for (var i2 = 0, length = getLength(list); i2 < length; i2++) {
        if (values2) {
          result2[list[i2]] = values2[i2];
        } else {
          result2[list[i2][0]] = list[i2][1];
        }
      }
      return result2;
    }
    function range(start, stop, step) {
      if (stop == null) {
        stop = start || 0;
        start = 0;
      }
      if (!step) {
        step = stop < start ? -1 : 1;
      }
      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var range2 = Array(length);
      for (var idx = 0; idx < length; idx++, start += step) {
        range2[idx] = start;
      }
      return range2;
    }
    function chunk(array, count) {
      if (count == null || count < 1)
        return [];
      var result2 = [];
      var i2 = 0, length = array.length;
      while (i2 < length) {
        result2.push(slice.call(array, i2, i2 += count));
      }
      return result2;
    }
    function chainResult(instance, obj) {
      return instance._chain ? _$1(obj).chain() : obj;
    }
    function mixin(obj) {
      each(functions(obj), function(name) {
        var func = _$1[name] = obj[name];
        _$1.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return chainResult(this, func.apply(_$1, args));
        };
      });
      return _$1;
    }
    each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
      var method = ArrayProto[name];
      _$1.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) {
          method.apply(obj, arguments);
          if ((name === "shift" || name === "splice") && obj.length === 0) {
            delete obj[0];
          }
        }
        return chainResult(this, obj);
      };
    });
    each(["concat", "join", "slice"], function(name) {
      var method = ArrayProto[name];
      _$1.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null)
          obj = method.apply(obj, arguments);
        return chainResult(this, obj);
      };
    });
    const allExports = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      VERSION,
      restArguments,
      isObject: isObject$1,
      isNull,
      isUndefined: isUndefined$1,
      isBoolean,
      isElement,
      isString: isString$1,
      isNumber: isNumber$1,
      isDate: isDate$1,
      isRegExp,
      isError,
      isSymbol,
      isArrayBuffer,
      isDataView: isDataView$1,
      isArray: isArray$1,
      isFunction: isFunction$2,
      isArguments: isArguments$1,
      isFinite: isFinite$1,
      isNaN: isNaN$1,
      isTypedArray: isTypedArray$1,
      isEmpty,
      isMatch,
      isEqual,
      isMap,
      isWeakMap,
      isSet,
      isWeakSet,
      keys: keys$1,
      allKeys,
      values,
      pairs,
      invert,
      functions,
      methods: functions,
      extend: extend$1,
      extendOwn,
      assign: extendOwn,
      defaults: defaults$1,
      create,
      clone: clone$2,
      tap,
      get: get$3,
      has,
      mapObject,
      identity,
      constant,
      noop,
      toPath: toPath$1,
      property,
      propertyOf,
      matcher,
      matches: matcher,
      times,
      random,
      now: now$1,
      escape: escape$1,
      unescape: unescape$1,
      templateSettings,
      template,
      result,
      uniqueId,
      chain,
      iteratee,
      partial,
      bind,
      bindAll,
      memoize,
      delay,
      defer,
      throttle,
      debounce,
      wrap,
      negate,
      compose,
      after,
      before,
      once,
      findKey,
      findIndex,
      findLastIndex,
      sortedIndex,
      indexOf: indexOf$1,
      lastIndexOf,
      find,
      detect: find,
      findWhere,
      each,
      forEach: each,
      map: map$1,
      collect: map$1,
      reduce,
      foldl: reduce,
      inject: reduce,
      reduceRight,
      foldr: reduceRight,
      filter,
      select: filter,
      reject,
      every,
      all: every,
      some: some$1,
      any: some$1,
      contains,
      includes: contains,
      include: contains,
      invoke,
      pluck,
      where,
      max: max$1,
      min: min$1,
      shuffle,
      sample,
      sortBy,
      groupBy,
      indexBy,
      countBy,
      partition,
      toArray: toArray$2,
      size,
      pick,
      omit,
      first,
      head: first,
      take: first,
      initial,
      last,
      rest,
      tail: rest,
      drop: rest,
      compact,
      flatten,
      without,
      uniq,
      unique: uniq,
      union,
      intersection,
      difference,
      unzip,
      transpose: unzip,
      zip,
      object,
      range,
      chunk,
      mixin,
      default: _$1
    }, Symbol.toStringTag, { value: "Module" }));
    var _ = mixin(allExports);
    _._ = _;
    class WordList {
      constructor() {
        __publicField(this, "text");
        __publicField(this, "list");
        __publicField(this, "counter", 0);
        __publicField(this, "load", async () => {
          let res = await axios$1.get(window.location.href + "/data/test.txt");
          let text = res.data;
          this.text = text;
          this.split();
          return this.list;
        });
        __publicField(this, "split", () => {
          let words2 = this.text.split(/[\s,.()\/\\=?<>`!"#%&\[\]_:;\*'^~\-\+{}|]/gm).filter((w2) => w2.length > 0).map((w2) => w2.toLowerCase().trim());
          console.log("Words is", words2);
          let list = [
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            []
          ];
          words2.forEach((word) => {
            switch (true) {
              case word.startsWith("a"):
                list[0].push(word);
                break;
              case word.startsWith("b"):
                list[1].push(word);
                break;
              case word.startsWith("c"):
                list[2].push(word);
                break;
              case word.startsWith("d"):
                list[3].push(word);
                break;
              case word.startsWith("e"):
                list[4].push(word);
                break;
              case word.startsWith("f"):
                list[5].push(word);
                break;
              case word.startsWith("g"):
                list[6].push(word);
                break;
              case word.startsWith("h"):
                list[7].push(word);
                break;
              case word.startsWith("i"):
                list[8].push(word);
                break;
              case word.startsWith("j"):
                list[9].push(word);
                break;
              case word.startsWith("k"):
                list[10].push(word);
                break;
              case word.startsWith("l"):
                list[11].push(word);
                break;
              case word.startsWith("m"):
                list[12].push(word);
                break;
              case word.startsWith("n"):
                list[13].push(word);
                break;
              case word.startsWith("o"):
                list[14].push(word);
                break;
              case word.startsWith("p"):
                list[15].push(word);
                break;
              case word.startsWith("q"):
                list[16].push(word);
                break;
              case word.startsWith("r"):
                list[17].push(word);
                break;
              case word.startsWith("s"):
                list[18].push(word);
                break;
              case word.startsWith("t"):
                list[19].push(word);
                break;
              case word.startsWith("u"):
                list[20].push(word);
                break;
              case word.startsWith("v"):
                list[21].push(word);
                break;
              case word.startsWith("w"):
                list[22].push(word);
                break;
              case word.startsWith("x"):
                list[23].push(word);
                break;
              case word.startsWith("y"):
                list[24].push(word);
                break;
              case word.startsWith("z"):
                list[25].push(word);
                break;
            }
          });
          this.list = list;
          console.log(this.list);
        });
        __publicField(this, "setOrdered", (to2) => {
          this.orderedMode = to2;
        });
        __publicField(this, "next", () => {
          if (this.counter >= this.list.length - 1) {
            this.counter = 0;
          }
          let wordGroup = this.list[this.counter];
          let word = _.sample(wordGroup);
          this.counter++;
          return word;
        });
      }
    }
    const sleep = (ms) => {
      return new Promise((resolve) => setTimeout(resolve, ms));
    };
    const abbreviateNumber = (value2) => {
      let newValue = value2;
      if (value2 < 1e3) {
        return value2;
      }
      const suffixes = ["", "k", "m", "b", "t"];
      const suffixNum = Math.floor(("" + value2).length / 3);
      let shortValue = "";
      for (var precision = 2; precision >= 1; precision--) {
        shortValue = parseFloat((suffixNum != 0 ? value2 / Math.pow(1e3, suffixNum) : value2).toPrecision(precision));
        var dotLessShortValue = (shortValue + "").replace(/[^a-zA-Z 0-9]+/g, "");
        if (dotLessShortValue.length <= 2) {
          break;
        }
      }
      if (shortValue % 1 != 0)
        shortValue = shortValue.toFixed(1);
      newValue = shortValue + suffixes[suffixNum];
      return newValue;
    };
    const truncate = (str, length) => {
      return str.length > length ? str.substr(0, length - 1) + "..." : str;
    };
    const MIN_VELOCITY = 0.475;
    const MAX_VELOCITY = 4;
    const DIFF_PER_WAVE = 0.025;
    class Velocity {
      constructor() {
        __publicField(this, "maxVelocity", MAX_VELOCITY);
        __publicField(this, "minVelocity", MIN_VELOCITY);
        __publicField(this, "velocity", MIN_VELOCITY);
        __publicField(this, "wave", 0);
        __publicField(this, "calculate", (wave) => {
          if (this._hasReachedMaximumVelocity()) {
            return this.maxVelocity;
          }
          if (this.wave != wave) {
            this.velocity += DIFF_PER_WAVE;
            this.wave = wave;
          }
          console.log(this.velocity);
          return this.velocity;
        });
        __publicField(this, "_hasReachedMaximumVelocity", () => {
          return this.velocity >= this.maxVelocity;
        });
      }
    }
    let app$1;
    let width;
    let height;
    let player;
    let dead = false;
    let words = [];
    let entities = [];
    let paused = false;
    let restarted = false;
    let waveStart = 0;
    let waveEnd = 0;
    let enemiesKilled = 0;
    let shotsFired = 0;
    let shotsMissed = 0;
    let velocity = new Velocity();
    const spawnEnemies = async (amount, wave) => {
      for (let i2 = 1; i2 <= amount; i2++) {
        let newWord = words.next();
        while (!newWord) {
          newWord = words.next();
        }
        Game.add(new Enemy(newWord, player, wave, velocity));
        if (i2 % 3 === 0) {
          await sleep(1e3);
        }
      }
    };
    const initEvents = () => {
      if (restarted) {
        return;
      }
      console.log("Setting up events");
      window.addEventListener("keydown", (e) => {
        if (paused) {
          return;
        }
        entities.forEach((entity) => {
          entity.onEvent("keydown", e);
        });
      });
      events.on("enemyDeath", () => {
        enemiesKilled++;
      });
      events.on("enemyTargeted", (enemy) => {
        Game.remove(enemy);
        Game.add(enemy);
      });
      events.on("shotFired", (missed) => {
        if (missed) {
          shotsMissed++;
        }
        shotsFired++;
      });
      events.on("playerDeath", () => {
        if (dead) {
          return;
        }
        dead = true;
        waveEnd = Date.now();
        events.emit("gameOver", {
          waveStart,
          waveEnd,
          enemiesKilled,
          shotsFired,
          shotsMissed
        });
      });
    };
    const animate$1 = (delta) => {
      if (dead) {
        app$1.ticker.stop();
        return;
      }
      entities.forEach((entity) => {
        entity.onUpdate(delta);
      });
      entities.forEach((entity) => {
        entity.draw(delta);
      });
      if (!Game.find("enemy").length) {
        waveEnd = Date.now();
        events.emit("waveEnd", {
          waveStart,
          waveEnd,
          enemiesKilled,
          shotsFired,
          shotsMissed
        });
        app$1.ticker.stop();
        return;
      }
    };
    const Game = {
      start: async (playerName) => {
        app$1 = new Application({
          width: 500,
          height: 800,
          antialias: true,
          autoResize: true,
          backgroundColor: 1777702,
          resolution: window.devicePixelRatio
        });
        document.body.querySelector(".grid").appendChild(app$1.view);
        width = app$1.screen.width;
        height = app$1.screen.height;
        words = new WordList();
        await words.load();
        player = new Player(playerName, width / 2, height - 60);
        Game.add(player);
        initEvents();
        app$1.ticker.stop();
        app$1.ticker.add(animate$1);
      },
      nextWave: (number) => {
        waveStart = Date.now();
        shotsFired = 0;
        shotsMissed = 0;
        enemiesKilled = 0;
        let enemies = 3;
        let multiplier = 3;
        let roundsMultiplier = 4;
        spawnEnemies(enemies + Math.ceil(number / roundsMultiplier) * multiplier, number);
        app$1.ticker.start();
      },
      add: (entity) => {
        entities.push(entity);
        app$1.stage.addChild(entity.container);
      },
      find: (tag) => {
        return entities.filter((a2) => a2.tag === tag);
      },
      remove: (entity) => {
        app$1.stage.removeChild(entity.container);
        const index2 = entities.indexOf(entity);
        if (index2 > -1) {
          entities.splice(index2, 1);
        }
      },
      pause: (status) => {
        paused = status;
        if (paused) {
          app$1.ticker.stop();
        } else {
          app$1.ticker.start();
        }
      },
      reset: () => {
        restarted = true;
        paused = false;
        shotsFired = 0;
        shotsMissed = 0;
        enemiesKilled = 0;
        dead = false;
        app$1.ticker.destroy();
        words = [];
        entities = [];
        player = null;
      }
    };
    const Game$1 = Game;
    class Background extends react.exports.Component {
      constructor(props) {
        super(props);
      }
      render() {
        const { hidden } = this.props;
        const classes = "background" + (hidden ? " hidden" : "");
        return /* @__PURE__ */ jsxs("div", { className: classes, children: [
          /* @__PURE__ */ jsx("svg", { className: "front", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1440 320", children: /* @__PURE__ */ jsx("path", { fill: "#0099ff", fillOpacity: "1", d: "M0,128L34.3,112C68.6,96,137,64,206,58.7C274.3,53,343,75,411,112C480,149,549,203,617,224C685.7,245,754,235,823,224C891.4,213,960,203,1029,218.7C1097.1,235,1166,277,1234,277.3C1302.9,277,1371,235,1406,213.3L1440,192L1440,320L1405.7,320C1371.4,320,1303,320,1234,320C1165.7,320,1097,320,1029,320C960,320,891,320,823,320C754.3,320,686,320,617,320C548.6,320,480,320,411,320C342.9,320,274,320,206,320C137.1,320,69,320,34,320L0,320Z" }) }),
          /* @__PURE__ */ jsx("div", { className: "front filler" }),
          /* @__PURE__ */ jsx("svg", { className: "back", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1440 320", children: /* @__PURE__ */ jsx("path", { fill: "#0099ff", fillOpacity: "0.6", d: "M0,256L34.3,213.3C68.6,171,137,85,206,58.7C274.3,32,343,64,411,101.3C480,139,549,181,617,213.3C685.7,245,754,267,823,272C891.4,277,960,267,1029,224C1097.1,181,1166,107,1234,96C1302.9,85,1371,139,1406,165.3L1440,192L1440,320L1405.7,320C1371.4,320,1303,320,1234,320C1165.7,320,1097,320,1029,320C960,320,891,320,823,320C754.3,320,686,320,617,320C548.6,320,480,320,411,320C342.9,320,274,320,206,320C137.1,320,69,320,34,320L0,320Z" }) }),
          /* @__PURE__ */ jsx("div", { className: "back filler" }),
          /* @__PURE__ */ jsx("svg", { className: "bumpy", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1440 320", children: /* @__PURE__ */ jsx("path", { fill: "#0099ff", fillOpacity: "0.2", d: "M0,192L34.3,181.3C68.6,171,137,149,206,149.3C274.3,149,343,171,411,160C480,149,549,107,617,90.7C685.7,75,754,85,823,90.7C891.4,96,960,96,1029,112C1097.1,128,1166,160,1234,149.3C1302.9,139,1371,85,1406,58.7L1440,32L1440,320L1405.7,320C1371.4,320,1303,320,1234,320C1165.7,320,1097,320,1029,320C960,320,891,320,823,320C754.3,320,686,320,617,320C548.6,320,480,320,411,320C342.9,320,274,320,206,320C137.1,320,69,320,34,320L0,320Z" }) }),
          /* @__PURE__ */ jsx("div", { className: "bumpy filler" })
        ] });
      }
    }
    class Button extends react.exports.Component {
      constructor(props) {
        super(props);
        __publicField(this, "_handleKeyDown", (e) => {
          let key = e.key;
          let hint = this.props.hint;
          if (!hint) {
            return;
          }
          if (hint.toLowerCase() === "ret") {
            hint = "Enter";
          }
          if (hint.toLowerCase() === "esc") {
            hint = "Escape";
          }
          if (key.toLowerCase() !== hint.toLowerCase()) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
          this.props.onClick();
        });
      }
      componentDidMount() {
        document.addEventListener("keydown", this._handleKeyDown, false);
      }
      componentWillUnmount() {
        document.removeEventListener("keydown", this._handleKeyDown, false);
      }
      render() {
        const { hint, text, onClick, mini, disabled, danger } = this.props;
        let classes = !hint ? "rounded" : "";
        let containerClasses = "buttonContainer" + (danger ? " danger" : "") + (mini ? " sub" : "") + (disabled ? " disabled" : "");
        let click = disabled ? () => {
        } : onClick;
        return /* @__PURE__ */ jsxs("div", { className: containerClasses, children: [
          /* @__PURE__ */ jsx("div", { className: classes, onClick: click, children: text }),
          hint && /* @__PURE__ */ jsx("div", { className: "shortcutHint", children: hint })
        ] });
      }
    }
    var defaultInstanceSettings = {
      update: null,
      begin: null,
      loopBegin: null,
      changeBegin: null,
      change: null,
      changeComplete: null,
      loopComplete: null,
      complete: null,
      loop: 1,
      direction: "normal",
      autoplay: true,
      timelineOffset: 0
    };
    var defaultTweenSettings = {
      duration: 1e3,
      delay: 0,
      endDelay: 0,
      easing: "easeOutElastic(1, .5)",
      round: 0
    };
    var validTransforms = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective", "matrix", "matrix3d"];
    var cache = {
      CSS: {},
      springs: {}
    };
    function minMax(val, min2, max2) {
      return Math.min(Math.max(val, min2), max2);
    }
    function stringContains(str, text) {
      return str.indexOf(text) > -1;
    }
    function applyArguments(func, args) {
      return func.apply(null, args);
    }
    var is = {
      arr: function(a2) {
        return Array.isArray(a2);
      },
      obj: function(a2) {
        return stringContains(Object.prototype.toString.call(a2), "Object");
      },
      pth: function(a2) {
        return is.obj(a2) && a2.hasOwnProperty("totalLength");
      },
      svg: function(a2) {
        return a2 instanceof SVGElement;
      },
      inp: function(a2) {
        return a2 instanceof HTMLInputElement;
      },
      dom: function(a2) {
        return a2.nodeType || is.svg(a2);
      },
      str: function(a2) {
        return typeof a2 === "string";
      },
      fnc: function(a2) {
        return typeof a2 === "function";
      },
      und: function(a2) {
        return typeof a2 === "undefined";
      },
      nil: function(a2) {
        return is.und(a2) || a2 === null;
      },
      hex: function(a2) {
        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a2);
      },
      rgb: function(a2) {
        return /^rgb/.test(a2);
      },
      hsl: function(a2) {
        return /^hsl/.test(a2);
      },
      col: function(a2) {
        return is.hex(a2) || is.rgb(a2) || is.hsl(a2);
      },
      key: function(a2) {
        return !defaultInstanceSettings.hasOwnProperty(a2) && !defaultTweenSettings.hasOwnProperty(a2) && a2 !== "targets" && a2 !== "keyframes";
      }
    };
    function parseEasingParameters(string) {
      var match = /\(([^)]+)\)/.exec(string);
      return match ? match[1].split(",").map(function(p2) {
        return parseFloat(p2);
      }) : [];
    }
    function spring(string, duration) {
      var params = parseEasingParameters(string);
      var mass = minMax(is.und(params[0]) ? 1 : params[0], 0.1, 100);
      var stiffness = minMax(is.und(params[1]) ? 100 : params[1], 0.1, 100);
      var damping = minMax(is.und(params[2]) ? 10 : params[2], 0.1, 100);
      var velocity2 = minMax(is.und(params[3]) ? 0 : params[3], 0.1, 100);
      var w0 = Math.sqrt(stiffness / mass);
      var zeta = damping / (2 * Math.sqrt(stiffness * mass));
      var wd2 = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
      var a2 = 1;
      var b = zeta < 1 ? (zeta * w0 + -velocity2) / wd2 : -velocity2 + w0;
      function solver(t2) {
        var progress = duration ? duration * t2 / 1e3 : t2;
        if (zeta < 1) {
          progress = Math.exp(-progress * zeta * w0) * (a2 * Math.cos(wd2 * progress) + b * Math.sin(wd2 * progress));
        } else {
          progress = (a2 + b * progress) * Math.exp(-progress * w0);
        }
        if (t2 === 0 || t2 === 1) {
          return t2;
        }
        return 1 - progress;
      }
      function getDuration() {
        var cached = cache.springs[string];
        if (cached) {
          return cached;
        }
        var frame = 1 / 6;
        var elapsed = 0;
        var rest2 = 0;
        while (true) {
          elapsed += frame;
          if (solver(elapsed) === 1) {
            rest2++;
            if (rest2 >= 16) {
              break;
            }
          } else {
            rest2 = 0;
          }
        }
        var duration2 = elapsed * frame * 1e3;
        cache.springs[string] = duration2;
        return duration2;
      }
      return duration ? solver : getDuration;
    }
    function steps(steps2) {
      if (steps2 === void 0)
        steps2 = 10;
      return function(t2) {
        return Math.ceil(minMax(t2, 1e-6, 1) * steps2) * (1 / steps2);
      };
    }
    var bezier = function() {
      var kSplineTableSize = 11;
      var kSampleStepSize = 1 / (kSplineTableSize - 1);
      function A2(aA1, aA2) {
        return 1 - 3 * aA2 + 3 * aA1;
      }
      function B2(aA1, aA2) {
        return 3 * aA2 - 6 * aA1;
      }
      function C2(aA1) {
        return 3 * aA1;
      }
      function calcBezier(aT, aA1, aA2) {
        return ((A2(aA1, aA2) * aT + B2(aA1, aA2)) * aT + C2(aA1)) * aT;
      }
      function getSlope(aT, aA1, aA2) {
        return 3 * A2(aA1, aA2) * aT * aT + 2 * B2(aA1, aA2) * aT + C2(aA1);
      }
      function binarySubdivide(aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i2 = 0;
        do {
          currentT = aA + (aB - aA) / 2;
          currentX = calcBezier(currentT, mX1, mX2) - aX;
          if (currentX > 0) {
            aB = currentT;
          } else {
            aA = currentT;
          }
        } while (Math.abs(currentX) > 1e-7 && ++i2 < 10);
        return currentT;
      }
      function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        for (var i2 = 0; i2 < 4; ++i2) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);
          if (currentSlope === 0) {
            return aGuessT;
          }
          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
      }
      function bezier2(mX1, mY1, mX2, mY2) {
        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
          return;
        }
        var sampleValues = new Float32Array(kSplineTableSize);
        if (mX1 !== mY1 || mX2 !== mY2) {
          for (var i2 = 0; i2 < kSplineTableSize; ++i2) {
            sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
          }
        }
        function getTForX(aX) {
          var intervalStart = 0;
          var currentSample = 1;
          var lastSample = kSplineTableSize - 1;
          for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }
          --currentSample;
          var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
          var guessForT = intervalStart + dist * kSampleStepSize;
          var initialSlope = getSlope(guessForT, mX1, mX2);
          if (initialSlope >= 1e-3) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
          } else if (initialSlope === 0) {
            return guessForT;
          } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }
        }
        return function(x2) {
          if (mX1 === mY1 && mX2 === mY2) {
            return x2;
          }
          if (x2 === 0 || x2 === 1) {
            return x2;
          }
          return calcBezier(getTForX(x2), mY1, mY2);
        };
      }
      return bezier2;
    }();
    var penner = function() {
      var eases = { linear: function() {
        return function(t2) {
          return t2;
        };
      } };
      var functionEasings = {
        Sine: function() {
          return function(t2) {
            return 1 - Math.cos(t2 * Math.PI / 2);
          };
        },
        Circ: function() {
          return function(t2) {
            return 1 - Math.sqrt(1 - t2 * t2);
          };
        },
        Back: function() {
          return function(t2) {
            return t2 * t2 * (3 * t2 - 2);
          };
        },
        Bounce: function() {
          return function(t2) {
            var pow2, b = 4;
            while (t2 < ((pow2 = Math.pow(2, --b)) - 1) / 11) {
            }
            return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t2, 2);
          };
        },
        Elastic: function(amplitude, period) {
          if (amplitude === void 0)
            amplitude = 1;
          if (period === void 0)
            period = 0.5;
          var a2 = minMax(amplitude, 1, 10);
          var p2 = minMax(period, 0.1, 2);
          return function(t2) {
            return t2 === 0 || t2 === 1 ? t2 : -a2 * Math.pow(2, 10 * (t2 - 1)) * Math.sin((t2 - 1 - p2 / (Math.PI * 2) * Math.asin(1 / a2)) * (Math.PI * 2) / p2);
          };
        }
      };
      var baseEasings = ["Quad", "Cubic", "Quart", "Quint", "Expo"];
      baseEasings.forEach(function(name, i2) {
        functionEasings[name] = function() {
          return function(t2) {
            return Math.pow(t2, i2 + 2);
          };
        };
      });
      Object.keys(functionEasings).forEach(function(name) {
        var easeIn = functionEasings[name];
        eases["easeIn" + name] = easeIn;
        eases["easeOut" + name] = function(a2, b) {
          return function(t2) {
            return 1 - easeIn(a2, b)(1 - t2);
          };
        };
        eases["easeInOut" + name] = function(a2, b) {
          return function(t2) {
            return t2 < 0.5 ? easeIn(a2, b)(t2 * 2) / 2 : 1 - easeIn(a2, b)(t2 * -2 + 2) / 2;
          };
        };
        eases["easeOutIn" + name] = function(a2, b) {
          return function(t2) {
            return t2 < 0.5 ? (1 - easeIn(a2, b)(1 - t2 * 2)) / 2 : (easeIn(a2, b)(t2 * 2 - 1) + 1) / 2;
          };
        };
      });
      return eases;
    }();
    function parseEasings(easing, duration) {
      if (is.fnc(easing)) {
        return easing;
      }
      var name = easing.split("(")[0];
      var ease = penner[name];
      var args = parseEasingParameters(easing);
      switch (name) {
        case "spring":
          return spring(easing, duration);
        case "cubicBezier":
          return applyArguments(bezier, args);
        case "steps":
          return applyArguments(steps, args);
        default:
          return applyArguments(ease, args);
      }
    }
    function selectString(str) {
      try {
        var nodes = document.querySelectorAll(str);
        return nodes;
      } catch (e) {
        return;
      }
    }
    function filterArray(arr, callback) {
      var len = arr.length;
      var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
      var result2 = [];
      for (var i2 = 0; i2 < len; i2++) {
        if (i2 in arr) {
          var val = arr[i2];
          if (callback.call(thisArg, val, i2, arr)) {
            result2.push(val);
          }
        }
      }
      return result2;
    }
    function flattenArray(arr) {
      return arr.reduce(function(a2, b) {
        return a2.concat(is.arr(b) ? flattenArray(b) : b);
      }, []);
    }
    function toArray$1(o) {
      if (is.arr(o)) {
        return o;
      }
      if (is.str(o)) {
        o = selectString(o) || o;
      }
      if (o instanceof NodeList || o instanceof HTMLCollection) {
        return [].slice.call(o);
      }
      return [o];
    }
    function arrayContains(arr, val) {
      return arr.some(function(a2) {
        return a2 === val;
      });
    }
    function cloneObject(o) {
      var clone2 = {};
      for (var p2 in o) {
        clone2[p2] = o[p2];
      }
      return clone2;
    }
    function replaceObjectProps(o1, o2) {
      var o = cloneObject(o1);
      for (var p2 in o1) {
        o[p2] = o2.hasOwnProperty(p2) ? o2[p2] : o1[p2];
      }
      return o;
    }
    function mergeObjects(o1, o2) {
      var o = cloneObject(o1);
      for (var p2 in o2) {
        o[p2] = is.und(o1[p2]) ? o2[p2] : o1[p2];
      }
      return o;
    }
    function rgbToRgba(rgbValue) {
      var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
      return rgb ? "rgba(" + rgb[1] + ",1)" : rgbValue;
    }
    function hexToRgba(hexValue) {
      var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      var hex = hexValue.replace(rgx, function(m2, r3, g3, b2) {
        return r3 + r3 + g3 + g3 + b2 + b2;
      });
      var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      var r2 = parseInt(rgb[1], 16);
      var g2 = parseInt(rgb[2], 16);
      var b = parseInt(rgb[3], 16);
      return "rgba(" + r2 + "," + g2 + "," + b + ",1)";
    }
    function hslToRgba(hslValue) {
      var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
      var h2 = parseInt(hsl[1], 10) / 360;
      var s2 = parseInt(hsl[2], 10) / 100;
      var l2 = parseInt(hsl[3], 10) / 100;
      var a2 = hsl[4] || 1;
      function hue2rgb(p3, q3, t2) {
        if (t2 < 0) {
          t2 += 1;
        }
        if (t2 > 1) {
          t2 -= 1;
        }
        if (t2 < 1 / 6) {
          return p3 + (q3 - p3) * 6 * t2;
        }
        if (t2 < 1 / 2) {
          return q3;
        }
        if (t2 < 2 / 3) {
          return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
        }
        return p3;
      }
      var r2, g2, b;
      if (s2 == 0) {
        r2 = g2 = b = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var p2 = 2 * l2 - q2;
        r2 = hue2rgb(p2, q2, h2 + 1 / 3);
        g2 = hue2rgb(p2, q2, h2);
        b = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return "rgba(" + r2 * 255 + "," + g2 * 255 + "," + b * 255 + "," + a2 + ")";
    }
    function colorToRgb(val) {
      if (is.rgb(val)) {
        return rgbToRgba(val);
      }
      if (is.hex(val)) {
        return hexToRgba(val);
      }
      if (is.hsl(val)) {
        return hslToRgba(val);
      }
    }
    function getUnit(val) {
      var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
      if (split) {
        return split[1];
      }
    }
    function getTransformUnit(propName) {
      if (stringContains(propName, "translate") || propName === "perspective") {
        return "px";
      }
      if (stringContains(propName, "rotate") || stringContains(propName, "skew")) {
        return "deg";
      }
    }
    function getFunctionValue(val, animatable) {
      if (!is.fnc(val)) {
        return val;
      }
      return val(animatable.target, animatable.id, animatable.total);
    }
    function getAttribute(el, prop) {
      return el.getAttribute(prop);
    }
    function convertPxToUnit(el, value2, unit) {
      var valueUnit = getUnit(value2);
      if (arrayContains([unit, "deg", "rad", "turn"], valueUnit)) {
        return value2;
      }
      var cached = cache.CSS[value2 + unit];
      if (!is.und(cached)) {
        return cached;
      }
      var baseline = 100;
      var tempEl = document.createElement(el.tagName);
      var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;
      parentEl.appendChild(tempEl);
      tempEl.style.position = "absolute";
      tempEl.style.width = baseline + unit;
      var factor = baseline / tempEl.offsetWidth;
      parentEl.removeChild(tempEl);
      var convertedUnit = factor * parseFloat(value2);
      cache.CSS[value2 + unit] = convertedUnit;
      return convertedUnit;
    }
    function getCSSValue(el, prop, unit) {
      if (prop in el.style) {
        var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
        var value2 = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || "0";
        return unit ? convertPxToUnit(el, value2, unit) : value2;
      }
    }
    function getAnimationType(el, prop) {
      if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || is.svg(el) && el[prop])) {
        return "attribute";
      }
      if (is.dom(el) && arrayContains(validTransforms, prop)) {
        return "transform";
      }
      if (is.dom(el) && (prop !== "transform" && getCSSValue(el, prop))) {
        return "css";
      }
      if (el[prop] != null) {
        return "object";
      }
    }
    function getElementTransforms(el) {
      if (!is.dom(el)) {
        return;
      }
      var str = el.style.transform || "";
      var reg = /(\w+)\(([^)]*)\)/g;
      var transforms = /* @__PURE__ */ new Map();
      var m2;
      while (m2 = reg.exec(str)) {
        transforms.set(m2[1], m2[2]);
      }
      return transforms;
    }
    function getTransformValue(el, propName, animatable, unit) {
      var defaultVal = stringContains(propName, "scale") ? 1 : 0 + getTransformUnit(propName);
      var value2 = getElementTransforms(el).get(propName) || defaultVal;
      if (animatable) {
        animatable.transforms.list.set(propName, value2);
        animatable.transforms["last"] = propName;
      }
      return unit ? convertPxToUnit(el, value2, unit) : value2;
    }
    function getOriginalTargetValue(target, propName, unit, animatable) {
      switch (getAnimationType(target, propName)) {
        case "transform":
          return getTransformValue(target, propName, animatable, unit);
        case "css":
          return getCSSValue(target, propName, unit);
        case "attribute":
          return getAttribute(target, propName);
        default:
          return target[propName] || 0;
      }
    }
    function getRelativeValue(to2, from2) {
      var operator = /^(\*=|\+=|-=)/.exec(to2);
      if (!operator) {
        return to2;
      }
      var u2 = getUnit(to2) || 0;
      var x2 = parseFloat(from2);
      var y2 = parseFloat(to2.replace(operator[0], ""));
      switch (operator[0][0]) {
        case "+":
          return x2 + y2 + u2;
        case "-":
          return x2 - y2 + u2;
        case "*":
          return x2 * y2 + u2;
      }
    }
    function validateValue(val, unit) {
      if (is.col(val)) {
        return colorToRgb(val);
      }
      if (/\s/g.test(val)) {
        return val;
      }
      var originalUnit = getUnit(val);
      var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
      if (unit) {
        return unitLess + unit;
      }
      return unitLess;
    }
    function getDistance(p1, p2) {
      return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
    }
    function getCircleLength(el) {
      return Math.PI * 2 * getAttribute(el, "r");
    }
    function getRectLength(el) {
      return getAttribute(el, "width") * 2 + getAttribute(el, "height") * 2;
    }
    function getLineLength(el) {
      return getDistance(
        { x: getAttribute(el, "x1"), y: getAttribute(el, "y1") },
        { x: getAttribute(el, "x2"), y: getAttribute(el, "y2") }
      );
    }
    function getPolylineLength(el) {
      var points = el.points;
      var totalLength = 0;
      var previousPos;
      for (var i2 = 0; i2 < points.numberOfItems; i2++) {
        var currentPos = points.getItem(i2);
        if (i2 > 0) {
          totalLength += getDistance(previousPos, currentPos);
        }
        previousPos = currentPos;
      }
      return totalLength;
    }
    function getPolygonLength(el) {
      var points = el.points;
      return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
    }
    function getTotalLength(el) {
      if (el.getTotalLength) {
        return el.getTotalLength();
      }
      switch (el.tagName.toLowerCase()) {
        case "circle":
          return getCircleLength(el);
        case "rect":
          return getRectLength(el);
        case "line":
          return getLineLength(el);
        case "polyline":
          return getPolylineLength(el);
        case "polygon":
          return getPolygonLength(el);
      }
    }
    function setDashoffset(el) {
      var pathLength = getTotalLength(el);
      el.setAttribute("stroke-dasharray", pathLength);
      return pathLength;
    }
    function getParentSvgEl(el) {
      var parentEl = el.parentNode;
      while (is.svg(parentEl)) {
        if (!is.svg(parentEl.parentNode)) {
          break;
        }
        parentEl = parentEl.parentNode;
      }
      return parentEl;
    }
    function getParentSvg(pathEl, svgData) {
      var svg = svgData || {};
      var parentSvgEl = svg.el || getParentSvgEl(pathEl);
      var rect = parentSvgEl.getBoundingClientRect();
      var viewBoxAttr = getAttribute(parentSvgEl, "viewBox");
      var width2 = rect.width;
      var height2 = rect.height;
      var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(" ") : [0, 0, width2, height2]);
      return {
        el: parentSvgEl,
        viewBox,
        x: viewBox[0] / 1,
        y: viewBox[1] / 1,
        w: width2,
        h: height2,
        vW: viewBox[2],
        vH: viewBox[3]
      };
    }
    function getPath(path, percent) {
      var pathEl = is.str(path) ? selectString(path)[0] : path;
      var p2 = percent || 100;
      return function(property2) {
        return {
          property: property2,
          el: pathEl,
          svg: getParentSvg(pathEl),
          totalLength: getTotalLength(pathEl) * (p2 / 100)
        };
      };
    }
    function getPathProgress(path, progress, isPathTargetInsideSVG) {
      function point(offset2) {
        if (offset2 === void 0)
          offset2 = 0;
        var l2 = progress + offset2 >= 1 ? progress + offset2 : 0;
        return path.el.getPointAtLength(l2);
      }
      var svg = getParentSvg(path.el, path.svg);
      var p2 = point();
      var p0 = point(-1);
      var p1 = point(1);
      var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;
      var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;
      switch (path.property) {
        case "x":
          return (p2.x - svg.x) * scaleX;
        case "y":
          return (p2.y - svg.y) * scaleY;
        case "angle":
          return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
      }
    }
    function decomposeValue(val, unit) {
      var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g;
      var value2 = validateValue(is.pth(val) ? val.totalLength : val, unit) + "";
      return {
        original: value2,
        numbers: value2.match(rgx) ? value2.match(rgx).map(Number) : [0],
        strings: is.str(val) || unit ? value2.split(rgx) : []
      };
    }
    function parseTargets(targets) {
      var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray$1) : toArray$1(targets)) : [];
      return filterArray(targetsArray, function(item, pos, self2) {
        return self2.indexOf(item) === pos;
      });
    }
    function getAnimatables(targets) {
      var parsed = parseTargets(targets);
      return parsed.map(function(t2, i2) {
        return { target: t2, id: i2, total: parsed.length, transforms: { list: getElementTransforms(t2) } };
      });
    }
    function normalizePropertyTweens(prop, tweenSettings) {
      var settings2 = cloneObject(tweenSettings);
      if (/^spring/.test(settings2.easing)) {
        settings2.duration = spring(settings2.easing);
      }
      if (is.arr(prop)) {
        var l2 = prop.length;
        var isFromTo = l2 === 2 && !is.obj(prop[0]);
        if (!isFromTo) {
          if (!is.fnc(tweenSettings.duration)) {
            settings2.duration = tweenSettings.duration / l2;
          }
        } else {
          prop = { value: prop };
        }
      }
      var propArray = is.arr(prop) ? prop : [prop];
      return propArray.map(function(v2, i2) {
        var obj = is.obj(v2) && !is.pth(v2) ? v2 : { value: v2 };
        if (is.und(obj.delay)) {
          obj.delay = !i2 ? tweenSettings.delay : 0;
        }
        if (is.und(obj.endDelay)) {
          obj.endDelay = i2 === propArray.length - 1 ? tweenSettings.endDelay : 0;
        }
        return obj;
      }).map(function(k) {
        return mergeObjects(k, settings2);
      });
    }
    function flattenKeyframes(keyframes) {
      var propertyNames = filterArray(flattenArray(keyframes.map(function(key) {
        return Object.keys(key);
      })), function(p2) {
        return is.key(p2);
      }).reduce(function(a2, b) {
        if (a2.indexOf(b) < 0) {
          a2.push(b);
        }
        return a2;
      }, []);
      var properties = {};
      var loop = function(i3) {
        var propName = propertyNames[i3];
        properties[propName] = keyframes.map(function(key) {
          var newKey = {};
          for (var p2 in key) {
            if (is.key(p2)) {
              if (p2 == propName) {
                newKey.value = key[p2];
              }
            } else {
              newKey[p2] = key[p2];
            }
          }
          return newKey;
        });
      };
      for (var i2 = 0; i2 < propertyNames.length; i2++)
        loop(i2);
      return properties;
    }
    function getProperties(tweenSettings, params) {
      var properties = [];
      var keyframes = params.keyframes;
      if (keyframes) {
        params = mergeObjects(flattenKeyframes(keyframes), params);
      }
      for (var p2 in params) {
        if (is.key(p2)) {
          properties.push({
            name: p2,
            tweens: normalizePropertyTweens(params[p2], tweenSettings)
          });
        }
      }
      return properties;
    }
    function normalizeTweenValues(tween, animatable) {
      var t2 = {};
      for (var p2 in tween) {
        var value2 = getFunctionValue(tween[p2], animatable);
        if (is.arr(value2)) {
          value2 = value2.map(function(v2) {
            return getFunctionValue(v2, animatable);
          });
          if (value2.length === 1) {
            value2 = value2[0];
          }
        }
        t2[p2] = value2;
      }
      t2.duration = parseFloat(t2.duration);
      t2.delay = parseFloat(t2.delay);
      return t2;
    }
    function normalizeTweens(prop, animatable) {
      var previousTween;
      return prop.tweens.map(function(t2) {
        var tween = normalizeTweenValues(t2, animatable);
        var tweenValue = tween.value;
        var to2 = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
        var toUnit = getUnit(to2);
        var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
        var previousValue = previousTween ? previousTween.to.original : originalValue;
        var from2 = is.arr(tweenValue) ? tweenValue[0] : previousValue;
        var fromUnit = getUnit(from2) || getUnit(originalValue);
        var unit = toUnit || fromUnit;
        if (is.und(to2)) {
          to2 = previousValue;
        }
        tween.from = decomposeValue(from2, unit);
        tween.to = decomposeValue(getRelativeValue(to2, from2), unit);
        tween.start = previousTween ? previousTween.end : 0;
        tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
        tween.easing = parseEasings(tween.easing, tween.duration);
        tween.isPath = is.pth(tweenValue);
        tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);
        tween.isColor = is.col(tween.from.original);
        if (tween.isColor) {
          tween.round = 1;
        }
        previousTween = tween;
        return tween;
      });
    }
    var setProgressValue = {
      css: function(t2, p2, v2) {
        return t2.style[p2] = v2;
      },
      attribute: function(t2, p2, v2) {
        return t2.setAttribute(p2, v2);
      },
      object: function(t2, p2, v2) {
        return t2[p2] = v2;
      },
      transform: function(t2, p2, v2, transforms, manual) {
        transforms.list.set(p2, v2);
        if (p2 === transforms.last || manual) {
          var str = "";
          transforms.list.forEach(function(value2, prop) {
            str += prop + "(" + value2 + ") ";
          });
          t2.style.transform = str;
        }
      }
    };
    function setTargetsValue(targets, properties) {
      var animatables = getAnimatables(targets);
      animatables.forEach(function(animatable) {
        for (var property2 in properties) {
          var value2 = getFunctionValue(properties[property2], animatable);
          var target = animatable.target;
          var valueUnit = getUnit(value2);
          var originalValue = getOriginalTargetValue(target, property2, valueUnit, animatable);
          var unit = valueUnit || getUnit(originalValue);
          var to2 = getRelativeValue(validateValue(value2, unit), originalValue);
          var animType = getAnimationType(target, property2);
          setProgressValue[animType](target, property2, to2, animatable.transforms, true);
        }
      });
    }
    function createAnimation(animatable, prop) {
      var animType = getAnimationType(animatable.target, prop.name);
      if (animType) {
        var tweens = normalizeTweens(prop, animatable);
        var lastTween = tweens[tweens.length - 1];
        return {
          type: animType,
          property: prop.name,
          animatable,
          tweens,
          duration: lastTween.end,
          delay: tweens[0].delay,
          endDelay: lastTween.endDelay
        };
      }
    }
    function getAnimations(animatables, properties) {
      return filterArray(flattenArray(animatables.map(function(animatable) {
        return properties.map(function(prop) {
          return createAnimation(animatable, prop);
        });
      })), function(a2) {
        return !is.und(a2);
      });
    }
    function getInstanceTimings(animations, tweenSettings) {
      var animLength = animations.length;
      var getTlOffset = function(anim) {
        return anim.timelineOffset ? anim.timelineOffset : 0;
      };
      var timings = {};
      timings.duration = animLength ? Math.max.apply(Math, animations.map(function(anim) {
        return getTlOffset(anim) + anim.duration;
      })) : tweenSettings.duration;
      timings.delay = animLength ? Math.min.apply(Math, animations.map(function(anim) {
        return getTlOffset(anim) + anim.delay;
      })) : tweenSettings.delay;
      timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function(anim) {
        return getTlOffset(anim) + anim.duration - anim.endDelay;
      })) : tweenSettings.endDelay;
      return timings;
    }
    var instanceID = 0;
    function createNewInstance(params) {
      var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
      var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
      var properties = getProperties(tweenSettings, params);
      var animatables = getAnimatables(params.targets);
      var animations = getAnimations(animatables, properties);
      var timings = getInstanceTimings(animations, tweenSettings);
      var id2 = instanceID;
      instanceID++;
      return mergeObjects(instanceSettings, {
        id: id2,
        children: [],
        animatables,
        animations,
        duration: timings.duration,
        delay: timings.delay,
        endDelay: timings.endDelay
      });
    }
    var activeInstances = [];
    var engine = function() {
      var raf;
      function play() {
        if (!raf && (!isDocumentHidden() || !anime.suspendWhenDocumentHidden) && activeInstances.length > 0) {
          raf = requestAnimationFrame(step);
        }
      }
      function step(t2) {
        var activeInstancesLength = activeInstances.length;
        var i2 = 0;
        while (i2 < activeInstancesLength) {
          var activeInstance = activeInstances[i2];
          if (!activeInstance.paused) {
            activeInstance.tick(t2);
            i2++;
          } else {
            activeInstances.splice(i2, 1);
            activeInstancesLength--;
          }
        }
        raf = i2 > 0 ? requestAnimationFrame(step) : void 0;
      }
      function handleVisibilityChange() {
        if (!anime.suspendWhenDocumentHidden) {
          return;
        }
        if (isDocumentHidden()) {
          raf = cancelAnimationFrame(raf);
        } else {
          activeInstances.forEach(
            function(instance) {
              return instance._onDocumentVisibility();
            }
          );
          engine();
        }
      }
      if (typeof document !== "undefined") {
        document.addEventListener("visibilitychange", handleVisibilityChange);
      }
      return play;
    }();
    function isDocumentHidden() {
      return !!document && document.hidden;
    }
    function anime(params) {
      if (params === void 0)
        params = {};
      var startTime = 0, lastTime2 = 0, now2 = 0;
      var children, childrenLength = 0;
      var resolve = null;
      function makePromise(instance2) {
        var promise2 = window.Promise && new Promise(function(_resolve) {
          return resolve = _resolve;
        });
        instance2.finished = promise2;
        return promise2;
      }
      var instance = createNewInstance(params);
      makePromise(instance);
      function toggleInstanceDirection() {
        var direction = instance.direction;
        if (direction !== "alternate") {
          instance.direction = direction !== "normal" ? "normal" : "reverse";
        }
        instance.reversed = !instance.reversed;
        children.forEach(function(child) {
          return child.reversed = instance.reversed;
        });
      }
      function adjustTime(time) {
        return instance.reversed ? instance.duration - time : time;
      }
      function resetTime() {
        startTime = 0;
        lastTime2 = adjustTime(instance.currentTime) * (1 / anime.speed);
      }
      function seekChild(time, child) {
        if (child) {
          child.seek(time - child.timelineOffset);
        }
      }
      function syncInstanceChildren(time) {
        if (!instance.reversePlayback) {
          for (var i2 = 0; i2 < childrenLength; i2++) {
            seekChild(time, children[i2]);
          }
        } else {
          for (var i$1 = childrenLength; i$1--; ) {
            seekChild(time, children[i$1]);
          }
        }
      }
      function setAnimationsProgress(insTime) {
        var i2 = 0;
        var animations = instance.animations;
        var animationsLength = animations.length;
        while (i2 < animationsLength) {
          var anim = animations[i2];
          var animatable = anim.animatable;
          var tweens = anim.tweens;
          var tweenLength = tweens.length - 1;
          var tween = tweens[tweenLength];
          if (tweenLength) {
            tween = filterArray(tweens, function(t2) {
              return insTime < t2.end;
            })[0] || tween;
          }
          var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
          var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
          var strings = tween.to.strings;
          var round2 = tween.round;
          var numbers = [];
          var toNumbersLength = tween.to.numbers.length;
          var progress = void 0;
          for (var n2 = 0; n2 < toNumbersLength; n2++) {
            var value2 = void 0;
            var toNumber = tween.to.numbers[n2];
            var fromNumber = tween.from.numbers[n2] || 0;
            if (!tween.isPath) {
              value2 = fromNumber + eased * (toNumber - fromNumber);
            } else {
              value2 = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);
            }
            if (round2) {
              if (!(tween.isColor && n2 > 2)) {
                value2 = Math.round(value2 * round2) / round2;
              }
            }
            numbers.push(value2);
          }
          var stringsLength = strings.length;
          if (!stringsLength) {
            progress = numbers[0];
          } else {
            progress = strings[0];
            for (var s2 = 0; s2 < stringsLength; s2++) {
              strings[s2];
              var b = strings[s2 + 1];
              var n$12 = numbers[s2];
              if (!isNaN(n$12)) {
                if (!b) {
                  progress += n$12 + " ";
                } else {
                  progress += n$12 + b;
                }
              }
            }
          }
          setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
          anim.currentValue = progress;
          i2++;
        }
      }
      function setCallback(cb2) {
        if (instance[cb2] && !instance.passThrough) {
          instance[cb2](instance);
        }
      }
      function countIteration() {
        if (instance.remaining && instance.remaining !== true) {
          instance.remaining--;
        }
      }
      function setInstanceProgress(engineTime) {
        var insDuration = instance.duration;
        var insDelay = instance.delay;
        var insEndDelay = insDuration - instance.endDelay;
        var insTime = adjustTime(engineTime);
        instance.progress = minMax(insTime / insDuration * 100, 0, 100);
        instance.reversePlayback = insTime < instance.currentTime;
        if (children) {
          syncInstanceChildren(insTime);
        }
        if (!instance.began && instance.currentTime > 0) {
          instance.began = true;
          setCallback("begin");
        }
        if (!instance.loopBegan && instance.currentTime > 0) {
          instance.loopBegan = true;
          setCallback("loopBegin");
        }
        if (insTime <= insDelay && instance.currentTime !== 0) {
          setAnimationsProgress(0);
        }
        if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {
          setAnimationsProgress(insDuration);
        }
        if (insTime > insDelay && insTime < insEndDelay) {
          if (!instance.changeBegan) {
            instance.changeBegan = true;
            instance.changeCompleted = false;
            setCallback("changeBegin");
          }
          setCallback("change");
          setAnimationsProgress(insTime);
        } else {
          if (instance.changeBegan) {
            instance.changeCompleted = true;
            instance.changeBegan = false;
            setCallback("changeComplete");
          }
        }
        instance.currentTime = minMax(insTime, 0, insDuration);
        if (instance.began) {
          setCallback("update");
        }
        if (engineTime >= insDuration) {
          lastTime2 = 0;
          countIteration();
          if (!instance.remaining) {
            instance.paused = true;
            if (!instance.completed) {
              instance.completed = true;
              setCallback("loopComplete");
              setCallback("complete");
              if (!instance.passThrough && "Promise" in window) {
                resolve();
                makePromise(instance);
              }
            }
          } else {
            startTime = now2;
            setCallback("loopComplete");
            instance.loopBegan = false;
            if (instance.direction === "alternate") {
              toggleInstanceDirection();
            }
          }
        }
      }
      instance.reset = function() {
        var direction = instance.direction;
        instance.passThrough = false;
        instance.currentTime = 0;
        instance.progress = 0;
        instance.paused = true;
        instance.began = false;
        instance.loopBegan = false;
        instance.changeBegan = false;
        instance.completed = false;
        instance.changeCompleted = false;
        instance.reversePlayback = false;
        instance.reversed = direction === "reverse";
        instance.remaining = instance.loop;
        children = instance.children;
        childrenLength = children.length;
        for (var i2 = childrenLength; i2--; ) {
          instance.children[i2].reset();
        }
        if (instance.reversed && instance.loop !== true || direction === "alternate" && instance.loop === 1) {
          instance.remaining++;
        }
        setAnimationsProgress(instance.reversed ? instance.duration : 0);
      };
      instance._onDocumentVisibility = resetTime;
      instance.set = function(targets, properties) {
        setTargetsValue(targets, properties);
        return instance;
      };
      instance.tick = function(t2) {
        now2 = t2;
        if (!startTime) {
          startTime = now2;
        }
        setInstanceProgress((now2 + (lastTime2 - startTime)) * anime.speed);
      };
      instance.seek = function(time) {
        setInstanceProgress(adjustTime(time));
      };
      instance.pause = function() {
        instance.paused = true;
        resetTime();
      };
      instance.play = function() {
        if (!instance.paused) {
          return;
        }
        if (instance.completed) {
          instance.reset();
        }
        instance.paused = false;
        activeInstances.push(instance);
        resetTime();
        engine();
      };
      instance.reverse = function() {
        toggleInstanceDirection();
        instance.completed = instance.reversed ? false : true;
        resetTime();
      };
      instance.restart = function() {
        instance.reset();
        instance.play();
      };
      instance.remove = function(targets) {
        var targetsArray = parseTargets(targets);
        removeTargetsFromInstance(targetsArray, instance);
      };
      instance.reset();
      if (instance.autoplay) {
        instance.play();
      }
      return instance;
    }
    function removeTargetsFromAnimations(targetsArray, animations) {
      for (var a2 = animations.length; a2--; ) {
        if (arrayContains(targetsArray, animations[a2].animatable.target)) {
          animations.splice(a2, 1);
        }
      }
    }
    function removeTargetsFromInstance(targetsArray, instance) {
      var animations = instance.animations;
      var children = instance.children;
      removeTargetsFromAnimations(targetsArray, animations);
      for (var c = children.length; c--; ) {
        var child = children[c];
        var childAnimations = child.animations;
        removeTargetsFromAnimations(targetsArray, childAnimations);
        if (!childAnimations.length && !child.children.length) {
          children.splice(c, 1);
        }
      }
      if (!animations.length && !children.length) {
        instance.pause();
      }
    }
    function removeTargetsFromActiveInstances(targets) {
      var targetsArray = parseTargets(targets);
      for (var i2 = activeInstances.length; i2--; ) {
        var instance = activeInstances[i2];
        removeTargetsFromInstance(targetsArray, instance);
      }
    }
    function stagger(val, params) {
      if (params === void 0)
        params = {};
      var direction = params.direction || "normal";
      var easing = params.easing ? parseEasings(params.easing) : null;
      var grid = params.grid;
      var axis = params.axis;
      var fromIndex = params.from || 0;
      var fromFirst = fromIndex === "first";
      var fromCenter = fromIndex === "center";
      var fromLast = fromIndex === "last";
      var isRange = is.arr(val);
      var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
      var val2 = isRange ? parseFloat(val[1]) : 0;
      var unit = getUnit(isRange ? val[1] : val) || 0;
      var start = params.start || 0 + (isRange ? val1 : 0);
      var values2 = [];
      var maxValue = 0;
      return function(el, i2, t2) {
        if (fromFirst) {
          fromIndex = 0;
        }
        if (fromCenter) {
          fromIndex = (t2 - 1) / 2;
        }
        if (fromLast) {
          fromIndex = t2 - 1;
        }
        if (!values2.length) {
          for (var index2 = 0; index2 < t2; index2++) {
            if (!grid) {
              values2.push(Math.abs(fromIndex - index2));
            } else {
              var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
              var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
              var toX = index2 % grid[0];
              var toY = Math.floor(index2 / grid[0]);
              var distanceX = fromX - toX;
              var distanceY = fromY - toY;
              var value2 = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
              if (axis === "x") {
                value2 = -distanceX;
              }
              if (axis === "y") {
                value2 = -distanceY;
              }
              values2.push(value2);
            }
            maxValue = Math.max.apply(Math, values2);
          }
          if (easing) {
            values2 = values2.map(function(val3) {
              return easing(val3 / maxValue) * maxValue;
            });
          }
          if (direction === "reverse") {
            values2 = values2.map(function(val3) {
              return axis ? val3 < 0 ? val3 * -1 : -val3 : Math.abs(maxValue - val3);
            });
          }
        }
        var spacing = isRange ? (val2 - val1) / maxValue : val1;
        return start + spacing * (Math.round(values2[i2] * 100) / 100) + unit;
      };
    }
    function timeline(params) {
      if (params === void 0)
        params = {};
      var tl = anime(params);
      tl.duration = 0;
      tl.add = function(instanceParams, timelineOffset) {
        var tlIndex = activeInstances.indexOf(tl);
        var children = tl.children;
        if (tlIndex > -1) {
          activeInstances.splice(tlIndex, 1);
        }
        function passThrough(ins2) {
          ins2.passThrough = true;
        }
        for (var i2 = 0; i2 < children.length; i2++) {
          passThrough(children[i2]);
        }
        var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
        insParams.targets = insParams.targets || params.targets;
        var tlDuration = tl.duration;
        insParams.autoplay = false;
        insParams.direction = tl.direction;
        insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
        passThrough(tl);
        tl.seek(insParams.timelineOffset);
        var ins = anime(insParams);
        passThrough(ins);
        children.push(ins);
        var timings = getInstanceTimings(children, params);
        tl.delay = timings.delay;
        tl.endDelay = timings.endDelay;
        tl.duration = timings.duration;
        tl.seek(0);
        tl.reset();
        if (tl.autoplay) {
          tl.play();
        }
        return tl;
      };
      return tl;
    }
    anime.version = "3.2.1";
    anime.speed = 1;
    anime.suspendWhenDocumentHidden = true;
    anime.running = activeInstances;
    anime.remove = removeTargetsFromActiveInstances;
    anime.get = getOriginalTargetValue;
    anime.set = setTargetsValue;
    anime.convertPx = convertPxToUnit;
    anime.path = getPath;
    anime.setDashoffset = setDashoffset;
    anime.stagger = stagger;
    anime.timeline = timeline;
    anime.easing = parseEasings;
    anime.penner = penner;
    anime.random = function(min2, max2) {
      return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
    };
    function l() {
      return (l = Object.assign || function(r2) {
        for (var e = 1; e < arguments.length; e++) {
          var t2 = arguments[e];
          for (var n2 in t2)
            Object.prototype.hasOwnProperty.call(t2, n2) && (r2[n2] = t2[n2]);
        }
        return r2;
      }).apply(this, arguments);
    }
    function i(r2) {
      const e = [];
      return a(r2, e), e;
    }
    function a(r2, e) {
      for (let t2 = 0; t2 < r2.length; t2++) {
        const n2 = r2[t2];
        Array.isArray(n2) ? a(n2, e) : e.push(n2);
      }
    }
    function s(a2) {
      const s2 = react.exports.useRef([]), f2 = react.exports.useRef([]), m2 = react.exports.useRef([]), p2 = react.exports.useRef(/* @__PURE__ */ new Set()), h2 = () => {
        for (let r2 of s2.current)
          r2.completed && (s2.current = s2.current.filter((e) => e != r2));
        f2.current = f2.current.filter((r2) => null != r2 && null != r2), m2.current = m2.current.filter((r2) => r2 && null != r2.current);
      }, d = react.exports.useCallback(() => {
        ((r2) => {
          h2(), f2.current.length > 0 && anime.remove(f2), f2.current = [];
          for (let r3 of m2.current)
            r3.current && !p2.current.has(r3.current) && f2.current.push(r3.current);
          const e = l({}, r2, { targets: f2.current, complete: (e2) => {
            r2.complete && r2.complete(e2), e2.animatables.map((r3) => p2.current.add(r3.target)), h2();
          } });
          delete e.children, s2.current.push(anime(e));
        })(a2);
      }, [a2]);
      react.exports.useEffect(() => {
        d();
      }, [d]);
      const g2 = m2.current;
      let y2 = Array.isArray(a2.children) ? a2.children : [a2.children];
      return y2 = i(y2), jsx(react.exports.Fragment, { children: y2.map((e, t2) => (g2.push(react.exports.createRef()), jsx(a2.component ? a2.component : "div", Object.assign({ ref: g2[g2.length - 1] }, { children: e }), `__anime__${t2}`))) }, void 0);
    }
    let defaultAnimation = {
      scale: [0.9, 1]
    };
    const animate = {
      default: (component) => {
        return /* @__PURE__ */ jsx(s, { ...defaultAnimation, children: component });
      }
    };
    class AnimatedComponent extends react.exports.Component {
      constructor(props) {
        super(props);
        __publicField(this, "smoothly", (component) => {
          return animate.default(component);
        });
        this.state = {};
      }
    }
    class PauseMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        __publicField(this, "unpauseGame", () => {
          events.emit("unpause");
        });
        __publicField(this, "restartGame", () => {
          events.emit("restartGame");
        });
      }
      render() {
        return this.smoothly(
          /* @__PURE__ */ jsxs("div", { className: "pauseMenu menu", children: [
            /* @__PURE__ */ jsx("h1", { className: "pauseHeader header", children: "Paused" }),
            /* @__PURE__ */ jsx(Button, { hint: "esc", text: "Continue", onClick: this.unpauseGame }),
            /* @__PURE__ */ jsx(Button, { danger: true, text: "Back to Menu", onClick: this.restartGame })
          ] })
        );
      }
    }
    class StartMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        __publicField(this, "startGame", () => {
          events.emit("gameStarted");
        });
        __publicField(this, "openSettings", () => {
          events.emit("settingsOpened");
        });
        __publicField(this, "openLeaderboard", () => {
          events.emit("leaderboardOpened");
        });
      }
      render() {
        const { playerName } = this.props;
        return this.smoothly(
          /* @__PURE__ */ jsxs("div", { className: "startMenu menu", children: [
            /* @__PURE__ */ jsxs("header", { children: [
              /* @__PURE__ */ jsx("h1", { className: "startHeader header", children: "XTYPE" }),
              /* @__PURE__ */ jsxs("div", { className: "username", children: [
                "Playing as ",
                playerName
              ] })
            ] }),
            /* @__PURE__ */ jsx(Button, { hint: "P", text: "Singleplayer", onClick: this.startGame }),
            /* @__PURE__ */ jsx(Button, { disabled: true, hint: "M", text: "Multiplayer", onClick: () => console.log("Multiplayer is WIP") }),
            /* @__PURE__ */ jsx("div", { className: "spacer" }),
            /* @__PURE__ */ jsx(Button, { mini: true, hint: "S", text: "Settings", onClick: this.openSettings }),
            /* @__PURE__ */ jsx(Button, { mini: true, hint: "L", text: "Leaderboard", onClick: this.openLeaderboard })
          ] })
        );
      }
    }
    class SettingsMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        __publicField(this, "handleFocus", (e) => e.target.select());
        __publicField(this, "handleChange", (e) => {
          e.stopPropagation();
          e.preventDefault();
          this.setState({
            playerName: e.target.value
          }, () => {
            this.updateShip();
          });
        });
        __publicField(this, "updateShip", () => {
          this.setState((old) => {
            return {
              playerShip: createIdenticon(old.playerName, { size: 200 })
            };
          });
        });
        __publicField(this, "saveSettings", () => {
          events.emit("settingsSaved", this.state.playerName);
        });
        this.state = {
          playerName: props.playerName,
          playerShip: ""
        };
        this.changed = false;
      }
      componentDidMount() {
        this.updateShip();
        this.changed = true;
      }
      render() {
        const { playerShip, playerName } = this.state;
        let content = /* @__PURE__ */ jsxs("div", { className: "settingsMenu menu", children: [
          /* @__PURE__ */ jsx("div", { className: "settingsHeader", children: /* @__PURE__ */ jsx("img", { src: playerShip, alt: "Visual representation of the player ship" }) }),
          /* @__PURE__ */ jsx(
            "input",
            {
              type: "text",
              defaultValue: playerName,
              onChange: this.handleChange,
              onFocus: this.handleFocus,
              required: true,
              autoFocus: true
            }
          ),
          /* @__PURE__ */ jsx(Button, { text: "Save", hint: "ret", onClick: this.saveSettings })
        ] });
        return this.changed ? content : this.smoothly(content);
      }
    }
    const localStorage = window.localStorage;
    const storage = {
      set: (key, value2) => {
        localStorage.setItem(key, value2);
      },
      get: (key) => {
        return localStorage.getItem(key);
      },
      del: (key) => {
        localStorage.removeItem(key);
      },
      push: (key, value2) => {
        let array = get(key);
        if (array) {
          array = JSON.parse(array);
        }
        if (typeof array !== "object") {
          array = [];
        }
        array.push(value2);
        set(key, JSON.stringify(array));
      },
      pop: (key) => {
        let array = get(key);
        if (array) {
          array = JSON.parse(array);
        }
        if (typeof array !== "object") {
          return null;
        }
        let val = array.pop();
        set(key, JSON.stringify(array));
        return val;
      },
      first: (key) => {
        let array = get(key);
        if (!array) {
          return null;
        }
        if (typeof array !== "object" && value.constructor !== Array) {
          return array;
        }
        return array[0];
      },
      last: (key) => {
        let array = get(key);
        if (!array) {
          return null;
        }
        if (typeof array !== "object" && value.constructor !== Array) {
          return array;
        }
        return array[array.length - 1];
      },
      exists: (key) => {
        let val = localStorage.getItem(key);
        if (val) {
          return true;
        }
        return false;
      }
    };
    const maxEntries = 15;
    let items = [];
    const sortEntry = (a2, b) => {
      return b.totalWaves - a2.totalWaves || b.score - a2.score;
    };
    const addEntry = (who, accuracy, wpm, score, totalWaves) => {
      let entry = {
        playerName: who,
        playerAvatar: createIdenticon(who),
        accuracy,
        wpm,
        score,
        totalWaves
      };
      if (storage.exists("leaderboard")) {
        items = JSON.parse(storage.get("leaderboard"));
      }
      items.push(entry);
      items.sort(sortEntry);
      if (items.length > maxEntries) {
        items = items.slice(0, maxEntries);
      }
      storage.set("leaderboard", JSON.stringify(items));
      return items;
    };
    const allEntries = () => {
      let entries = storage.get("leaderboard");
      if (!entries) {
        return [];
      }
      return JSON.parse(entries);
    };
    class LeaderboardMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        __publicField(this, "closeLeaderboard", () => {
          events.emit("leaderboardClosed");
        });
        __publicField(this, "leaderboardEntry", (data, i2) => {
          return /* @__PURE__ */ jsxs("div", { className: "leaderboardEntry", children: [
            /* @__PURE__ */ jsxs("div", { className: "playerInfo", children: [
              /* @__PURE__ */ jsx("img", { src: data.playerAvatar }),
              /* @__PURE__ */ jsx("div", { className: "playerName", children: truncate(data.playerName, 10) })
            ] }),
            /* @__PURE__ */ jsxs("div", { className: "playerData", children: [
              /* @__PURE__ */ jsxs("div", { className: "data accuracy", children: [
                data.accuracy,
                "%"
              ] }),
              /* @__PURE__ */ jsx("div", { className: "spacer" }),
              /* @__PURE__ */ jsx("div", { className: "data wpm", children: data.wpm }),
              /* @__PURE__ */ jsx("div", { className: "data score", children: data.score })
            ] })
          ] }, i2);
        });
        __publicField(this, "leaderboardSeparator", (level, i2) => {
          return /* @__PURE__ */ jsxs("div", { className: "levelDisplay", children: [
            "Wave ",
            level
          ] }, i2 * i2);
        });
      }
      render() {
        let animeProps = {
          opacity: [0, 1],
          translateX: [-64, 0],
          delay: (el, i2) => i2 * 200
        };
        let all = allEntries().sort((a2, b) => {
          return b.totalWaves - a2.totalWaves || b.score - a2.score;
        });
        let entries = [];
        let lastLevel = all[0] ? all[0].totalWaves : 0;
        all.forEach((e, i2) => {
          if (i2 === 0) {
            entries.push(this.leaderboardSeparator(lastLevel, i2));
          }
          if (e.totalWaves !== lastLevel) {
            lastLevel = e.totalWaves;
            entries.push(this.leaderboardSeparator(lastLevel, i2));
          }
          entries.push(this.leaderboardEntry(e, i2));
        });
        return this.smoothly(
          /* @__PURE__ */ jsxs("div", { className: "leaderboardMenu menu", children: [
            entries.length === 0 && /* @__PURE__ */ jsx("div", { className: "nothingHere", children: "You haven't set any scores yet!" }),
            entries.length > 0 && /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx(s, { ...animeProps, children: entries }) }),
            /* @__PURE__ */ jsx(Button, { mini: true, hint: "esc", text: "Close", onClick: this.closeLeaderboard })
          ] })
        );
      }
    }
    var Chart = { exports: {} };
    //! moment.js
    //! version : 2.29.4
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    var hookCallback;
    function hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a2, b) {
      return Object.prototype.hasOwnProperty.call(a2, b);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;
        for (k in obj) {
          if (hasOwnProp(obj, k)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined(input) {
      return input === void 0;
    }
    function isNumber(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
      var res = [], i2, arrLen = arr.length;
      for (i2 = 0; i2 < arrLen; ++i2) {
        res.push(fn(arr[i2], i2));
      }
      return res;
    }
    function extend(a2, b) {
      for (var i2 in b) {
        if (hasOwnProp(b, i2)) {
          a2[i2] = b[i2];
        }
      }
      if (hasOwnProp(b, "toString")) {
        a2.toString = b.toString;
      }
      if (hasOwnProp(b, "valueOf")) {
        a2.valueOf = b.valueOf;
      }
      return a2;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m2) {
      if (m2._pf == null) {
        m2._pf = defaultParsingFlags();
      }
      return m2._pf;
    }
    var some;
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t2 = Object(this), len = t2.length >>> 0, i2;
        for (i2 = 0; i2 < len; i2++) {
          if (i2 in t2 && fun.call(this, t2[i2], i2, t2)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid(m2) {
      if (m2._isValid == null) {
        var flags = getParsingFlags(m2), parsedParts = some.call(flags.parsedDateParts, function(i2) {
          return i2 != null;
        }), isNowValid = !isNaN(m2._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m2._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
        }
        if (Object.isFrozen == null || !Object.isFrozen(m2)) {
          m2._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }
      return m2._isValid;
    }
    function createInvalid(flags) {
      var m2 = createUTC(NaN);
      if (flags != null) {
        extend(getParsingFlags(m2), flags);
      } else {
        getParsingFlags(m2).userInvalidated = true;
      }
      return m2;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i2, prop, val, momentPropertiesLen = momentProperties.length;
      if (!isUndefined(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentPropertiesLen > 0) {
        for (i2 = 0; i2 < momentPropertiesLen; i2++) {
          prop = momentProperties[i2];
          val = from2[prop];
          if (!isUndefined(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function() {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i2, key, argLen = arguments.length;
          for (i2 = 0; i2 < argLen; i2++) {
            arg = "";
            if (typeof arguments[i2] === "object") {
              arg += "\n[" + i2 + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i2];
            }
            args.push(arg);
          }
          warn(
            msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
          );
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }
      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set$1(config) {
      var prop, i2;
      for (i2 in config) {
        if (hasOwnProp(config, i2)) {
          prop = config[i2];
          if (isFunction(prop)) {
            this[i2] = prop;
          } else {
            this["_" + i2] = prop;
          }
        }
      }
      this._config = config;
      this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
      );
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          res[prop] = extend({}, res[prop]);
        }
      }
      return res;
    }
    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }
    var keys;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i2, res = [];
        for (i2 in obj) {
          if (hasOwnProp(obj, i2)) {
            res.push(i2);
          }
        }
        return res;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now2) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction(output) ? output.call(mom, now2) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback) {
      var func = callback;
      if (typeof callback === "string") {
        func = function() {
          return this[callback]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(
            func.apply(this, arguments),
            token2
          );
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array = format2.match(formattingTokens), i2, length;
      for (i2 = 0, length = array.length; i2 < length; i2++) {
        if (formatTokenFunctions[array[i2]]) {
          array[i2] = formatTokenFunctions[array[i2]];
        } else {
          array[i2] = removeFormattingTokens(array[i2]);
        }
      }
      return function(mom) {
        var output = "", i3;
        for (i3 = 0; i3 < length; i3++) {
          output += isFunction(array[i3]) ? array[i3].call(mom, format2) : array[i3];
        }
        return output;
      };
    }
    function formatMoment(m2, format2) {
      if (!m2.isValid()) {
        return m2.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m2.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m2);
    }
    function expandFormat(format2, locale2) {
      var i2 = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i2 >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(
          localFormattingTokens,
          replaceLongDateFormatTokens
        );
        localFormattingTokens.lastIndex = 0;
        i2 -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
      return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
      var units = [], u2;
      for (u2 in unitsObj) {
        if (hasOwnProp(unitsObj, u2)) {
          units.push({ unit: u2, priority: priorities[u2] });
        }
      }
      units.sort(function(a2, b) {
        return a2.priority - b.priority;
      });
      return units;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value2 = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value2 = absFloor(coercedNumber);
      }
      return value2;
    }
    function makeGetSet(unit, keepTime) {
      return function(value2) {
        if (value2 != null) {
          set$1$1(this, unit, value2);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get$1(this, unit);
        }
      };
    }
    function get$1(mom, unit) {
      return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
    }
    function set$1$1(mom, unit, value2) {
      if (mom.isValid() && !isNaN(value2)) {
        if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          value2 = toInt(value2);
          mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
            value2,
            mom.month(),
            daysInMonth(value2, mom.month())
          );
        } else {
          mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value2);
        }
      }
    }
    function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units]();
      }
      return this;
    }
    function stringSet(units, value2) {
      if (typeof units === "object") {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
        for (i2 = 0; i2 < prioritizedLen; i2++) {
          this[prioritized[i2].unit](units[prioritized[i2].unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units](value2);
        }
      }
      return this;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
    regexes = {};
    function addRegexToken(token2, regex, strictRegex) {
      regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token2, config) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config._strict, config._locale);
    }
    function unescapeFormat(s2) {
      return regexEscape(
        s2.replace("\\", "").replace(
          /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
          function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }
        )
      );
    }
    function regexEscape(s2) {
      return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tokens = {};
    function addParseToken(token2, callback) {
      var i2, func = callback, tokenLen;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber(callback)) {
        func = function(input, array) {
          array[callback] = toInt(input);
        };
      }
      tokenLen = token2.length;
      for (i2 = 0; i2 < tokenLen; i2++) {
        tokens[token2[i2]] = func;
      }
    }
    function addWeekParseToken(token2, callback) {
      addParseToken(token2, function(input, array, config, token3) {
        config._w = config._w || {};
        callback(input, config._w, config, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config._a, config, token2);
      }
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    function mod(n2, x2) {
      return (n2 % x2 + x2) % x2;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o) {
        var i2;
        for (i2 = 0; i2 < this.length; ++i2) {
          if (this[i2] === o) {
            return i2;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addUnitAlias("month", "M");
    addUnitPriority("month", 8);
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
      var month = config._locale.monthsParse(input, token2, config._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m2, format2) {
      if (!m2) {
        return isArray(this._months) ? this._months : this._months["standalone"];
      }
      return isArray(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
    }
    function localeMonthsShort(m2, format2) {
      if (!m2) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i2, ii2, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i2 = 0; i2 < 12; ++i2) {
          mom = createUTC([2e3, i2]);
          this._shortMonthsParse[i2] = this.monthsShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._longMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      } else {
        if (format2 === "MMM") {
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._longMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._longMonthsParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i2, mom, regex;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i2 = 0; i2 < 12; i2++) {
        mom = createUTC([2e3, i2]);
        if (strict && !this._longMonthsParse[i2]) {
          this._longMonthsParse[i2] = new RegExp(
            "^" + this.months(mom, "").replace(".", "") + "$",
            "i"
          );
          this._shortMonthsParse[i2] = new RegExp(
            "^" + this.monthsShort(mom, "").replace(".", "") + "$",
            "i"
          );
        }
        if (!strict && !this._monthsParse[i2]) {
          regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
          return i2;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
          return i2;
        } else if (!strict && this._monthsParse[i2].test(monthName)) {
          return i2;
        }
      }
    }
    function setMonth(mom, value2) {
      var dayOfMonth;
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value2 === "string") {
        if (/^\d+$/.test(value2)) {
          value2 = toInt(value2);
        } else {
          value2 = mom.localeData().monthsParse(value2);
          if (!isNumber(value2)) {
            return mom;
          }
        }
      }
      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value2));
      mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value2, dayOfMonth);
      return mom;
    }
    function getSetMonth(value2) {
      if (value2 != null) {
        setMonth(this, value2);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get$1(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a2, b) {
        return b.length - a2.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
      for (i2 = 0; i2 < 12; i2++) {
        mom = createUTC([2e3, i2]);
        shortPieces.push(this.monthsShort(mom, ""));
        longPieces.push(this.months(mom, ""));
        mixedPieces.push(this.months(mom, ""));
        mixedPieces.push(this.monthsShort(mom, ""));
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      for (i2 = 0; i2 < 12; i2++) {
        shortPieces[i2] = regexEscape(shortPieces[i2]);
        longPieces[i2] = regexEscape(longPieces[i2]);
      }
      for (i2 = 0; i2 < 24; i2++) {
        mixedPieces[i2] = regexEscape(mixedPieces[i2]);
      }
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._monthsShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken("Y", 0, 0, function() {
      var y2 = this.year();
      return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addUnitAlias("year", "y");
    addUnitPriority("year", 1);
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function createDate(y2, m2, d, h2, M2, s2, ms) {
      var date;
      if (y2 < 100 && y2 >= 0) {
        date = new Date(y2 + 400, m2, d, h2, M2, s2, ms);
        if (isFinite(date.getFullYear())) {
          date.setFullYear(y2);
        }
      } else {
        date = new Date(y2, m2, d, h2, M2, s2, ms);
      }
      return date;
    }
    function createUTCDate(y2) {
      var date, args;
      if (y2 < 100 && y2 >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y2 + 400;
        date = new Date(Date.UTC.apply(null, args));
        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y2);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }
      return date;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addUnitPriority("week", 5);
    addUnitPriority("isoWeek", 5);
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      }
    );
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      doy: 6
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addUnitPriority("day", 11);
    addUnitPriority("weekday", 11);
    addUnitPriority("isoWeekday", 11);
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
      var weekday = config._locale.weekdaysParse(input, token2, config._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
      week[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n2) {
      return ws.slice(n2, 7).concat(ws.slice(0, n2));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m2, format2) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
    }
    function localeWeekdaysShort(m2) {
      return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m2) {
      return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i2, ii2, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i2 = 0; i2 < 7; ++i2) {
          mom = createUTC([2e3, 1]).day(i2);
          this._minWeekdaysParse[i2] = this.weekdaysMin(
            mom,
            ""
          ).toLocaleLowerCase();
          this._shortWeekdaysParse[i2] = this.weekdaysShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii2 = indexOf.call(this._weekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else if (format2 === "ddd") {
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      } else {
        if (format2 === "dddd") {
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else if (format2 === "ddd") {
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i2, mom, regex;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i2 = 0; i2 < 7; i2++) {
        mom = createUTC([2e3, 1]).day(i2);
        if (strict && !this._fullWeekdaysParse[i2]) {
          this._fullWeekdaysParse[i2] = new RegExp(
            "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._shortWeekdaysParse[i2] = new RegExp(
            "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._minWeekdaysParse[i2] = new RegExp(
            "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
        }
        if (!this._weekdaysParse[i2]) {
          regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
          return i2;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
          return i2;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
          return i2;
        } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
          return i2;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a2, b) {
        return b.length - a2.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
      for (i2 = 0; i2 < 7; i2++) {
        mom = createUTC([2e3, 1]).day(i2);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._weekdaysShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
      this._weekdaysMinStrictRegex = new RegExp(
        "^(" + minPieces.join("|") + ")",
        "i"
      );
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(
          this.hours(),
          this.minutes(),
          lowercase
        );
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    addUnitPriority("hour", 13);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("k", match1to2);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i2, minl = Math.min(arr1.length, arr2.length);
      for (i2 = 0; i2 < minl; i2 += 1) {
        if (arr1[i2] !== arr2[i2]) {
          return i2;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
      var i2 = 0, j, next, locale2, split;
      while (i2 < names.length) {
        split = normalizeLocale(names[i2]).split("-");
        j = split.length;
        next = normalizeLocale(names[i2 + 1]);
        next = next ? next.split("-") : null;
        while (j > 0) {
          locale2 = loadLocale(split.slice(0, j).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
            break;
          }
          j--;
        }
        i2++;
      }
      return globalLocale;
    }
    function isLocaleNameSane(name) {
      return name.match("^[^/\\\\]*$") != null;
    }
    function loadLocale(name) {
      var oldLocale = null, aliasedRequire;
      if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = require;
          aliasedRequire("./locale/" + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {
          locales[name] = null;
        }
      }
      return locales[name];
    }
    function getSetGlobalLocale(key, values2) {
      var data;
      if (key) {
        if (isUndefined(values2)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values2);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(
              "Locale " + key + " not found. Did you forget to load it?"
            );
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name, config) {
      if (config !== null) {
        var locale2, parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
          deprecateSimple(
            "defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
          );
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale2 = loadLocale(config.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }
              localeFamilies[config.parentLocale].push({
                name,
                config
              });
              return null;
            }
          }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));
        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function(x2) {
            defineLocale(x2.name, x2.config);
          });
        }
        getSetGlobalLocale(name);
        return locales[name];
      } else {
        delete locales[name];
        return null;
      }
    }
    function updateLocale(name, config) {
      if (config != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name] != null && locales[name].parentLocale != null) {
          locales[name].set(mergeConfigs(locales[name]._config, config));
        } else {
          tmpLocale = loadLocale(name);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          if (tmpLocale == null) {
            config.abbr = name;
          }
          locale2 = new Locale(config);
          locale2.parentLocale = locales[name];
          locales[name] = locale2;
        }
        getSetGlobalLocale(name);
      } else {
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
            if (name === getSetGlobalLocale()) {
              getSetGlobalLocale(name);
            }
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }
      return locales[name];
    }
    function getLocale(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys(locales);
    }
    function checkOverflow(m2) {
      var overflow, a2 = m2._a;
      if (a2 && getParsingFlags(m2).overflow === -2) {
        overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }
        if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }
        getParsingFlags(m2).overflow = overflow;
      }
      return m2;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config) {
      var i2, l2, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
      if (match) {
        getParsingFlags(config).iso = true;
        for (i2 = 0, l2 = isoDatesLen; i2 < l2; i2++) {
          if (isoDates[i2][1].exec(match[1])) {
            dateFormat = isoDates[i2][0];
            allowTime = isoDates[i2][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config._isValid = false;
          return;
        }
        if (match[3]) {
          for (i2 = 0, l2 = isoTimesLen; i2 < l2; i2++) {
            if (isoTimes[i2][1].exec(match[3])) {
              timeFormat = (match[2] || " ") + isoTimes[i2][0];
              break;
            }
          }
          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }
        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = "Z";
          } else {
            config._isValid = false;
            return;
          }
        }
        config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result2 = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result2.push(parseInt(secondStr, 10));
      }
      return result2;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2e3 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s2) {
      return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
          parsedInput[0],
          parsedInput[1],
          parsedInput[2]
        ).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m2 = hm % 100, h2 = (hm - m2) / 100;
        return h2 * 60 + m2;
      }
    }
    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
      if (match) {
        parsedArray = extractFromRFC2822Strings(
          match[4],
          match[3],
          match[2],
          match[5],
          match[6],
          match[7]
        );
        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }
        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      configFromRFC2822(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      if (config._strict) {
        config._isValid = false;
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
      }
    );
    function defaults(a2, b, c) {
      if (a2 != null) {
        return a2;
      }
      if (b != null) {
        return b;
      }
      return c;
    }
    function currentDateArray(config) {
      var nowValue = new Date(hooks.now());
      if (config._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
      var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
        config._a[i2] = input[i2] = currentDate[i2];
      }
      for (; i2 < 7; i2++) {
        config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(
        null,
        input
      );
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
      if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w2, weekYear, week, weekday, dow, doy, temp2, weekdayOverflow, curWeek;
      w2 = config._w;
      if (w2.GG != null || w2.W != null || w2.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults(
          w2.GG,
          config._a[YEAR],
          weekOfYear(createLocal(), 1, 4).year
        );
        week = defaults(w2.W, 1);
        weekday = defaults(w2.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w2.gg, config._a[YEAR], curWeek.year);
        week = defaults(w2.w, curWeek.week);
        if (w2.d != null) {
          weekday = w2.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w2.e != null) {
          weekday = w2.e + dow;
          if (w2.e < 0 || w2.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp2 = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp2.year;
        config._dayOfYear = temp2.dayOfYear;
      }
    }
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config) {
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }
      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
      tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      tokenLen = tokens2.length;
      for (i2 = 0; i2 < tokenLen; i2++) {
        token2 = tokens2[i2];
        parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string = string.slice(
            string.indexOf(parsedInput) + parsedInput.length
          );
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      }
      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = void 0;
      }
      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem;
      config._a[HOUR] = meridiemFixWrap(
        config._locale,
        config._a[HOUR],
        config._meridiem
      );
      era = getParsingFlags(config).era;
      if (era !== null) {
        config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
      }
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
      if (configfLen === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }
      for (i2 = 0; i2 < configfLen; i2++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i2];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
      config._a = map(
        [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
        function(obj) {
          return obj && parseInt(obj, 10);
        }
      );
      configFromArray(config);
    }
    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
        res.add(1, "d");
        res._nextDay = void 0;
      }
      return res;
    }
    function prepareConfig(config) {
      var input = config._i, format2 = config._f;
      config._locale = config._locale || getLocale(config._l);
      if (input === null || format2 === void 0 && input === "") {
        return createInvalid({ nullInput: true });
      }
      if (typeof input === "string") {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format2)) {
        configFromStringAndArray(config);
      } else if (format2) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }
      if (!isValid(config)) {
        config._d = null;
      }
      return config;
    }
    function configFromInput(config) {
      var input = config._i;
      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = void 0;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = void 0;
      }
      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = void 0;
      }
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale2;
      c._i = input;
      c._f = format2;
      c._strict = strict;
      return createFromConfig(c);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    ), prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    function pickBy(fn, moments) {
      var res, i2;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res = moments[0];
      for (i2 = 1; i2 < moments.length; ++i2) {
        if (!moments[i2].isValid() || moments[i2][fn](res)) {
          res = moments[i2];
        }
      }
      return res;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now = function() {
      return Date.now ? Date.now() : +new Date();
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m2) {
      var key, unitHasDecimal = false, i2, orderLen = ordering.length;
      for (key in m2) {
        if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
          return false;
        }
      }
      for (i2 = 0; i2 < orderLen; ++i2) {
        if (m2[ordering[i2]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m2[ordering[i2]]) !== toInt(m2[ordering[i2]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
      for (i2 = 0; i2 < len; i2++) {
        if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher2, string) {
      var matches = (string || "").match(matcher2), chunk2, parts, minutes2;
      if (matches === null) {
        return null;
      }
      chunk2 = matches[matches.length - 1] || [];
      parts = (chunk2 + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res, diff2;
      if (model._isUTC) {
        res = model.clone();
        diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        res._d.setTime(res._d.valueOf() + diff2);
        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m2) {
      return -Math.round(m2._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(
              this,
              createDuration(input - offset2, "m"),
              1,
              false
            );
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c = {}, other;
      copyConfig(c, this);
      c = prepareConfig(c);
      if (c._a) {
        other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration = input, match = null, sign2, ret, diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input) || !isNaN(+input)) {
        duration = {};
        if (key) {
          duration[key] = +input;
        } else {
          duration.milliseconds = +input;
        }
      } else if (match = aspNetRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign2,
          h: toInt(match[HOUR]) * sign2,
          m: toInt(match[MINUTE]) * sign2,
          s: toInt(match[SECOND]) * sign2,
          ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
        };
      } else if (match = isoRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign2),
          M: parseIso(match[3], sign2),
          w: parseIso(match[4], sign2),
          d: parseIso(match[5], sign2),
          h: parseIso(match[6], sign2),
          m: parseIso(match[7], sign2),
          s: parseIso(match[8], sign2)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
        diffRes = momentsDifference(
          createLocal(duration.from),
          createLocal(duration.to)
        );
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret._isValid = input._isValid;
      }
      return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res) ? 0 : res) * sign2;
    }
    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, "M").isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +base.clone().add(res.months, "M");
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(
            name,
            "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
          );
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get$1(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$1$1(mom, "Date", get$1(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i2, property2, propertyLen = properties.length;
      for (i2 = 0; i2 < propertyLen; i2 += 1) {
        property2 = properties[i2];
        propertyTest = propertyTest || hasOwnProp(input, property2);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber(item) && isString(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i2, property2;
      for (i2 = 0; i2 < properties.length; i2 += 1) {
        property2 = properties[i2];
        propertyTest = propertyTest || hasOwnProp(input, property2);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now2) {
      var diff2 = myMoment.diff(now2, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats2) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = void 0;
          formats2 = void 0;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats2 = void 0;
        } else if (isCalendarSpec(arguments[0])) {
          formats2 = arguments[0];
          time = void 0;
        }
      }
      var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats2 && (isFunction(formats2[format2]) ? formats2[format2].call(this, now2) : formats2[format2]);
      return this.format(
        output || this.localeData().calendar(format2, this, createLocal(now2))
      );
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }
    function isBetween(from2, to2, units, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);
      switch (units) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1e3;
          break;
        case "minute":
          output = (this - that) / 6e4;
          break;
        case "hour":
          output = (this - that) / 36e5;
          break;
        case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;
        case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a2, b) {
      if (a2.date() < b.date()) {
        return -monthDiff(b, a2);
      }
      var wholeMonthDiff = (b.year() - a2.year()) * 12 + (b.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
      if (b - anchor < 0) {
        anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
      if (m2.year() < 0 || m2.year() > 9999) {
        return formatMoment(
          m2,
          utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      if (isFunction(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
        }
      }
      return formatMoment(
        m2,
        utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
      var newLocaleData;
      if (key === void 0) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y2, m2, d) {
      if (y2 < 100 && y2 >= 0) {
        return new Date(y2 + 400, m2, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y2, m2, d).valueOf();
      }
    }
    function utcStartOfDate(y2, m2, d) {
      if (y2 < 100 && y2 >= 0) {
        return Date.UTC(y2 + 400, m2, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y2, m2, d);
      }
    }
    function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3,
            1
          );
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday()
          );
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1)
          );
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          );
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3 + 3,
            1
          ) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday() + 7
          ) - 1;
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1) + 7
          ) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          ) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
      return new Date(this.valueOf());
    }
    function toArray() {
      var m2 = this;
      return [
        m2.year(),
        m2.month(),
        m2.date(),
        m2.hour(),
        m2.minute(),
        m2.second(),
        m2.millisecond()
      ];
    }
    function toObject() {
      var m2 = this;
      return {
        years: m2.year(),
        months: m2.month(),
        date: m2.date(),
        hours: m2.hours(),
        minutes: m2.minutes(),
        seconds: m2.seconds(),
        milliseconds: m2.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid(this);
    }
    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array, config, token2) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
        match = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
      } else {
        array[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m2, format2) {
      var i2, l2, date, eras = this._eras || getLocale("en")._eras;
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        switch (typeof eras[i2].since) {
          case "string":
            date = hooks(eras[i2].since).startOf("day");
            eras[i2].since = date.valueOf();
            break;
        }
        switch (typeof eras[i2].until) {
          case "undefined":
            eras[i2].until = Infinity;
            break;
          case "string":
            date = hooks(eras[i2].until).startOf("day").valueOf();
            eras[i2].until = date.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i2, l2, eras = this.eras(), name, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        name = eras[i2].name.toUpperCase();
        abbr = eras[i2].abbr.toUpperCase();
        narrow = eras[i2].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i2];
              }
              break;
            case "NNNN":
              if (name === eraName) {
                return eras[i2];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i2];
              }
              break;
          }
        } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i2];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === void 0) {
        return hooks(era.since).year();
      } else {
        return hooks(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i2, l2, val, eras = this.localeData().eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until) {
          return eras[i2].name;
        }
        if (eras[i2].until <= val && val <= eras[i2].since) {
          return eras[i2].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i2, l2, val, eras = this.localeData().eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until) {
          return eras[i2].narrow;
        }
        if (eras[i2].until <= val && val <= eras[i2].since) {
          return eras[i2].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i2, l2, val, eras = this.localeData().eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until) {
          return eras[i2].abbr;
        }
        if (eras[i2].until <= val && val <= eras[i2].since) {
          return eras[i2].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i2, l2, dir, val, eras = this.localeData().eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        dir = eras[i2].since <= eras[i2].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
          return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l2, eras = this.eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        namePieces.push(regexEscape(eras[i2].name));
        abbrPieces.push(regexEscape(eras[i2].abbr));
        narrowPieces.push(regexEscape(eras[i2].narrow));
        mixedPieces.push(regexEscape(eras[i2].name));
        mixedPieces.push(regexEscape(eras[i2].abbr));
        mixedPieces.push(regexEscape(eras[i2].narrow));
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp(
        "^(" + narrowPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addUnitPriority("weekYear", 1);
    addUnitPriority("isoWeekYear", 1);
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.week(),
        this.weekday(),
        this.localeData()._week.dow,
        this.localeData()._week.doy
      );
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.isoWeek(),
        this.isoWeekday(),
        1,
        4
      );
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addUnitAlias("quarter", "Q");
    addUnitPriority("quarter", 7);
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addUnitAlias("date", "D");
    addUnitPriority("date", 9);
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addUnitPriority("dayOfYear", 4);
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array, config) {
      config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addUnitAlias("minute", "m");
    addUnitPriority("minute", 14);
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addUnitAlias("second", "s");
    addUnitPriority("second", 15);
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addUnitAlias("millisecond", "ms");
    addUnitPriority("millisecond", 16);
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
      array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    function createUnix(input) {
      return createLocal(input * 1e3);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
      return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set$1;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1$1(format2, index2, field, setter) {
      var locale2 = getLocale(), utc = createUTC().set(setter, index2);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index2, field) {
      if (isNumber(format2)) {
        index2 = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
      if (index2 != null) {
        return get$1$1(format2, index2, field, "month");
      }
      var i2, out = [];
      for (i2 = 0; i2 < 12; i2++) {
        out[i2] = get$1$1(format2, i2, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index2, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index2 = format2;
        localeSorted = false;
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
      if (index2 != null) {
        return get$1$1(format2, (index2 + shift) % 7, field, "day");
      }
      for (i2 = 0; i2 < 7; i2++) {
        out[i2] = get$1$1(format2, (i2 + shift) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index2) {
      return listMonthsImpl(format2, index2, "months");
    }
    function listMonthsShort(format2, index2) {
      return listMonthsImpl(format2, index2, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration, input, value2, direction) {
      var other = createDuration(input, value2);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function add$1(input, value2) {
      return addSubtract$1(this, input, value2, 1);
    }
    function subtract$1(input, value2) {
      return addSubtract$1(this, input, value2, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1e3;
      seconds2 = absFloor(milliseconds2 / 1e3);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units = normalizeUnits(units);
      if (units === "month" || units === "quarter" || units === "year") {
        days2 = this._days + milliseconds2 / 864e5;
        months2 = this._months + daysToMonths(days2);
        switch (units) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case "week":
            return days2 / 7 + milliseconds2 / 6048e5;
          case "day":
            return days2 + milliseconds2 / 864e5;
          case "hour":
            return days2 * 24 + milliseconds2 / 36e5;
          case "minute":
            return days2 * 1440 + milliseconds2 / 6e4;
          case "second":
            return days2 * 86400 + milliseconds2 / 1e3;
          case "millisecond":
            return Math.floor(days2 * 864e5) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units);
        }
      }
    }
    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }
      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
    function clone$1() {
      return createDuration(this);
    }
    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name) {
      return function() {
        return this.isValid() ? this._data[name] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
      ss: 44,
      s: 45,
      m: 45,
      h: 22,
      d: 26,
      w: null,
      M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a2[2] = withoutSuffix;
      a2[3] = +posNegDuration > 0;
      a2[4] = locale2;
      return substituteTimeAgo.apply(null, a2);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === void 0) {
        return round;
      }
      if (typeof roundingFunction === "function") {
        round = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === void 0) {
        return false;
      }
      if (limit === void 0) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === "s") {
        thresholds.ss = limit - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th2 = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th2 = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th2.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th2, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x2) {
      return (x2 > 0) - (x2 < 0) || +x2;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
      config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
      config._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = "2.29.4";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      DATE: "YYYY-MM-DD",
      TIME: "HH:mm",
      TIME_SECONDS: "HH:mm:ss",
      TIME_MS: "HH:mm:ss.SSS",
      WEEK: "GGGG-[W]WW",
      MONTH: "YYYY-MM"
    };
    const moment = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: hooks
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$0 = /* @__PURE__ */ getAugmentedNamespace(moment);
    /*!
     * Chart.js v2.9.4
     * https://www.chartjs.org
     * (c) 2020 Chart.js Contributors
     * Released under the MIT License
     */
    (function(module2, exports2) {
      (function(global2, factory) {
        module2.exports = factory(function() {
          try {
            return require$$0;
          } catch (e) {
          }
        }());
      })(commonjsGlobal, function(moment2) {
        moment2 = moment2 && moment2.hasOwnProperty("default") ? moment2["default"] : moment2;
        function createCommonjsModule(fn, module3) {
          return module3 = { exports: {} }, fn(module3, module3.exports), module3.exports;
        }
        function getCjsExportFromNamespace(n2) {
          return n2 && n2["default"] || n2;
        }
        var colorName = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
        var conversions = createCommonjsModule(function(module3) {
          var reverseKeywords = {};
          for (var key in colorName) {
            if (colorName.hasOwnProperty(key)) {
              reverseKeywords[colorName[key]] = key;
            }
          }
          var convert2 = module3.exports = {
            rgb: { channels: 3, labels: "rgb" },
            hsl: { channels: 3, labels: "hsl" },
            hsv: { channels: 3, labels: "hsv" },
            hwb: { channels: 3, labels: "hwb" },
            cmyk: { channels: 4, labels: "cmyk" },
            xyz: { channels: 3, labels: "xyz" },
            lab: { channels: 3, labels: "lab" },
            lch: { channels: 3, labels: "lch" },
            hex: { channels: 1, labels: ["hex"] },
            keyword: { channels: 1, labels: ["keyword"] },
            ansi16: { channels: 1, labels: ["ansi16"] },
            ansi256: { channels: 1, labels: ["ansi256"] },
            hcg: { channels: 3, labels: ["h", "c", "g"] },
            apple: { channels: 3, labels: ["r16", "g16", "b16"] },
            gray: { channels: 1, labels: ["gray"] }
          };
          for (var model in convert2) {
            if (convert2.hasOwnProperty(model)) {
              if (!("channels" in convert2[model])) {
                throw new Error("missing channels property: " + model);
              }
              if (!("labels" in convert2[model])) {
                throw new Error("missing channel labels property: " + model);
              }
              if (convert2[model].labels.length !== convert2[model].channels) {
                throw new Error("channel and label counts mismatch: " + model);
              }
              var channels = convert2[model].channels;
              var labels = convert2[model].labels;
              delete convert2[model].channels;
              delete convert2[model].labels;
              Object.defineProperty(convert2[model], "channels", { value: channels });
              Object.defineProperty(convert2[model], "labels", { value: labels });
            }
          }
          convert2.rgb.hsl = function(rgb) {
            var r2 = rgb[0] / 255;
            var g2 = rgb[1] / 255;
            var b = rgb[2] / 255;
            var min2 = Math.min(r2, g2, b);
            var max2 = Math.max(r2, g2, b);
            var delta = max2 - min2;
            var h2;
            var s2;
            var l2;
            if (max2 === min2) {
              h2 = 0;
            } else if (r2 === max2) {
              h2 = (g2 - b) / delta;
            } else if (g2 === max2) {
              h2 = 2 + (b - r2) / delta;
            } else if (b === max2) {
              h2 = 4 + (r2 - g2) / delta;
            }
            h2 = Math.min(h2 * 60, 360);
            if (h2 < 0) {
              h2 += 360;
            }
            l2 = (min2 + max2) / 2;
            if (max2 === min2) {
              s2 = 0;
            } else if (l2 <= 0.5) {
              s2 = delta / (max2 + min2);
            } else {
              s2 = delta / (2 - max2 - min2);
            }
            return [h2, s2 * 100, l2 * 100];
          };
          convert2.rgb.hsv = function(rgb) {
            var rdif;
            var gdif;
            var bdif;
            var h2;
            var s2;
            var r2 = rgb[0] / 255;
            var g2 = rgb[1] / 255;
            var b = rgb[2] / 255;
            var v2 = Math.max(r2, g2, b);
            var diff2 = v2 - Math.min(r2, g2, b);
            var diffc = function(c) {
              return (v2 - c) / 6 / diff2 + 1 / 2;
            };
            if (diff2 === 0) {
              h2 = s2 = 0;
            } else {
              s2 = diff2 / v2;
              rdif = diffc(r2);
              gdif = diffc(g2);
              bdif = diffc(b);
              if (r2 === v2) {
                h2 = bdif - gdif;
              } else if (g2 === v2) {
                h2 = 1 / 3 + rdif - bdif;
              } else if (b === v2) {
                h2 = 2 / 3 + gdif - rdif;
              }
              if (h2 < 0) {
                h2 += 1;
              } else if (h2 > 1) {
                h2 -= 1;
              }
            }
            return [
              h2 * 360,
              s2 * 100,
              v2 * 100
            ];
          };
          convert2.rgb.hwb = function(rgb) {
            var r2 = rgb[0];
            var g2 = rgb[1];
            var b = rgb[2];
            var h2 = convert2.rgb.hsl(rgb)[0];
            var w2 = 1 / 255 * Math.min(r2, Math.min(g2, b));
            b = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b));
            return [h2, w2 * 100, b * 100];
          };
          convert2.rgb.cmyk = function(rgb) {
            var r2 = rgb[0] / 255;
            var g2 = rgb[1] / 255;
            var b = rgb[2] / 255;
            var c;
            var m2;
            var y2;
            var k2;
            k2 = Math.min(1 - r2, 1 - g2, 1 - b);
            c = (1 - r2 - k2) / (1 - k2) || 0;
            m2 = (1 - g2 - k2) / (1 - k2) || 0;
            y2 = (1 - b - k2) / (1 - k2) || 0;
            return [c * 100, m2 * 100, y2 * 100, k2 * 100];
          };
          function comparativeDistance(x2, y2) {
            return Math.pow(x2[0] - y2[0], 2) + Math.pow(x2[1] - y2[1], 2) + Math.pow(x2[2] - y2[2], 2);
          }
          convert2.rgb.keyword = function(rgb) {
            var reversed = reverseKeywords[rgb];
            if (reversed) {
              return reversed;
            }
            var currentClosestDistance = Infinity;
            var currentClosestKeyword;
            for (var keyword2 in colorName) {
              if (colorName.hasOwnProperty(keyword2)) {
                var value2 = colorName[keyword2];
                var distance = comparativeDistance(rgb, value2);
                if (distance < currentClosestDistance) {
                  currentClosestDistance = distance;
                  currentClosestKeyword = keyword2;
                }
              }
            }
            return currentClosestKeyword;
          };
          convert2.keyword.rgb = function(keyword2) {
            return colorName[keyword2];
          };
          convert2.rgb.xyz = function(rgb) {
            var r2 = rgb[0] / 255;
            var g2 = rgb[1] / 255;
            var b = rgb[2] / 255;
            r2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92;
            g2 = g2 > 0.04045 ? Math.pow((g2 + 0.055) / 1.055, 2.4) : g2 / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
            var x2 = r2 * 0.4124 + g2 * 0.3576 + b * 0.1805;
            var y2 = r2 * 0.2126 + g2 * 0.7152 + b * 0.0722;
            var z2 = r2 * 0.0193 + g2 * 0.1192 + b * 0.9505;
            return [x2 * 100, y2 * 100, z2 * 100];
          };
          convert2.rgb.lab = function(rgb) {
            var xyz = convert2.rgb.xyz(rgb);
            var x2 = xyz[0];
            var y2 = xyz[1];
            var z2 = xyz[2];
            var l2;
            var a2;
            var b;
            x2 /= 95.047;
            y2 /= 100;
            z2 /= 108.883;
            x2 = x2 > 8856e-6 ? Math.pow(x2, 1 / 3) : 7.787 * x2 + 16 / 116;
            y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
            z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
            l2 = 116 * y2 - 16;
            a2 = 500 * (x2 - y2);
            b = 200 * (y2 - z2);
            return [l2, a2, b];
          };
          convert2.hsl.rgb = function(hsl) {
            var h2 = hsl[0] / 360;
            var s2 = hsl[1] / 100;
            var l2 = hsl[2] / 100;
            var t1;
            var t2;
            var t3;
            var rgb;
            var val;
            if (s2 === 0) {
              val = l2 * 255;
              return [val, val, val];
            }
            if (l2 < 0.5) {
              t2 = l2 * (1 + s2);
            } else {
              t2 = l2 + s2 - l2 * s2;
            }
            t1 = 2 * l2 - t2;
            rgb = [0, 0, 0];
            for (var i2 = 0; i2 < 3; i2++) {
              t3 = h2 + 1 / 3 * -(i2 - 1);
              if (t3 < 0) {
                t3++;
              }
              if (t3 > 1) {
                t3--;
              }
              if (6 * t3 < 1) {
                val = t1 + (t2 - t1) * 6 * t3;
              } else if (2 * t3 < 1) {
                val = t2;
              } else if (3 * t3 < 2) {
                val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
              } else {
                val = t1;
              }
              rgb[i2] = val * 255;
            }
            return rgb;
          };
          convert2.hsl.hsv = function(hsl) {
            var h2 = hsl[0];
            var s2 = hsl[1] / 100;
            var l2 = hsl[2] / 100;
            var smin = s2;
            var lmin = Math.max(l2, 0.01);
            var sv;
            var v2;
            l2 *= 2;
            s2 *= l2 <= 1 ? l2 : 2 - l2;
            smin *= lmin <= 1 ? lmin : 2 - lmin;
            v2 = (l2 + s2) / 2;
            sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
            return [h2, sv * 100, v2 * 100];
          };
          convert2.hsv.rgb = function(hsv) {
            var h2 = hsv[0] / 60;
            var s2 = hsv[1] / 100;
            var v2 = hsv[2] / 100;
            var hi2 = Math.floor(h2) % 6;
            var f2 = h2 - Math.floor(h2);
            var p2 = 255 * v2 * (1 - s2);
            var q2 = 255 * v2 * (1 - s2 * f2);
            var t2 = 255 * v2 * (1 - s2 * (1 - f2));
            v2 *= 255;
            switch (hi2) {
              case 0:
                return [v2, t2, p2];
              case 1:
                return [q2, v2, p2];
              case 2:
                return [p2, v2, t2];
              case 3:
                return [p2, q2, v2];
              case 4:
                return [t2, p2, v2];
              case 5:
                return [v2, p2, q2];
            }
          };
          convert2.hsv.hsl = function(hsv) {
            var h2 = hsv[0];
            var s2 = hsv[1] / 100;
            var v2 = hsv[2] / 100;
            var vmin = Math.max(v2, 0.01);
            var lmin;
            var sl;
            var l2;
            l2 = (2 - s2) * v2;
            lmin = (2 - s2) * vmin;
            sl = s2 * vmin;
            sl /= lmin <= 1 ? lmin : 2 - lmin;
            sl = sl || 0;
            l2 /= 2;
            return [h2, sl * 100, l2 * 100];
          };
          convert2.hwb.rgb = function(hwb) {
            var h2 = hwb[0] / 360;
            var wh2 = hwb[1] / 100;
            var bl = hwb[2] / 100;
            var ratio = wh2 + bl;
            var i2;
            var v2;
            var f2;
            var n2;
            if (ratio > 1) {
              wh2 /= ratio;
              bl /= ratio;
            }
            i2 = Math.floor(6 * h2);
            v2 = 1 - bl;
            f2 = 6 * h2 - i2;
            if ((i2 & 1) !== 0) {
              f2 = 1 - f2;
            }
            n2 = wh2 + f2 * (v2 - wh2);
            var r2;
            var g2;
            var b;
            switch (i2) {
              default:
              case 6:
              case 0:
                r2 = v2;
                g2 = n2;
                b = wh2;
                break;
              case 1:
                r2 = n2;
                g2 = v2;
                b = wh2;
                break;
              case 2:
                r2 = wh2;
                g2 = v2;
                b = n2;
                break;
              case 3:
                r2 = wh2;
                g2 = n2;
                b = v2;
                break;
              case 4:
                r2 = n2;
                g2 = wh2;
                b = v2;
                break;
              case 5:
                r2 = v2;
                g2 = wh2;
                b = n2;
                break;
            }
            return [r2 * 255, g2 * 255, b * 255];
          };
          convert2.cmyk.rgb = function(cmyk) {
            var c = cmyk[0] / 100;
            var m2 = cmyk[1] / 100;
            var y2 = cmyk[2] / 100;
            var k2 = cmyk[3] / 100;
            var r2;
            var g2;
            var b;
            r2 = 1 - Math.min(1, c * (1 - k2) + k2);
            g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
            b = 1 - Math.min(1, y2 * (1 - k2) + k2);
            return [r2 * 255, g2 * 255, b * 255];
          };
          convert2.xyz.rgb = function(xyz) {
            var x2 = xyz[0] / 100;
            var y2 = xyz[1] / 100;
            var z2 = xyz[2] / 100;
            var r2;
            var g2;
            var b;
            r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
            g2 = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
            b = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
            r2 = r2 > 31308e-7 ? 1.055 * Math.pow(r2, 1 / 2.4) - 0.055 : r2 * 12.92;
            g2 = g2 > 31308e-7 ? 1.055 * Math.pow(g2, 1 / 2.4) - 0.055 : g2 * 12.92;
            b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
            r2 = Math.min(Math.max(0, r2), 1);
            g2 = Math.min(Math.max(0, g2), 1);
            b = Math.min(Math.max(0, b), 1);
            return [r2 * 255, g2 * 255, b * 255];
          };
          convert2.xyz.lab = function(xyz) {
            var x2 = xyz[0];
            var y2 = xyz[1];
            var z2 = xyz[2];
            var l2;
            var a2;
            var b;
            x2 /= 95.047;
            y2 /= 100;
            z2 /= 108.883;
            x2 = x2 > 8856e-6 ? Math.pow(x2, 1 / 3) : 7.787 * x2 + 16 / 116;
            y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
            z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
            l2 = 116 * y2 - 16;
            a2 = 500 * (x2 - y2);
            b = 200 * (y2 - z2);
            return [l2, a2, b];
          };
          convert2.lab.xyz = function(lab) {
            var l2 = lab[0];
            var a2 = lab[1];
            var b = lab[2];
            var x2;
            var y2;
            var z2;
            y2 = (l2 + 16) / 116;
            x2 = a2 / 500 + y2;
            z2 = y2 - b / 200;
            var y22 = Math.pow(y2, 3);
            var x22 = Math.pow(x2, 3);
            var z22 = Math.pow(z2, 3);
            y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
            x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
            z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
            x2 *= 95.047;
            y2 *= 100;
            z2 *= 108.883;
            return [x2, y2, z2];
          };
          convert2.lab.lch = function(lab) {
            var l2 = lab[0];
            var a2 = lab[1];
            var b = lab[2];
            var hr;
            var h2;
            var c;
            hr = Math.atan2(b, a2);
            h2 = hr * 360 / 2 / Math.PI;
            if (h2 < 0) {
              h2 += 360;
            }
            c = Math.sqrt(a2 * a2 + b * b);
            return [l2, c, h2];
          };
          convert2.lch.lab = function(lch) {
            var l2 = lch[0];
            var c = lch[1];
            var h2 = lch[2];
            var a2;
            var b;
            var hr;
            hr = h2 / 360 * 2 * Math.PI;
            a2 = c * Math.cos(hr);
            b = c * Math.sin(hr);
            return [l2, a2, b];
          };
          convert2.rgb.ansi16 = function(args) {
            var r2 = args[0];
            var g2 = args[1];
            var b = args[2];
            var value2 = 1 in arguments ? arguments[1] : convert2.rgb.hsv(args)[2];
            value2 = Math.round(value2 / 50);
            if (value2 === 0) {
              return 30;
            }
            var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
            if (value2 === 2) {
              ansi += 60;
            }
            return ansi;
          };
          convert2.hsv.ansi16 = function(args) {
            return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
          };
          convert2.rgb.ansi256 = function(args) {
            var r2 = args[0];
            var g2 = args[1];
            var b = args[2];
            if (r2 === g2 && g2 === b) {
              if (r2 < 8) {
                return 16;
              }
              if (r2 > 248) {
                return 231;
              }
              return Math.round((r2 - 8) / 247 * 24) + 232;
            }
            var ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b / 255 * 5);
            return ansi;
          };
          convert2.ansi16.rgb = function(args) {
            var color = args % 10;
            if (color === 0 || color === 7) {
              if (args > 50) {
                color += 3.5;
              }
              color = color / 10.5 * 255;
              return [color, color, color];
            }
            var mult = (~~(args > 50) + 1) * 0.5;
            var r2 = (color & 1) * mult * 255;
            var g2 = (color >> 1 & 1) * mult * 255;
            var b = (color >> 2 & 1) * mult * 255;
            return [r2, g2, b];
          };
          convert2.ansi256.rgb = function(args) {
            if (args >= 232) {
              var c = (args - 232) * 10 + 8;
              return [c, c, c];
            }
            args -= 16;
            var rem;
            var r2 = Math.floor(args / 36) / 5 * 255;
            var g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
            var b = rem % 6 / 5 * 255;
            return [r2, g2, b];
          };
          convert2.rgb.hex = function(args) {
            var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
            var string = integer.toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          };
          convert2.hex.rgb = function(args) {
            var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
            if (!match) {
              return [0, 0, 0];
            }
            var colorString2 = match[0];
            if (match[0].length === 3) {
              colorString2 = colorString2.split("").map(function(char) {
                return char + char;
              }).join("");
            }
            var integer = parseInt(colorString2, 16);
            var r2 = integer >> 16 & 255;
            var g2 = integer >> 8 & 255;
            var b = integer & 255;
            return [r2, g2, b];
          };
          convert2.rgb.hcg = function(rgb) {
            var r2 = rgb[0] / 255;
            var g2 = rgb[1] / 255;
            var b = rgb[2] / 255;
            var max2 = Math.max(Math.max(r2, g2), b);
            var min2 = Math.min(Math.min(r2, g2), b);
            var chroma = max2 - min2;
            var grayscale;
            var hue;
            if (chroma < 1) {
              grayscale = min2 / (1 - chroma);
            } else {
              grayscale = 0;
            }
            if (chroma <= 0) {
              hue = 0;
            } else if (max2 === r2) {
              hue = (g2 - b) / chroma % 6;
            } else if (max2 === g2) {
              hue = 2 + (b - r2) / chroma;
            } else {
              hue = 4 + (r2 - g2) / chroma + 4;
            }
            hue /= 6;
            hue %= 1;
            return [hue * 360, chroma * 100, grayscale * 100];
          };
          convert2.hsl.hcg = function(hsl) {
            var s2 = hsl[1] / 100;
            var l2 = hsl[2] / 100;
            var c = 1;
            var f2 = 0;
            if (l2 < 0.5) {
              c = 2 * s2 * l2;
            } else {
              c = 2 * s2 * (1 - l2);
            }
            if (c < 1) {
              f2 = (l2 - 0.5 * c) / (1 - c);
            }
            return [hsl[0], c * 100, f2 * 100];
          };
          convert2.hsv.hcg = function(hsv) {
            var s2 = hsv[1] / 100;
            var v2 = hsv[2] / 100;
            var c = s2 * v2;
            var f2 = 0;
            if (c < 1) {
              f2 = (v2 - c) / (1 - c);
            }
            return [hsv[0], c * 100, f2 * 100];
          };
          convert2.hcg.rgb = function(hcg) {
            var h2 = hcg[0] / 360;
            var c = hcg[1] / 100;
            var g2 = hcg[2] / 100;
            if (c === 0) {
              return [g2 * 255, g2 * 255, g2 * 255];
            }
            var pure = [0, 0, 0];
            var hi2 = h2 % 1 * 6;
            var v2 = hi2 % 1;
            var w2 = 1 - v2;
            var mg2 = 0;
            switch (Math.floor(hi2)) {
              case 0:
                pure[0] = 1;
                pure[1] = v2;
                pure[2] = 0;
                break;
              case 1:
                pure[0] = w2;
                pure[1] = 1;
                pure[2] = 0;
                break;
              case 2:
                pure[0] = 0;
                pure[1] = 1;
                pure[2] = v2;
                break;
              case 3:
                pure[0] = 0;
                pure[1] = w2;
                pure[2] = 1;
                break;
              case 4:
                pure[0] = v2;
                pure[1] = 0;
                pure[2] = 1;
                break;
              default:
                pure[0] = 1;
                pure[1] = 0;
                pure[2] = w2;
            }
            mg2 = (1 - c) * g2;
            return [
              (c * pure[0] + mg2) * 255,
              (c * pure[1] + mg2) * 255,
              (c * pure[2] + mg2) * 255
            ];
          };
          convert2.hcg.hsv = function(hcg) {
            var c = hcg[1] / 100;
            var g2 = hcg[2] / 100;
            var v2 = c + g2 * (1 - c);
            var f2 = 0;
            if (v2 > 0) {
              f2 = c / v2;
            }
            return [hcg[0], f2 * 100, v2 * 100];
          };
          convert2.hcg.hsl = function(hcg) {
            var c = hcg[1] / 100;
            var g2 = hcg[2] / 100;
            var l2 = g2 * (1 - c) + 0.5 * c;
            var s2 = 0;
            if (l2 > 0 && l2 < 0.5) {
              s2 = c / (2 * l2);
            } else if (l2 >= 0.5 && l2 < 1) {
              s2 = c / (2 * (1 - l2));
            }
            return [hcg[0], s2 * 100, l2 * 100];
          };
          convert2.hcg.hwb = function(hcg) {
            var c = hcg[1] / 100;
            var g2 = hcg[2] / 100;
            var v2 = c + g2 * (1 - c);
            return [hcg[0], (v2 - c) * 100, (1 - v2) * 100];
          };
          convert2.hwb.hcg = function(hwb) {
            var w2 = hwb[1] / 100;
            var b = hwb[2] / 100;
            var v2 = 1 - b;
            var c = v2 - w2;
            var g2 = 0;
            if (c < 1) {
              g2 = (v2 - c) / (1 - c);
            }
            return [hwb[0], c * 100, g2 * 100];
          };
          convert2.apple.rgb = function(apple) {
            return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
          };
          convert2.rgb.apple = function(rgb) {
            return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
          };
          convert2.gray.rgb = function(args) {
            return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
          };
          convert2.gray.hsl = convert2.gray.hsv = function(args) {
            return [0, 0, args[0]];
          };
          convert2.gray.hwb = function(gray) {
            return [0, 100, gray[0]];
          };
          convert2.gray.cmyk = function(gray) {
            return [0, 0, 0, gray[0]];
          };
          convert2.gray.lab = function(gray) {
            return [gray[0], 0, 0];
          };
          convert2.gray.hex = function(gray) {
            var val = Math.round(gray[0] / 100 * 255) & 255;
            var integer = (val << 16) + (val << 8) + val;
            var string = integer.toString(16).toUpperCase();
            return "000000".substring(string.length) + string;
          };
          convert2.rgb.gray = function(rgb) {
            var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
            return [val / 255 * 100];
          };
        });
        conversions.rgb;
        conversions.hsl;
        conversions.hsv;
        conversions.hwb;
        conversions.cmyk;
        conversions.xyz;
        conversions.lab;
        conversions.lch;
        conversions.hex;
        conversions.keyword;
        conversions.ansi16;
        conversions.ansi256;
        conversions.hcg;
        conversions.apple;
        conversions.gray;
        function buildGraph() {
          var graph = {};
          var models2 = Object.keys(conversions);
          for (var len = models2.length, i2 = 0; i2 < len; i2++) {
            graph[models2[i2]] = {
              distance: -1,
              parent: null
            };
          }
          return graph;
        }
        function deriveBFS(fromModel) {
          var graph = buildGraph();
          var queue2 = [fromModel];
          graph[fromModel].distance = 0;
          while (queue2.length) {
            var current = queue2.pop();
            var adjacents = Object.keys(conversions[current]);
            for (var len = adjacents.length, i2 = 0; i2 < len; i2++) {
              var adjacent = adjacents[i2];
              var node = graph[adjacent];
              if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue2.unshift(adjacent);
              }
            }
          }
          return graph;
        }
        function link(from2, to2) {
          return function(args) {
            return to2(from2(args));
          };
        }
        function wrapConversion(toModel, graph) {
          var path = [graph[toModel].parent, toModel];
          var fn = conversions[graph[toModel].parent][toModel];
          var cur = graph[toModel].parent;
          while (graph[cur].parent) {
            path.unshift(graph[cur].parent);
            fn = link(conversions[graph[cur].parent][cur], fn);
            cur = graph[cur].parent;
          }
          fn.conversion = path;
          return fn;
        }
        var route = function(fromModel) {
          var graph = deriveBFS(fromModel);
          var conversion = {};
          var models2 = Object.keys(graph);
          for (var len = models2.length, i2 = 0; i2 < len; i2++) {
            var toModel = models2[i2];
            var node = graph[toModel];
            if (node.parent === null) {
              continue;
            }
            conversion[toModel] = wrapConversion(toModel, graph);
          }
          return conversion;
        };
        var convert = {};
        var models = Object.keys(conversions);
        function wrapRaw(fn) {
          var wrappedFn = function(args) {
            if (args === void 0 || args === null) {
              return args;
            }
            if (arguments.length > 1) {
              args = Array.prototype.slice.call(arguments);
            }
            return fn(args);
          };
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        function wrapRounded(fn) {
          var wrappedFn = function(args) {
            if (args === void 0 || args === null) {
              return args;
            }
            if (arguments.length > 1) {
              args = Array.prototype.slice.call(arguments);
            }
            var result2 = fn(args);
            if (typeof result2 === "object") {
              for (var len = result2.length, i2 = 0; i2 < len; i2++) {
                result2[i2] = Math.round(result2[i2]);
              }
            }
            return result2;
          };
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        models.forEach(function(fromModel) {
          convert[fromModel] = {};
          Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
          Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
          var routes = route(fromModel);
          var routeModels = Object.keys(routes);
          routeModels.forEach(function(toModel) {
            var fn = routes[toModel];
            convert[fromModel][toModel] = wrapRounded(fn);
            convert[fromModel][toModel].raw = wrapRaw(fn);
          });
        });
        var colorConvert = convert;
        var colorName$1 = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
        var colorString = {
          getRgba,
          getHsla,
          getRgb,
          getHsl,
          getHwb,
          getAlpha,
          hexString,
          rgbString,
          rgbaString,
          percentString,
          percentaString,
          hslString,
          hslaString,
          hwbString,
          keyword
        };
        function getRgba(string) {
          if (!string) {
            return;
          }
          var abbr = /^#([a-fA-F0-9]{3,4})$/i, hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i, rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, keyword2 = /(\w+)/;
          var rgb = [0, 0, 0], a2 = 1, match = string.match(abbr), hexAlpha = "";
          if (match) {
            match = match[1];
            hexAlpha = match[3];
            for (var i2 = 0; i2 < rgb.length; i2++) {
              rgb[i2] = parseInt(match[i2] + match[i2], 16);
            }
            if (hexAlpha) {
              a2 = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
            }
          } else if (match = string.match(hex)) {
            hexAlpha = match[2];
            match = match[1];
            for (var i2 = 0; i2 < rgb.length; i2++) {
              rgb[i2] = parseInt(match.slice(i2 * 2, i2 * 2 + 2), 16);
            }
            if (hexAlpha) {
              a2 = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
            }
          } else if (match = string.match(rgba)) {
            for (var i2 = 0; i2 < rgb.length; i2++) {
              rgb[i2] = parseInt(match[i2 + 1]);
            }
            a2 = parseFloat(match[4]);
          } else if (match = string.match(per)) {
            for (var i2 = 0; i2 < rgb.length; i2++) {
              rgb[i2] = Math.round(parseFloat(match[i2 + 1]) * 2.55);
            }
            a2 = parseFloat(match[4]);
          } else if (match = string.match(keyword2)) {
            if (match[1] == "transparent") {
              return [0, 0, 0, 0];
            }
            rgb = colorName$1[match[1]];
            if (!rgb) {
              return;
            }
          }
          for (var i2 = 0; i2 < rgb.length; i2++) {
            rgb[i2] = scale(rgb[i2], 0, 255);
          }
          if (!a2 && a2 != 0) {
            a2 = 1;
          } else {
            a2 = scale(a2, 0, 1);
          }
          rgb[3] = a2;
          return rgb;
        }
        function getHsla(string) {
          if (!string) {
            return;
          }
          var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
          var match = string.match(hsl);
          if (match) {
            var alpha = parseFloat(match[4]);
            var h2 = scale(parseInt(match[1]), 0, 360), s2 = scale(parseFloat(match[2]), 0, 100), l2 = scale(parseFloat(match[3]), 0, 100), a2 = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
            return [h2, s2, l2, a2];
          }
        }
        function getHwb(string) {
          if (!string) {
            return;
          }
          var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
          var match = string.match(hwb);
          if (match) {
            var alpha = parseFloat(match[4]);
            var h2 = scale(parseInt(match[1]), 0, 360), w2 = scale(parseFloat(match[2]), 0, 100), b = scale(parseFloat(match[3]), 0, 100), a2 = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
            return [h2, w2, b, a2];
          }
        }
        function getRgb(string) {
          var rgba = getRgba(string);
          return rgba && rgba.slice(0, 3);
        }
        function getHsl(string) {
          var hsla = getHsla(string);
          return hsla && hsla.slice(0, 3);
        }
        function getAlpha(string) {
          var vals = getRgba(string);
          if (vals) {
            return vals[3];
          } else if (vals = getHsla(string)) {
            return vals[3];
          } else if (vals = getHwb(string)) {
            return vals[3];
          }
        }
        function hexString(rgba, a2) {
          var a2 = a2 !== void 0 && rgba.length === 3 ? a2 : rgba[3];
          return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a2 >= 0 && a2 < 1 ? hexDouble(Math.round(a2 * 255)) : "");
        }
        function rgbString(rgba, alpha) {
          if (alpha < 1 || rgba[3] && rgba[3] < 1) {
            return rgbaString(rgba, alpha);
          }
          return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
        }
        function rgbaString(rgba, alpha) {
          if (alpha === void 0) {
            alpha = rgba[3] !== void 0 ? rgba[3] : 1;
          }
          return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
        }
        function percentString(rgba, alpha) {
          if (alpha < 1 || rgba[3] && rgba[3] < 1) {
            return percentaString(rgba, alpha);
          }
          var r2 = Math.round(rgba[0] / 255 * 100), g2 = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
          return "rgb(" + r2 + "%, " + g2 + "%, " + b + "%)";
        }
        function percentaString(rgba, alpha) {
          var r2 = Math.round(rgba[0] / 255 * 100), g2 = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
          return "rgba(" + r2 + "%, " + g2 + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
        }
        function hslString(hsla, alpha) {
          if (alpha < 1 || hsla[3] && hsla[3] < 1) {
            return hslaString(hsla, alpha);
          }
          return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
        }
        function hslaString(hsla, alpha) {
          if (alpha === void 0) {
            alpha = hsla[3] !== void 0 ? hsla[3] : 1;
          }
          return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
        }
        function hwbString(hwb, alpha) {
          if (alpha === void 0) {
            alpha = hwb[3] !== void 0 ? hwb[3] : 1;
          }
          return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== void 0 && alpha !== 1 ? ", " + alpha : "") + ")";
        }
        function keyword(rgb) {
          return reverseNames[rgb.slice(0, 3)];
        }
        function scale(num, min2, max2) {
          return Math.min(Math.max(min2, num), max2);
        }
        function hexDouble(num) {
          var str = num.toString(16).toUpperCase();
          return str.length < 2 ? "0" + str : str;
        }
        var reverseNames = {};
        for (var name in colorName$1) {
          reverseNames[colorName$1[name]] = name;
        }
        var Color = function(obj) {
          if (obj instanceof Color) {
            return obj;
          }
          if (!(this instanceof Color)) {
            return new Color(obj);
          }
          this.valid = false;
          this.values = {
            rgb: [0, 0, 0],
            hsl: [0, 0, 0],
            hsv: [0, 0, 0],
            hwb: [0, 0, 0],
            cmyk: [0, 0, 0, 0],
            alpha: 1
          };
          var vals;
          if (typeof obj === "string") {
            vals = colorString.getRgba(obj);
            if (vals) {
              this.setValues("rgb", vals);
            } else if (vals = colorString.getHsla(obj)) {
              this.setValues("hsl", vals);
            } else if (vals = colorString.getHwb(obj)) {
              this.setValues("hwb", vals);
            }
          } else if (typeof obj === "object") {
            vals = obj;
            if (vals.r !== void 0 || vals.red !== void 0) {
              this.setValues("rgb", vals);
            } else if (vals.l !== void 0 || vals.lightness !== void 0) {
              this.setValues("hsl", vals);
            } else if (vals.v !== void 0 || vals.value !== void 0) {
              this.setValues("hsv", vals);
            } else if (vals.w !== void 0 || vals.whiteness !== void 0) {
              this.setValues("hwb", vals);
            } else if (vals.c !== void 0 || vals.cyan !== void 0) {
              this.setValues("cmyk", vals);
            }
          }
        };
        Color.prototype = {
          isValid: function() {
            return this.valid;
          },
          rgb: function() {
            return this.setSpace("rgb", arguments);
          },
          hsl: function() {
            return this.setSpace("hsl", arguments);
          },
          hsv: function() {
            return this.setSpace("hsv", arguments);
          },
          hwb: function() {
            return this.setSpace("hwb", arguments);
          },
          cmyk: function() {
            return this.setSpace("cmyk", arguments);
          },
          rgbArray: function() {
            return this.values.rgb;
          },
          hslArray: function() {
            return this.values.hsl;
          },
          hsvArray: function() {
            return this.values.hsv;
          },
          hwbArray: function() {
            var values2 = this.values;
            if (values2.alpha !== 1) {
              return values2.hwb.concat([values2.alpha]);
            }
            return values2.hwb;
          },
          cmykArray: function() {
            return this.values.cmyk;
          },
          rgbaArray: function() {
            var values2 = this.values;
            return values2.rgb.concat([values2.alpha]);
          },
          hslaArray: function() {
            var values2 = this.values;
            return values2.hsl.concat([values2.alpha]);
          },
          alpha: function(val) {
            if (val === void 0) {
              return this.values.alpha;
            }
            this.setValues("alpha", val);
            return this;
          },
          red: function(val) {
            return this.setChannel("rgb", 0, val);
          },
          green: function(val) {
            return this.setChannel("rgb", 1, val);
          },
          blue: function(val) {
            return this.setChannel("rgb", 2, val);
          },
          hue: function(val) {
            if (val) {
              val %= 360;
              val = val < 0 ? 360 + val : val;
            }
            return this.setChannel("hsl", 0, val);
          },
          saturation: function(val) {
            return this.setChannel("hsl", 1, val);
          },
          lightness: function(val) {
            return this.setChannel("hsl", 2, val);
          },
          saturationv: function(val) {
            return this.setChannel("hsv", 1, val);
          },
          whiteness: function(val) {
            return this.setChannel("hwb", 1, val);
          },
          blackness: function(val) {
            return this.setChannel("hwb", 2, val);
          },
          value: function(val) {
            return this.setChannel("hsv", 2, val);
          },
          cyan: function(val) {
            return this.setChannel("cmyk", 0, val);
          },
          magenta: function(val) {
            return this.setChannel("cmyk", 1, val);
          },
          yellow: function(val) {
            return this.setChannel("cmyk", 2, val);
          },
          black: function(val) {
            return this.setChannel("cmyk", 3, val);
          },
          hexString: function() {
            return colorString.hexString(this.values.rgb);
          },
          rgbString: function() {
            return colorString.rgbString(this.values.rgb, this.values.alpha);
          },
          rgbaString: function() {
            return colorString.rgbaString(this.values.rgb, this.values.alpha);
          },
          percentString: function() {
            return colorString.percentString(this.values.rgb, this.values.alpha);
          },
          hslString: function() {
            return colorString.hslString(this.values.hsl, this.values.alpha);
          },
          hslaString: function() {
            return colorString.hslaString(this.values.hsl, this.values.alpha);
          },
          hwbString: function() {
            return colorString.hwbString(this.values.hwb, this.values.alpha);
          },
          keyword: function() {
            return colorString.keyword(this.values.rgb, this.values.alpha);
          },
          rgbNumber: function() {
            var rgb = this.values.rgb;
            return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
          },
          luminosity: function() {
            var rgb = this.values.rgb;
            var lum = [];
            for (var i2 = 0; i2 < rgb.length; i2++) {
              var chan = rgb[i2] / 255;
              lum[i2] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
          },
          contrast: function(color2) {
            var lum1 = this.luminosity();
            var lum2 = color2.luminosity();
            if (lum1 > lum2) {
              return (lum1 + 0.05) / (lum2 + 0.05);
            }
            return (lum2 + 0.05) / (lum1 + 0.05);
          },
          level: function(color2) {
            var contrastRatio = this.contrast(color2);
            if (contrastRatio >= 7.1) {
              return "AAA";
            }
            return contrastRatio >= 4.5 ? "AA" : "";
          },
          dark: function() {
            var rgb = this.values.rgb;
            var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
            return yiq < 128;
          },
          light: function() {
            return !this.dark();
          },
          negate: function() {
            var rgb = [];
            for (var i2 = 0; i2 < 3; i2++) {
              rgb[i2] = 255 - this.values.rgb[i2];
            }
            this.setValues("rgb", rgb);
            return this;
          },
          lighten: function(ratio) {
            var hsl = this.values.hsl;
            hsl[2] += hsl[2] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          darken: function(ratio) {
            var hsl = this.values.hsl;
            hsl[2] -= hsl[2] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          saturate: function(ratio) {
            var hsl = this.values.hsl;
            hsl[1] += hsl[1] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          desaturate: function(ratio) {
            var hsl = this.values.hsl;
            hsl[1] -= hsl[1] * ratio;
            this.setValues("hsl", hsl);
            return this;
          },
          whiten: function(ratio) {
            var hwb = this.values.hwb;
            hwb[1] += hwb[1] * ratio;
            this.setValues("hwb", hwb);
            return this;
          },
          blacken: function(ratio) {
            var hwb = this.values.hwb;
            hwb[2] += hwb[2] * ratio;
            this.setValues("hwb", hwb);
            return this;
          },
          greyscale: function() {
            var rgb = this.values.rgb;
            var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
            this.setValues("rgb", [val, val, val]);
            return this;
          },
          clearer: function(ratio) {
            var alpha = this.values.alpha;
            this.setValues("alpha", alpha - alpha * ratio);
            return this;
          },
          opaquer: function(ratio) {
            var alpha = this.values.alpha;
            this.setValues("alpha", alpha + alpha * ratio);
            return this;
          },
          rotate: function(degrees) {
            var hsl = this.values.hsl;
            var hue = (hsl[0] + degrees) % 360;
            hsl[0] = hue < 0 ? 360 + hue : hue;
            this.setValues("hsl", hsl);
            return this;
          },
          mix: function(mixinColor, weight) {
            var color1 = this;
            var color2 = mixinColor;
            var p2 = weight === void 0 ? 0.5 : weight;
            var w2 = 2 * p2 - 1;
            var a2 = color1.alpha() - color2.alpha();
            var w1 = ((w2 * a2 === -1 ? w2 : (w2 + a2) / (1 + w2 * a2)) + 1) / 2;
            var w22 = 1 - w1;
            return this.rgb(
              w1 * color1.red() + w22 * color2.red(),
              w1 * color1.green() + w22 * color2.green(),
              w1 * color1.blue() + w22 * color2.blue()
            ).alpha(color1.alpha() * p2 + color2.alpha() * (1 - p2));
          },
          toJSON: function() {
            return this.rgb();
          },
          clone: function() {
            var result2 = new Color();
            var source = this.values;
            var target = result2.values;
            var value2, type;
            for (var prop in source) {
              if (source.hasOwnProperty(prop)) {
                value2 = source[prop];
                type = {}.toString.call(value2);
                if (type === "[object Array]") {
                  target[prop] = value2.slice(0);
                } else if (type === "[object Number]") {
                  target[prop] = value2;
                } else {
                  console.error("unexpected color value:", value2);
                }
              }
            }
            return result2;
          }
        };
        Color.prototype.spaces = {
          rgb: ["red", "green", "blue"],
          hsl: ["hue", "saturation", "lightness"],
          hsv: ["hue", "saturation", "value"],
          hwb: ["hue", "whiteness", "blackness"],
          cmyk: ["cyan", "magenta", "yellow", "black"]
        };
        Color.prototype.maxes = {
          rgb: [255, 255, 255],
          hsl: [360, 100, 100],
          hsv: [360, 100, 100],
          hwb: [360, 100, 100],
          cmyk: [100, 100, 100, 100]
        };
        Color.prototype.getValues = function(space) {
          var values2 = this.values;
          var vals = {};
          for (var i2 = 0; i2 < space.length; i2++) {
            vals[space.charAt(i2)] = values2[space][i2];
          }
          if (values2.alpha !== 1) {
            vals.a = values2.alpha;
          }
          return vals;
        };
        Color.prototype.setValues = function(space, vals) {
          var values2 = this.values;
          var spaces = this.spaces;
          var maxes = this.maxes;
          var alpha = 1;
          var i2;
          this.valid = true;
          if (space === "alpha") {
            alpha = vals;
          } else if (vals.length) {
            values2[space] = vals.slice(0, space.length);
            alpha = vals[space.length];
          } else if (vals[space.charAt(0)] !== void 0) {
            for (i2 = 0; i2 < space.length; i2++) {
              values2[space][i2] = vals[space.charAt(i2)];
            }
            alpha = vals.a;
          } else if (vals[spaces[space][0]] !== void 0) {
            var chans = spaces[space];
            for (i2 = 0; i2 < space.length; i2++) {
              values2[space][i2] = vals[chans[i2]];
            }
            alpha = vals.alpha;
          }
          values2.alpha = Math.max(0, Math.min(1, alpha === void 0 ? values2.alpha : alpha));
          if (space === "alpha") {
            return false;
          }
          var capped;
          for (i2 = 0; i2 < space.length; i2++) {
            capped = Math.max(0, Math.min(maxes[space][i2], values2[space][i2]));
            values2[space][i2] = Math.round(capped);
          }
          for (var sname in spaces) {
            if (sname !== space) {
              values2[sname] = colorConvert[space][sname](values2[space]);
            }
          }
          return true;
        };
        Color.prototype.setSpace = function(space, args) {
          var vals = args[0];
          if (vals === void 0) {
            return this.getValues(space);
          }
          if (typeof vals === "number") {
            vals = Array.prototype.slice.call(args);
          }
          this.setValues(space, vals);
          return this;
        };
        Color.prototype.setChannel = function(space, index2, val) {
          var svalues = this.values[space];
          if (val === void 0) {
            return svalues[index2];
          } else if (val === svalues[index2]) {
            return this;
          }
          svalues[index2] = val;
          this.setValues(space, svalues);
          return this;
        };
        if (typeof window !== "undefined") {
          window.Color = Color;
        }
        var chartjsColor = Color;
        function isValidKey(key) {
          return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
        }
        var helpers = {
          noop: function() {
          },
          uid: function() {
            var id2 = 0;
            return function() {
              return id2++;
            };
          }(),
          isNullOrUndef: function(value2) {
            return value2 === null || typeof value2 === "undefined";
          },
          isArray: function(value2) {
            if (Array.isArray && Array.isArray(value2)) {
              return true;
            }
            var type = Object.prototype.toString.call(value2);
            if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
              return true;
            }
            return false;
          },
          isObject: function(value2) {
            return value2 !== null && Object.prototype.toString.call(value2) === "[object Object]";
          },
          isFinite: function(value2) {
            return (typeof value2 === "number" || value2 instanceof Number) && isFinite(value2);
          },
          valueOrDefault: function(value2, defaultValue2) {
            return typeof value2 === "undefined" ? defaultValue2 : value2;
          },
          valueAtIndexOrDefault: function(value2, index2, defaultValue2) {
            return helpers.valueOrDefault(helpers.isArray(value2) ? value2[index2] : value2, defaultValue2);
          },
          callback: function(fn, args, thisArg) {
            if (fn && typeof fn.call === "function") {
              return fn.apply(thisArg, args);
            }
          },
          each: function(loopable, fn, thisArg, reverse) {
            var i2, len, keys2;
            if (helpers.isArray(loopable)) {
              len = loopable.length;
              if (reverse) {
                for (i2 = len - 1; i2 >= 0; i2--) {
                  fn.call(thisArg, loopable[i2], i2);
                }
              } else {
                for (i2 = 0; i2 < len; i2++) {
                  fn.call(thisArg, loopable[i2], i2);
                }
              }
            } else if (helpers.isObject(loopable)) {
              keys2 = Object.keys(loopable);
              len = keys2.length;
              for (i2 = 0; i2 < len; i2++) {
                fn.call(thisArg, loopable[keys2[i2]], keys2[i2]);
              }
            }
          },
          arrayEquals: function(a0, a1) {
            var i2, ilen, v0, v1;
            if (!a0 || !a1 || a0.length !== a1.length) {
              return false;
            }
            for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
              v0 = a0[i2];
              v1 = a1[i2];
              if (v0 instanceof Array && v1 instanceof Array) {
                if (!helpers.arrayEquals(v0, v1)) {
                  return false;
                }
              } else if (v0 !== v1) {
                return false;
              }
            }
            return true;
          },
          clone: function(source) {
            if (helpers.isArray(source)) {
              return source.map(helpers.clone);
            }
            if (helpers.isObject(source)) {
              var target = Object.create(source);
              var keys2 = Object.keys(source);
              var klen = keys2.length;
              var k2 = 0;
              for (; k2 < klen; ++k2) {
                target[keys2[k2]] = helpers.clone(source[keys2[k2]]);
              }
              return target;
            }
            return source;
          },
          _merger: function(key, target, source, options2) {
            if (!isValidKey(key)) {
              return;
            }
            var tval = target[key];
            var sval = source[key];
            if (helpers.isObject(tval) && helpers.isObject(sval)) {
              helpers.merge(tval, sval, options2);
            } else {
              target[key] = helpers.clone(sval);
            }
          },
          _mergerIf: function(key, target, source) {
            if (!isValidKey(key)) {
              return;
            }
            var tval = target[key];
            var sval = source[key];
            if (helpers.isObject(tval) && helpers.isObject(sval)) {
              helpers.mergeIf(tval, sval);
            } else if (!target.hasOwnProperty(key)) {
              target[key] = helpers.clone(sval);
            }
          },
          merge: function(target, source, options2) {
            var sources = helpers.isArray(source) ? source : [source];
            var ilen = sources.length;
            var merge2, i2, keys2, klen, k2;
            if (!helpers.isObject(target)) {
              return target;
            }
            options2 = options2 || {};
            merge2 = options2.merger || helpers._merger;
            for (i2 = 0; i2 < ilen; ++i2) {
              source = sources[i2];
              if (!helpers.isObject(source)) {
                continue;
              }
              keys2 = Object.keys(source);
              for (k2 = 0, klen = keys2.length; k2 < klen; ++k2) {
                merge2(keys2[k2], target, source, options2);
              }
            }
            return target;
          },
          mergeIf: function(target, source) {
            return helpers.merge(target, source, { merger: helpers._mergerIf });
          },
          extend: Object.assign || function(target) {
            return helpers.merge(target, [].slice.call(arguments, 1), {
              merger: function(key, dst, src3) {
                dst[key] = src3[key];
              }
            });
          },
          inherits: function(extensions) {
            var me2 = this;
            var ChartElement = extensions && extensions.hasOwnProperty("constructor") ? extensions.constructor : function() {
              return me2.apply(this, arguments);
            };
            var Surrogate = function() {
              this.constructor = ChartElement;
            };
            Surrogate.prototype = me2.prototype;
            ChartElement.prototype = new Surrogate();
            ChartElement.extend = helpers.inherits;
            if (extensions) {
              helpers.extend(ChartElement.prototype, extensions);
            }
            ChartElement.__super__ = me2.prototype;
            return ChartElement;
          },
          _deprecated: function(scope, value2, previous, current) {
            if (value2 !== void 0) {
              console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
            }
          }
        };
        var helpers_core = helpers;
        helpers.callCallback = helpers.callback;
        helpers.indexOf = function(array, item, fromIndex) {
          return Array.prototype.indexOf.call(array, item, fromIndex);
        };
        helpers.getValueOrDefault = helpers.valueOrDefault;
        helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
        var effects = {
          linear: function(t2) {
            return t2;
          },
          easeInQuad: function(t2) {
            return t2 * t2;
          },
          easeOutQuad: function(t2) {
            return -t2 * (t2 - 2);
          },
          easeInOutQuad: function(t2) {
            if ((t2 /= 0.5) < 1) {
              return 0.5 * t2 * t2;
            }
            return -0.5 * (--t2 * (t2 - 2) - 1);
          },
          easeInCubic: function(t2) {
            return t2 * t2 * t2;
          },
          easeOutCubic: function(t2) {
            return (t2 = t2 - 1) * t2 * t2 + 1;
          },
          easeInOutCubic: function(t2) {
            if ((t2 /= 0.5) < 1) {
              return 0.5 * t2 * t2 * t2;
            }
            return 0.5 * ((t2 -= 2) * t2 * t2 + 2);
          },
          easeInQuart: function(t2) {
            return t2 * t2 * t2 * t2;
          },
          easeOutQuart: function(t2) {
            return -((t2 = t2 - 1) * t2 * t2 * t2 - 1);
          },
          easeInOutQuart: function(t2) {
            if ((t2 /= 0.5) < 1) {
              return 0.5 * t2 * t2 * t2 * t2;
            }
            return -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2);
          },
          easeInQuint: function(t2) {
            return t2 * t2 * t2 * t2 * t2;
          },
          easeOutQuint: function(t2) {
            return (t2 = t2 - 1) * t2 * t2 * t2 * t2 + 1;
          },
          easeInOutQuint: function(t2) {
            if ((t2 /= 0.5) < 1) {
              return 0.5 * t2 * t2 * t2 * t2 * t2;
            }
            return 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2);
          },
          easeInSine: function(t2) {
            return -Math.cos(t2 * (Math.PI / 2)) + 1;
          },
          easeOutSine: function(t2) {
            return Math.sin(t2 * (Math.PI / 2));
          },
          easeInOutSine: function(t2) {
            return -0.5 * (Math.cos(Math.PI * t2) - 1);
          },
          easeInExpo: function(t2) {
            return t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1));
          },
          easeOutExpo: function(t2) {
            return t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1;
          },
          easeInOutExpo: function(t2) {
            if (t2 === 0) {
              return 0;
            }
            if (t2 === 1) {
              return 1;
            }
            if ((t2 /= 0.5) < 1) {
              return 0.5 * Math.pow(2, 10 * (t2 - 1));
            }
            return 0.5 * (-Math.pow(2, -10 * --t2) + 2);
          },
          easeInCirc: function(t2) {
            if (t2 >= 1) {
              return t2;
            }
            return -(Math.sqrt(1 - t2 * t2) - 1);
          },
          easeOutCirc: function(t2) {
            return Math.sqrt(1 - (t2 = t2 - 1) * t2);
          },
          easeInOutCirc: function(t2) {
            if ((t2 /= 0.5) < 1) {
              return -0.5 * (Math.sqrt(1 - t2 * t2) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1);
          },
          easeInElastic: function(t2) {
            var s2 = 1.70158;
            var p2 = 0;
            var a2 = 1;
            if (t2 === 0) {
              return 0;
            }
            if (t2 === 1) {
              return 1;
            }
            if (!p2) {
              p2 = 0.3;
            }
            {
              s2 = p2 / (2 * Math.PI) * Math.asin(1 / a2);
            }
            return -(a2 * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s2) * (2 * Math.PI) / p2));
          },
          easeOutElastic: function(t2) {
            var s2 = 1.70158;
            var p2 = 0;
            var a2 = 1;
            if (t2 === 0) {
              return 0;
            }
            if (t2 === 1) {
              return 1;
            }
            if (!p2) {
              p2 = 0.3;
            }
            {
              s2 = p2 / (2 * Math.PI) * Math.asin(1 / a2);
            }
            return a2 * Math.pow(2, -10 * t2) * Math.sin((t2 - s2) * (2 * Math.PI) / p2) + 1;
          },
          easeInOutElastic: function(t2) {
            var s2 = 1.70158;
            var p2 = 0;
            var a2 = 1;
            if (t2 === 0) {
              return 0;
            }
            if ((t2 /= 0.5) === 2) {
              return 1;
            }
            if (!p2) {
              p2 = 0.45;
            }
            {
              s2 = p2 / (2 * Math.PI) * Math.asin(1 / a2);
            }
            if (t2 < 1) {
              return -0.5 * (a2 * Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s2) * (2 * Math.PI) / p2));
            }
            return a2 * Math.pow(2, -10 * (t2 -= 1)) * Math.sin((t2 - s2) * (2 * Math.PI) / p2) * 0.5 + 1;
          },
          easeInBack: function(t2) {
            var s2 = 1.70158;
            return t2 * t2 * ((s2 + 1) * t2 - s2);
          },
          easeOutBack: function(t2) {
            var s2 = 1.70158;
            return (t2 = t2 - 1) * t2 * ((s2 + 1) * t2 + s2) + 1;
          },
          easeInOutBack: function(t2) {
            var s2 = 1.70158;
            if ((t2 /= 0.5) < 1) {
              return 0.5 * (t2 * t2 * (((s2 *= 1.525) + 1) * t2 - s2));
            }
            return 0.5 * ((t2 -= 2) * t2 * (((s2 *= 1.525) + 1) * t2 + s2) + 2);
          },
          easeInBounce: function(t2) {
            return 1 - effects.easeOutBounce(1 - t2);
          },
          easeOutBounce: function(t2) {
            if (t2 < 1 / 2.75) {
              return 7.5625 * t2 * t2;
            }
            if (t2 < 2 / 2.75) {
              return 7.5625 * (t2 -= 1.5 / 2.75) * t2 + 0.75;
            }
            if (t2 < 2.5 / 2.75) {
              return 7.5625 * (t2 -= 2.25 / 2.75) * t2 + 0.9375;
            }
            return 7.5625 * (t2 -= 2.625 / 2.75) * t2 + 0.984375;
          },
          easeInOutBounce: function(t2) {
            if (t2 < 0.5) {
              return effects.easeInBounce(t2 * 2) * 0.5;
            }
            return effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5;
          }
        };
        var helpers_easing = {
          effects
        };
        helpers_core.easingEffects = effects;
        var PI = Math.PI;
        var RAD_PER_DEG = PI / 180;
        var DOUBLE_PI = PI * 2;
        var HALF_PI = PI / 2;
        var QUARTER_PI = PI / 4;
        var TWO_THIRDS_PI = PI * 2 / 3;
        var exports$1 = {
          clear: function(chart) {
            chart.ctx.clearRect(0, 0, chart.width, chart.height);
          },
          roundedRect: function(ctx, x2, y2, width2, height2, radius) {
            if (radius) {
              var r2 = Math.min(radius, height2 / 2, width2 / 2);
              var left = x2 + r2;
              var top = y2 + r2;
              var right = x2 + width2 - r2;
              var bottom = y2 + height2 - r2;
              ctx.moveTo(x2, top);
              if (left < right && top < bottom) {
                ctx.arc(left, top, r2, -PI, -HALF_PI);
                ctx.arc(right, top, r2, -HALF_PI, 0);
                ctx.arc(right, bottom, r2, 0, HALF_PI);
                ctx.arc(left, bottom, r2, HALF_PI, PI);
              } else if (left < right) {
                ctx.moveTo(left, y2);
                ctx.arc(right, top, r2, -HALF_PI, HALF_PI);
                ctx.arc(left, top, r2, HALF_PI, PI + HALF_PI);
              } else if (top < bottom) {
                ctx.arc(left, top, r2, -PI, 0);
                ctx.arc(left, bottom, r2, 0, PI);
              } else {
                ctx.arc(left, top, r2, -PI, PI);
              }
              ctx.closePath();
              ctx.moveTo(x2, y2);
            } else {
              ctx.rect(x2, y2, width2, height2);
            }
          },
          drawPoint: function(ctx, style, radius, x2, y2, rotation) {
            var type, xOffset, yOffset, size2, cornerRadius;
            var rad = (rotation || 0) * RAD_PER_DEG;
            if (style && typeof style === "object") {
              type = style.toString();
              if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
                ctx.save();
                ctx.translate(x2, y2);
                ctx.rotate(rad);
                ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
                ctx.restore();
                return;
              }
            }
            if (isNaN(radius) || radius <= 0) {
              return;
            }
            ctx.beginPath();
            switch (style) {
              default:
                ctx.arc(x2, y2, radius, 0, DOUBLE_PI);
                ctx.closePath();
                break;
              case "triangle":
                ctx.moveTo(x2 + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x2 + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x2 + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
                ctx.closePath();
                break;
              case "rectRounded":
                cornerRadius = radius * 0.516;
                size2 = radius - cornerRadius;
                xOffset = Math.cos(rad + QUARTER_PI) * size2;
                yOffset = Math.sin(rad + QUARTER_PI) * size2;
                ctx.arc(x2 - xOffset, y2 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
                ctx.arc(x2 + yOffset, y2 - xOffset, cornerRadius, rad - HALF_PI, rad);
                ctx.arc(x2 + xOffset, y2 + yOffset, cornerRadius, rad, rad + HALF_PI);
                ctx.arc(x2 - yOffset, y2 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
                ctx.closePath();
                break;
              case "rect":
                if (!rotation) {
                  size2 = Math.SQRT1_2 * radius;
                  ctx.rect(x2 - size2, y2 - size2, 2 * size2, 2 * size2);
                  break;
                }
                rad += QUARTER_PI;
              case "rectRot":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x2 - xOffset, y2 - yOffset);
                ctx.lineTo(x2 + yOffset, y2 - xOffset);
                ctx.lineTo(x2 + xOffset, y2 + yOffset);
                ctx.lineTo(x2 - yOffset, y2 + xOffset);
                ctx.closePath();
                break;
              case "crossRot":
                rad += QUARTER_PI;
              case "cross":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x2 - xOffset, y2 - yOffset);
                ctx.lineTo(x2 + xOffset, y2 + yOffset);
                ctx.moveTo(x2 + yOffset, y2 - xOffset);
                ctx.lineTo(x2 - yOffset, y2 + xOffset);
                break;
              case "star":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x2 - xOffset, y2 - yOffset);
                ctx.lineTo(x2 + xOffset, y2 + yOffset);
                ctx.moveTo(x2 + yOffset, y2 - xOffset);
                ctx.lineTo(x2 - yOffset, y2 + xOffset);
                rad += QUARTER_PI;
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x2 - xOffset, y2 - yOffset);
                ctx.lineTo(x2 + xOffset, y2 + yOffset);
                ctx.moveTo(x2 + yOffset, y2 - xOffset);
                ctx.lineTo(x2 - yOffset, y2 + xOffset);
                break;
              case "line":
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x2 - xOffset, y2 - yOffset);
                ctx.lineTo(x2 + xOffset, y2 + yOffset);
                break;
              case "dash":
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 + Math.cos(rad) * radius, y2 + Math.sin(rad) * radius);
                break;
            }
            ctx.fill();
            ctx.stroke();
          },
          _isPointInArea: function(point, area2) {
            var epsilon = 1e-6;
            return point.x > area2.left - epsilon && point.x < area2.right + epsilon && point.y > area2.top - epsilon && point.y < area2.bottom + epsilon;
          },
          clipArea: function(ctx, area2) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(area2.left, area2.top, area2.right - area2.left, area2.bottom - area2.top);
            ctx.clip();
          },
          unclipArea: function(ctx) {
            ctx.restore();
          },
          lineTo: function(ctx, previous, target, flip) {
            var stepped = target.steppedLine;
            if (stepped) {
              if (stepped === "middle") {
                var midpoint = (previous.x + target.x) / 2;
                ctx.lineTo(midpoint, flip ? target.y : previous.y);
                ctx.lineTo(midpoint, flip ? previous.y : target.y);
              } else if (stepped === "after" && !flip || stepped !== "after" && flip) {
                ctx.lineTo(previous.x, target.y);
              } else {
                ctx.lineTo(target.x, previous.y);
              }
              ctx.lineTo(target.x, target.y);
              return;
            }
            if (!target.tension) {
              ctx.lineTo(target.x, target.y);
              return;
            }
            ctx.bezierCurveTo(
              flip ? previous.controlPointPreviousX : previous.controlPointNextX,
              flip ? previous.controlPointPreviousY : previous.controlPointNextY,
              flip ? target.controlPointNextX : target.controlPointPreviousX,
              flip ? target.controlPointNextY : target.controlPointPreviousY,
              target.x,
              target.y
            );
          }
        };
        var helpers_canvas = exports$1;
        helpers_core.clear = exports$1.clear;
        helpers_core.drawRoundedRectangle = function(ctx) {
          ctx.beginPath();
          exports$1.roundedRect.apply(exports$1, arguments);
        };
        var defaults2 = {
          _set: function(scope, values2) {
            return helpers_core.merge(this[scope] || (this[scope] = {}), values2);
          }
        };
        defaults2._set("global", {
          defaultColor: "rgba(0,0,0,0.1)",
          defaultFontColor: "#666",
          defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
          defaultFontSize: 12,
          defaultFontStyle: "normal",
          defaultLineHeight: 1.2,
          showLines: true
        });
        var core_defaults = defaults2;
        var valueOrDefault = helpers_core.valueOrDefault;
        function toFontString(font) {
          if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
            return null;
          }
          return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        }
        var helpers_options = {
          toLineHeight: function(value2, size2) {
            var matches = ("" + value2).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
            if (!matches || matches[1] === "normal") {
              return size2 * 1.2;
            }
            value2 = +matches[2];
            switch (matches[3]) {
              case "px":
                return value2;
              case "%":
                value2 /= 100;
                break;
            }
            return size2 * value2;
          },
          toPadding: function(value2) {
            var t2, r2, b, l2;
            if (helpers_core.isObject(value2)) {
              t2 = +value2.top || 0;
              r2 = +value2.right || 0;
              b = +value2.bottom || 0;
              l2 = +value2.left || 0;
            } else {
              t2 = r2 = b = l2 = +value2 || 0;
            }
            return {
              top: t2,
              right: r2,
              bottom: b,
              left: l2,
              height: t2 + b,
              width: l2 + r2
            };
          },
          _parseFont: function(options2) {
            var globalDefaults = core_defaults.global;
            var size2 = valueOrDefault(options2.fontSize, globalDefaults.defaultFontSize);
            var font = {
              family: valueOrDefault(options2.fontFamily, globalDefaults.defaultFontFamily),
              lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options2.lineHeight, globalDefaults.defaultLineHeight), size2),
              size: size2,
              style: valueOrDefault(options2.fontStyle, globalDefaults.defaultFontStyle),
              weight: null,
              string: ""
            };
            font.string = toFontString(font);
            return font;
          },
          resolve: function(inputs, context2, index2, info) {
            var cacheable = true;
            var i2, ilen, value2;
            for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
              value2 = inputs[i2];
              if (value2 === void 0) {
                continue;
              }
              if (context2 !== void 0 && typeof value2 === "function") {
                value2 = value2(context2);
                cacheable = false;
              }
              if (index2 !== void 0 && helpers_core.isArray(value2)) {
                value2 = value2[index2];
                cacheable = false;
              }
              if (value2 !== void 0) {
                if (info && !cacheable) {
                  info.cacheable = false;
                }
                return value2;
              }
            }
          }
        };
        var exports$2 = {
          _factorize: function(value2) {
            var result2 = [];
            var sqrt = Math.sqrt(value2);
            var i2;
            for (i2 = 1; i2 < sqrt; i2++) {
              if (value2 % i2 === 0) {
                result2.push(i2);
                result2.push(value2 / i2);
              }
            }
            if (sqrt === (sqrt | 0)) {
              result2.push(sqrt);
            }
            result2.sort(function(a2, b) {
              return a2 - b;
            }).pop();
            return result2;
          },
          log10: Math.log10 || function(x2) {
            var exponent = Math.log(x2) * Math.LOG10E;
            var powerOf10 = Math.round(exponent);
            var isPowerOf10 = x2 === Math.pow(10, powerOf10);
            return isPowerOf10 ? powerOf10 : exponent;
          }
        };
        var helpers_math = exports$2;
        helpers_core.log10 = exports$2.log10;
        var getRtlAdapter = function(rectX, width2) {
          return {
            x: function(x2) {
              return rectX + rectX + width2 - x2;
            },
            setWidth: function(w2) {
              width2 = w2;
            },
            textAlign: function(align) {
              if (align === "center") {
                return align;
              }
              return align === "right" ? "left" : "right";
            },
            xPlus: function(x2, value2) {
              return x2 - value2;
            },
            leftForLtr: function(x2, itemWidth) {
              return x2 - itemWidth;
            }
          };
        };
        var getLtrAdapter = function() {
          return {
            x: function(x2) {
              return x2;
            },
            setWidth: function(w2) {
            },
            textAlign: function(align) {
              return align;
            },
            xPlus: function(x2, value2) {
              return x2 + value2;
            },
            leftForLtr: function(x2, _itemWidth) {
              return x2;
            }
          };
        };
        var getAdapter = function(rtl2, rectX, width2) {
          return rtl2 ? getRtlAdapter(rectX, width2) : getLtrAdapter();
        };
        var overrideTextDirection = function(ctx, direction) {
          var style, original;
          if (direction === "ltr" || direction === "rtl") {
            style = ctx.canvas.style;
            original = [
              style.getPropertyValue("direction"),
              style.getPropertyPriority("direction")
            ];
            style.setProperty("direction", direction, "important");
            ctx.prevTextDirection = original;
          }
        };
        var restoreTextDirection = function(ctx) {
          var original = ctx.prevTextDirection;
          if (original !== void 0) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty("direction", original[0], original[1]);
          }
        };
        var helpers_rtl = {
          getRtlAdapter: getAdapter,
          overrideTextDirection,
          restoreTextDirection
        };
        var helpers$1 = helpers_core;
        var easing = helpers_easing;
        var canvas2 = helpers_canvas;
        var options = helpers_options;
        var math = helpers_math;
        var rtl = helpers_rtl;
        helpers$1.easing = easing;
        helpers$1.canvas = canvas2;
        helpers$1.options = options;
        helpers$1.math = math;
        helpers$1.rtl = rtl;
        function interpolate(start, view, model, ease) {
          var keys2 = Object.keys(model);
          var i2, ilen, key, actual, origin, target, type, c0, c1;
          for (i2 = 0, ilen = keys2.length; i2 < ilen; ++i2) {
            key = keys2[i2];
            target = model[key];
            if (!view.hasOwnProperty(key)) {
              view[key] = target;
            }
            actual = view[key];
            if (actual === target || key[0] === "_") {
              continue;
            }
            if (!start.hasOwnProperty(key)) {
              start[key] = actual;
            }
            origin = start[key];
            type = typeof target;
            if (type === typeof origin) {
              if (type === "string") {
                c0 = chartjsColor(origin);
                if (c0.valid) {
                  c1 = chartjsColor(target);
                  if (c1.valid) {
                    view[key] = c1.mix(c0, ease).rgbString();
                    continue;
                  }
                }
              } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
                view[key] = origin + (target - origin) * ease;
                continue;
              }
            }
            view[key] = target;
          }
        }
        var Element = function(configuration) {
          helpers$1.extend(this, configuration);
          this.initialize.apply(this, arguments);
        };
        helpers$1.extend(Element.prototype, {
          _type: void 0,
          initialize: function() {
            this.hidden = false;
          },
          pivot: function() {
            var me2 = this;
            if (!me2._view) {
              me2._view = helpers$1.extend({}, me2._model);
            }
            me2._start = {};
            return me2;
          },
          transition: function(ease) {
            var me2 = this;
            var model = me2._model;
            var start = me2._start;
            var view = me2._view;
            if (!model || ease === 1) {
              me2._view = helpers$1.extend({}, model);
              me2._start = null;
              return me2;
            }
            if (!view) {
              view = me2._view = {};
            }
            if (!start) {
              start = me2._start = {};
            }
            interpolate(start, view, model, ease);
            return me2;
          },
          tooltipPosition: function() {
            return {
              x: this._model.x,
              y: this._model.y
            };
          },
          hasValue: function() {
            return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
          }
        });
        Element.extend = helpers$1.inherits;
        var core_element = Element;
        var exports$3 = core_element.extend({
          chart: null,
          currentStep: 0,
          numSteps: 60,
          easing: "",
          render: null,
          onAnimationProgress: null,
          onAnimationComplete: null
        });
        var core_animation = exports$3;
        Object.defineProperty(exports$3.prototype, "animationObject", {
          get: function() {
            return this;
          }
        });
        Object.defineProperty(exports$3.prototype, "chartInstance", {
          get: function() {
            return this.chart;
          },
          set: function(value2) {
            this.chart = value2;
          }
        });
        core_defaults._set("global", {
          animation: {
            duration: 1e3,
            easing: "easeOutQuart",
            onProgress: helpers$1.noop,
            onComplete: helpers$1.noop
          }
        });
        var core_animations = {
          animations: [],
          request: null,
          addAnimation: function(chart, animation, duration, lazy) {
            var animations = this.animations;
            var i2, ilen;
            animation.chart = chart;
            animation.startTime = Date.now();
            animation.duration = duration;
            if (!lazy) {
              chart.animating = true;
            }
            for (i2 = 0, ilen = animations.length; i2 < ilen; ++i2) {
              if (animations[i2].chart === chart) {
                animations[i2] = animation;
                return;
              }
            }
            animations.push(animation);
            if (animations.length === 1) {
              this.requestAnimationFrame();
            }
          },
          cancelAnimation: function(chart) {
            var index2 = helpers$1.findIndex(this.animations, function(animation) {
              return animation.chart === chart;
            });
            if (index2 !== -1) {
              this.animations.splice(index2, 1);
              chart.animating = false;
            }
          },
          requestAnimationFrame: function() {
            var me2 = this;
            if (me2.request === null) {
              me2.request = helpers$1.requestAnimFrame.call(window, function() {
                me2.request = null;
                me2.startDigest();
              });
            }
          },
          startDigest: function() {
            var me2 = this;
            me2.advance();
            if (me2.animations.length > 0) {
              me2.requestAnimationFrame();
            }
          },
          advance: function() {
            var animations = this.animations;
            var animation, chart, numSteps, nextStep;
            var i2 = 0;
            while (i2 < animations.length) {
              animation = animations[i2];
              chart = animation.chart;
              numSteps = animation.numSteps;
              nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
              animation.currentStep = Math.min(nextStep, numSteps);
              helpers$1.callback(animation.render, [chart, animation], chart);
              helpers$1.callback(animation.onAnimationProgress, [animation], chart);
              if (animation.currentStep >= numSteps) {
                helpers$1.callback(animation.onAnimationComplete, [animation], chart);
                chart.animating = false;
                animations.splice(i2, 1);
              } else {
                ++i2;
              }
            }
          }
        };
        var resolve = helpers$1.options.resolve;
        var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
        function listenArrayEvents(array, listener) {
          if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
          }
          Object.defineProperty(array, "_chartjs", {
            configurable: true,
            enumerable: false,
            value: {
              listeners: [listener]
            }
          });
          arrayEvents.forEach(function(key) {
            var method = "onData" + key.charAt(0).toUpperCase() + key.slice(1);
            var base = array[key];
            Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value: function() {
                var args = Array.prototype.slice.call(arguments);
                var res = base.apply(this, args);
                helpers$1.each(array._chartjs.listeners, function(object2) {
                  if (typeof object2[method] === "function") {
                    object2[method].apply(object2, args);
                  }
                });
                return res;
              }
            });
          });
        }
        function unlistenArrayEvents(array, listener) {
          var stub = array._chartjs;
          if (!stub) {
            return;
          }
          var listeners = stub.listeners;
          var index2 = listeners.indexOf(listener);
          if (index2 !== -1) {
            listeners.splice(index2, 1);
          }
          if (listeners.length > 0) {
            return;
          }
          arrayEvents.forEach(function(key) {
            delete array[key];
          });
          delete array._chartjs;
        }
        var DatasetController = function(chart, datasetIndex) {
          this.initialize(chart, datasetIndex);
        };
        helpers$1.extend(DatasetController.prototype, {
          datasetElementType: null,
          dataElementType: null,
          _datasetElementOptions: [
            "backgroundColor",
            "borderCapStyle",
            "borderColor",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "borderWidth"
          ],
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "pointStyle"
          ],
          initialize: function(chart, datasetIndex) {
            var me2 = this;
            me2.chart = chart;
            me2.index = datasetIndex;
            me2.linkScales();
            me2.addElements();
            me2._type = me2.getMeta().type;
          },
          updateIndex: function(datasetIndex) {
            this.index = datasetIndex;
          },
          linkScales: function() {
            var me2 = this;
            var meta = me2.getMeta();
            var chart = me2.chart;
            var scales2 = chart.scales;
            var dataset = me2.getDataset();
            var scalesOpts = chart.options.scales;
            if (meta.xAxisID === null || !(meta.xAxisID in scales2) || dataset.xAxisID) {
              meta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;
            }
            if (meta.yAxisID === null || !(meta.yAxisID in scales2) || dataset.yAxisID) {
              meta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;
            }
          },
          getDataset: function() {
            return this.chart.data.datasets[this.index];
          },
          getMeta: function() {
            return this.chart.getDatasetMeta(this.index);
          },
          getScaleForId: function(scaleID) {
            return this.chart.scales[scaleID];
          },
          _getValueScaleId: function() {
            return this.getMeta().yAxisID;
          },
          _getIndexScaleId: function() {
            return this.getMeta().xAxisID;
          },
          _getValueScale: function() {
            return this.getScaleForId(this._getValueScaleId());
          },
          _getIndexScale: function() {
            return this.getScaleForId(this._getIndexScaleId());
          },
          reset: function() {
            this._update(true);
          },
          destroy: function() {
            if (this._data) {
              unlistenArrayEvents(this._data, this);
            }
          },
          createMetaDataset: function() {
            var me2 = this;
            var type = me2.datasetElementType;
            return type && new type({
              _chart: me2.chart,
              _datasetIndex: me2.index
            });
          },
          createMetaData: function(index2) {
            var me2 = this;
            var type = me2.dataElementType;
            return type && new type({
              _chart: me2.chart,
              _datasetIndex: me2.index,
              _index: index2
            });
          },
          addElements: function() {
            var me2 = this;
            var meta = me2.getMeta();
            var data = me2.getDataset().data || [];
            var metaData = meta.data;
            var i2, ilen;
            for (i2 = 0, ilen = data.length; i2 < ilen; ++i2) {
              metaData[i2] = metaData[i2] || me2.createMetaData(i2);
            }
            meta.dataset = meta.dataset || me2.createMetaDataset();
          },
          addElementAndReset: function(index2) {
            var element = this.createMetaData(index2);
            this.getMeta().data.splice(index2, 0, element);
            this.updateElement(element, index2, true);
          },
          buildOrUpdateElements: function() {
            var me2 = this;
            var dataset = me2.getDataset();
            var data = dataset.data || (dataset.data = []);
            if (me2._data !== data) {
              if (me2._data) {
                unlistenArrayEvents(me2._data, me2);
              }
              if (data && Object.isExtensible(data)) {
                listenArrayEvents(data, me2);
              }
              me2._data = data;
            }
            me2.resyncElements();
          },
          _configure: function() {
            var me2 = this;
            me2._config = helpers$1.merge(/* @__PURE__ */ Object.create(null), [
              me2.chart.options.datasets[me2._type],
              me2.getDataset()
            ], {
              merger: function(key, target, source) {
                if (key !== "_meta" && key !== "data") {
                  helpers$1._merger(key, target, source);
                }
              }
            });
          },
          _update: function(reset) {
            var me2 = this;
            me2._configure();
            me2._cachedDataOpts = null;
            me2.update(reset);
          },
          update: helpers$1.noop,
          transition: function(easingValue) {
            var meta = this.getMeta();
            var elements2 = meta.data || [];
            var ilen = elements2.length;
            var i2 = 0;
            for (; i2 < ilen; ++i2) {
              elements2[i2].transition(easingValue);
            }
            if (meta.dataset) {
              meta.dataset.transition(easingValue);
            }
          },
          draw: function() {
            var meta = this.getMeta();
            var elements2 = meta.data || [];
            var ilen = elements2.length;
            var i2 = 0;
            if (meta.dataset) {
              meta.dataset.draw();
            }
            for (; i2 < ilen; ++i2) {
              elements2[i2].draw();
            }
          },
          getStyle: function(index2) {
            var me2 = this;
            var meta = me2.getMeta();
            var dataset = meta.dataset;
            var style;
            me2._configure();
            if (dataset && index2 === void 0) {
              style = me2._resolveDatasetElementOptions(dataset || {});
            } else {
              index2 = index2 || 0;
              style = me2._resolveDataElementOptions(meta.data[index2] || {}, index2);
            }
            if (style.fill === false || style.fill === null) {
              style.backgroundColor = style.borderColor;
            }
            return style;
          },
          _resolveDatasetElementOptions: function(element, hover) {
            var me2 = this;
            var chart = me2.chart;
            var datasetOpts = me2._config;
            var custom = element.custom || {};
            var options2 = chart.options.elements[me2.datasetElementType.prototype._type] || {};
            var elementOptions = me2._datasetElementOptions;
            var values2 = {};
            var i2, ilen, key, readKey;
            var context2 = {
              chart,
              dataset: me2.getDataset(),
              datasetIndex: me2.index,
              hover
            };
            for (i2 = 0, ilen = elementOptions.length; i2 < ilen; ++i2) {
              key = elementOptions[i2];
              readKey = hover ? "hover" + key.charAt(0).toUpperCase() + key.slice(1) : key;
              values2[key] = resolve([
                custom[readKey],
                datasetOpts[readKey],
                options2[readKey]
              ], context2);
            }
            return values2;
          },
          _resolveDataElementOptions: function(element, index2) {
            var me2 = this;
            var custom = element && element.custom;
            var cached = me2._cachedDataOpts;
            if (cached && !custom) {
              return cached;
            }
            var chart = me2.chart;
            var datasetOpts = me2._config;
            var options2 = chart.options.elements[me2.dataElementType.prototype._type] || {};
            var elementOptions = me2._dataElementOptions;
            var values2 = {};
            var context2 = {
              chart,
              dataIndex: index2,
              dataset: me2.getDataset(),
              datasetIndex: me2.index
            };
            var info = { cacheable: !custom };
            var keys2, i2, ilen, key;
            custom = custom || {};
            if (helpers$1.isArray(elementOptions)) {
              for (i2 = 0, ilen = elementOptions.length; i2 < ilen; ++i2) {
                key = elementOptions[i2];
                values2[key] = resolve([
                  custom[key],
                  datasetOpts[key],
                  options2[key]
                ], context2, index2, info);
              }
            } else {
              keys2 = Object.keys(elementOptions);
              for (i2 = 0, ilen = keys2.length; i2 < ilen; ++i2) {
                key = keys2[i2];
                values2[key] = resolve([
                  custom[key],
                  datasetOpts[elementOptions[key]],
                  datasetOpts[key],
                  options2[key]
                ], context2, index2, info);
              }
            }
            if (info.cacheable) {
              me2._cachedDataOpts = Object.freeze(values2);
            }
            return values2;
          },
          removeHoverStyle: function(element) {
            helpers$1.merge(element._model, element.$previousStyle || {});
            delete element.$previousStyle;
          },
          setHoverStyle: function(element) {
            var dataset = this.chart.data.datasets[element._datasetIndex];
            var index2 = element._index;
            var custom = element.custom || {};
            var model = element._model;
            var getHoverColor = helpers$1.getHoverColor;
            element.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], void 0, index2);
            model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], void 0, index2);
            model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], void 0, index2);
          },
          _removeDatasetHoverStyle: function() {
            var element = this.getMeta().dataset;
            if (element) {
              this.removeHoverStyle(element);
            }
          },
          _setDatasetHoverStyle: function() {
            var element = this.getMeta().dataset;
            var prev = {};
            var i2, ilen, key, keys2, hoverOptions, model;
            if (!element) {
              return;
            }
            model = element._model;
            hoverOptions = this._resolveDatasetElementOptions(element, true);
            keys2 = Object.keys(hoverOptions);
            for (i2 = 0, ilen = keys2.length; i2 < ilen; ++i2) {
              key = keys2[i2];
              prev[key] = model[key];
              model[key] = hoverOptions[key];
            }
            element.$previousStyle = prev;
          },
          resyncElements: function() {
            var me2 = this;
            var meta = me2.getMeta();
            var data = me2.getDataset().data;
            var numMeta = meta.data.length;
            var numData = data.length;
            if (numData < numMeta) {
              meta.data.splice(numData, numMeta - numData);
            } else if (numData > numMeta) {
              me2.insertElements(numMeta, numData - numMeta);
            }
          },
          insertElements: function(start, count) {
            for (var i2 = 0; i2 < count; ++i2) {
              this.addElementAndReset(start + i2);
            }
          },
          onDataPush: function() {
            var count = arguments.length;
            this.insertElements(this.getDataset().data.length - count, count);
          },
          onDataPop: function() {
            this.getMeta().data.pop();
          },
          onDataShift: function() {
            this.getMeta().data.shift();
          },
          onDataSplice: function(start, count) {
            this.getMeta().data.splice(start, count);
            this.insertElements(start, arguments.length - 2);
          },
          onDataUnshift: function() {
            this.insertElements(0, arguments.length);
          }
        });
        DatasetController.extend = helpers$1.inherits;
        var core_datasetController = DatasetController;
        var TAU = Math.PI * 2;
        core_defaults._set("global", {
          elements: {
            arc: {
              backgroundColor: core_defaults.global.defaultColor,
              borderColor: "#fff",
              borderWidth: 2,
              borderAlign: "center"
            }
          }
        });
        function clipArc(ctx, arc) {
          var startAngle = arc.startAngle;
          var endAngle = arc.endAngle;
          var pixelMargin = arc.pixelMargin;
          var angleMargin = pixelMargin / arc.outerRadius;
          var x2 = arc.x;
          var y2 = arc.y;
          ctx.beginPath();
          ctx.arc(x2, y2, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);
          if (arc.innerRadius > pixelMargin) {
            angleMargin = pixelMargin / arc.innerRadius;
            ctx.arc(x2, y2, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);
          } else {
            ctx.arc(x2, y2, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);
          }
          ctx.closePath();
          ctx.clip();
        }
        function drawFullCircleBorders(ctx, vm, arc, inner) {
          var endAngle = arc.endAngle;
          var i2;
          if (inner) {
            arc.endAngle = arc.startAngle + TAU;
            clipArc(ctx, arc);
            arc.endAngle = endAngle;
            if (arc.endAngle === arc.startAngle && arc.fullCircles) {
              arc.endAngle += TAU;
              arc.fullCircles--;
            }
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);
          for (i2 = 0; i2 < arc.fullCircles; ++i2) {
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);
          for (i2 = 0; i2 < arc.fullCircles; ++i2) {
            ctx.stroke();
          }
        }
        function drawBorder(ctx, vm, arc) {
          var inner = vm.borderAlign === "inner";
          if (inner) {
            ctx.lineWidth = vm.borderWidth * 2;
            ctx.lineJoin = "round";
          } else {
            ctx.lineWidth = vm.borderWidth;
            ctx.lineJoin = "bevel";
          }
          if (arc.fullCircles) {
            drawFullCircleBorders(ctx, vm, arc, inner);
          }
          if (inner) {
            clipArc(ctx, arc);
          }
          ctx.beginPath();
          ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);
          ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
          ctx.closePath();
          ctx.stroke();
        }
        var element_arc = core_element.extend({
          _type: "arc",
          inLabelRange: function(mouseX) {
            var vm = this._view;
            if (vm) {
              return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
            }
            return false;
          },
          inRange: function(chartX, chartY) {
            var vm = this._view;
            if (vm) {
              var pointRelativePosition = helpers$1.getAngleFromPoint(vm, { x: chartX, y: chartY });
              var angle = pointRelativePosition.angle;
              var distance = pointRelativePosition.distance;
              var startAngle = vm.startAngle;
              var endAngle = vm.endAngle;
              while (endAngle < startAngle) {
                endAngle += TAU;
              }
              while (angle > endAngle) {
                angle -= TAU;
              }
              while (angle < startAngle) {
                angle += TAU;
              }
              var betweenAngles = angle >= startAngle && angle <= endAngle;
              var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
              return betweenAngles && withinRadius;
            }
            return false;
          },
          getCenterPoint: function() {
            var vm = this._view;
            var halfAngle = (vm.startAngle + vm.endAngle) / 2;
            var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
            return {
              x: vm.x + Math.cos(halfAngle) * halfRadius,
              y: vm.y + Math.sin(halfAngle) * halfRadius
            };
          },
          getArea: function() {
            var vm = this._view;
            return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
          },
          tooltipPosition: function() {
            var vm = this._view;
            var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
            var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
            return {
              x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
              y: vm.y + Math.sin(centreAngle) * rangeFromCentre
            };
          },
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var pixelMargin = vm.borderAlign === "inner" ? 0.33 : 0;
            var arc = {
              x: vm.x,
              y: vm.y,
              innerRadius: vm.innerRadius,
              outerRadius: Math.max(vm.outerRadius - pixelMargin, 0),
              pixelMargin,
              startAngle: vm.startAngle,
              endAngle: vm.endAngle,
              fullCircles: Math.floor(vm.circumference / TAU)
            };
            var i2;
            ctx.save();
            ctx.fillStyle = vm.backgroundColor;
            ctx.strokeStyle = vm.borderColor;
            if (arc.fullCircles) {
              arc.endAngle = arc.startAngle + TAU;
              ctx.beginPath();
              ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
              ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
              ctx.closePath();
              for (i2 = 0; i2 < arc.fullCircles; ++i2) {
                ctx.fill();
              }
              arc.endAngle = arc.startAngle + vm.circumference % TAU;
            }
            ctx.beginPath();
            ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
            ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
            ctx.closePath();
            ctx.fill();
            if (vm.borderWidth) {
              drawBorder(ctx, vm, arc);
            }
            ctx.restore();
          }
        });
        var valueOrDefault$1 = helpers$1.valueOrDefault;
        var defaultColor = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            line: {
              tension: 0.4,
              backgroundColor: defaultColor,
              borderWidth: 3,
              borderColor: defaultColor,
              borderCapStyle: "butt",
              borderDash: [],
              borderDashOffset: 0,
              borderJoinStyle: "miter",
              capBezierPoints: true,
              fill: true
            }
          }
        });
        var element_line = core_element.extend({
          _type: "line",
          draw: function() {
            var me2 = this;
            var vm = me2._view;
            var ctx = me2._chart.ctx;
            var spanGaps = vm.spanGaps;
            var points = me2._children.slice();
            var globalDefaults = core_defaults.global;
            var globalOptionLineElements = globalDefaults.elements.line;
            var lastDrawnIndex = -1;
            var closePath = me2._loop;
            var index2, previous, currentVM;
            if (!points.length) {
              return;
            }
            if (me2._loop) {
              for (index2 = 0; index2 < points.length; ++index2) {
                previous = helpers$1.previousItem(points, index2);
                if (!points[index2]._view.skip && previous._view.skip) {
                  points = points.slice(index2).concat(points.slice(0, index2));
                  closePath = spanGaps;
                  break;
                }
              }
              if (closePath) {
                points.push(points[0]);
              }
            }
            ctx.save();
            ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
            if (ctx.setLineDash) {
              ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
            }
            ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
            ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
            ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
            ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
            ctx.beginPath();
            currentVM = points[0]._view;
            if (!currentVM.skip) {
              ctx.moveTo(currentVM.x, currentVM.y);
              lastDrawnIndex = 0;
            }
            for (index2 = 1; index2 < points.length; ++index2) {
              currentVM = points[index2]._view;
              previous = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index2) : points[lastDrawnIndex];
              if (!currentVM.skip) {
                if (lastDrawnIndex !== index2 - 1 && !spanGaps || lastDrawnIndex === -1) {
                  ctx.moveTo(currentVM.x, currentVM.y);
                } else {
                  helpers$1.canvas.lineTo(ctx, previous._view, currentVM);
                }
                lastDrawnIndex = index2;
              }
            }
            if (closePath) {
              ctx.closePath();
            }
            ctx.stroke();
            ctx.restore();
          }
        });
        var valueOrDefault$2 = helpers$1.valueOrDefault;
        var defaultColor$1 = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            point: {
              radius: 3,
              pointStyle: "circle",
              backgroundColor: defaultColor$1,
              borderColor: defaultColor$1,
              borderWidth: 1,
              hitRadius: 1,
              hoverRadius: 4,
              hoverBorderWidth: 1
            }
          }
        });
        function xRange(mouseX) {
          var vm = this._view;
          return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
        }
        function yRange(mouseY) {
          var vm = this._view;
          return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
        }
        var element_point = core_element.extend({
          _type: "point",
          inRange: function(mouseX, mouseY) {
            var vm = this._view;
            return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
          },
          inLabelRange: xRange,
          inXRange: xRange,
          inYRange: yRange,
          getCenterPoint: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y
            };
          },
          getArea: function() {
            return Math.PI * Math.pow(this._view.radius, 2);
          },
          tooltipPosition: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y,
              padding: vm.radius + vm.borderWidth
            };
          },
          draw: function(chartArea) {
            var vm = this._view;
            var ctx = this._chart.ctx;
            var pointStyle = vm.pointStyle;
            var rotation = vm.rotation;
            var radius = vm.radius;
            var x2 = vm.x;
            var y2 = vm.y;
            var globalDefaults = core_defaults.global;
            var defaultColor2 = globalDefaults.defaultColor;
            if (vm.skip) {
              return;
            }
            if (chartArea === void 0 || helpers$1.canvas._isPointInArea(vm, chartArea)) {
              ctx.strokeStyle = vm.borderColor || defaultColor2;
              ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
              ctx.fillStyle = vm.backgroundColor || defaultColor2;
              helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x2, y2, rotation);
            }
          }
        });
        var defaultColor$2 = core_defaults.global.defaultColor;
        core_defaults._set("global", {
          elements: {
            rectangle: {
              backgroundColor: defaultColor$2,
              borderColor: defaultColor$2,
              borderSkipped: "bottom",
              borderWidth: 0
            }
          }
        });
        function isVertical(vm) {
          return vm && vm.width !== void 0;
        }
        function getBarBounds(vm) {
          var x1, x2, y1, y2, half;
          if (isVertical(vm)) {
            half = vm.width / 2;
            x1 = vm.x - half;
            x2 = vm.x + half;
            y1 = Math.min(vm.y, vm.base);
            y2 = Math.max(vm.y, vm.base);
          } else {
            half = vm.height / 2;
            x1 = Math.min(vm.x, vm.base);
            x2 = Math.max(vm.x, vm.base);
            y1 = vm.y - half;
            y2 = vm.y + half;
          }
          return {
            left: x1,
            top: y1,
            right: x2,
            bottom: y2
          };
        }
        function swap(orig, v1, v2) {
          return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function parseBorderSkipped(vm) {
          var edge = vm.borderSkipped;
          var res = {};
          if (!edge) {
            return res;
          }
          if (vm.horizontal) {
            if (vm.base > vm.x) {
              edge = swap(edge, "left", "right");
            }
          } else if (vm.base < vm.y) {
            edge = swap(edge, "bottom", "top");
          }
          res[edge] = true;
          return res;
        }
        function parseBorderWidth(vm, maxW, maxH) {
          var value2 = vm.borderWidth;
          var skip2 = parseBorderSkipped(vm);
          var t2, r2, b, l2;
          if (helpers$1.isObject(value2)) {
            t2 = +value2.top || 0;
            r2 = +value2.right || 0;
            b = +value2.bottom || 0;
            l2 = +value2.left || 0;
          } else {
            t2 = r2 = b = l2 = +value2 || 0;
          }
          return {
            t: skip2.top || t2 < 0 ? 0 : t2 > maxH ? maxH : t2,
            r: skip2.right || r2 < 0 ? 0 : r2 > maxW ? maxW : r2,
            b: skip2.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
            l: skip2.left || l2 < 0 ? 0 : l2 > maxW ? maxW : l2
          };
        }
        function boundingRects(vm) {
          var bounds = getBarBounds(vm);
          var width2 = bounds.right - bounds.left;
          var height2 = bounds.bottom - bounds.top;
          var border = parseBorderWidth(vm, width2 / 2, height2 / 2);
          return {
            outer: {
              x: bounds.left,
              y: bounds.top,
              w: width2,
              h: height2
            },
            inner: {
              x: bounds.left + border.l,
              y: bounds.top + border.t,
              w: width2 - border.l - border.r,
              h: height2 - border.t - border.b
            }
          };
        }
        function inRange(vm, x2, y2) {
          var skipX = x2 === null;
          var skipY = y2 === null;
          var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
          return bounds && (skipX || x2 >= bounds.left && x2 <= bounds.right) && (skipY || y2 >= bounds.top && y2 <= bounds.bottom);
        }
        var element_rectangle = core_element.extend({
          _type: "rectangle",
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var rects = boundingRects(vm);
            var outer = rects.outer;
            var inner = rects.inner;
            ctx.fillStyle = vm.backgroundColor;
            ctx.fillRect(outer.x, outer.y, outer.w, outer.h);
            if (outer.w === inner.w && outer.h === inner.h) {
              return;
            }
            ctx.save();
            ctx.beginPath();
            ctx.rect(outer.x, outer.y, outer.w, outer.h);
            ctx.clip();
            ctx.fillStyle = vm.borderColor;
            ctx.rect(inner.x, inner.y, inner.w, inner.h);
            ctx.fill("evenodd");
            ctx.restore();
          },
          height: function() {
            var vm = this._view;
            return vm.base - vm.y;
          },
          inRange: function(mouseX, mouseY) {
            return inRange(this._view, mouseX, mouseY);
          },
          inLabelRange: function(mouseX, mouseY) {
            var vm = this._view;
            return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
          },
          inXRange: function(mouseX) {
            return inRange(this._view, mouseX, null);
          },
          inYRange: function(mouseY) {
            return inRange(this._view, null, mouseY);
          },
          getCenterPoint: function() {
            var vm = this._view;
            var x2, y2;
            if (isVertical(vm)) {
              x2 = vm.x;
              y2 = (vm.y + vm.base) / 2;
            } else {
              x2 = (vm.x + vm.base) / 2;
              y2 = vm.y;
            }
            return { x: x2, y: y2 };
          },
          getArea: function() {
            var vm = this._view;
            return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
          },
          tooltipPosition: function() {
            var vm = this._view;
            return {
              x: vm.x,
              y: vm.y
            };
          }
        });
        var elements = {};
        var Arc = element_arc;
        var Line = element_line;
        var Point2 = element_point;
        var Rectangle2 = element_rectangle;
        elements.Arc = Arc;
        elements.Line = Line;
        elements.Point = Point2;
        elements.Rectangle = Rectangle2;
        var deprecated = helpers$1._deprecated;
        var valueOrDefault$3 = helpers$1.valueOrDefault;
        core_defaults._set("bar", {
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "category",
              offset: true,
              gridLines: {
                offsetGridLines: true
              }
            }],
            yAxes: [{
              type: "linear"
            }]
          }
        });
        core_defaults._set("global", {
          datasets: {
            bar: {
              categoryPercentage: 0.8,
              barPercentage: 0.9
            }
          }
        });
        function computeMinSampleSize(scale2, pixels) {
          var min2 = scale2._length;
          var prev, curr, i2, ilen;
          for (i2 = 1, ilen = pixels.length; i2 < ilen; ++i2) {
            min2 = Math.min(min2, Math.abs(pixels[i2] - pixels[i2 - 1]));
          }
          for (i2 = 0, ilen = scale2.getTicks().length; i2 < ilen; ++i2) {
            curr = scale2.getPixelForTick(i2);
            min2 = i2 > 0 ? Math.min(min2, Math.abs(curr - prev)) : min2;
            prev = curr;
          }
          return min2;
        }
        function computeFitCategoryTraits(index2, ruler, options2) {
          var thickness = options2.barThickness;
          var count = ruler.stackCount;
          var curr = ruler.pixels[index2];
          var min2 = helpers$1.isNullOrUndef(thickness) ? computeMinSampleSize(ruler.scale, ruler.pixels) : -1;
          var size2, ratio;
          if (helpers$1.isNullOrUndef(thickness)) {
            size2 = min2 * options2.categoryPercentage;
            ratio = options2.barPercentage;
          } else {
            size2 = thickness * count;
            ratio = 1;
          }
          return {
            chunk: size2 / count,
            ratio,
            start: curr - size2 / 2
          };
        }
        function computeFlexCategoryTraits(index2, ruler, options2) {
          var pixels = ruler.pixels;
          var curr = pixels[index2];
          var prev = index2 > 0 ? pixels[index2 - 1] : null;
          var next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
          var percent = options2.categoryPercentage;
          var start, size2;
          if (prev === null) {
            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
          }
          if (next === null) {
            next = curr + curr - prev;
          }
          start = curr - (curr - Math.min(prev, next)) / 2 * percent;
          size2 = Math.abs(next - prev) / 2 * percent;
          return {
            chunk: size2 / ruler.stackCount,
            ratio: options2.barPercentage,
            start
          };
        }
        var controller_bar = core_datasetController.extend({
          dataElementType: elements.Rectangle,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderSkipped",
            "borderWidth",
            "barPercentage",
            "barThickness",
            "categoryPercentage",
            "maxBarThickness",
            "minBarLength"
          ],
          initialize: function() {
            var me2 = this;
            var meta, scaleOpts;
            core_datasetController.prototype.initialize.apply(me2, arguments);
            meta = me2.getMeta();
            meta.stack = me2.getDataset().stack;
            meta.bar = true;
            scaleOpts = me2._getIndexScale().options;
            deprecated("bar chart", scaleOpts.barPercentage, "scales.[x/y]Axes.barPercentage", "dataset.barPercentage");
            deprecated("bar chart", scaleOpts.barThickness, "scales.[x/y]Axes.barThickness", "dataset.barThickness");
            deprecated("bar chart", scaleOpts.categoryPercentage, "scales.[x/y]Axes.categoryPercentage", "dataset.categoryPercentage");
            deprecated("bar chart", me2._getValueScale().options.minBarLength, "scales.[x/y]Axes.minBarLength", "dataset.minBarLength");
            deprecated("bar chart", scaleOpts.maxBarThickness, "scales.[x/y]Axes.maxBarThickness", "dataset.maxBarThickness");
          },
          update: function(reset) {
            var me2 = this;
            var rects = me2.getMeta().data;
            var i2, ilen;
            me2._ruler = me2.getRuler();
            for (i2 = 0, ilen = rects.length; i2 < ilen; ++i2) {
              me2.updateElement(rects[i2], i2, reset);
            }
          },
          updateElement: function(rectangle, index2, reset) {
            var me2 = this;
            var meta = me2.getMeta();
            var dataset = me2.getDataset();
            var options2 = me2._resolveDataElementOptions(rectangle, index2);
            rectangle._xScale = me2.getScaleForId(meta.xAxisID);
            rectangle._yScale = me2.getScaleForId(meta.yAxisID);
            rectangle._datasetIndex = me2.index;
            rectangle._index = index2;
            rectangle._model = {
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderSkipped: options2.borderSkipped,
              borderWidth: options2.borderWidth,
              datasetLabel: dataset.label,
              label: me2.chart.data.labels[index2]
            };
            if (helpers$1.isArray(dataset.data[index2])) {
              rectangle._model.borderSkipped = null;
            }
            me2._updateElementGeometry(rectangle, index2, reset, options2);
            rectangle.pivot();
          },
          _updateElementGeometry: function(rectangle, index2, reset, options2) {
            var me2 = this;
            var model = rectangle._model;
            var vscale = me2._getValueScale();
            var base = vscale.getBasePixel();
            var horizontal = vscale.isHorizontal();
            var ruler = me2._ruler || me2.getRuler();
            var vpixels = me2.calculateBarValuePixels(me2.index, index2, options2);
            var ipixels = me2.calculateBarIndexPixels(me2.index, index2, ruler, options2);
            model.horizontal = horizontal;
            model.base = reset ? base : vpixels.base;
            model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
            model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
            model.height = horizontal ? ipixels.size : void 0;
            model.width = horizontal ? void 0 : ipixels.size;
          },
          _getStacks: function(last2) {
            var me2 = this;
            var scale2 = me2._getIndexScale();
            var metasets = scale2._getMatchingVisibleMetas(me2._type);
            var stacked = scale2.options.stacked;
            var ilen = metasets.length;
            var stacks = [];
            var i2, meta;
            for (i2 = 0; i2 < ilen; ++i2) {
              meta = metasets[i2];
              if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
                stacks.push(meta.stack);
              }
              if (meta.index === last2) {
                break;
              }
            }
            return stacks;
          },
          getStackCount: function() {
            return this._getStacks().length;
          },
          getStackIndex: function(datasetIndex, name2) {
            var stacks = this._getStacks(datasetIndex);
            var index2 = name2 !== void 0 ? stacks.indexOf(name2) : -1;
            return index2 === -1 ? stacks.length - 1 : index2;
          },
          getRuler: function() {
            var me2 = this;
            var scale2 = me2._getIndexScale();
            var pixels = [];
            var i2, ilen;
            for (i2 = 0, ilen = me2.getMeta().data.length; i2 < ilen; ++i2) {
              pixels.push(scale2.getPixelForValue(null, i2, me2.index));
            }
            return {
              pixels,
              start: scale2._startPixel,
              end: scale2._endPixel,
              stackCount: me2.getStackCount(),
              scale: scale2
            };
          },
          calculateBarValuePixels: function(datasetIndex, index2, options2) {
            var me2 = this;
            var chart = me2.chart;
            var scale2 = me2._getValueScale();
            var isHorizontal = scale2.isHorizontal();
            var datasets = chart.data.datasets;
            var metasets = scale2._getMatchingVisibleMetas(me2._type);
            var value2 = scale2._parseValue(datasets[datasetIndex].data[index2]);
            var minBarLength = options2.minBarLength;
            var stacked = scale2.options.stacked;
            var stack = me2.getMeta().stack;
            var start = value2.start === void 0 ? 0 : value2.max >= 0 && value2.min >= 0 ? value2.min : value2.max;
            var length = value2.start === void 0 ? value2.end : value2.max >= 0 && value2.min >= 0 ? value2.max - value2.min : value2.min - value2.max;
            var ilen = metasets.length;
            var i2, imeta, ivalue, base, head, size2, stackLength;
            if (stacked || stacked === void 0 && stack !== void 0) {
              for (i2 = 0; i2 < ilen; ++i2) {
                imeta = metasets[i2];
                if (imeta.index === datasetIndex) {
                  break;
                }
                if (imeta.stack === stack) {
                  stackLength = scale2._parseValue(datasets[imeta.index].data[index2]);
                  ivalue = stackLength.start === void 0 ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;
                  if (value2.min < 0 && ivalue < 0 || value2.max >= 0 && ivalue > 0) {
                    start += ivalue;
                  }
                }
              }
            }
            base = scale2.getPixelForValue(start);
            head = scale2.getPixelForValue(start + length);
            size2 = head - base;
            if (minBarLength !== void 0 && Math.abs(size2) < minBarLength) {
              size2 = minBarLength;
              if (length >= 0 && !isHorizontal || length < 0 && isHorizontal) {
                head = base - minBarLength;
              } else {
                head = base + minBarLength;
              }
            }
            return {
              size: size2,
              base,
              head,
              center: head + size2 / 2
            };
          },
          calculateBarIndexPixels: function(datasetIndex, index2, ruler, options2) {
            var me2 = this;
            var range2 = options2.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options2) : computeFitCategoryTraits(index2, ruler, options2);
            var stackIndex = me2.getStackIndex(datasetIndex, me2.getMeta().stack);
            var center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
            var size2 = Math.min(
              valueOrDefault$3(options2.maxBarThickness, Infinity),
              range2.chunk * range2.ratio
            );
            return {
              base: center - size2 / 2,
              head: center + size2 / 2,
              center,
              size: size2
            };
          },
          draw: function() {
            var me2 = this;
            var chart = me2.chart;
            var scale2 = me2._getValueScale();
            var rects = me2.getMeta().data;
            var dataset = me2.getDataset();
            var ilen = rects.length;
            var i2 = 0;
            helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);
            for (; i2 < ilen; ++i2) {
              var val = scale2._parseValue(dataset.data[i2]);
              if (!isNaN(val.min) && !isNaN(val.max)) {
                rects[i2].draw();
              }
            }
            helpers$1.canvas.unclipArea(chart.ctx);
          },
          _resolveDataElementOptions: function() {
            var me2 = this;
            var values2 = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me2, arguments));
            var indexOpts = me2._getIndexScale().options;
            var valueOpts = me2._getValueScale().options;
            values2.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values2.barPercentage);
            values2.barThickness = valueOrDefault$3(indexOpts.barThickness, values2.barThickness);
            values2.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values2.categoryPercentage);
            values2.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values2.maxBarThickness);
            values2.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values2.minBarLength);
            return values2;
          }
        });
        var valueOrDefault$4 = helpers$1.valueOrDefault;
        var resolve$1 = helpers$1.options.resolve;
        core_defaults._set("bubble", {
          hover: {
            mode: "single"
          },
          scales: {
            xAxes: [{
              type: "linear",
              position: "bottom",
              id: "x-axis-0"
            }],
            yAxes: [{
              type: "linear",
              position: "left",
              id: "y-axis-0"
            }]
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item, data) {
                var datasetLabel = data.datasets[item.datasetIndex].label || "";
                var dataPoint = data.datasets[item.datasetIndex].data[item.index];
                return datasetLabel + ": (" + item.xLabel + ", " + item.yLabel + ", " + dataPoint.r + ")";
              }
            }
          }
        });
        var controller_bubble = core_datasetController.extend({
          dataElementType: elements.Point,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth",
            "hoverRadius",
            "hitRadius",
            "pointStyle",
            "rotation"
          ],
          update: function(reset) {
            var me2 = this;
            var meta = me2.getMeta();
            var points = meta.data;
            helpers$1.each(points, function(point, index2) {
              me2.updateElement(point, index2, reset);
            });
          },
          updateElement: function(point, index2, reset) {
            var me2 = this;
            var meta = me2.getMeta();
            var custom = point.custom || {};
            var xScale = me2.getScaleForId(meta.xAxisID);
            var yScale = me2.getScaleForId(meta.yAxisID);
            var options2 = me2._resolveDataElementOptions(point, index2);
            var data = me2.getDataset().data[index2];
            var dsIndex = me2.index;
            var x2 = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === "object" ? data : NaN, index2, dsIndex);
            var y2 = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index2, dsIndex);
            point._xScale = xScale;
            point._yScale = yScale;
            point._options = options2;
            point._datasetIndex = dsIndex;
            point._index = index2;
            point._model = {
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              hitRadius: options2.hitRadius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              radius: reset ? 0 : options2.radius,
              skip: custom.skip || isNaN(x2) || isNaN(y2),
              x: x2,
              y: y2
            };
            point.pivot();
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$4(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$4(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$4(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = options2.radius + options2.hoverRadius;
          },
          _resolveDataElementOptions: function(point, index2) {
            var me2 = this;
            var chart = me2.chart;
            var dataset = me2.getDataset();
            var custom = point.custom || {};
            var data = dataset.data[index2] || {};
            var values2 = core_datasetController.prototype._resolveDataElementOptions.apply(me2, arguments);
            var context2 = {
              chart,
              dataIndex: index2,
              dataset,
              datasetIndex: me2.index
            };
            if (me2._cachedDataOpts === values2) {
              values2 = helpers$1.extend({}, values2);
            }
            values2.radius = resolve$1([
              custom.radius,
              data.r,
              me2._config.radius,
              chart.options.elements.point.radius
            ], context2, index2);
            return values2;
          }
        });
        var valueOrDefault$5 = helpers$1.valueOrDefault;
        var PI$1 = Math.PI;
        var DOUBLE_PI$1 = PI$1 * 2;
        var HALF_PI$1 = PI$1 / 2;
        core_defaults._set("doughnut", {
          animation: {
            animateRotate: true,
            animateScale: false
          },
          hover: {
            mode: "single"
          },
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var data = chart.data;
            var datasets = data.datasets;
            var labels = data.labels;
            var i2, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            if (datasets.length) {
              for (i2 = 0, ilen = datasets[0].data.length; i2 < ilen; ++i2) {
                listItem = list.appendChild(document.createElement("li"));
                listItemSpan = listItem.appendChild(document.createElement("span"));
                listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i2];
                if (labels[i2]) {
                  listItem.appendChild(document.createTextNode(labels[i2]));
                }
              }
            }
            return list.outerHTML;
          },
          legend: {
            labels: {
              generateLabels: function(chart) {
                var data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  return data.labels.map(function(label, i2) {
                    var meta = chart.getDatasetMeta(0);
                    var style = meta.controller.getStyle(i2);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      hidden: isNaN(data.datasets[0].data[i2]) || meta.data[i2].hidden,
                      index: i2
                    };
                  });
                }
                return [];
              }
            },
            onClick: function(e, legendItem) {
              var index2 = legendItem.index;
              var chart = this.chart;
              var i2, ilen, meta;
              for (i2 = 0, ilen = (chart.data.datasets || []).length; i2 < ilen; ++i2) {
                meta = chart.getDatasetMeta(i2);
                if (meta.data[index2]) {
                  meta.data[index2].hidden = !meta.data[index2].hidden;
                }
              }
              chart.update();
            }
          },
          cutoutPercentage: 50,
          rotation: -HALF_PI$1,
          circumference: DOUBLE_PI$1,
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(tooltipItem, data) {
                var dataLabel = data.labels[tooltipItem.index];
                var value2 = ": " + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                if (helpers$1.isArray(dataLabel)) {
                  dataLabel = dataLabel.slice();
                  dataLabel[0] += value2;
                } else {
                  dataLabel += value2;
                }
                return dataLabel;
              }
            }
          }
        });
        var controller_doughnut = core_datasetController.extend({
          dataElementType: elements.Arc,
          linkScales: helpers$1.noop,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "borderAlign",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth"
          ],
          getRingIndex: function(datasetIndex) {
            var ringIndex = 0;
            for (var j = 0; j < datasetIndex; ++j) {
              if (this.chart.isDatasetVisible(j)) {
                ++ringIndex;
              }
            }
            return ringIndex;
          },
          update: function(reset) {
            var me2 = this;
            var chart = me2.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var ratioX = 1;
            var ratioY = 1;
            var offsetX = 0;
            var offsetY = 0;
            var meta = me2.getMeta();
            var arcs = meta.data;
            var cutout = opts.cutoutPercentage / 100 || 0;
            var circumference = opts.circumference;
            var chartWeight = me2._getRingWeight(me2.index);
            var maxWidth, maxHeight, i2, ilen;
            if (circumference < DOUBLE_PI$1) {
              var startAngle = opts.rotation % DOUBLE_PI$1;
              startAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;
              var endAngle = startAngle + circumference;
              var startX = Math.cos(startAngle);
              var startY = Math.sin(startAngle);
              var endX = Math.cos(endAngle);
              var endY = Math.sin(endAngle);
              var contains0 = startAngle <= 0 && endAngle >= 0 || endAngle >= DOUBLE_PI$1;
              var contains90 = startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1 || endAngle >= DOUBLE_PI$1 + HALF_PI$1;
              var contains180 = startAngle === -PI$1 || endAngle >= PI$1;
              var contains270 = startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1 || endAngle >= PI$1 + HALF_PI$1;
              var minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);
              var minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);
              var maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);
              var maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);
              ratioX = (maxX - minX) / 2;
              ratioY = (maxY - minY) / 2;
              offsetX = -(maxX + minX) / 2;
              offsetY = -(maxY + minY) / 2;
            }
            for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
              arcs[i2]._options = me2._resolveDataElementOptions(arcs[i2], i2);
            }
            chart.borderWidth = me2.getMaxBorderWidth();
            maxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;
            maxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;
            chart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            chart.innerRadius = Math.max(chart.outerRadius * cutout, 0);
            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me2._getVisibleDatasetWeightTotal() || 1);
            chart.offsetX = offsetX * chart.outerRadius;
            chart.offsetY = offsetY * chart.outerRadius;
            meta.total = me2.calculateTotal();
            me2.outerRadius = chart.outerRadius - chart.radiusLength * me2._getRingWeightOffset(me2.index);
            me2.innerRadius = Math.max(me2.outerRadius - chart.radiusLength * chartWeight, 0);
            for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
              me2.updateElement(arcs[i2], i2, reset);
            }
          },
          updateElement: function(arc, index2, reset) {
            var me2 = this;
            var chart = me2.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var animationOpts = opts.animation;
            var centerX = (chartArea.left + chartArea.right) / 2;
            var centerY = (chartArea.top + chartArea.bottom) / 2;
            var startAngle = opts.rotation;
            var endAngle = opts.rotation;
            var dataset = me2.getDataset();
            var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me2.calculateCircumference(dataset.data[index2]) * (opts.circumference / DOUBLE_PI$1);
            var innerRadius = reset && animationOpts.animateScale ? 0 : me2.innerRadius;
            var outerRadius = reset && animationOpts.animateScale ? 0 : me2.outerRadius;
            var options2 = arc._options || {};
            helpers$1.extend(arc, {
              _datasetIndex: me2.index,
              _index: index2,
              _model: {
                backgroundColor: options2.backgroundColor,
                borderColor: options2.borderColor,
                borderWidth: options2.borderWidth,
                borderAlign: options2.borderAlign,
                x: centerX + chart.offsetX,
                y: centerY + chart.offsetY,
                startAngle,
                endAngle,
                circumference,
                outerRadius,
                innerRadius,
                label: helpers$1.valueAtIndexOrDefault(dataset.label, index2, chart.data.labels[index2])
              }
            });
            var model = arc._model;
            if (!reset || !animationOpts.animateRotate) {
              if (index2 === 0) {
                model.startAngle = opts.rotation;
              } else {
                model.startAngle = me2.getMeta().data[index2 - 1]._model.endAngle;
              }
              model.endAngle = model.startAngle + model.circumference;
            }
            arc.pivot();
          },
          calculateTotal: function() {
            var dataset = this.getDataset();
            var meta = this.getMeta();
            var total = 0;
            var value2;
            helpers$1.each(meta.data, function(element, index2) {
              value2 = dataset.data[index2];
              if (!isNaN(value2) && !element.hidden) {
                total += Math.abs(value2);
              }
            });
            return total;
          },
          calculateCircumference: function(value2) {
            var total = this.getMeta().total;
            if (total > 0 && !isNaN(value2)) {
              return DOUBLE_PI$1 * (Math.abs(value2) / total);
            }
            return 0;
          },
          getMaxBorderWidth: function(arcs) {
            var me2 = this;
            var max2 = 0;
            var chart = me2.chart;
            var i2, ilen, meta, arc, controller, options2, borderWidth, hoverWidth;
            if (!arcs) {
              for (i2 = 0, ilen = chart.data.datasets.length; i2 < ilen; ++i2) {
                if (chart.isDatasetVisible(i2)) {
                  meta = chart.getDatasetMeta(i2);
                  arcs = meta.data;
                  if (i2 !== me2.index) {
                    controller = meta.controller;
                  }
                  break;
                }
              }
            }
            if (!arcs) {
              return 0;
            }
            for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
              arc = arcs[i2];
              if (controller) {
                controller._configure();
                options2 = controller._resolveDataElementOptions(arc, i2);
              } else {
                options2 = arc._options;
              }
              if (options2.borderAlign !== "inner") {
                borderWidth = options2.borderWidth;
                hoverWidth = options2.hoverBorderWidth;
                max2 = borderWidth > max2 ? borderWidth : max2;
                max2 = hoverWidth > max2 ? hoverWidth : max2;
              }
            }
            return max2;
          },
          setHoverStyle: function(arc) {
            var model = arc._model;
            var options2 = arc._options;
            var getHoverColor = helpers$1.getHoverColor;
            arc.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = valueOrDefault$5(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$5(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$5(options2.hoverBorderWidth, options2.borderWidth);
          },
          _getRingWeightOffset: function(datasetIndex) {
            var ringWeightOffset = 0;
            for (var i2 = 0; i2 < datasetIndex; ++i2) {
              if (this.chart.isDatasetVisible(i2)) {
                ringWeightOffset += this._getRingWeight(i2);
              }
            }
            return ringWeightOffset;
          },
          _getRingWeight: function(dataSetIndex) {
            return Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
          },
          _getVisibleDatasetWeightTotal: function() {
            return this._getRingWeightOffset(this.chart.data.datasets.length);
          }
        });
        core_defaults._set("horizontalBar", {
          hover: {
            mode: "index",
            axis: "y"
          },
          scales: {
            xAxes: [{
              type: "linear",
              position: "bottom"
            }],
            yAxes: [{
              type: "category",
              position: "left",
              offset: true,
              gridLines: {
                offsetGridLines: true
              }
            }]
          },
          elements: {
            rectangle: {
              borderSkipped: "left"
            }
          },
          tooltips: {
            mode: "index",
            axis: "y"
          }
        });
        core_defaults._set("global", {
          datasets: {
            horizontalBar: {
              categoryPercentage: 0.8,
              barPercentage: 0.9
            }
          }
        });
        var controller_horizontalBar = controller_bar.extend({
          _getValueScaleId: function() {
            return this.getMeta().xAxisID;
          },
          _getIndexScaleId: function() {
            return this.getMeta().yAxisID;
          }
        });
        var valueOrDefault$6 = helpers$1.valueOrDefault;
        var resolve$2 = helpers$1.options.resolve;
        var isPointInArea = helpers$1.canvas._isPointInArea;
        core_defaults._set("line", {
          showLines: true,
          spanGaps: false,
          hover: {
            mode: "label"
          },
          scales: {
            xAxes: [{
              type: "category",
              id: "x-axis-0"
            }],
            yAxes: [{
              type: "linear",
              id: "y-axis-0"
            }]
          }
        });
        function scaleClip(scale2, halfBorderWidth) {
          var tickOpts = scale2 && scale2.options.ticks || {};
          var reverse = tickOpts.reverse;
          var min2 = tickOpts.min === void 0 ? halfBorderWidth : 0;
          var max2 = tickOpts.max === void 0 ? halfBorderWidth : 0;
          return {
            start: reverse ? max2 : min2,
            end: reverse ? min2 : max2
          };
        }
        function defaultClip(xScale, yScale, borderWidth) {
          var halfBorderWidth = borderWidth / 2;
          var x2 = scaleClip(xScale, halfBorderWidth);
          var y2 = scaleClip(yScale, halfBorderWidth);
          return {
            top: y2.end,
            right: x2.end,
            bottom: y2.start,
            left: x2.start
          };
        }
        function toClip(value2) {
          var t2, r2, b, l2;
          if (helpers$1.isObject(value2)) {
            t2 = value2.top;
            r2 = value2.right;
            b = value2.bottom;
            l2 = value2.left;
          } else {
            t2 = r2 = b = l2 = value2;
          }
          return {
            top: t2,
            right: r2,
            bottom: b,
            left: l2
          };
        }
        var controller_line = core_datasetController.extend({
          datasetElementType: elements.Line,
          dataElementType: elements.Point,
          _datasetElementOptions: [
            "backgroundColor",
            "borderCapStyle",
            "borderColor",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "borderWidth",
            "cubicInterpolationMode",
            "fill"
          ],
          _dataElementOptions: {
            backgroundColor: "pointBackgroundColor",
            borderColor: "pointBorderColor",
            borderWidth: "pointBorderWidth",
            hitRadius: "pointHitRadius",
            hoverBackgroundColor: "pointHoverBackgroundColor",
            hoverBorderColor: "pointHoverBorderColor",
            hoverBorderWidth: "pointHoverBorderWidth",
            hoverRadius: "pointHoverRadius",
            pointStyle: "pointStyle",
            radius: "pointRadius",
            rotation: "pointRotation"
          },
          update: function(reset) {
            var me2 = this;
            var meta = me2.getMeta();
            var line = meta.dataset;
            var points = meta.data || [];
            var options2 = me2.chart.options;
            var config = me2._config;
            var showLine = me2._showLine = valueOrDefault$6(config.showLine, options2.showLines);
            var i2, ilen;
            me2._xScale = me2.getScaleForId(meta.xAxisID);
            me2._yScale = me2.getScaleForId(meta.yAxisID);
            if (showLine) {
              if (config.tension !== void 0 && config.lineTension === void 0) {
                config.lineTension = config.tension;
              }
              line._scale = me2._yScale;
              line._datasetIndex = me2.index;
              line._children = points;
              line._model = me2._resolveDatasetElementOptions(line);
              line.pivot();
            }
            for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
              me2.updateElement(points[i2], i2, reset);
            }
            if (showLine && line._model.tension !== 0) {
              me2.updateBezierControlPoints();
            }
            for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
              points[i2].pivot();
            }
          },
          updateElement: function(point, index2, reset) {
            var me2 = this;
            var meta = me2.getMeta();
            var custom = point.custom || {};
            var dataset = me2.getDataset();
            var datasetIndex = me2.index;
            var value2 = dataset.data[index2];
            var xScale = me2._xScale;
            var yScale = me2._yScale;
            var lineModel = meta.dataset._model;
            var x2, y2;
            var options2 = me2._resolveDataElementOptions(point, index2);
            x2 = xScale.getPixelForValue(typeof value2 === "object" ? value2 : NaN, index2, datasetIndex);
            y2 = reset ? yScale.getBasePixel() : me2.calculatePointY(value2, index2, datasetIndex);
            point._xScale = xScale;
            point._yScale = yScale;
            point._options = options2;
            point._datasetIndex = datasetIndex;
            point._index = index2;
            point._model = {
              x: x2,
              y: y2,
              skip: custom.skip || isNaN(x2) || isNaN(y2),
              radius: options2.radius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
              steppedLine: lineModel ? lineModel.steppedLine : false,
              hitRadius: options2.hitRadius
            };
          },
          _resolveDatasetElementOptions: function(element) {
            var me2 = this;
            var config = me2._config;
            var custom = element.custom || {};
            var options2 = me2.chart.options;
            var lineOptions = options2.elements.line;
            var values2 = core_datasetController.prototype._resolveDatasetElementOptions.apply(me2, arguments);
            values2.spanGaps = valueOrDefault$6(config.spanGaps, options2.spanGaps);
            values2.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);
            values2.steppedLine = resolve$2([custom.steppedLine, config.steppedLine, lineOptions.stepped]);
            values2.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me2._xScale, me2._yScale, values2.borderWidth)));
            return values2;
          },
          calculatePointY: function(value2, index2, datasetIndex) {
            var me2 = this;
            var chart = me2.chart;
            var yScale = me2._yScale;
            var sumPos = 0;
            var sumNeg = 0;
            var i2, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;
            if (yScale.options.stacked) {
              rightValue = +yScale.getRightValue(value2);
              metasets = chart._getSortedVisibleDatasetMetas();
              ilen = metasets.length;
              for (i2 = 0; i2 < ilen; ++i2) {
                dsMeta = metasets[i2];
                if (dsMeta.index === datasetIndex) {
                  break;
                }
                ds = chart.data.datasets[dsMeta.index];
                if (dsMeta.type === "line" && dsMeta.yAxisID === yScale.id) {
                  stackedRightValue = +yScale.getRightValue(ds.data[index2]);
                  if (stackedRightValue < 0) {
                    sumNeg += stackedRightValue || 0;
                  } else {
                    sumPos += stackedRightValue || 0;
                  }
                }
              }
              if (rightValue < 0) {
                return yScale.getPixelForValue(sumNeg + rightValue);
              }
              return yScale.getPixelForValue(sumPos + rightValue);
            }
            return yScale.getPixelForValue(value2);
          },
          updateBezierControlPoints: function() {
            var me2 = this;
            var chart = me2.chart;
            var meta = me2.getMeta();
            var lineModel = meta.dataset._model;
            var area2 = chart.chartArea;
            var points = meta.data || [];
            var i2, ilen, model, controlPoints;
            if (lineModel.spanGaps) {
              points = points.filter(function(pt) {
                return !pt._model.skip;
              });
            }
            function capControlPoint(pt, min2, max2) {
              return Math.max(Math.min(pt, max2), min2);
            }
            if (lineModel.cubicInterpolationMode === "monotone") {
              helpers$1.splineCurveMonotone(points);
            } else {
              for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
                model = points[i2]._model;
                controlPoints = helpers$1.splineCurve(
                  helpers$1.previousItem(points, i2)._model,
                  model,
                  helpers$1.nextItem(points, i2)._model,
                  lineModel.tension
                );
                model.controlPointPreviousX = controlPoints.previous.x;
                model.controlPointPreviousY = controlPoints.previous.y;
                model.controlPointNextX = controlPoints.next.x;
                model.controlPointNextY = controlPoints.next.y;
              }
            }
            if (chart.options.elements.line.capBezierPoints) {
              for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
                model = points[i2]._model;
                if (isPointInArea(model, area2)) {
                  if (i2 > 0 && isPointInArea(points[i2 - 1]._model, area2)) {
                    model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area2.left, area2.right);
                    model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area2.top, area2.bottom);
                  }
                  if (i2 < points.length - 1 && isPointInArea(points[i2 + 1]._model, area2)) {
                    model.controlPointNextX = capControlPoint(model.controlPointNextX, area2.left, area2.right);
                    model.controlPointNextY = capControlPoint(model.controlPointNextY, area2.top, area2.bottom);
                  }
                }
              }
            }
          },
          draw: function() {
            var me2 = this;
            var chart = me2.chart;
            var meta = me2.getMeta();
            var points = meta.data || [];
            var area2 = chart.chartArea;
            var canvas3 = chart.canvas;
            var i2 = 0;
            var ilen = points.length;
            var clip;
            if (me2._showLine) {
              clip = meta.dataset._model.clip;
              helpers$1.canvas.clipArea(chart.ctx, {
                left: clip.left === false ? 0 : area2.left - clip.left,
                right: clip.right === false ? canvas3.width : area2.right + clip.right,
                top: clip.top === false ? 0 : area2.top - clip.top,
                bottom: clip.bottom === false ? canvas3.height : area2.bottom + clip.bottom
              });
              meta.dataset.draw();
              helpers$1.canvas.unclipArea(chart.ctx);
            }
            for (; i2 < ilen; ++i2) {
              points[i2].draw(area2);
            }
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$6(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$6(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$6(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = valueOrDefault$6(options2.hoverRadius, options2.radius);
          }
        });
        var resolve$3 = helpers$1.options.resolve;
        core_defaults._set("polarArea", {
          scale: {
            type: "radialLinear",
            angleLines: {
              display: false
            },
            gridLines: {
              circular: true
            },
            pointLabels: {
              display: false
            },
            ticks: {
              beginAtZero: true
            }
          },
          animation: {
            animateRotate: true,
            animateScale: true
          },
          startAngle: -0.5 * Math.PI,
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var data = chart.data;
            var datasets = data.datasets;
            var labels = data.labels;
            var i2, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            if (datasets.length) {
              for (i2 = 0, ilen = datasets[0].data.length; i2 < ilen; ++i2) {
                listItem = list.appendChild(document.createElement("li"));
                listItemSpan = listItem.appendChild(document.createElement("span"));
                listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i2];
                if (labels[i2]) {
                  listItem.appendChild(document.createTextNode(labels[i2]));
                }
              }
            }
            return list.outerHTML;
          },
          legend: {
            labels: {
              generateLabels: function(chart) {
                var data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  return data.labels.map(function(label, i2) {
                    var meta = chart.getDatasetMeta(0);
                    var style = meta.controller.getStyle(i2);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      hidden: isNaN(data.datasets[0].data[i2]) || meta.data[i2].hidden,
                      index: i2
                    };
                  });
                }
                return [];
              }
            },
            onClick: function(e, legendItem) {
              var index2 = legendItem.index;
              var chart = this.chart;
              var i2, ilen, meta;
              for (i2 = 0, ilen = (chart.data.datasets || []).length; i2 < ilen; ++i2) {
                meta = chart.getDatasetMeta(i2);
                meta.data[index2].hidden = !meta.data[index2].hidden;
              }
              chart.update();
            }
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item, data) {
                return data.labels[item.index] + ": " + item.yLabel;
              }
            }
          }
        });
        var controller_polarArea = core_datasetController.extend({
          dataElementType: elements.Arc,
          linkScales: helpers$1.noop,
          _dataElementOptions: [
            "backgroundColor",
            "borderColor",
            "borderWidth",
            "borderAlign",
            "hoverBackgroundColor",
            "hoverBorderColor",
            "hoverBorderWidth"
          ],
          _getIndexScaleId: function() {
            return this.chart.scale.id;
          },
          _getValueScaleId: function() {
            return this.chart.scale.id;
          },
          update: function(reset) {
            var me2 = this;
            var dataset = me2.getDataset();
            var meta = me2.getMeta();
            var start = me2.chart.options.startAngle || 0;
            var starts = me2._starts = [];
            var angles = me2._angles = [];
            var arcs = meta.data;
            var i2, ilen, angle;
            me2._updateRadius();
            meta.count = me2.countVisibleElements();
            for (i2 = 0, ilen = dataset.data.length; i2 < ilen; i2++) {
              starts[i2] = start;
              angle = me2._computeAngle(i2);
              angles[i2] = angle;
              start += angle;
            }
            for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
              arcs[i2]._options = me2._resolveDataElementOptions(arcs[i2], i2);
              me2.updateElement(arcs[i2], i2, reset);
            }
          },
          _updateRadius: function() {
            var me2 = this;
            var chart = me2.chart;
            var chartArea = chart.chartArea;
            var opts = chart.options;
            var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            chart.outerRadius = Math.max(minSize / 2, 0);
            chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
            me2.outerRadius = chart.outerRadius - chart.radiusLength * me2.index;
            me2.innerRadius = me2.outerRadius - chart.radiusLength;
          },
          updateElement: function(arc, index2, reset) {
            var me2 = this;
            var chart = me2.chart;
            var dataset = me2.getDataset();
            var opts = chart.options;
            var animationOpts = opts.animation;
            var scale2 = chart.scale;
            var labels = chart.data.labels;
            var centerX = scale2.xCenter;
            var centerY = scale2.yCenter;
            var datasetStartAngle = opts.startAngle;
            var distance = arc.hidden ? 0 : scale2.getDistanceFromCenterForValue(dataset.data[index2]);
            var startAngle = me2._starts[index2];
            var endAngle = startAngle + (arc.hidden ? 0 : me2._angles[index2]);
            var resetRadius = animationOpts.animateScale ? 0 : scale2.getDistanceFromCenterForValue(dataset.data[index2]);
            var options2 = arc._options || {};
            helpers$1.extend(arc, {
              _datasetIndex: me2.index,
              _index: index2,
              _scale: scale2,
              _model: {
                backgroundColor: options2.backgroundColor,
                borderColor: options2.borderColor,
                borderWidth: options2.borderWidth,
                borderAlign: options2.borderAlign,
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius: reset ? resetRadius : distance,
                startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
                endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
                label: helpers$1.valueAtIndexOrDefault(labels, index2, labels[index2])
              }
            });
            arc.pivot();
          },
          countVisibleElements: function() {
            var dataset = this.getDataset();
            var meta = this.getMeta();
            var count = 0;
            helpers$1.each(meta.data, function(element, index2) {
              if (!isNaN(dataset.data[index2]) && !element.hidden) {
                count++;
              }
            });
            return count;
          },
          setHoverStyle: function(arc) {
            var model = arc._model;
            var options2 = arc._options;
            var getHoverColor = helpers$1.getHoverColor;
            var valueOrDefault2 = helpers$1.valueOrDefault;
            arc.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth
            };
            model.backgroundColor = valueOrDefault2(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault2(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault2(options2.hoverBorderWidth, options2.borderWidth);
          },
          _computeAngle: function(index2) {
            var me2 = this;
            var count = this.getMeta().count;
            var dataset = me2.getDataset();
            var meta = me2.getMeta();
            if (isNaN(dataset.data[index2]) || meta.data[index2].hidden) {
              return 0;
            }
            var context2 = {
              chart: me2.chart,
              dataIndex: index2,
              dataset,
              datasetIndex: me2.index
            };
            return resolve$3([
              me2.chart.options.elements.arc.angle,
              2 * Math.PI / count
            ], context2, index2);
          }
        });
        core_defaults._set("pie", helpers$1.clone(core_defaults.doughnut));
        core_defaults._set("pie", {
          cutoutPercentage: 0
        });
        var controller_pie = controller_doughnut;
        var valueOrDefault$7 = helpers$1.valueOrDefault;
        core_defaults._set("radar", {
          spanGaps: false,
          scale: {
            type: "radialLinear"
          },
          elements: {
            line: {
              fill: "start",
              tension: 0
            }
          }
        });
        var controller_radar = core_datasetController.extend({
          datasetElementType: elements.Line,
          dataElementType: elements.Point,
          linkScales: helpers$1.noop,
          _datasetElementOptions: [
            "backgroundColor",
            "borderWidth",
            "borderColor",
            "borderCapStyle",
            "borderDash",
            "borderDashOffset",
            "borderJoinStyle",
            "fill"
          ],
          _dataElementOptions: {
            backgroundColor: "pointBackgroundColor",
            borderColor: "pointBorderColor",
            borderWidth: "pointBorderWidth",
            hitRadius: "pointHitRadius",
            hoverBackgroundColor: "pointHoverBackgroundColor",
            hoverBorderColor: "pointHoverBorderColor",
            hoverBorderWidth: "pointHoverBorderWidth",
            hoverRadius: "pointHoverRadius",
            pointStyle: "pointStyle",
            radius: "pointRadius",
            rotation: "pointRotation"
          },
          _getIndexScaleId: function() {
            return this.chart.scale.id;
          },
          _getValueScaleId: function() {
            return this.chart.scale.id;
          },
          update: function(reset) {
            var me2 = this;
            var meta = me2.getMeta();
            var line = meta.dataset;
            var points = meta.data || [];
            var scale2 = me2.chart.scale;
            var config = me2._config;
            var i2, ilen;
            if (config.tension !== void 0 && config.lineTension === void 0) {
              config.lineTension = config.tension;
            }
            line._scale = scale2;
            line._datasetIndex = me2.index;
            line._children = points;
            line._loop = true;
            line._model = me2._resolveDatasetElementOptions(line);
            line.pivot();
            for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
              me2.updateElement(points[i2], i2, reset);
            }
            me2.updateBezierControlPoints();
            for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
              points[i2].pivot();
            }
          },
          updateElement: function(point, index2, reset) {
            var me2 = this;
            var custom = point.custom || {};
            var dataset = me2.getDataset();
            var scale2 = me2.chart.scale;
            var pointPosition = scale2.getPointPositionForValue(index2, dataset.data[index2]);
            var options2 = me2._resolveDataElementOptions(point, index2);
            var lineModel = me2.getMeta().dataset._model;
            var x2 = reset ? scale2.xCenter : pointPosition.x;
            var y2 = reset ? scale2.yCenter : pointPosition.y;
            point._scale = scale2;
            point._options = options2;
            point._datasetIndex = me2.index;
            point._index = index2;
            point._model = {
              x: x2,
              y: y2,
              skip: custom.skip || isNaN(x2) || isNaN(y2),
              radius: options2.radius,
              pointStyle: options2.pointStyle,
              rotation: options2.rotation,
              backgroundColor: options2.backgroundColor,
              borderColor: options2.borderColor,
              borderWidth: options2.borderWidth,
              tension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),
              hitRadius: options2.hitRadius
            };
          },
          _resolveDatasetElementOptions: function() {
            var me2 = this;
            var config = me2._config;
            var options2 = me2.chart.options;
            var values2 = core_datasetController.prototype._resolveDatasetElementOptions.apply(me2, arguments);
            values2.spanGaps = valueOrDefault$7(config.spanGaps, options2.spanGaps);
            values2.tension = valueOrDefault$7(config.lineTension, options2.elements.line.tension);
            return values2;
          },
          updateBezierControlPoints: function() {
            var me2 = this;
            var meta = me2.getMeta();
            var area2 = me2.chart.chartArea;
            var points = meta.data || [];
            var i2, ilen, model, controlPoints;
            if (meta.dataset._model.spanGaps) {
              points = points.filter(function(pt) {
                return !pt._model.skip;
              });
            }
            function capControlPoint(pt, min2, max2) {
              return Math.max(Math.min(pt, max2), min2);
            }
            for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
              model = points[i2]._model;
              controlPoints = helpers$1.splineCurve(
                helpers$1.previousItem(points, i2, true)._model,
                model,
                helpers$1.nextItem(points, i2, true)._model,
                model.tension
              );
              model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area2.left, area2.right);
              model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area2.top, area2.bottom);
              model.controlPointNextX = capControlPoint(controlPoints.next.x, area2.left, area2.right);
              model.controlPointNextY = capControlPoint(controlPoints.next.y, area2.top, area2.bottom);
            }
          },
          setHoverStyle: function(point) {
            var model = point._model;
            var options2 = point._options;
            var getHoverColor = helpers$1.getHoverColor;
            point.$previousStyle = {
              backgroundColor: model.backgroundColor,
              borderColor: model.borderColor,
              borderWidth: model.borderWidth,
              radius: model.radius
            };
            model.backgroundColor = valueOrDefault$7(options2.hoverBackgroundColor, getHoverColor(options2.backgroundColor));
            model.borderColor = valueOrDefault$7(options2.hoverBorderColor, getHoverColor(options2.borderColor));
            model.borderWidth = valueOrDefault$7(options2.hoverBorderWidth, options2.borderWidth);
            model.radius = valueOrDefault$7(options2.hoverRadius, options2.radius);
          }
        });
        core_defaults._set("scatter", {
          hover: {
            mode: "single"
          },
          scales: {
            xAxes: [{
              id: "x-axis-1",
              type: "linear",
              position: "bottom"
            }],
            yAxes: [{
              id: "y-axis-1",
              type: "linear",
              position: "left"
            }]
          },
          tooltips: {
            callbacks: {
              title: function() {
                return "";
              },
              label: function(item) {
                return "(" + item.xLabel + ", " + item.yLabel + ")";
              }
            }
          }
        });
        core_defaults._set("global", {
          datasets: {
            scatter: {
              showLine: false
            }
          }
        });
        var controller_scatter = controller_line;
        var controllers = {
          bar: controller_bar,
          bubble: controller_bubble,
          doughnut: controller_doughnut,
          horizontalBar: controller_horizontalBar,
          line: controller_line,
          polarArea: controller_polarArea,
          pie: controller_pie,
          radar: controller_radar,
          scatter: controller_scatter
        };
        function getRelativePosition(e, chart) {
          if (e.native) {
            return {
              x: e.x,
              y: e.y
            };
          }
          return helpers$1.getRelativePosition(e, chart);
        }
        function parseVisibleItems(chart, handler) {
          var metasets = chart._getSortedVisibleDatasetMetas();
          var metadata, i2, j, ilen, jlen, element;
          for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
            metadata = metasets[i2].data;
            for (j = 0, jlen = metadata.length; j < jlen; ++j) {
              element = metadata[j];
              if (!element._view.skip) {
                handler(element);
              }
            }
          }
        }
        function getIntersectItems(chart, position) {
          var elements2 = [];
          parseVisibleItems(chart, function(element) {
            if (element.inRange(position.x, position.y)) {
              elements2.push(element);
            }
          });
          return elements2;
        }
        function getNearestItems(chart, position, intersect, distanceMetric) {
          var minDistance = Number.POSITIVE_INFINITY;
          var nearestItems = [];
          parseVisibleItems(chart, function(element) {
            if (intersect && !element.inRange(position.x, position.y)) {
              return;
            }
            var center = element.getCenterPoint();
            var distance = distanceMetric(position, center);
            if (distance < minDistance) {
              nearestItems = [element];
              minDistance = distance;
            } else if (distance === minDistance) {
              nearestItems.push(element);
            }
          });
          return nearestItems;
        }
        function getDistanceMetricForAxis(axis) {
          var useX = axis.indexOf("x") !== -1;
          var useY = axis.indexOf("y") !== -1;
          return function(pt1, pt2) {
            var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          };
        }
        function indexMode(chart, e, options2) {
          var position = getRelativePosition(e, chart);
          options2.axis = options2.axis || "x";
          var distanceMetric = getDistanceMetricForAxis(options2.axis);
          var items2 = options2.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
          var elements2 = [];
          if (!items2.length) {
            return [];
          }
          chart._getSortedVisibleDatasetMetas().forEach(function(meta) {
            var element = meta.data[items2[0]._index];
            if (element && !element._view.skip) {
              elements2.push(element);
            }
          });
          return elements2;
        }
        var core_interaction = {
          modes: {
            single: function(chart, e) {
              var position = getRelativePosition(e, chart);
              var elements2 = [];
              parseVisibleItems(chart, function(element) {
                if (element.inRange(position.x, position.y)) {
                  elements2.push(element);
                  return elements2;
                }
              });
              return elements2.slice(0, 1);
            },
            label: indexMode,
            index: indexMode,
            dataset: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              options2.axis = options2.axis || "xy";
              var distanceMetric = getDistanceMetricForAxis(options2.axis);
              var items2 = options2.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
              if (items2.length > 0) {
                items2 = chart.getDatasetMeta(items2[0]._datasetIndex).data;
              }
              return items2;
            },
            "x-axis": function(chart, e) {
              return indexMode(chart, e, { intersect: false });
            },
            point: function(chart, e) {
              var position = getRelativePosition(e, chart);
              return getIntersectItems(chart, position);
            },
            nearest: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              options2.axis = options2.axis || "xy";
              var distanceMetric = getDistanceMetricForAxis(options2.axis);
              return getNearestItems(chart, position, options2.intersect, distanceMetric);
            },
            x: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              var items2 = [];
              var intersectsItem = false;
              parseVisibleItems(chart, function(element) {
                if (element.inXRange(position.x)) {
                  items2.push(element);
                }
                if (element.inRange(position.x, position.y)) {
                  intersectsItem = true;
                }
              });
              if (options2.intersect && !intersectsItem) {
                items2 = [];
              }
              return items2;
            },
            y: function(chart, e, options2) {
              var position = getRelativePosition(e, chart);
              var items2 = [];
              var intersectsItem = false;
              parseVisibleItems(chart, function(element) {
                if (element.inYRange(position.y)) {
                  items2.push(element);
                }
                if (element.inRange(position.x, position.y)) {
                  intersectsItem = true;
                }
              });
              if (options2.intersect && !intersectsItem) {
                items2 = [];
              }
              return items2;
            }
          }
        };
        var extend2 = helpers$1.extend;
        function filterByPosition(array, position) {
          return helpers$1.where(array, function(v2) {
            return v2.pos === position;
          });
        }
        function sortByWeight(array, reverse) {
          return array.sort(function(a2, b) {
            var v0 = reverse ? b : a2;
            var v1 = reverse ? a2 : b;
            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
          });
        }
        function wrapBoxes(boxes) {
          var layoutBoxes = [];
          var i2, ilen, box;
          for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
            box = boxes[i2];
            layoutBoxes.push({
              index: i2,
              box,
              pos: box.position,
              horizontal: box.isHorizontal(),
              weight: box.weight
            });
          }
          return layoutBoxes;
        }
        function setLayoutDims(layouts, params) {
          var i2, ilen, layout;
          for (i2 = 0, ilen = layouts.length; i2 < ilen; ++i2) {
            layout = layouts[i2];
            layout.width = layout.horizontal ? layout.box.fullWidth && params.availableWidth : params.vBoxMaxWidth;
            layout.height = layout.horizontal && params.hBoxMaxHeight;
          }
        }
        function buildLayoutBoxes(boxes) {
          var layoutBoxes = wrapBoxes(boxes);
          var left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
          var right = sortByWeight(filterByPosition(layoutBoxes, "right"));
          var top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
          var bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
          return {
            leftAndTop: left.concat(top),
            rightAndBottom: right.concat(bottom),
            chartArea: filterByPosition(layoutBoxes, "chartArea"),
            vertical: left.concat(right),
            horizontal: top.concat(bottom)
          };
        }
        function getCombinedMax(maxPadding, chartArea, a2, b) {
          return Math.max(maxPadding[a2], chartArea[a2]) + Math.max(maxPadding[b], chartArea[b]);
        }
        function updateDims(chartArea, params, layout) {
          var box = layout.box;
          var maxPadding = chartArea.maxPadding;
          var newWidth, newHeight;
          if (layout.size) {
            chartArea[layout.pos] -= layout.size;
          }
          layout.size = layout.horizontal ? box.height : box.width;
          chartArea[layout.pos] += layout.size;
          if (box.getPadding) {
            var boxPadding = box.getPadding();
            maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
            maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
            maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
            maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
          }
          newWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right");
          newHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom");
          if (newWidth !== chartArea.w || newHeight !== chartArea.h) {
            chartArea.w = newWidth;
            chartArea.h = newHeight;
            var sizes = layout.horizontal ? [newWidth, chartArea.w] : [newHeight, chartArea.h];
            return sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));
          }
        }
        function handleMaxPadding(chartArea) {
          var maxPadding = chartArea.maxPadding;
          function updatePos(pos) {
            var change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
          }
          chartArea.y += updatePos("top");
          chartArea.x += updatePos("left");
          updatePos("right");
          updatePos("bottom");
        }
        function getMargins(horizontal, chartArea) {
          var maxPadding = chartArea.maxPadding;
          function marginForPositions(positions) {
            var margin = { left: 0, top: 0, right: 0, bottom: 0 };
            positions.forEach(function(pos) {
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
          }
          return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
        }
        function fitBoxes(boxes, chartArea, params) {
          var refitBoxes = [];
          var i2, ilen, layout, box, refit, changed;
          for (i2 = 0, ilen = boxes.length; i2 < ilen; ++i2) {
            layout = boxes[i2];
            box = layout.box;
            box.update(
              layout.width || chartArea.w,
              layout.height || chartArea.h,
              getMargins(layout.horizontal, chartArea)
            );
            if (updateDims(chartArea, params, layout)) {
              changed = true;
              if (refitBoxes.length) {
                refit = true;
              }
            }
            if (!box.fullWidth) {
              refitBoxes.push(layout);
            }
          }
          return refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;
        }
        function placeBoxes(boxes, chartArea, params) {
          var userPadding = params.padding;
          var x2 = chartArea.x;
          var y2 = chartArea.y;
          var i2, ilen, layout, box;
          for (i2 = 0, ilen = boxes.length; i2 < ilen; ++i2) {
            layout = boxes[i2];
            box = layout.box;
            if (layout.horizontal) {
              box.left = box.fullWidth ? userPadding.left : chartArea.left;
              box.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;
              box.top = y2;
              box.bottom = y2 + box.height;
              box.width = box.right - box.left;
              y2 = box.bottom;
            } else {
              box.left = x2;
              box.right = x2 + box.width;
              box.top = chartArea.top;
              box.bottom = chartArea.top + chartArea.h;
              box.height = box.bottom - box.top;
              x2 = box.right;
            }
          }
          chartArea.x = x2;
          chartArea.y = y2;
        }
        core_defaults._set("global", {
          layout: {
            padding: {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            }
          }
        });
        var core_layouts = {
          defaults: {},
          addBox: function(chart, item) {
            if (!chart.boxes) {
              chart.boxes = [];
            }
            item.fullWidth = item.fullWidth || false;
            item.position = item.position || "top";
            item.weight = item.weight || 0;
            item._layers = item._layers || function() {
              return [{
                z: 0,
                draw: function() {
                  item.draw.apply(item, arguments);
                }
              }];
            };
            chart.boxes.push(item);
          },
          removeBox: function(chart, layoutItem) {
            var index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
            if (index2 !== -1) {
              chart.boxes.splice(index2, 1);
            }
          },
          configure: function(chart, item, options2) {
            var props = ["fullWidth", "position", "weight"];
            var ilen = props.length;
            var i2 = 0;
            var prop;
            for (; i2 < ilen; ++i2) {
              prop = props[i2];
              if (options2.hasOwnProperty(prop)) {
                item[prop] = options2[prop];
              }
            }
          },
          update: function(chart, width2, height2) {
            if (!chart) {
              return;
            }
            var layoutOptions = chart.options.layout || {};
            var padding = helpers$1.options.toPadding(layoutOptions.padding);
            var availableWidth = width2 - padding.width;
            var availableHeight = height2 - padding.height;
            var boxes = buildLayoutBoxes(chart.boxes);
            var verticalBoxes = boxes.vertical;
            var horizontalBoxes = boxes.horizontal;
            var params = Object.freeze({
              outerWidth: width2,
              outerHeight: height2,
              padding,
              availableWidth,
              vBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,
              hBoxMaxHeight: availableHeight / 2
            });
            var chartArea = extend2({
              maxPadding: extend2({}, padding),
              w: availableWidth,
              h: availableHeight,
              x: padding.left,
              y: padding.top
            }, padding);
            setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
            fitBoxes(verticalBoxes, chartArea, params);
            if (fitBoxes(horizontalBoxes, chartArea, params)) {
              fitBoxes(verticalBoxes, chartArea, params);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params);
            chart.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h
            };
            helpers$1.each(boxes.chartArea, function(layout) {
              var box = layout.box;
              extend2(box, chart.chartArea);
              box.update(chartArea.w, chartArea.h);
            });
          }
        };
        var platform_basic = {
          acquireContext: function(item) {
            if (item && item.canvas) {
              item = item.canvas;
            }
            return item && item.getContext("2d") || null;
          }
        };
        var platform_dom = "/*\r\n * DOM element rendering detection\r\n * https://davidwalsh.name/detect-node-insertion\r\n */\r\n@keyframes chartjs-render-animation {\r\n	from { opacity: 0.99; }\r\n	to { opacity: 1; }\r\n}\r\n\r\n.chartjs-render-monitor {\r\n	animation: chartjs-render-animation 0.001s;\r\n}\r\n\r\n/*\r\n * DOM element resizing detection\r\n * https://github.com/marcj/css-element-queries\r\n */\r\n.chartjs-size-monitor,\r\n.chartjs-size-monitor-expand,\r\n.chartjs-size-monitor-shrink {\r\n	position: absolute;\r\n	direction: ltr;\r\n	left: 0;\r\n	top: 0;\r\n	right: 0;\r\n	bottom: 0;\r\n	overflow: hidden;\r\n	pointer-events: none;\r\n	visibility: hidden;\r\n	z-index: -1;\r\n}\r\n\r\n.chartjs-size-monitor-expand > div {\r\n	position: absolute;\r\n	width: 1000000px;\r\n	height: 1000000px;\r\n	left: 0;\r\n	top: 0;\r\n}\r\n\r\n.chartjs-size-monitor-shrink > div {\r\n	position: absolute;\r\n	width: 200%;\r\n	height: 200%;\r\n	left: 0;\r\n	top: 0;\r\n}\r\n";
        var platform_dom$1 = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          "default": platform_dom
        });
        var stylesheet = getCjsExportFromNamespace(platform_dom$1);
        var EXPANDO_KEY = "$chartjs";
        var CSS_PREFIX = "chartjs-";
        var CSS_SIZE_MONITOR = CSS_PREFIX + "size-monitor";
        var CSS_RENDER_MONITOR = CSS_PREFIX + "render-monitor";
        var CSS_RENDER_ANIMATION = CSS_PREFIX + "render-animation";
        var ANIMATION_START_EVENTS = ["animationstart", "webkitAnimationStart"];
        var EVENT_TYPES = {
          touchstart: "mousedown",
          touchmove: "mousemove",
          touchend: "mouseup",
          pointerenter: "mouseenter",
          pointerdown: "mousedown",
          pointermove: "mousemove",
          pointerup: "mouseup",
          pointerleave: "mouseout",
          pointerout: "mouseout"
        };
        function readUsedSize(element, property2) {
          var value2 = helpers$1.getStyle(element, property2);
          var matches = value2 && value2.match(/^(\d+)(\.\d+)?px$/);
          return matches ? Number(matches[1]) : void 0;
        }
        function initCanvas(canvas3, config) {
          var style = canvas3.style;
          var renderHeight = canvas3.getAttribute("height");
          var renderWidth = canvas3.getAttribute("width");
          canvas3[EXPANDO_KEY] = {
            initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                display: style.display,
                height: style.height,
                width: style.width
              }
            }
          };
          style.display = style.display || "block";
          if (renderWidth === null || renderWidth === "") {
            var displayWidth = readUsedSize(canvas3, "width");
            if (displayWidth !== void 0) {
              canvas3.width = displayWidth;
            }
          }
          if (renderHeight === null || renderHeight === "") {
            if (canvas3.style.height === "") {
              canvas3.height = canvas3.width / (config.options.aspectRatio || 2);
            } else {
              var displayHeight = readUsedSize(canvas3, "height");
              if (displayWidth !== void 0) {
                canvas3.height = displayHeight;
              }
            }
          }
          return canvas3;
        }
        var supportsEventListenerOptions = function() {
          var supports = false;
          try {
            var options2 = Object.defineProperty({}, "passive", {
              get: function() {
                supports = true;
              }
            });
            window.addEventListener("e", null, options2);
          } catch (e) {
          }
          return supports;
        }();
        var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
        function addListener(node, type, listener) {
          node.addEventListener(type, listener, eventListenerOptions);
        }
        function removeListener(node, type, listener) {
          node.removeEventListener(type, listener, eventListenerOptions);
        }
        function createEvent(type, chart, x2, y2, nativeEvent) {
          return {
            type,
            chart,
            native: nativeEvent || null,
            x: x2 !== void 0 ? x2 : null,
            y: y2 !== void 0 ? y2 : null
          };
        }
        function fromNativeEvent(event, chart) {
          var type = EVENT_TYPES[event.type] || event.type;
          var pos = helpers$1.getRelativePosition(event, chart);
          return createEvent(type, chart, pos.x, pos.y, event);
        }
        function throttled(fn, thisArg) {
          var ticking = false;
          var args = [];
          return function() {
            args = Array.prototype.slice.call(arguments);
            thisArg = thisArg || this;
            if (!ticking) {
              ticking = true;
              helpers$1.requestAnimFrame.call(window, function() {
                ticking = false;
                fn.apply(thisArg, args);
              });
            }
          };
        }
        function createDiv(cls) {
          var el = document.createElement("div");
          el.className = cls || "";
          return el;
        }
        function createResizer(handler) {
          var maxSize = 1e6;
          var resizer = createDiv(CSS_SIZE_MONITOR);
          var expand = createDiv(CSS_SIZE_MONITOR + "-expand");
          var shrink = createDiv(CSS_SIZE_MONITOR + "-shrink");
          expand.appendChild(createDiv());
          shrink.appendChild(createDiv());
          resizer.appendChild(expand);
          resizer.appendChild(shrink);
          resizer._reset = function() {
            expand.scrollLeft = maxSize;
            expand.scrollTop = maxSize;
            shrink.scrollLeft = maxSize;
            shrink.scrollTop = maxSize;
          };
          var onScroll = function() {
            resizer._reset();
            handler();
          };
          addListener(expand, "scroll", onScroll.bind(expand, "expand"));
          addListener(shrink, "scroll", onScroll.bind(shrink, "shrink"));
          return resizer;
        }
        function watchForRender(node, handler) {
          var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
          var proxy = expando.renderProxy = function(e) {
            if (e.animationName === CSS_RENDER_ANIMATION) {
              handler();
            }
          };
          helpers$1.each(ANIMATION_START_EVENTS, function(type) {
            addListener(node, type, proxy);
          });
          expando.reflow = !!node.offsetParent;
          node.classList.add(CSS_RENDER_MONITOR);
        }
        function unwatchForRender(node) {
          var expando = node[EXPANDO_KEY] || {};
          var proxy = expando.renderProxy;
          if (proxy) {
            helpers$1.each(ANIMATION_START_EVENTS, function(type) {
              removeListener(node, type, proxy);
            });
            delete expando.renderProxy;
          }
          node.classList.remove(CSS_RENDER_MONITOR);
        }
        function addResizeListener(node, listener, chart) {
          var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
          var resizer = expando.resizer = createResizer(throttled(function() {
            if (expando.resizer) {
              var container = chart.options.maintainAspectRatio && node.parentNode;
              var w2 = container ? container.clientWidth : 0;
              listener(createEvent("resize", chart));
              if (container && container.clientWidth < w2 && chart.canvas) {
                listener(createEvent("resize", chart));
              }
            }
          }));
          watchForRender(node, function() {
            if (expando.resizer) {
              var container = node.parentNode;
              if (container && container !== resizer.parentNode) {
                container.insertBefore(resizer, container.firstChild);
              }
              resizer._reset();
            }
          });
        }
        function removeResizeListener(node) {
          var expando = node[EXPANDO_KEY] || {};
          var resizer = expando.resizer;
          delete expando.resizer;
          unwatchForRender(node);
          if (resizer && resizer.parentNode) {
            resizer.parentNode.removeChild(resizer);
          }
        }
        function injectCSS(rootNode, css) {
          var expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});
          if (!expando.containsStyles) {
            expando.containsStyles = true;
            css = "/* Chart.js */\n" + css;
            var style = document.createElement("style");
            style.setAttribute("type", "text/css");
            style.appendChild(document.createTextNode(css));
            rootNode.appendChild(style);
          }
        }
        var platform_dom$2 = {
          disableCSSInjection: false,
          _enabled: typeof window !== "undefined" && typeof document !== "undefined",
          _ensureLoaded: function(canvas3) {
            if (!this.disableCSSInjection) {
              var root2 = canvas3.getRootNode ? canvas3.getRootNode() : document;
              var targetNode = root2.host ? root2 : document.head;
              injectCSS(targetNode, stylesheet);
            }
          },
          acquireContext: function(item, config) {
            if (typeof item === "string") {
              item = document.getElementById(item);
            } else if (item.length) {
              item = item[0];
            }
            if (item && item.canvas) {
              item = item.canvas;
            }
            var context2 = item && item.getContext && item.getContext("2d");
            if (context2 && context2.canvas === item) {
              this._ensureLoaded(item);
              initCanvas(item, config);
              return context2;
            }
            return null;
          },
          releaseContext: function(context2) {
            var canvas3 = context2.canvas;
            if (!canvas3[EXPANDO_KEY]) {
              return;
            }
            var initial2 = canvas3[EXPANDO_KEY].initial;
            ["height", "width"].forEach(function(prop) {
              var value2 = initial2[prop];
              if (helpers$1.isNullOrUndef(value2)) {
                canvas3.removeAttribute(prop);
              } else {
                canvas3.setAttribute(prop, value2);
              }
            });
            helpers$1.each(initial2.style || {}, function(value2, key) {
              canvas3.style[key] = value2;
            });
            canvas3.width = canvas3.width;
            delete canvas3[EXPANDO_KEY];
          },
          addEventListener: function(chart, type, listener) {
            var canvas3 = chart.canvas;
            if (type === "resize") {
              addResizeListener(canvas3, listener, chart);
              return;
            }
            var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
            var proxies = expando.proxies || (expando.proxies = {});
            var proxy = proxies[chart.id + "_" + type] = function(event) {
              listener(fromNativeEvent(event, chart));
            };
            addListener(canvas3, type, proxy);
          },
          removeEventListener: function(chart, type, listener) {
            var canvas3 = chart.canvas;
            if (type === "resize") {
              removeResizeListener(canvas3);
              return;
            }
            var expando = listener[EXPANDO_KEY] || {};
            var proxies = expando.proxies || {};
            var proxy = proxies[chart.id + "_" + type];
            if (!proxy) {
              return;
            }
            removeListener(canvas3, type, proxy);
          }
        };
        helpers$1.addEvent = addListener;
        helpers$1.removeEvent = removeListener;
        var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
        var platform2 = helpers$1.extend({
          initialize: function() {
          },
          acquireContext: function() {
          },
          releaseContext: function() {
          },
          addEventListener: function() {
          },
          removeEventListener: function() {
          }
        }, implementation);
        core_defaults._set("global", {
          plugins: {}
        });
        var core_plugins = {
          _plugins: [],
          _cacheId: 0,
          register: function(plugins2) {
            var p2 = this._plugins;
            [].concat(plugins2).forEach(function(plugin) {
              if (p2.indexOf(plugin) === -1) {
                p2.push(plugin);
              }
            });
            this._cacheId++;
          },
          unregister: function(plugins2) {
            var p2 = this._plugins;
            [].concat(plugins2).forEach(function(plugin) {
              var idx = p2.indexOf(plugin);
              if (idx !== -1) {
                p2.splice(idx, 1);
              }
            });
            this._cacheId++;
          },
          clear: function() {
            this._plugins = [];
            this._cacheId++;
          },
          count: function() {
            return this._plugins.length;
          },
          getAll: function() {
            return this._plugins;
          },
          notify: function(chart, hook, args) {
            var descriptors2 = this.descriptors(chart);
            var ilen = descriptors2.length;
            var i2, descriptor, plugin, params, method;
            for (i2 = 0; i2 < ilen; ++i2) {
              descriptor = descriptors2[i2];
              plugin = descriptor.plugin;
              method = plugin[hook];
              if (typeof method === "function") {
                params = [chart].concat(args || []);
                params.push(descriptor.options);
                if (method.apply(plugin, params) === false) {
                  return false;
                }
              }
            }
            return true;
          },
          descriptors: function(chart) {
            var cache2 = chart.$plugins || (chart.$plugins = {});
            if (cache2.id === this._cacheId) {
              return cache2.descriptors;
            }
            var plugins2 = [];
            var descriptors2 = [];
            var config = chart && chart.config || {};
            var options2 = config.options && config.options.plugins || {};
            this._plugins.concat(config.plugins || []).forEach(function(plugin) {
              var idx = plugins2.indexOf(plugin);
              if (idx !== -1) {
                return;
              }
              var id2 = plugin.id;
              var opts = options2[id2];
              if (opts === false) {
                return;
              }
              if (opts === true) {
                opts = helpers$1.clone(core_defaults.global.plugins[id2]);
              }
              plugins2.push(plugin);
              descriptors2.push({
                plugin,
                options: opts || {}
              });
            });
            cache2.descriptors = descriptors2;
            cache2.id = this._cacheId;
            return descriptors2;
          },
          _invalidate: function(chart) {
            delete chart.$plugins;
          }
        };
        var core_scaleService = {
          constructors: {},
          defaults: {},
          registerScaleType: function(type, scaleConstructor, scaleDefaults) {
            this.constructors[type] = scaleConstructor;
            this.defaults[type] = helpers$1.clone(scaleDefaults);
          },
          getScaleConstructor: function(type) {
            return this.constructors.hasOwnProperty(type) ? this.constructors[type] : void 0;
          },
          getScaleDefaults: function(type) {
            return this.defaults.hasOwnProperty(type) ? helpers$1.merge(/* @__PURE__ */ Object.create(null), [core_defaults.scale, this.defaults[type]]) : {};
          },
          updateScaleDefaults: function(type, additions) {
            var me2 = this;
            if (me2.defaults.hasOwnProperty(type)) {
              me2.defaults[type] = helpers$1.extend(me2.defaults[type], additions);
            }
          },
          addScalesToLayout: function(chart) {
            helpers$1.each(chart.scales, function(scale2) {
              scale2.fullWidth = scale2.options.fullWidth;
              scale2.position = scale2.options.position;
              scale2.weight = scale2.options.weight;
              core_layouts.addBox(chart, scale2);
            });
          }
        };
        var valueOrDefault$8 = helpers$1.valueOrDefault;
        var getRtlHelper = helpers$1.rtl.getRtlAdapter;
        core_defaults._set("global", {
          tooltips: {
            enabled: true,
            custom: null,
            mode: "nearest",
            position: "average",
            intersect: true,
            backgroundColor: "rgba(0,0,0,0.8)",
            titleFontStyle: "bold",
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleFontColor: "#fff",
            titleAlign: "left",
            bodySpacing: 2,
            bodyFontColor: "#fff",
            bodyAlign: "left",
            footerFontStyle: "bold",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFontColor: "#fff",
            footerAlign: "left",
            yPadding: 6,
            xPadding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            multiKeyBackground: "#fff",
            displayColors: true,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            callbacks: {
              beforeTitle: helpers$1.noop,
              title: function(tooltipItems, data) {
                var title2 = "";
                var labels = data.labels;
                var labelCount = labels ? labels.length : 0;
                if (tooltipItems.length > 0) {
                  var item = tooltipItems[0];
                  if (item.label) {
                    title2 = item.label;
                  } else if (item.xLabel) {
                    title2 = item.xLabel;
                  } else if (labelCount > 0 && item.index < labelCount) {
                    title2 = labels[item.index];
                  }
                }
                return title2;
              },
              afterTitle: helpers$1.noop,
              beforeBody: helpers$1.noop,
              beforeLabel: helpers$1.noop,
              label: function(tooltipItem, data) {
                var label = data.datasets[tooltipItem.datasetIndex].label || "";
                if (label) {
                  label += ": ";
                }
                if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
                  label += tooltipItem.value;
                } else {
                  label += tooltipItem.yLabel;
                }
                return label;
              },
              labelColor: function(tooltipItem, chart) {
                var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
                var activeElement = meta.data[tooltipItem.index];
                var view = activeElement._view;
                return {
                  borderColor: view.borderColor,
                  backgroundColor: view.backgroundColor
                };
              },
              labelTextColor: function() {
                return this._options.bodyFontColor;
              },
              afterLabel: helpers$1.noop,
              afterBody: helpers$1.noop,
              beforeFooter: helpers$1.noop,
              footer: helpers$1.noop,
              afterFooter: helpers$1.noop
            }
          }
        });
        var positioners = {
          average: function(elements2) {
            if (!elements2.length) {
              return false;
            }
            var i2, len;
            var x2 = 0;
            var y2 = 0;
            var count = 0;
            for (i2 = 0, len = elements2.length; i2 < len; ++i2) {
              var el = elements2[i2];
              if (el && el.hasValue()) {
                var pos = el.tooltipPosition();
                x2 += pos.x;
                y2 += pos.y;
                ++count;
              }
            }
            return {
              x: x2 / count,
              y: y2 / count
            };
          },
          nearest: function(elements2, eventPosition) {
            var x2 = eventPosition.x;
            var y2 = eventPosition.y;
            var minDistance = Number.POSITIVE_INFINITY;
            var i2, len, nearestElement;
            for (i2 = 0, len = elements2.length; i2 < len; ++i2) {
              var el = elements2[i2];
              if (el && el.hasValue()) {
                var center = el.getCenterPoint();
                var d = helpers$1.distanceBetweenPoints(eventPosition, center);
                if (d < minDistance) {
                  minDistance = d;
                  nearestElement = el;
                }
              }
            }
            if (nearestElement) {
              var tp = nearestElement.tooltipPosition();
              x2 = tp.x;
              y2 = tp.y;
            }
            return {
              x: x2,
              y: y2
            };
          }
        };
        function pushOrConcat(base, toPush) {
          if (toPush) {
            if (helpers$1.isArray(toPush)) {
              Array.prototype.push.apply(base, toPush);
            } else {
              base.push(toPush);
            }
          }
          return base;
        }
        function splitNewlines(str) {
          if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
            return str.split("\n");
          }
          return str;
        }
        function createTooltipItem(element) {
          var xScale = element._xScale;
          var yScale = element._yScale || element._scale;
          var index2 = element._index;
          var datasetIndex = element._datasetIndex;
          var controller = element._chart.getDatasetMeta(datasetIndex).controller;
          var indexScale = controller._getIndexScale();
          var valueScale = controller._getValueScale();
          return {
            xLabel: xScale ? xScale.getLabelForIndex(index2, datasetIndex) : "",
            yLabel: yScale ? yScale.getLabelForIndex(index2, datasetIndex) : "",
            label: indexScale ? "" + indexScale.getLabelForIndex(index2, datasetIndex) : "",
            value: valueScale ? "" + valueScale.getLabelForIndex(index2, datasetIndex) : "",
            index: index2,
            datasetIndex,
            x: element._model.x,
            y: element._model.y
          };
        }
        function getBaseModel(tooltipOpts) {
          var globalDefaults = core_defaults.global;
          return {
            xPadding: tooltipOpts.xPadding,
            yPadding: tooltipOpts.yPadding,
            xAlign: tooltipOpts.xAlign,
            yAlign: tooltipOpts.yAlign,
            rtl: tooltipOpts.rtl,
            textDirection: tooltipOpts.textDirection,
            bodyFontColor: tooltipOpts.bodyFontColor,
            _bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
            _bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
            _bodyAlign: tooltipOpts.bodyAlign,
            bodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
            bodySpacing: tooltipOpts.bodySpacing,
            titleFontColor: tooltipOpts.titleFontColor,
            _titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
            _titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
            titleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
            _titleAlign: tooltipOpts.titleAlign,
            titleSpacing: tooltipOpts.titleSpacing,
            titleMarginBottom: tooltipOpts.titleMarginBottom,
            footerFontColor: tooltipOpts.footerFontColor,
            _footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
            _footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
            footerFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
            _footerAlign: tooltipOpts.footerAlign,
            footerSpacing: tooltipOpts.footerSpacing,
            footerMarginTop: tooltipOpts.footerMarginTop,
            caretSize: tooltipOpts.caretSize,
            cornerRadius: tooltipOpts.cornerRadius,
            backgroundColor: tooltipOpts.backgroundColor,
            opacity: 0,
            legendColorBackground: tooltipOpts.multiKeyBackground,
            displayColors: tooltipOpts.displayColors,
            borderColor: tooltipOpts.borderColor,
            borderWidth: tooltipOpts.borderWidth
          };
        }
        function getTooltipSize(tooltip, model) {
          var ctx = tooltip._chart.ctx;
          var height2 = model.yPadding * 2;
          var width2 = 0;
          var body = model.body;
          var combinedBodyLength = body.reduce(function(count, bodyItem) {
            return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
          }, 0);
          combinedBodyLength += model.beforeBody.length + model.afterBody.length;
          var titleLineCount = model.title.length;
          var footerLineCount = model.footer.length;
          var titleFontSize = model.titleFontSize;
          var bodyFontSize = model.bodyFontSize;
          var footerFontSize = model.footerFontSize;
          height2 += titleLineCount * titleFontSize;
          height2 += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0;
          height2 += titleLineCount ? model.titleMarginBottom : 0;
          height2 += combinedBodyLength * bodyFontSize;
          height2 += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0;
          height2 += footerLineCount ? model.footerMarginTop : 0;
          height2 += footerLineCount * footerFontSize;
          height2 += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0;
          var widthPadding = 0;
          var maxLineWidth = function(line) {
            width2 = Math.max(width2, ctx.measureText(line).width + widthPadding);
          };
          ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
          helpers$1.each(model.title, maxLineWidth);
          ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
          helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
          widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
          helpers$1.each(body, function(bodyItem) {
            helpers$1.each(bodyItem.before, maxLineWidth);
            helpers$1.each(bodyItem.lines, maxLineWidth);
            helpers$1.each(bodyItem.after, maxLineWidth);
          });
          widthPadding = 0;
          ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
          helpers$1.each(model.footer, maxLineWidth);
          width2 += 2 * model.xPadding;
          return {
            width: width2,
            height: height2
          };
        }
        function determineAlignment(tooltip, size2) {
          var model = tooltip._model;
          var chart = tooltip._chart;
          var chartArea = tooltip._chart.chartArea;
          var xAlign = "center";
          var yAlign = "center";
          if (model.y < size2.height) {
            yAlign = "top";
          } else if (model.y > chart.height - size2.height) {
            yAlign = "bottom";
          }
          var lf2, rf2;
          var olf, orf;
          var yf2;
          var midX = (chartArea.left + chartArea.right) / 2;
          var midY = (chartArea.top + chartArea.bottom) / 2;
          if (yAlign === "center") {
            lf2 = function(x2) {
              return x2 <= midX;
            };
            rf2 = function(x2) {
              return x2 > midX;
            };
          } else {
            lf2 = function(x2) {
              return x2 <= size2.width / 2;
            };
            rf2 = function(x2) {
              return x2 >= chart.width - size2.width / 2;
            };
          }
          olf = function(x2) {
            return x2 + size2.width + model.caretSize + model.caretPadding > chart.width;
          };
          orf = function(x2) {
            return x2 - size2.width - model.caretSize - model.caretPadding < 0;
          };
          yf2 = function(y2) {
            return y2 <= midY ? "top" : "bottom";
          };
          if (lf2(model.x)) {
            xAlign = "left";
            if (olf(model.x)) {
              xAlign = "center";
              yAlign = yf2(model.y);
            }
          } else if (rf2(model.x)) {
            xAlign = "right";
            if (orf(model.x)) {
              xAlign = "center";
              yAlign = yf2(model.y);
            }
          }
          var opts = tooltip._options;
          return {
            xAlign: opts.xAlign ? opts.xAlign : xAlign,
            yAlign: opts.yAlign ? opts.yAlign : yAlign
          };
        }
        function getBackgroundPoint(vm, size2, alignment, chart) {
          var x2 = vm.x;
          var y2 = vm.y;
          var caretSize = vm.caretSize;
          var caretPadding = vm.caretPadding;
          var cornerRadius = vm.cornerRadius;
          var xAlign = alignment.xAlign;
          var yAlign = alignment.yAlign;
          var paddingAndSize = caretSize + caretPadding;
          var radiusAndPadding = cornerRadius + caretPadding;
          if (xAlign === "right") {
            x2 -= size2.width;
          } else if (xAlign === "center") {
            x2 -= size2.width / 2;
            if (x2 + size2.width > chart.width) {
              x2 = chart.width - size2.width;
            }
            if (x2 < 0) {
              x2 = 0;
            }
          }
          if (yAlign === "top") {
            y2 += paddingAndSize;
          } else if (yAlign === "bottom") {
            y2 -= size2.height + paddingAndSize;
          } else {
            y2 -= size2.height / 2;
          }
          if (yAlign === "center") {
            if (xAlign === "left") {
              x2 += paddingAndSize;
            } else if (xAlign === "right") {
              x2 -= paddingAndSize;
            }
          } else if (xAlign === "left") {
            x2 -= radiusAndPadding;
          } else if (xAlign === "right") {
            x2 += radiusAndPadding;
          }
          return {
            x: x2,
            y: y2
          };
        }
        function getAlignedX(vm, align) {
          return align === "center" ? vm.x + vm.width / 2 : align === "right" ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
        }
        function getBeforeAfterBodyLines(callback) {
          return pushOrConcat([], splitNewlines(callback));
        }
        var exports$4 = core_element.extend({
          initialize: function() {
            this._model = getBaseModel(this._options);
            this._lastActive = [];
          },
          getTitle: function() {
            var me2 = this;
            var opts = me2._options;
            var callbacks = opts.callbacks;
            var beforeTitle = callbacks.beforeTitle.apply(me2, arguments);
            var title2 = callbacks.title.apply(me2, arguments);
            var afterTitle = callbacks.afterTitle.apply(me2, arguments);
            var lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title2));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
          },
          getBeforeBody: function() {
            return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
          },
          getBody: function(tooltipItems, data) {
            var me2 = this;
            var callbacks = me2._options.callbacks;
            var bodyItems = [];
            helpers$1.each(tooltipItems, function(tooltipItem) {
              var bodyItem = {
                before: [],
                lines: [],
                after: []
              };
              pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me2, tooltipItem, data)));
              pushOrConcat(bodyItem.lines, callbacks.label.call(me2, tooltipItem, data));
              pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me2, tooltipItem, data)));
              bodyItems.push(bodyItem);
            });
            return bodyItems;
          },
          getAfterBody: function() {
            return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
          },
          getFooter: function() {
            var me2 = this;
            var callbacks = me2._options.callbacks;
            var beforeFooter = callbacks.beforeFooter.apply(me2, arguments);
            var footer = callbacks.footer.apply(me2, arguments);
            var afterFooter = callbacks.afterFooter.apply(me2, arguments);
            var lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
          },
          update: function(changed) {
            var me2 = this;
            var opts = me2._options;
            var existingModel = me2._model;
            var model = me2._model = getBaseModel(opts);
            var active = me2._active;
            var data = me2._data;
            var alignment = {
              xAlign: existingModel.xAlign,
              yAlign: existingModel.yAlign
            };
            var backgroundPoint = {
              x: existingModel.x,
              y: existingModel.y
            };
            var tooltipSize = {
              width: existingModel.width,
              height: existingModel.height
            };
            var tooltipPosition = {
              x: existingModel.caretX,
              y: existingModel.caretY
            };
            var i2, len;
            if (active.length) {
              model.opacity = 1;
              var labelColors = [];
              var labelTextColors = [];
              tooltipPosition = positioners[opts.position].call(me2, active, me2._eventPosition);
              var tooltipItems = [];
              for (i2 = 0, len = active.length; i2 < len; ++i2) {
                tooltipItems.push(createTooltipItem(active[i2]));
              }
              if (opts.filter) {
                tooltipItems = tooltipItems.filter(function(a2) {
                  return opts.filter(a2, data);
                });
              }
              if (opts.itemSort) {
                tooltipItems = tooltipItems.sort(function(a2, b) {
                  return opts.itemSort(a2, b, data);
                });
              }
              helpers$1.each(tooltipItems, function(tooltipItem) {
                labelColors.push(opts.callbacks.labelColor.call(me2, tooltipItem, me2._chart));
                labelTextColors.push(opts.callbacks.labelTextColor.call(me2, tooltipItem, me2._chart));
              });
              model.title = me2.getTitle(tooltipItems, data);
              model.beforeBody = me2.getBeforeBody(tooltipItems, data);
              model.body = me2.getBody(tooltipItems, data);
              model.afterBody = me2.getAfterBody(tooltipItems, data);
              model.footer = me2.getFooter(tooltipItems, data);
              model.x = tooltipPosition.x;
              model.y = tooltipPosition.y;
              model.caretPadding = opts.caretPadding;
              model.labelColors = labelColors;
              model.labelTextColors = labelTextColors;
              model.dataPoints = tooltipItems;
              tooltipSize = getTooltipSize(this, model);
              alignment = determineAlignment(this, tooltipSize);
              backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me2._chart);
            } else {
              model.opacity = 0;
            }
            model.xAlign = alignment.xAlign;
            model.yAlign = alignment.yAlign;
            model.x = backgroundPoint.x;
            model.y = backgroundPoint.y;
            model.width = tooltipSize.width;
            model.height = tooltipSize.height;
            model.caretX = tooltipPosition.x;
            model.caretY = tooltipPosition.y;
            me2._model = model;
            if (changed && opts.custom) {
              opts.custom.call(me2, model);
            }
            return me2;
          },
          drawCaret: function(tooltipPoint, size2) {
            var ctx = this._chart.ctx;
            var vm = this._view;
            var caretPosition = this.getCaretPosition(tooltipPoint, size2, vm);
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
          },
          getCaretPosition: function(tooltipPoint, size2, vm) {
            var x1, x2, x3, y1, y2, y3;
            var caretSize = vm.caretSize;
            var cornerRadius = vm.cornerRadius;
            var xAlign = vm.xAlign;
            var yAlign = vm.yAlign;
            var ptX = tooltipPoint.x;
            var ptY = tooltipPoint.y;
            var width2 = size2.width;
            var height2 = size2.height;
            if (yAlign === "center") {
              y2 = ptY + height2 / 2;
              if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                x3 = x1;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
              } else {
                x1 = ptX + width2;
                x2 = x1 + caretSize;
                x3 = x1;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
              }
            } else {
              if (xAlign === "left") {
                x2 = ptX + cornerRadius + caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else if (xAlign === "right") {
                x2 = ptX + width2 - cornerRadius - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else {
                x2 = vm.caretX;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              }
              if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                y3 = y1;
              } else {
                y1 = ptY + height2;
                y2 = y1 + caretSize;
                y3 = y1;
                var tmp = x3;
                x3 = x1;
                x1 = tmp;
              }
            }
            return { x1, x2, x3, y1, y2, y3 };
          },
          drawTitle: function(pt, vm, ctx) {
            var title2 = vm.title;
            var length = title2.length;
            var titleFontSize, titleSpacing, i2;
            if (length) {
              var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
              pt.x = getAlignedX(vm, vm._titleAlign);
              ctx.textAlign = rtlHelper.textAlign(vm._titleAlign);
              ctx.textBaseline = "middle";
              titleFontSize = vm.titleFontSize;
              titleSpacing = vm.titleSpacing;
              ctx.fillStyle = vm.titleFontColor;
              ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
              for (i2 = 0; i2 < length; ++i2) {
                ctx.fillText(title2[i2], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);
                pt.y += titleFontSize + titleSpacing;
                if (i2 + 1 === length) {
                  pt.y += vm.titleMarginBottom - titleSpacing;
                }
              }
            }
          },
          drawBody: function(pt, vm, ctx) {
            var bodyFontSize = vm.bodyFontSize;
            var bodySpacing = vm.bodySpacing;
            var bodyAlign = vm._bodyAlign;
            var body = vm.body;
            var drawColorBoxes = vm.displayColors;
            var xLinePadding = 0;
            var colorX = drawColorBoxes ? getAlignedX(vm, "left") : 0;
            var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
            var fillLineOfText = function(line) {
              ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);
              pt.y += bodyFontSize + bodySpacing;
            };
            var bodyItem, textColor, labelColors, lines, i2, j, ilen, jlen;
            var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = "middle";
            ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
            pt.x = getAlignedX(vm, bodyAlignForCalculation);
            ctx.fillStyle = vm.bodyFontColor;
            helpers$1.each(vm.beforeBody, fillLineOfText);
            xLinePadding = drawColorBoxes && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0;
            for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
              bodyItem = body[i2];
              textColor = vm.labelTextColors[i2];
              labelColors = vm.labelColors[i2];
              ctx.fillStyle = textColor;
              helpers$1.each(bodyItem.before, fillLineOfText);
              lines = bodyItem.lines;
              for (j = 0, jlen = lines.length; j < jlen; ++j) {
                if (drawColorBoxes) {
                  var rtlColorX = rtlHelper.x(colorX);
                  ctx.fillStyle = vm.legendColorBackground;
                  ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                  ctx.lineWidth = 1;
                  ctx.strokeStyle = labelColors.borderColor;
                  ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                  ctx.fillStyle = labelColors.backgroundColor;
                  ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                  ctx.fillStyle = textColor;
                }
                fillLineOfText(lines[j]);
              }
              helpers$1.each(bodyItem.after, fillLineOfText);
            }
            xLinePadding = 0;
            helpers$1.each(vm.afterBody, fillLineOfText);
            pt.y -= bodySpacing;
          },
          drawFooter: function(pt, vm, ctx) {
            var footer = vm.footer;
            var length = footer.length;
            var footerFontSize, i2;
            if (length) {
              var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
              pt.x = getAlignedX(vm, vm._footerAlign);
              pt.y += vm.footerMarginTop;
              ctx.textAlign = rtlHelper.textAlign(vm._footerAlign);
              ctx.textBaseline = "middle";
              footerFontSize = vm.footerFontSize;
              ctx.fillStyle = vm.footerFontColor;
              ctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
              for (i2 = 0; i2 < length; ++i2) {
                ctx.fillText(footer[i2], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);
                pt.y += footerFontSize + vm.footerSpacing;
              }
            }
          },
          drawBackground: function(pt, vm, ctx, tooltipSize) {
            ctx.fillStyle = vm.backgroundColor;
            ctx.strokeStyle = vm.borderColor;
            ctx.lineWidth = vm.borderWidth;
            var xAlign = vm.xAlign;
            var yAlign = vm.yAlign;
            var x2 = pt.x;
            var y2 = pt.y;
            var width2 = tooltipSize.width;
            var height2 = tooltipSize.height;
            var radius = vm.cornerRadius;
            ctx.beginPath();
            ctx.moveTo(x2 + radius, y2);
            if (yAlign === "top") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x2 + width2 - radius, y2);
            ctx.quadraticCurveTo(x2 + width2, y2, x2 + width2, y2 + radius);
            if (yAlign === "center" && xAlign === "right") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x2 + width2, y2 + height2 - radius);
            ctx.quadraticCurveTo(x2 + width2, y2 + height2, x2 + width2 - radius, y2 + height2);
            if (yAlign === "bottom") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x2 + radius, y2 + height2);
            ctx.quadraticCurveTo(x2, y2 + height2, x2, y2 + height2 - radius);
            if (yAlign === "center" && xAlign === "left") {
              this.drawCaret(pt, tooltipSize);
            }
            ctx.lineTo(x2, y2 + radius);
            ctx.quadraticCurveTo(x2, y2, x2 + radius, y2);
            ctx.closePath();
            ctx.fill();
            if (vm.borderWidth > 0) {
              ctx.stroke();
            }
          },
          draw: function() {
            var ctx = this._chart.ctx;
            var vm = this._view;
            if (vm.opacity === 0) {
              return;
            }
            var tooltipSize = {
              width: vm.width,
              height: vm.height
            };
            var pt = {
              x: vm.x,
              y: vm.y
            };
            var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;
            var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
            if (this._options.enabled && hasTooltipContent) {
              ctx.save();
              ctx.globalAlpha = opacity;
              this.drawBackground(pt, vm, ctx, tooltipSize);
              pt.y += vm.yPadding;
              helpers$1.rtl.overrideTextDirection(ctx, vm.textDirection);
              this.drawTitle(pt, vm, ctx);
              this.drawBody(pt, vm, ctx);
              this.drawFooter(pt, vm, ctx);
              helpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);
              ctx.restore();
            }
          },
          handleEvent: function(e) {
            var me2 = this;
            var options2 = me2._options;
            var changed = false;
            me2._lastActive = me2._lastActive || [];
            if (e.type === "mouseout") {
              me2._active = [];
            } else {
              me2._active = me2._chart.getElementsAtEventForMode(e, options2.mode, options2);
              if (options2.reverse) {
                me2._active.reverse();
              }
            }
            changed = !helpers$1.arrayEquals(me2._active, me2._lastActive);
            if (changed) {
              me2._lastActive = me2._active;
              if (options2.enabled || options2.custom) {
                me2._eventPosition = {
                  x: e.x,
                  y: e.y
                };
                me2.update(true);
                me2.pivot();
              }
            }
            return changed;
          }
        });
        var positioners_1 = positioners;
        var core_tooltip = exports$4;
        core_tooltip.positioners = positioners_1;
        var valueOrDefault$9 = helpers$1.valueOrDefault;
        core_defaults._set("global", {
          elements: {},
          events: [
            "mousemove",
            "mouseout",
            "click",
            "touchstart",
            "touchmove"
          ],
          hover: {
            onHover: null,
            mode: "nearest",
            intersect: true,
            animationDuration: 400
          },
          onClick: null,
          maintainAspectRatio: true,
          responsive: true,
          responsiveAnimationDuration: 0
        });
        function mergeScaleConfig() {
          return helpers$1.merge(/* @__PURE__ */ Object.create(null), [].slice.call(arguments), {
            merger: function(key, target, source, options2) {
              if (key === "xAxes" || key === "yAxes") {
                var slen = source[key].length;
                var i2, type, scale2;
                if (!target[key]) {
                  target[key] = [];
                }
                for (i2 = 0; i2 < slen; ++i2) {
                  scale2 = source[key][i2];
                  type = valueOrDefault$9(scale2.type, key === "xAxes" ? "category" : "linear");
                  if (i2 >= target[key].length) {
                    target[key].push({});
                  }
                  if (!target[key][i2].type || scale2.type && scale2.type !== target[key][i2].type) {
                    helpers$1.merge(target[key][i2], [core_scaleService.getScaleDefaults(type), scale2]);
                  } else {
                    helpers$1.merge(target[key][i2], scale2);
                  }
                }
              } else {
                helpers$1._merger(key, target, source, options2);
              }
            }
          });
        }
        function mergeConfig2() {
          return helpers$1.merge(/* @__PURE__ */ Object.create(null), [].slice.call(arguments), {
            merger: function(key, target, source, options2) {
              var tval = target[key] || /* @__PURE__ */ Object.create(null);
              var sval = source[key];
              if (key === "scales") {
                target[key] = mergeScaleConfig(tval, sval);
              } else if (key === "scale") {
                target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
              } else {
                helpers$1._merger(key, target, source, options2);
              }
            }
          });
        }
        function initConfig(config) {
          config = config || /* @__PURE__ */ Object.create(null);
          var data = config.data = config.data || {};
          data.datasets = data.datasets || [];
          data.labels = data.labels || [];
          config.options = mergeConfig2(
            core_defaults.global,
            core_defaults[config.type],
            config.options || {}
          );
          return config;
        }
        function updateConfig(chart) {
          var newOptions = chart.options;
          helpers$1.each(chart.scales, function(scale2) {
            core_layouts.removeBox(chart, scale2);
          });
          newOptions = mergeConfig2(
            core_defaults.global,
            core_defaults[chart.config.type],
            newOptions
          );
          chart.options = chart.config.options = newOptions;
          chart.ensureScalesHaveIDs();
          chart.buildOrUpdateScales();
          chart.tooltip._options = newOptions.tooltips;
          chart.tooltip.initialize();
        }
        function nextAvailableScaleId(axesOpts, prefix, index2) {
          var id2;
          var hasId = function(obj) {
            return obj.id === id2;
          };
          do {
            id2 = prefix + index2++;
          } while (helpers$1.findIndex(axesOpts, hasId) >= 0);
          return id2;
        }
        function positionIsHorizontal(position) {
          return position === "top" || position === "bottom";
        }
        function compare2Level(l1, l2) {
          return function(a2, b) {
            return a2[l1] === b[l1] ? a2[l2] - b[l2] : a2[l1] - b[l1];
          };
        }
        var Chart2 = function(item, config) {
          this.construct(item, config);
          return this;
        };
        helpers$1.extend(Chart2.prototype, {
          construct: function(item, config) {
            var me2 = this;
            config = initConfig(config);
            var context2 = platform2.acquireContext(item, config);
            var canvas3 = context2 && context2.canvas;
            var height2 = canvas3 && canvas3.height;
            var width2 = canvas3 && canvas3.width;
            me2.id = helpers$1.uid();
            me2.ctx = context2;
            me2.canvas = canvas3;
            me2.config = config;
            me2.width = width2;
            me2.height = height2;
            me2.aspectRatio = height2 ? width2 / height2 : null;
            me2.options = config.options;
            me2._bufferedRender = false;
            me2._layers = [];
            me2.chart = me2;
            me2.controller = me2;
            Chart2.instances[me2.id] = me2;
            Object.defineProperty(me2, "data", {
              get: function() {
                return me2.config.data;
              },
              set: function(value2) {
                me2.config.data = value2;
              }
            });
            if (!context2 || !canvas3) {
              console.error("Failed to create chart: can't acquire context from the given item");
              return;
            }
            me2.initialize();
            me2.update();
          },
          initialize: function() {
            var me2 = this;
            core_plugins.notify(me2, "beforeInit");
            helpers$1.retinaScale(me2, me2.options.devicePixelRatio);
            me2.bindEvents();
            if (me2.options.responsive) {
              me2.resize(true);
            }
            me2.initToolTip();
            core_plugins.notify(me2, "afterInit");
            return me2;
          },
          clear: function() {
            helpers$1.canvas.clear(this);
            return this;
          },
          stop: function() {
            core_animations.cancelAnimation(this);
            return this;
          },
          resize: function(silent) {
            var me2 = this;
            var options2 = me2.options;
            var canvas3 = me2.canvas;
            var aspectRatio = options2.maintainAspectRatio && me2.aspectRatio || null;
            var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas3)));
            var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas3)));
            if (me2.width === newWidth && me2.height === newHeight) {
              return;
            }
            canvas3.width = me2.width = newWidth;
            canvas3.height = me2.height = newHeight;
            canvas3.style.width = newWidth + "px";
            canvas3.style.height = newHeight + "px";
            helpers$1.retinaScale(me2, options2.devicePixelRatio);
            if (!silent) {
              var newSize = { width: newWidth, height: newHeight };
              core_plugins.notify(me2, "resize", [newSize]);
              if (options2.onResize) {
                options2.onResize(me2, newSize);
              }
              me2.stop();
              me2.update({
                duration: options2.responsiveAnimationDuration
              });
            }
          },
          ensureScalesHaveIDs: function() {
            var options2 = this.options;
            var scalesOptions = options2.scales || {};
            var scaleOptions = options2.scale;
            helpers$1.each(scalesOptions.xAxes, function(xAxisOptions, index2) {
              if (!xAxisOptions.id) {
                xAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, "x-axis-", index2);
              }
            });
            helpers$1.each(scalesOptions.yAxes, function(yAxisOptions, index2) {
              if (!yAxisOptions.id) {
                yAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, "y-axis-", index2);
              }
            });
            if (scaleOptions) {
              scaleOptions.id = scaleOptions.id || "scale";
            }
          },
          buildOrUpdateScales: function() {
            var me2 = this;
            var options2 = me2.options;
            var scales2 = me2.scales || {};
            var items2 = [];
            var updated = Object.keys(scales2).reduce(function(obj, id2) {
              obj[id2] = false;
              return obj;
            }, {});
            if (options2.scales) {
              items2 = items2.concat(
                (options2.scales.xAxes || []).map(function(xAxisOptions) {
                  return { options: xAxisOptions, dtype: "category", dposition: "bottom" };
                }),
                (options2.scales.yAxes || []).map(function(yAxisOptions) {
                  return { options: yAxisOptions, dtype: "linear", dposition: "left" };
                })
              );
            }
            if (options2.scale) {
              items2.push({
                options: options2.scale,
                dtype: "radialLinear",
                isDefault: true,
                dposition: "chartArea"
              });
            }
            helpers$1.each(items2, function(item) {
              var scaleOptions = item.options;
              var id2 = scaleOptions.id;
              var scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);
              if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
                scaleOptions.position = item.dposition;
              }
              updated[id2] = true;
              var scale2 = null;
              if (id2 in scales2 && scales2[id2].type === scaleType) {
                scale2 = scales2[id2];
                scale2.options = scaleOptions;
                scale2.ctx = me2.ctx;
                scale2.chart = me2;
              } else {
                var scaleClass = core_scaleService.getScaleConstructor(scaleType);
                if (!scaleClass) {
                  return;
                }
                scale2 = new scaleClass({
                  id: id2,
                  type: scaleType,
                  options: scaleOptions,
                  ctx: me2.ctx,
                  chart: me2
                });
                scales2[scale2.id] = scale2;
              }
              scale2.mergeTicksOptions();
              if (item.isDefault) {
                me2.scale = scale2;
              }
            });
            helpers$1.each(updated, function(hasUpdated, id2) {
              if (!hasUpdated) {
                delete scales2[id2];
              }
            });
            me2.scales = scales2;
            core_scaleService.addScalesToLayout(this);
          },
          buildOrUpdateControllers: function() {
            var me2 = this;
            var newControllers = [];
            var datasets = me2.data.datasets;
            var i2, ilen;
            for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
              var dataset = datasets[i2];
              var meta = me2.getDatasetMeta(i2);
              var type = dataset.type || me2.config.type;
              if (meta.type && meta.type !== type) {
                me2.destroyDatasetMeta(i2);
                meta = me2.getDatasetMeta(i2);
              }
              meta.type = type;
              meta.order = dataset.order || 0;
              meta.index = i2;
              if (meta.controller) {
                meta.controller.updateIndex(i2);
                meta.controller.linkScales();
              } else {
                var ControllerClass = controllers[meta.type];
                if (ControllerClass === void 0) {
                  throw new Error('"' + meta.type + '" is not a chart type.');
                }
                meta.controller = new ControllerClass(me2, i2);
                newControllers.push(meta.controller);
              }
            }
            return newControllers;
          },
          resetElements: function() {
            var me2 = this;
            helpers$1.each(me2.data.datasets, function(dataset, datasetIndex) {
              me2.getDatasetMeta(datasetIndex).controller.reset();
            }, me2);
          },
          reset: function() {
            this.resetElements();
            this.tooltip.initialize();
          },
          update: function(config) {
            var me2 = this;
            var i2, ilen;
            if (!config || typeof config !== "object") {
              config = {
                duration: config,
                lazy: arguments[1]
              };
            }
            updateConfig(me2);
            core_plugins._invalidate(me2);
            if (core_plugins.notify(me2, "beforeUpdate") === false) {
              return;
            }
            me2.tooltip._data = me2.data;
            var newControllers = me2.buildOrUpdateControllers();
            for (i2 = 0, ilen = me2.data.datasets.length; i2 < ilen; i2++) {
              me2.getDatasetMeta(i2).controller.buildOrUpdateElements();
            }
            me2.updateLayout();
            if (me2.options.animation && me2.options.animation.duration) {
              helpers$1.each(newControllers, function(controller) {
                controller.reset();
              });
            }
            me2.updateDatasets();
            me2.tooltip.initialize();
            me2.lastActive = [];
            core_plugins.notify(me2, "afterUpdate");
            me2._layers.sort(compare2Level("z", "_idx"));
            if (me2._bufferedRender) {
              me2._bufferedRequest = {
                duration: config.duration,
                easing: config.easing,
                lazy: config.lazy
              };
            } else {
              me2.render(config);
            }
          },
          updateLayout: function() {
            var me2 = this;
            if (core_plugins.notify(me2, "beforeLayout") === false) {
              return;
            }
            core_layouts.update(this, this.width, this.height);
            me2._layers = [];
            helpers$1.each(me2.boxes, function(box) {
              if (box._configure) {
                box._configure();
              }
              me2._layers.push.apply(me2._layers, box._layers());
            }, me2);
            me2._layers.forEach(function(item, index2) {
              item._idx = index2;
            });
            core_plugins.notify(me2, "afterScaleUpdate");
            core_plugins.notify(me2, "afterLayout");
          },
          updateDatasets: function() {
            var me2 = this;
            if (core_plugins.notify(me2, "beforeDatasetsUpdate") === false) {
              return;
            }
            for (var i2 = 0, ilen = me2.data.datasets.length; i2 < ilen; ++i2) {
              me2.updateDataset(i2);
            }
            core_plugins.notify(me2, "afterDatasetsUpdate");
          },
          updateDataset: function(index2) {
            var me2 = this;
            var meta = me2.getDatasetMeta(index2);
            var args = {
              meta,
              index: index2
            };
            if (core_plugins.notify(me2, "beforeDatasetUpdate", [args]) === false) {
              return;
            }
            meta.controller._update();
            core_plugins.notify(me2, "afterDatasetUpdate", [args]);
          },
          render: function(config) {
            var me2 = this;
            if (!config || typeof config !== "object") {
              config = {
                duration: config,
                lazy: arguments[1]
              };
            }
            var animationOptions = me2.options.animation;
            var duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);
            var lazy = config.lazy;
            if (core_plugins.notify(me2, "beforeRender") === false) {
              return;
            }
            var onComplete = function(animation2) {
              core_plugins.notify(me2, "afterRender");
              helpers$1.callback(animationOptions && animationOptions.onComplete, [animation2], me2);
            };
            if (animationOptions && duration) {
              var animation = new core_animation({
                numSteps: duration / 16.66,
                easing: config.easing || animationOptions.easing,
                render: function(chart, animationObject) {
                  var easingFunction = helpers$1.easing.effects[animationObject.easing];
                  var currentStep = animationObject.currentStep;
                  var stepDecimal = currentStep / animationObject.numSteps;
                  chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
                },
                onAnimationProgress: animationOptions.onProgress,
                onAnimationComplete: onComplete
              });
              core_animations.addAnimation(me2, animation, duration, lazy);
            } else {
              me2.draw();
              onComplete(new core_animation({ numSteps: 0, chart: me2 }));
            }
            return me2;
          },
          draw: function(easingValue) {
            var me2 = this;
            var i2, layers;
            me2.clear();
            if (helpers$1.isNullOrUndef(easingValue)) {
              easingValue = 1;
            }
            me2.transition(easingValue);
            if (me2.width <= 0 || me2.height <= 0) {
              return;
            }
            if (core_plugins.notify(me2, "beforeDraw", [easingValue]) === false) {
              return;
            }
            layers = me2._layers;
            for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
              layers[i2].draw(me2.chartArea);
            }
            me2.drawDatasets(easingValue);
            for (; i2 < layers.length; ++i2) {
              layers[i2].draw(me2.chartArea);
            }
            me2._drawTooltip(easingValue);
            core_plugins.notify(me2, "afterDraw", [easingValue]);
          },
          transition: function(easingValue) {
            var me2 = this;
            for (var i2 = 0, ilen = (me2.data.datasets || []).length; i2 < ilen; ++i2) {
              if (me2.isDatasetVisible(i2)) {
                me2.getDatasetMeta(i2).controller.transition(easingValue);
              }
            }
            me2.tooltip.transition(easingValue);
          },
          _getSortedDatasetMetas: function(filterVisible) {
            var me2 = this;
            var datasets = me2.data.datasets || [];
            var result2 = [];
            var i2, ilen;
            for (i2 = 0, ilen = datasets.length; i2 < ilen; ++i2) {
              if (!filterVisible || me2.isDatasetVisible(i2)) {
                result2.push(me2.getDatasetMeta(i2));
              }
            }
            result2.sort(compare2Level("order", "index"));
            return result2;
          },
          _getSortedVisibleDatasetMetas: function() {
            return this._getSortedDatasetMetas(true);
          },
          drawDatasets: function(easingValue) {
            var me2 = this;
            var metasets, i2;
            if (core_plugins.notify(me2, "beforeDatasetsDraw", [easingValue]) === false) {
              return;
            }
            metasets = me2._getSortedVisibleDatasetMetas();
            for (i2 = metasets.length - 1; i2 >= 0; --i2) {
              me2.drawDataset(metasets[i2], easingValue);
            }
            core_plugins.notify(me2, "afterDatasetsDraw", [easingValue]);
          },
          drawDataset: function(meta, easingValue) {
            var me2 = this;
            var args = {
              meta,
              index: meta.index,
              easingValue
            };
            if (core_plugins.notify(me2, "beforeDatasetDraw", [args]) === false) {
              return;
            }
            meta.controller.draw(easingValue);
            core_plugins.notify(me2, "afterDatasetDraw", [args]);
          },
          _drawTooltip: function(easingValue) {
            var me2 = this;
            var tooltip = me2.tooltip;
            var args = {
              tooltip,
              easingValue
            };
            if (core_plugins.notify(me2, "beforeTooltipDraw", [args]) === false) {
              return;
            }
            tooltip.draw();
            core_plugins.notify(me2, "afterTooltipDraw", [args]);
          },
          getElementAtEvent: function(e) {
            return core_interaction.modes.single(this, e);
          },
          getElementsAtEvent: function(e) {
            return core_interaction.modes.label(this, e, { intersect: true });
          },
          getElementsAtXAxis: function(e) {
            return core_interaction.modes["x-axis"](this, e, { intersect: true });
          },
          getElementsAtEventForMode: function(e, mode, options2) {
            var method = core_interaction.modes[mode];
            if (typeof method === "function") {
              return method(this, e, options2);
            }
            return [];
          },
          getDatasetAtEvent: function(e) {
            return core_interaction.modes.dataset(this, e, { intersect: true });
          },
          getDatasetMeta: function(datasetIndex) {
            var me2 = this;
            var dataset = me2.data.datasets[datasetIndex];
            if (!dataset._meta) {
              dataset._meta = {};
            }
            var meta = dataset._meta[me2.id];
            if (!meta) {
              meta = dataset._meta[me2.id] = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset.order || 0,
                index: datasetIndex
              };
            }
            return meta;
          },
          getVisibleDatasetCount: function() {
            var count = 0;
            for (var i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
              if (this.isDatasetVisible(i2)) {
                count++;
              }
            }
            return count;
          },
          isDatasetVisible: function(datasetIndex) {
            var meta = this.getDatasetMeta(datasetIndex);
            return typeof meta.hidden === "boolean" ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
          },
          generateLegend: function() {
            return this.options.legendCallback(this);
          },
          destroyDatasetMeta: function(datasetIndex) {
            var id2 = this.id;
            var dataset = this.data.datasets[datasetIndex];
            var meta = dataset._meta && dataset._meta[id2];
            if (meta) {
              meta.controller.destroy();
              delete dataset._meta[id2];
            }
          },
          destroy: function() {
            var me2 = this;
            var canvas3 = me2.canvas;
            var i2, ilen;
            me2.stop();
            for (i2 = 0, ilen = me2.data.datasets.length; i2 < ilen; ++i2) {
              me2.destroyDatasetMeta(i2);
            }
            if (canvas3) {
              me2.unbindEvents();
              helpers$1.canvas.clear(me2);
              platform2.releaseContext(me2.ctx);
              me2.canvas = null;
              me2.ctx = null;
            }
            core_plugins.notify(me2, "destroy");
            delete Chart2.instances[me2.id];
          },
          toBase64Image: function() {
            return this.canvas.toDataURL.apply(this.canvas, arguments);
          },
          initToolTip: function() {
            var me2 = this;
            me2.tooltip = new core_tooltip({
              _chart: me2,
              _chartInstance: me2,
              _data: me2.data,
              _options: me2.options.tooltips
            }, me2);
          },
          bindEvents: function() {
            var me2 = this;
            var listeners = me2._listeners = {};
            var listener = function() {
              me2.eventHandler.apply(me2, arguments);
            };
            helpers$1.each(me2.options.events, function(type) {
              platform2.addEventListener(me2, type, listener);
              listeners[type] = listener;
            });
            if (me2.options.responsive) {
              listener = function() {
                me2.resize();
              };
              platform2.addEventListener(me2, "resize", listener);
              listeners.resize = listener;
            }
          },
          unbindEvents: function() {
            var me2 = this;
            var listeners = me2._listeners;
            if (!listeners) {
              return;
            }
            delete me2._listeners;
            helpers$1.each(listeners, function(listener, type) {
              platform2.removeEventListener(me2, type, listener);
            });
          },
          updateHoverStyle: function(elements2, mode, enabled) {
            var prefix = enabled ? "set" : "remove";
            var element, i2, ilen;
            for (i2 = 0, ilen = elements2.length; i2 < ilen; ++i2) {
              element = elements2[i2];
              if (element) {
                this.getDatasetMeta(element._datasetIndex).controller[prefix + "HoverStyle"](element);
              }
            }
            if (mode === "dataset") {
              this.getDatasetMeta(elements2[0]._datasetIndex).controller["_" + prefix + "DatasetHoverStyle"]();
            }
          },
          eventHandler: function(e) {
            var me2 = this;
            var tooltip = me2.tooltip;
            if (core_plugins.notify(me2, "beforeEvent", [e]) === false) {
              return;
            }
            me2._bufferedRender = true;
            me2._bufferedRequest = null;
            var changed = me2.handleEvent(e);
            if (tooltip) {
              changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
            }
            core_plugins.notify(me2, "afterEvent", [e]);
            var bufferedRequest = me2._bufferedRequest;
            if (bufferedRequest) {
              me2.render(bufferedRequest);
            } else if (changed && !me2.animating) {
              me2.stop();
              me2.render({
                duration: me2.options.hover.animationDuration,
                lazy: true
              });
            }
            me2._bufferedRender = false;
            me2._bufferedRequest = null;
            return me2;
          },
          handleEvent: function(e) {
            var me2 = this;
            var options2 = me2.options || {};
            var hoverOptions = options2.hover;
            var changed = false;
            me2.lastActive = me2.lastActive || [];
            if (e.type === "mouseout") {
              me2.active = [];
            } else {
              me2.active = me2.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
            }
            helpers$1.callback(options2.onHover || options2.hover.onHover, [e.native, me2.active], me2);
            if (e.type === "mouseup" || e.type === "click") {
              if (options2.onClick) {
                options2.onClick.call(me2, e.native, me2.active);
              }
            }
            if (me2.lastActive.length) {
              me2.updateHoverStyle(me2.lastActive, hoverOptions.mode, false);
            }
            if (me2.active.length && hoverOptions.mode) {
              me2.updateHoverStyle(me2.active, hoverOptions.mode, true);
            }
            changed = !helpers$1.arrayEquals(me2.active, me2.lastActive);
            me2.lastActive = me2.active;
            return changed;
          }
        });
        Chart2.instances = {};
        var core_controller = Chart2;
        Chart2.Controller = Chart2;
        Chart2.types = {};
        helpers$1.configMerge = mergeConfig2;
        helpers$1.scaleMerge = mergeScaleConfig;
        var core_helpers = function() {
          helpers$1.where = function(collection, filterCallback) {
            if (helpers$1.isArray(collection) && Array.prototype.filter) {
              return collection.filter(filterCallback);
            }
            var filtered = [];
            helpers$1.each(collection, function(item) {
              if (filterCallback(item)) {
                filtered.push(item);
              }
            });
            return filtered;
          };
          helpers$1.findIndex = Array.prototype.findIndex ? function(array, callback, scope) {
            return array.findIndex(callback, scope);
          } : function(array, callback, scope) {
            scope = scope === void 0 ? array : scope;
            for (var i2 = 0, ilen = array.length; i2 < ilen; ++i2) {
              if (callback.call(scope, array[i2], i2, array)) {
                return i2;
              }
            }
            return -1;
          };
          helpers$1.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
            if (helpers$1.isNullOrUndef(startIndex)) {
              startIndex = -1;
            }
            for (var i2 = startIndex + 1; i2 < arrayToSearch.length; i2++) {
              var currentItem = arrayToSearch[i2];
              if (filterCallback(currentItem)) {
                return currentItem;
              }
            }
          };
          helpers$1.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
            if (helpers$1.isNullOrUndef(startIndex)) {
              startIndex = arrayToSearch.length;
            }
            for (var i2 = startIndex - 1; i2 >= 0; i2--) {
              var currentItem = arrayToSearch[i2];
              if (filterCallback(currentItem)) {
                return currentItem;
              }
            }
          };
          helpers$1.isNumber = function(n2) {
            return !isNaN(parseFloat(n2)) && isFinite(n2);
          };
          helpers$1.almostEquals = function(x2, y2, epsilon) {
            return Math.abs(x2 - y2) < epsilon;
          };
          helpers$1.almostWhole = function(x2, epsilon) {
            var rounded = Math.round(x2);
            return rounded - epsilon <= x2 && rounded + epsilon >= x2;
          };
          helpers$1.max = function(array) {
            return array.reduce(function(max2, value2) {
              if (!isNaN(value2)) {
                return Math.max(max2, value2);
              }
              return max2;
            }, Number.NEGATIVE_INFINITY);
          };
          helpers$1.min = function(array) {
            return array.reduce(function(min2, value2) {
              if (!isNaN(value2)) {
                return Math.min(min2, value2);
              }
              return min2;
            }, Number.POSITIVE_INFINITY);
          };
          helpers$1.sign = Math.sign ? function(x2) {
            return Math.sign(x2);
          } : function(x2) {
            x2 = +x2;
            if (x2 === 0 || isNaN(x2)) {
              return x2;
            }
            return x2 > 0 ? 1 : -1;
          };
          helpers$1.toRadians = function(degrees) {
            return degrees * (Math.PI / 180);
          };
          helpers$1.toDegrees = function(radians) {
            return radians * (180 / Math.PI);
          };
          helpers$1._decimalPlaces = function(x2) {
            if (!helpers$1.isFinite(x2)) {
              return;
            }
            var e = 1;
            var p2 = 0;
            while (Math.round(x2 * e) / e !== x2) {
              e *= 10;
              p2++;
            }
            return p2;
          };
          helpers$1.getAngleFromPoint = function(centrePoint, anglePoint) {
            var distanceFromXCenter = anglePoint.x - centrePoint.x;
            var distanceFromYCenter = anglePoint.y - centrePoint.y;
            var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
            var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
            if (angle < -0.5 * Math.PI) {
              angle += 2 * Math.PI;
            }
            return {
              angle,
              distance: radialDistanceFromCenter
            };
          };
          helpers$1.distanceBetweenPoints = function(pt1, pt2) {
            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
          };
          helpers$1.aliasPixel = function(pixelWidth) {
            return pixelWidth % 2 === 0 ? 0 : 0.5;
          };
          helpers$1._alignPixel = function(chart, pixel, width2) {
            var devicePixelRatio = chart.currentDevicePixelRatio;
            var halfWidth = width2 / 2;
            return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
          };
          helpers$1.splineCurve = function(firstPoint, middlePoint, afterPoint, t2) {
            var previous = firstPoint.skip ? middlePoint : firstPoint;
            var current = middlePoint;
            var next = afterPoint.skip ? middlePoint : afterPoint;
            var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
            var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
            var s01 = d01 / (d01 + d12);
            var s12 = d12 / (d01 + d12);
            s01 = isNaN(s01) ? 0 : s01;
            s12 = isNaN(s12) ? 0 : s12;
            var fa2 = t2 * s01;
            var fb2 = t2 * s12;
            return {
              previous: {
                x: current.x - fa2 * (next.x - previous.x),
                y: current.y - fa2 * (next.y - previous.y)
              },
              next: {
                x: current.x + fb2 * (next.x - previous.x),
                y: current.y + fb2 * (next.y - previous.y)
              }
            };
          };
          helpers$1.EPSILON = Number.EPSILON || 1e-14;
          helpers$1.splineCurveMonotone = function(points) {
            var pointsWithTangents = (points || []).map(function(point) {
              return {
                model: point._model,
                deltaK: 0,
                mK: 0
              };
            });
            var pointsLen = pointsWithTangents.length;
            var i2, pointBefore, pointCurrent, pointAfter;
            for (i2 = 0; i2 < pointsLen; ++i2) {
              pointCurrent = pointsWithTangents[i2];
              if (pointCurrent.model.skip) {
                continue;
              }
              pointBefore = i2 > 0 ? pointsWithTangents[i2 - 1] : null;
              pointAfter = i2 < pointsLen - 1 ? pointsWithTangents[i2 + 1] : null;
              if (pointAfter && !pointAfter.model.skip) {
                var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;
                pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
              }
              if (!pointBefore || pointBefore.model.skip) {
                pointCurrent.mK = pointCurrent.deltaK;
              } else if (!pointAfter || pointAfter.model.skip) {
                pointCurrent.mK = pointBefore.deltaK;
              } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
                pointCurrent.mK = 0;
              } else {
                pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
              }
            }
            var alphaK, betaK, tauK, squaredMagnitude;
            for (i2 = 0; i2 < pointsLen - 1; ++i2) {
              pointCurrent = pointsWithTangents[i2];
              pointAfter = pointsWithTangents[i2 + 1];
              if (pointCurrent.model.skip || pointAfter.model.skip) {
                continue;
              }
              if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
                pointCurrent.mK = pointAfter.mK = 0;
                continue;
              }
              alphaK = pointCurrent.mK / pointCurrent.deltaK;
              betaK = pointAfter.mK / pointCurrent.deltaK;
              squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
              if (squaredMagnitude <= 9) {
                continue;
              }
              tauK = 3 / Math.sqrt(squaredMagnitude);
              pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
              pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
            }
            var deltaX;
            for (i2 = 0; i2 < pointsLen; ++i2) {
              pointCurrent = pointsWithTangents[i2];
              if (pointCurrent.model.skip) {
                continue;
              }
              pointBefore = i2 > 0 ? pointsWithTangents[i2 - 1] : null;
              pointAfter = i2 < pointsLen - 1 ? pointsWithTangents[i2 + 1] : null;
              if (pointBefore && !pointBefore.model.skip) {
                deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
                pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
                pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
              }
              if (pointAfter && !pointAfter.model.skip) {
                deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
                pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
                pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
              }
            }
          };
          helpers$1.nextItem = function(collection, index2, loop) {
            if (loop) {
              return index2 >= collection.length - 1 ? collection[0] : collection[index2 + 1];
            }
            return index2 >= collection.length - 1 ? collection[collection.length - 1] : collection[index2 + 1];
          };
          helpers$1.previousItem = function(collection, index2, loop) {
            if (loop) {
              return index2 <= 0 ? collection[collection.length - 1] : collection[index2 - 1];
            }
            return index2 <= 0 ? collection[0] : collection[index2 - 1];
          };
          helpers$1.niceNum = function(range2, round2) {
            var exponent = Math.floor(helpers$1.log10(range2));
            var fraction = range2 / Math.pow(10, exponent);
            var niceFraction;
            if (round2) {
              if (fraction < 1.5) {
                niceFraction = 1;
              } else if (fraction < 3) {
                niceFraction = 2;
              } else if (fraction < 7) {
                niceFraction = 5;
              } else {
                niceFraction = 10;
              }
            } else if (fraction <= 1) {
              niceFraction = 1;
            } else if (fraction <= 2) {
              niceFraction = 2;
            } else if (fraction <= 5) {
              niceFraction = 5;
            } else {
              niceFraction = 10;
            }
            return niceFraction * Math.pow(10, exponent);
          };
          helpers$1.requestAnimFrame = function() {
            if (typeof window === "undefined") {
              return function(callback) {
                callback();
              };
            }
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
              return window.setTimeout(callback, 1e3 / 60);
            };
          }();
          helpers$1.getRelativePosition = function(evt, chart) {
            var mouseX, mouseY;
            var e = evt.originalEvent || evt;
            var canvas3 = evt.target || evt.srcElement;
            var boundingRect = canvas3.getBoundingClientRect();
            var touches = e.touches;
            if (touches && touches.length > 0) {
              mouseX = touches[0].clientX;
              mouseY = touches[0].clientY;
            } else {
              mouseX = e.clientX;
              mouseY = e.clientY;
            }
            var paddingLeft = parseFloat(helpers$1.getStyle(canvas3, "padding-left"));
            var paddingTop = parseFloat(helpers$1.getStyle(canvas3, "padding-top"));
            var paddingRight = parseFloat(helpers$1.getStyle(canvas3, "padding-right"));
            var paddingBottom = parseFloat(helpers$1.getStyle(canvas3, "padding-bottom"));
            var width2 = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
            var height2 = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
            mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width2 * canvas3.width / chart.currentDevicePixelRatio);
            mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height2 * canvas3.height / chart.currentDevicePixelRatio);
            return {
              x: mouseX,
              y: mouseY
            };
          };
          function parseMaxStyle(styleValue, node, parentProperty) {
            var valueInPixels;
            if (typeof styleValue === "string") {
              valueInPixels = parseInt(styleValue, 10);
              if (styleValue.indexOf("%") !== -1) {
                valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
              }
            } else {
              valueInPixels = styleValue;
            }
            return valueInPixels;
          }
          function isConstrainedValue(value2) {
            return value2 !== void 0 && value2 !== null && value2 !== "none";
          }
          function getConstraintDimension(domNode, maxStyle, percentageProperty) {
            var view = document.defaultView;
            var parentNode = helpers$1._getParentNode(domNode);
            var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
            var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
            var hasCNode = isConstrainedValue(constrainedNode);
            var hasCContainer = isConstrainedValue(constrainedContainer);
            var infinity = Number.POSITIVE_INFINITY;
            if (hasCNode || hasCContainer) {
              return Math.min(
                hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
                hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity
              );
            }
            return "none";
          }
          helpers$1.getConstraintWidth = function(domNode) {
            return getConstraintDimension(domNode, "max-width", "clientWidth");
          };
          helpers$1.getConstraintHeight = function(domNode) {
            return getConstraintDimension(domNode, "max-height", "clientHeight");
          };
          helpers$1._calculatePadding = function(container, padding, parentDimension) {
            padding = helpers$1.getStyle(container, padding);
            return padding.indexOf("%") > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
          };
          helpers$1._getParentNode = function(domNode) {
            var parent = domNode.parentNode;
            if (parent && parent.toString() === "[object ShadowRoot]") {
              parent = parent.host;
            }
            return parent;
          };
          helpers$1.getMaximumWidth = function(domNode) {
            var container = helpers$1._getParentNode(domNode);
            if (!container) {
              return domNode.clientWidth;
            }
            var clientWidth = container.clientWidth;
            var paddingLeft = helpers$1._calculatePadding(container, "padding-left", clientWidth);
            var paddingRight = helpers$1._calculatePadding(container, "padding-right", clientWidth);
            var w2 = clientWidth - paddingLeft - paddingRight;
            var cw = helpers$1.getConstraintWidth(domNode);
            return isNaN(cw) ? w2 : Math.min(w2, cw);
          };
          helpers$1.getMaximumHeight = function(domNode) {
            var container = helpers$1._getParentNode(domNode);
            if (!container) {
              return domNode.clientHeight;
            }
            var clientHeight = container.clientHeight;
            var paddingTop = helpers$1._calculatePadding(container, "padding-top", clientHeight);
            var paddingBottom = helpers$1._calculatePadding(container, "padding-bottom", clientHeight);
            var h2 = clientHeight - paddingTop - paddingBottom;
            var ch2 = helpers$1.getConstraintHeight(domNode);
            return isNaN(ch2) ? h2 : Math.min(h2, ch2);
          };
          helpers$1.getStyle = function(el, property2) {
            return el.currentStyle ? el.currentStyle[property2] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property2);
          };
          helpers$1.retinaScale = function(chart, forceRatio) {
            var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== "undefined" && window.devicePixelRatio || 1;
            if (pixelRatio === 1) {
              return;
            }
            var canvas3 = chart.canvas;
            var height2 = chart.height;
            var width2 = chart.width;
            canvas3.height = height2 * pixelRatio;
            canvas3.width = width2 * pixelRatio;
            chart.ctx.scale(pixelRatio, pixelRatio);
            if (!canvas3.style.height && !canvas3.style.width) {
              canvas3.style.height = height2 + "px";
              canvas3.style.width = width2 + "px";
            }
          };
          helpers$1.fontString = function(pixelSize, fontStyle, fontFamily) {
            return fontStyle + " " + pixelSize + "px " + fontFamily;
          };
          helpers$1.longestText = function(ctx, font, arrayOfThings, cache2) {
            cache2 = cache2 || {};
            var data = cache2.data = cache2.data || {};
            var gc2 = cache2.garbageCollect = cache2.garbageCollect || [];
            if (cache2.font !== font) {
              data = cache2.data = {};
              gc2 = cache2.garbageCollect = [];
              cache2.font = font;
            }
            ctx.font = font;
            var longest = 0;
            var ilen = arrayOfThings.length;
            var i2, j, jlen, thing, nestedThing;
            for (i2 = 0; i2 < ilen; i2++) {
              thing = arrayOfThings[i2];
              if (thing !== void 0 && thing !== null && helpers$1.isArray(thing) !== true) {
                longest = helpers$1.measureText(ctx, data, gc2, longest, thing);
              } else if (helpers$1.isArray(thing)) {
                for (j = 0, jlen = thing.length; j < jlen; j++) {
                  nestedThing = thing[j];
                  if (nestedThing !== void 0 && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                    longest = helpers$1.measureText(ctx, data, gc2, longest, nestedThing);
                  }
                }
              }
            }
            var gcLen = gc2.length / 2;
            if (gcLen > arrayOfThings.length) {
              for (i2 = 0; i2 < gcLen; i2++) {
                delete data[gc2[i2]];
              }
              gc2.splice(0, gcLen);
            }
            return longest;
          };
          helpers$1.measureText = function(ctx, data, gc2, longest, string) {
            var textWidth = data[string];
            if (!textWidth) {
              textWidth = data[string] = ctx.measureText(string).width;
              gc2.push(string);
            }
            if (textWidth > longest) {
              longest = textWidth;
            }
            return longest;
          };
          helpers$1.numberOfLabelLines = function(arrayOfThings) {
            var numberOfLines = 1;
            helpers$1.each(arrayOfThings, function(thing) {
              if (helpers$1.isArray(thing)) {
                if (thing.length > numberOfLines) {
                  numberOfLines = thing.length;
                }
              }
            });
            return numberOfLines;
          };
          helpers$1.color = !chartjsColor ? function(value2) {
            console.error("Color.js not found!");
            return value2;
          } : function(value2) {
            if (value2 instanceof CanvasGradient) {
              value2 = core_defaults.global.defaultColor;
            }
            return chartjsColor(value2);
          };
          helpers$1.getHoverColor = function(colorValue) {
            return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
          };
        };
        function abstract() {
          throw new Error(
            "This method is not implemented: either no adapter can be found or an incomplete integration was provided."
          );
        }
        function DateAdapter(options2) {
          this.options = options2 || {};
        }
        helpers$1.extend(DateAdapter.prototype, {
          formats: abstract,
          parse: abstract,
          format: abstract,
          add: abstract,
          diff: abstract,
          startOf: abstract,
          endOf: abstract,
          _create: function(value2) {
            return value2;
          }
        });
        DateAdapter.override = function(members) {
          helpers$1.extend(DateAdapter.prototype, members);
        };
        var _date = DateAdapter;
        var core_adapters = {
          _date
        };
        var core_ticks = {
          formatters: {
            values: function(value2) {
              return helpers$1.isArray(value2) ? value2 : "" + value2;
            },
            linear: function(tickValue, index2, ticks) {
              var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
              if (Math.abs(delta) > 1) {
                if (tickValue !== Math.floor(tickValue)) {
                  delta = tickValue - Math.floor(tickValue);
                }
              }
              var logDelta = helpers$1.log10(Math.abs(delta));
              var tickString = "";
              if (tickValue !== 0) {
                var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
                if (maxTick < 1e-4) {
                  var logTick = helpers$1.log10(Math.abs(tickValue));
                  var numExponential = Math.floor(logTick) - Math.floor(logDelta);
                  numExponential = Math.max(Math.min(numExponential, 20), 0);
                  tickString = tickValue.toExponential(numExponential);
                } else {
                  var numDecimal = -1 * Math.floor(logDelta);
                  numDecimal = Math.max(Math.min(numDecimal, 20), 0);
                  tickString = tickValue.toFixed(numDecimal);
                }
              } else {
                tickString = "0";
              }
              return tickString;
            },
            logarithmic: function(tickValue, index2, ticks) {
              var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));
              if (tickValue === 0) {
                return "0";
              } else if (remain === 1 || remain === 2 || remain === 5 || index2 === 0 || index2 === ticks.length - 1) {
                return tickValue.toExponential();
              }
              return "";
            }
          }
        };
        var isArray2 = helpers$1.isArray;
        var isNullOrUndef = helpers$1.isNullOrUndef;
        var valueOrDefault$a = helpers$1.valueOrDefault;
        var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;
        core_defaults._set("scale", {
          display: true,
          position: "left",
          offset: false,
          gridLines: {
            display: true,
            color: "rgba(0,0,0,0.1)",
            lineWidth: 1,
            drawBorder: true,
            drawOnChartArea: true,
            drawTicks: true,
            tickMarkLength: 10,
            zeroLineWidth: 1,
            zeroLineColor: "rgba(0,0,0,0.25)",
            zeroLineBorderDash: [],
            zeroLineBorderDashOffset: 0,
            offsetGridLines: false,
            borderDash: [],
            borderDashOffset: 0
          },
          scaleLabel: {
            display: false,
            labelString: "",
            padding: {
              top: 4,
              bottom: 4
            }
          },
          ticks: {
            beginAtZero: false,
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            padding: 0,
            reverse: false,
            display: true,
            autoSkip: true,
            autoSkipPadding: 0,
            labelOffset: 0,
            callback: core_ticks.formatters.values,
            minor: {},
            major: {}
          }
        });
        function sample2(arr, numItems) {
          var result2 = [];
          var increment = arr.length / numItems;
          var i2 = 0;
          var len = arr.length;
          for (; i2 < len; i2 += increment) {
            result2.push(arr[Math.floor(i2)]);
          }
          return result2;
        }
        function getPixelForGridLine(scale2, index2, offsetGridLines) {
          var length = scale2.getTicks().length;
          var validIndex = Math.min(index2, length - 1);
          var lineValue = scale2.getPixelForTick(validIndex);
          var start = scale2._startPixel;
          var end = scale2._endPixel;
          var epsilon = 1e-6;
          var offset2;
          if (offsetGridLines) {
            if (length === 1) {
              offset2 = Math.max(lineValue - start, end - lineValue);
            } else if (index2 === 0) {
              offset2 = (scale2.getPixelForTick(1) - lineValue) / 2;
            } else {
              offset2 = (lineValue - scale2.getPixelForTick(validIndex - 1)) / 2;
            }
            lineValue += validIndex < index2 ? offset2 : -offset2;
            if (lineValue < start - epsilon || lineValue > end + epsilon) {
              return;
            }
          }
          return lineValue;
        }
        function garbageCollect(caches, length) {
          helpers$1.each(caches, function(cache2) {
            var gc2 = cache2.gc;
            var gcLen = gc2.length / 2;
            var i2;
            if (gcLen > length) {
              for (i2 = 0; i2 < gcLen; ++i2) {
                delete cache2.data[gc2[i2]];
              }
              gc2.splice(0, gcLen);
            }
          });
        }
        function computeLabelSizes(ctx, tickFonts, ticks, caches) {
          var length = ticks.length;
          var widths = [];
          var heights = [];
          var offsets = [];
          var widestLabelSize = 0;
          var highestLabelSize = 0;
          var i2, j, jlen, label, tickFont, fontString, cache2, lineHeight, width2, height2, nestedLabel, widest, highest;
          for (i2 = 0; i2 < length; ++i2) {
            label = ticks[i2].label;
            tickFont = ticks[i2].major ? tickFonts.major : tickFonts.minor;
            ctx.font = fontString = tickFont.string;
            cache2 = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
            lineHeight = tickFont.lineHeight;
            width2 = height2 = 0;
            if (!isNullOrUndef(label) && !isArray2(label)) {
              width2 = helpers$1.measureText(ctx, cache2.data, cache2.gc, width2, label);
              height2 = lineHeight;
            } else if (isArray2(label)) {
              for (j = 0, jlen = label.length; j < jlen; ++j) {
                nestedLabel = label[j];
                if (!isNullOrUndef(nestedLabel) && !isArray2(nestedLabel)) {
                  width2 = helpers$1.measureText(ctx, cache2.data, cache2.gc, width2, nestedLabel);
                  height2 += lineHeight;
                }
              }
            }
            widths.push(width2);
            heights.push(height2);
            offsets.push(lineHeight / 2);
            widestLabelSize = Math.max(width2, widestLabelSize);
            highestLabelSize = Math.max(height2, highestLabelSize);
          }
          garbageCollect(caches, length);
          widest = widths.indexOf(widestLabelSize);
          highest = heights.indexOf(highestLabelSize);
          function valueAt(idx) {
            return {
              width: widths[idx] || 0,
              height: heights[idx] || 0,
              offset: offsets[idx] || 0
            };
          }
          return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest)
          };
        }
        function getTickMarkLength(options2) {
          return options2.drawTicks ? options2.tickMarkLength : 0;
        }
        function getScaleLabelHeight(options2) {
          var font, padding;
          if (!options2.display) {
            return 0;
          }
          font = helpers$1.options._parseFont(options2);
          padding = helpers$1.options.toPadding(options2.padding);
          return font.lineHeight + padding.height;
        }
        function parseFontOptions(options2, nestedOpts) {
          return helpers$1.extend(helpers$1.options._parseFont({
            fontFamily: valueOrDefault$a(nestedOpts.fontFamily, options2.fontFamily),
            fontSize: valueOrDefault$a(nestedOpts.fontSize, options2.fontSize),
            fontStyle: valueOrDefault$a(nestedOpts.fontStyle, options2.fontStyle),
            lineHeight: valueOrDefault$a(nestedOpts.lineHeight, options2.lineHeight)
          }), {
            color: helpers$1.options.resolve([nestedOpts.fontColor, options2.fontColor, core_defaults.global.defaultFontColor])
          });
        }
        function parseTickFontOptions(options2) {
          var minor = parseFontOptions(options2, options2.minor);
          var major = options2.major.enabled ? parseFontOptions(options2, options2.major) : minor;
          return { minor, major };
        }
        function nonSkipped(ticksToFilter) {
          var filtered = [];
          var item, index2, len;
          for (index2 = 0, len = ticksToFilter.length; index2 < len; ++index2) {
            item = ticksToFilter[index2];
            if (typeof item._index !== "undefined") {
              filtered.push(item);
            }
          }
          return filtered;
        }
        function getEvenSpacing(arr) {
          var len = arr.length;
          var i2, diff2;
          if (len < 2) {
            return false;
          }
          for (diff2 = arr[0], i2 = 1; i2 < len; ++i2) {
            if (arr[i2] - arr[i2 - 1] !== diff2) {
              return false;
            }
          }
          return diff2;
        }
        function calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {
          var evenMajorSpacing = getEvenSpacing(majorIndices);
          var spacing = (ticks.length - 1) / ticksLimit;
          var factors, factor, i2, ilen;
          if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
          }
          factors = helpers$1.math._factorize(evenMajorSpacing);
          for (i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
            factor = factors[i2];
            if (factor > spacing) {
              return factor;
            }
          }
          return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
          var result2 = [];
          var i2, ilen;
          for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
            if (ticks[i2].major) {
              result2.push(i2);
            }
          }
          return result2;
        }
        function skipMajors(ticks, majorIndices, spacing) {
          var count = 0;
          var next = majorIndices[0];
          var i2, tick;
          spacing = Math.ceil(spacing);
          for (i2 = 0; i2 < ticks.length; i2++) {
            tick = ticks[i2];
            if (i2 === next) {
              tick._index = i2;
              count++;
              next = majorIndices[count * spacing];
            } else {
              delete tick.label;
            }
          }
        }
        function skip(ticks, spacing, majorStart, majorEnd) {
          var start = valueOrDefault$a(majorStart, 0);
          var end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);
          var count = 0;
          var length, i2, tick, next;
          spacing = Math.ceil(spacing);
          if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
          }
          next = start;
          while (next < 0) {
            count++;
            next = Math.round(start + count * spacing);
          }
          for (i2 = Math.max(start, 0); i2 < end; i2++) {
            tick = ticks[i2];
            if (i2 === next) {
              tick._index = i2;
              count++;
              next = Math.round(start + count * spacing);
            } else {
              delete tick.label;
            }
          }
        }
        var Scale = core_element.extend({
          zeroLineIndex: 0,
          getPadding: function() {
            var me2 = this;
            return {
              left: me2.paddingLeft || 0,
              top: me2.paddingTop || 0,
              right: me2.paddingRight || 0,
              bottom: me2.paddingBottom || 0
            };
          },
          getTicks: function() {
            return this._ticks;
          },
          _getLabels: function() {
            var data = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
          },
          mergeTicksOptions: function() {
          },
          beforeUpdate: function() {
            helpers$1.callback(this.options.beforeUpdate, [this]);
          },
          update: function(maxWidth, maxHeight, margins) {
            var me2 = this;
            var tickOpts = me2.options.ticks;
            var sampleSize = tickOpts.sampleSize;
            var i2, ilen, labels, ticks, samplingEnabled;
            me2.beforeUpdate();
            me2.maxWidth = maxWidth;
            me2.maxHeight = maxHeight;
            me2.margins = helpers$1.extend({
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }, margins);
            me2._ticks = null;
            me2.ticks = null;
            me2._labelSizes = null;
            me2._maxLabelLines = 0;
            me2.longestLabelWidth = 0;
            me2.longestTextCache = me2.longestTextCache || {};
            me2._gridLineItems = null;
            me2._labelItems = null;
            me2.beforeSetDimensions();
            me2.setDimensions();
            me2.afterSetDimensions();
            me2.beforeDataLimits();
            me2.determineDataLimits();
            me2.afterDataLimits();
            me2.beforeBuildTicks();
            ticks = me2.buildTicks() || [];
            ticks = me2.afterBuildTicks(ticks) || ticks;
            if ((!ticks || !ticks.length) && me2.ticks) {
              ticks = [];
              for (i2 = 0, ilen = me2.ticks.length; i2 < ilen; ++i2) {
                ticks.push({
                  value: me2.ticks[i2],
                  major: false
                });
              }
            }
            me2._ticks = ticks;
            samplingEnabled = sampleSize < ticks.length;
            labels = me2._convertTicksToLabels(samplingEnabled ? sample2(ticks, sampleSize) : ticks);
            me2._configure();
            me2.beforeCalculateTickRotation();
            me2.calculateTickRotation();
            me2.afterCalculateTickRotation();
            me2.beforeFit();
            me2.fit();
            me2.afterFit();
            me2._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto") ? me2._autoSkip(ticks) : ticks;
            if (samplingEnabled) {
              labels = me2._convertTicksToLabels(me2._ticksToDraw);
            }
            me2.ticks = labels;
            me2.afterUpdate();
            return me2.minSize;
          },
          _configure: function() {
            var me2 = this;
            var reversePixels = me2.options.ticks.reverse;
            var startPixel, endPixel;
            if (me2.isHorizontal()) {
              startPixel = me2.left;
              endPixel = me2.right;
            } else {
              startPixel = me2.top;
              endPixel = me2.bottom;
              reversePixels = !reversePixels;
            }
            me2._startPixel = startPixel;
            me2._endPixel = endPixel;
            me2._reversePixels = reversePixels;
            me2._length = endPixel - startPixel;
          },
          afterUpdate: function() {
            helpers$1.callback(this.options.afterUpdate, [this]);
          },
          beforeSetDimensions: function() {
            helpers$1.callback(this.options.beforeSetDimensions, [this]);
          },
          setDimensions: function() {
            var me2 = this;
            if (me2.isHorizontal()) {
              me2.width = me2.maxWidth;
              me2.left = 0;
              me2.right = me2.width;
            } else {
              me2.height = me2.maxHeight;
              me2.top = 0;
              me2.bottom = me2.height;
            }
            me2.paddingLeft = 0;
            me2.paddingTop = 0;
            me2.paddingRight = 0;
            me2.paddingBottom = 0;
          },
          afterSetDimensions: function() {
            helpers$1.callback(this.options.afterSetDimensions, [this]);
          },
          beforeDataLimits: function() {
            helpers$1.callback(this.options.beforeDataLimits, [this]);
          },
          determineDataLimits: helpers$1.noop,
          afterDataLimits: function() {
            helpers$1.callback(this.options.afterDataLimits, [this]);
          },
          beforeBuildTicks: function() {
            helpers$1.callback(this.options.beforeBuildTicks, [this]);
          },
          buildTicks: helpers$1.noop,
          afterBuildTicks: function(ticks) {
            var me2 = this;
            if (isArray2(ticks) && ticks.length) {
              return helpers$1.callback(me2.options.afterBuildTicks, [me2, ticks]);
            }
            me2.ticks = helpers$1.callback(me2.options.afterBuildTicks, [me2, me2.ticks]) || me2.ticks;
            return ticks;
          },
          beforeTickToLabelConversion: function() {
            helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
          },
          convertTicksToLabels: function() {
            var me2 = this;
            var tickOpts = me2.options.ticks;
            me2.ticks = me2.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
          },
          afterTickToLabelConversion: function() {
            helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
          },
          beforeCalculateTickRotation: function() {
            helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
          },
          calculateTickRotation: function() {
            var me2 = this;
            var options2 = me2.options;
            var tickOpts = options2.ticks;
            var numTicks = me2.getTicks().length;
            var minRotation = tickOpts.minRotation || 0;
            var maxRotation = tickOpts.maxRotation;
            var labelRotation = minRotation;
            var labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;
            if (!me2._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me2.isHorizontal()) {
              me2.labelRotation = minRotation;
              return;
            }
            labelSizes = me2._getLabelSizes();
            maxLabelWidth = labelSizes.widest.width;
            maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset;
            maxWidth = Math.min(me2.maxWidth, me2.chart.width - maxLabelWidth);
            tickWidth = options2.offset ? me2.maxWidth / numTicks : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
              tickWidth = maxWidth / (numTicks - (options2.offset ? 0.5 : 1));
              maxHeight = me2.maxHeight - getTickMarkLength(options2.gridLines) - tickOpts.padding - getScaleLabelHeight(options2.scaleLabel);
              maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
              labelRotation = helpers$1.toDegrees(Math.min(
                Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)),
                Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)
              ));
              labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
            }
            me2.labelRotation = labelRotation;
          },
          afterCalculateTickRotation: function() {
            helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
          },
          beforeFit: function() {
            helpers$1.callback(this.options.beforeFit, [this]);
          },
          fit: function() {
            var me2 = this;
            var minSize = me2.minSize = {
              width: 0,
              height: 0
            };
            var chart = me2.chart;
            var opts = me2.options;
            var tickOpts = opts.ticks;
            var scaleLabelOpts = opts.scaleLabel;
            var gridLineOpts = opts.gridLines;
            var display = me2._isVisible();
            var isBottom = opts.position === "bottom";
            var isHorizontal = me2.isHorizontal();
            if (isHorizontal) {
              minSize.width = me2.maxWidth;
            } else if (display) {
              minSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
            }
            if (!isHorizontal) {
              minSize.height = me2.maxHeight;
            } else if (display) {
              minSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
            }
            if (tickOpts.display && display) {
              var tickFonts = parseTickFontOptions(tickOpts);
              var labelSizes = me2._getLabelSizes();
              var firstLabelSize = labelSizes.first;
              var lastLabelSize = labelSizes.last;
              var widestLabelSize = labelSizes.widest;
              var highestLabelSize = labelSizes.highest;
              var lineSpace = tickFonts.minor.lineHeight * 0.4;
              var tickPadding = tickOpts.padding;
              if (isHorizontal) {
                var isRotated = me2.labelRotation !== 0;
                var angleRadians = helpers$1.toRadians(me2.labelRotation);
                var cosRotation = Math.cos(angleRadians);
                var sinRotation = Math.sin(angleRadians);
                var labelHeight = sinRotation * widestLabelSize.width + cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0)) + (isRotated ? 0 : lineSpace);
                minSize.height = Math.min(me2.maxHeight, minSize.height + labelHeight + tickPadding);
                var offsetLeft = me2.getPixelForTick(0) - me2.left;
                var offsetRight = me2.right - me2.getPixelForTick(me2.getTicks().length - 1);
                var paddingLeft, paddingRight;
                if (isRotated) {
                  paddingLeft = isBottom ? cosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset : sinRotation * (firstLabelSize.height - firstLabelSize.offset);
                  paddingRight = isBottom ? sinRotation * (lastLabelSize.height - lastLabelSize.offset) : cosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;
                } else {
                  paddingLeft = firstLabelSize.width / 2;
                  paddingRight = lastLabelSize.width / 2;
                }
                me2.paddingLeft = Math.max((paddingLeft - offsetLeft) * me2.width / (me2.width - offsetLeft), 0) + 3;
                me2.paddingRight = Math.max((paddingRight - offsetRight) * me2.width / (me2.width - offsetRight), 0) + 3;
              } else {
                var labelWidth = tickOpts.mirror ? 0 : widestLabelSize.width + tickPadding + lineSpace;
                minSize.width = Math.min(me2.maxWidth, minSize.width + labelWidth);
                me2.paddingTop = firstLabelSize.height / 2;
                me2.paddingBottom = lastLabelSize.height / 2;
              }
            }
            me2.handleMargins();
            if (isHorizontal) {
              me2.width = me2._length = chart.width - me2.margins.left - me2.margins.right;
              me2.height = minSize.height;
            } else {
              me2.width = minSize.width;
              me2.height = me2._length = chart.height - me2.margins.top - me2.margins.bottom;
            }
          },
          handleMargins: function() {
            var me2 = this;
            if (me2.margins) {
              me2.margins.left = Math.max(me2.paddingLeft, me2.margins.left);
              me2.margins.top = Math.max(me2.paddingTop, me2.margins.top);
              me2.margins.right = Math.max(me2.paddingRight, me2.margins.right);
              me2.margins.bottom = Math.max(me2.paddingBottom, me2.margins.bottom);
            }
          },
          afterFit: function() {
            helpers$1.callback(this.options.afterFit, [this]);
          },
          isHorizontal: function() {
            var pos = this.options.position;
            return pos === "top" || pos === "bottom";
          },
          isFullWidth: function() {
            return this.options.fullWidth;
          },
          getRightValue: function(rawValue) {
            if (isNullOrUndef(rawValue)) {
              return NaN;
            }
            if ((typeof rawValue === "number" || rawValue instanceof Number) && !isFinite(rawValue)) {
              return NaN;
            }
            if (rawValue) {
              if (this.isHorizontal()) {
                if (rawValue.x !== void 0) {
                  return this.getRightValue(rawValue.x);
                }
              } else if (rawValue.y !== void 0) {
                return this.getRightValue(rawValue.y);
              }
            }
            return rawValue;
          },
          _convertTicksToLabels: function(ticks) {
            var me2 = this;
            var labels, i2, ilen;
            me2.ticks = ticks.map(function(tick) {
              return tick.value;
            });
            me2.beforeTickToLabelConversion();
            labels = me2.convertTicksToLabels(ticks) || me2.ticks;
            me2.afterTickToLabelConversion();
            for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
              ticks[i2].label = labels[i2];
            }
            return labels;
          },
          _getLabelSizes: function() {
            var me2 = this;
            var labelSizes = me2._labelSizes;
            if (!labelSizes) {
              me2._labelSizes = labelSizes = computeLabelSizes(me2.ctx, parseTickFontOptions(me2.options.ticks), me2.getTicks(), me2.longestTextCache);
              me2.longestLabelWidth = labelSizes.widest.width;
            }
            return labelSizes;
          },
          _parseValue: function(value2) {
            var start, end, min2, max2;
            if (isArray2(value2)) {
              start = +this.getRightValue(value2[0]);
              end = +this.getRightValue(value2[1]);
              min2 = Math.min(start, end);
              max2 = Math.max(start, end);
            } else {
              value2 = +this.getRightValue(value2);
              start = void 0;
              end = value2;
              min2 = value2;
              max2 = value2;
            }
            return {
              min: min2,
              max: max2,
              start,
              end
            };
          },
          _getScaleLabel: function(rawValue) {
            var v2 = this._parseValue(rawValue);
            if (v2.start !== void 0) {
              return "[" + v2.start + ", " + v2.end + "]";
            }
            return +this.getRightValue(rawValue);
          },
          getLabelForIndex: helpers$1.noop,
          getPixelForValue: helpers$1.noop,
          getValueForPixel: helpers$1.noop,
          getPixelForTick: function(index2) {
            var me2 = this;
            var offset2 = me2.options.offset;
            var numTicks = me2._ticks.length;
            var tickWidth = 1 / Math.max(numTicks - (offset2 ? 0 : 1), 1);
            return index2 < 0 || index2 > numTicks - 1 ? null : me2.getPixelForDecimal(index2 * tickWidth + (offset2 ? tickWidth / 2 : 0));
          },
          getPixelForDecimal: function(decimal) {
            var me2 = this;
            if (me2._reversePixels) {
              decimal = 1 - decimal;
            }
            return me2._startPixel + decimal * me2._length;
          },
          getDecimalForPixel: function(pixel) {
            var decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
          },
          getBasePixel: function() {
            return this.getPixelForValue(this.getBaseValue());
          },
          getBaseValue: function() {
            var me2 = this;
            var min2 = me2.min;
            var max2 = me2.max;
            return me2.beginAtZero ? 0 : min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0;
          },
          _autoSkip: function(ticks) {
            var me2 = this;
            var tickOpts = me2.options.ticks;
            var axisLength = me2._length;
            var ticksLimit = tickOpts.maxTicksLimit || axisLength / me2._tickSize() + 1;
            var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
            var numMajorIndices = majorIndices.length;
            var first2 = majorIndices[0];
            var last2 = majorIndices[numMajorIndices - 1];
            var i2, ilen, spacing, avgMajorSpacing;
            if (numMajorIndices > ticksLimit) {
              skipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);
              return nonSkipped(ticks);
            }
            spacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);
            if (numMajorIndices > 0) {
              for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
                skip(ticks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
              }
              avgMajorSpacing = numMajorIndices > 1 ? (last2 - first2) / (numMajorIndices - 1) : null;
              skip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first2 - avgMajorSpacing, first2);
              skip(ticks, spacing, last2, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last2 + avgMajorSpacing);
              return nonSkipped(ticks);
            }
            skip(ticks, spacing);
            return nonSkipped(ticks);
          },
          _tickSize: function() {
            var me2 = this;
            var optionTicks = me2.options.ticks;
            var rot = helpers$1.toRadians(me2.labelRotation);
            var cos = Math.abs(Math.cos(rot));
            var sin = Math.abs(Math.sin(rot));
            var labelSizes = me2._getLabelSizes();
            var padding = optionTicks.autoSkipPadding || 0;
            var w2 = labelSizes ? labelSizes.widest.width + padding : 0;
            var h2 = labelSizes ? labelSizes.highest.height + padding : 0;
            return me2.isHorizontal() ? h2 * cos > w2 * sin ? w2 / cos : h2 / sin : h2 * sin < w2 * cos ? h2 / cos : w2 / sin;
          },
          _isVisible: function() {
            var me2 = this;
            var chart = me2.chart;
            var display = me2.options.display;
            var i2, ilen, meta;
            if (display !== "auto") {
              return !!display;
            }
            for (i2 = 0, ilen = chart.data.datasets.length; i2 < ilen; ++i2) {
              if (chart.isDatasetVisible(i2)) {
                meta = chart.getDatasetMeta(i2);
                if (meta.xAxisID === me2.id || meta.yAxisID === me2.id) {
                  return true;
                }
              }
            }
            return false;
          },
          _computeGridLineItems: function(chartArea) {
            var me2 = this;
            var chart = me2.chart;
            var options2 = me2.options;
            var gridLines = options2.gridLines;
            var position = options2.position;
            var offsetGridLines = gridLines.offsetGridLines;
            var isHorizontal = me2.isHorizontal();
            var ticks = me2._ticksToDraw;
            var ticksLength = ticks.length + (offsetGridLines ? 1 : 0);
            var tl = getTickMarkLength(gridLines);
            var items2 = [];
            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
            var axisHalfWidth = axisWidth / 2;
            var alignPixel = helpers$1._alignPixel;
            var alignBorderValue = function(pixel) {
              return alignPixel(chart, pixel, axisWidth);
            };
            var borderValue, i2, tick, lineValue, alignedLineValue;
            var tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;
            if (position === "top") {
              borderValue = alignBorderValue(me2.bottom);
              ty1 = me2.bottom - tl;
              ty2 = borderValue - axisHalfWidth;
              y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
              y2 = chartArea.bottom;
            } else if (position === "bottom") {
              borderValue = alignBorderValue(me2.top);
              y1 = chartArea.top;
              y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
              ty1 = borderValue + axisHalfWidth;
              ty2 = me2.top + tl;
            } else if (position === "left") {
              borderValue = alignBorderValue(me2.right);
              tx1 = me2.right - tl;
              tx2 = borderValue - axisHalfWidth;
              x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
              x2 = chartArea.right;
            } else {
              borderValue = alignBorderValue(me2.left);
              x1 = chartArea.left;
              x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
              tx1 = borderValue + axisHalfWidth;
              tx2 = me2.left + tl;
            }
            for (i2 = 0; i2 < ticksLength; ++i2) {
              tick = ticks[i2] || {};
              if (isNullOrUndef(tick.label) && i2 < ticks.length) {
                continue;
              }
              if (i2 === me2.zeroLineIndex && options2.offset === offsetGridLines) {
                lineWidth = gridLines.zeroLineWidth;
                lineColor = gridLines.zeroLineColor;
                borderDash = gridLines.zeroLineBorderDash || [];
                borderDashOffset = gridLines.zeroLineBorderDashOffset || 0;
              } else {
                lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i2, 1);
                lineColor = valueAtIndexOrDefault(gridLines.color, i2, "rgba(0,0,0,0.1)");
                borderDash = gridLines.borderDash || [];
                borderDashOffset = gridLines.borderDashOffset || 0;
              }
              lineValue = getPixelForGridLine(me2, tick._index || i2, offsetGridLines);
              if (lineValue === void 0) {
                continue;
              }
              alignedLineValue = alignPixel(chart, lineValue, lineWidth);
              if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
              } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
              }
              items2.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset
              });
            }
            items2.ticksLength = ticksLength;
            items2.borderValue = borderValue;
            return items2;
          },
          _computeLabelItems: function() {
            var me2 = this;
            var options2 = me2.options;
            var optionTicks = options2.ticks;
            var position = options2.position;
            var isMirrored = optionTicks.mirror;
            var isHorizontal = me2.isHorizontal();
            var ticks = me2._ticksToDraw;
            var fonts = parseTickFontOptions(optionTicks);
            var tickPadding = optionTicks.padding;
            var tl = getTickMarkLength(options2.gridLines);
            var rotation = -helpers$1.toRadians(me2.labelRotation);
            var items2 = [];
            var i2, ilen, tick, label, x2, y2, textAlign, pixel, font, lineHeight, lineCount, textOffset;
            if (position === "top") {
              y2 = me2.bottom - tl - tickPadding;
              textAlign = !rotation ? "center" : "left";
            } else if (position === "bottom") {
              y2 = me2.top + tl + tickPadding;
              textAlign = !rotation ? "center" : "right";
            } else if (position === "left") {
              x2 = me2.right - (isMirrored ? 0 : tl) - tickPadding;
              textAlign = isMirrored ? "left" : "right";
            } else {
              x2 = me2.left + (isMirrored ? 0 : tl) + tickPadding;
              textAlign = isMirrored ? "right" : "left";
            }
            for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
              tick = ticks[i2];
              label = tick.label;
              if (isNullOrUndef(label)) {
                continue;
              }
              pixel = me2.getPixelForTick(tick._index || i2) + optionTicks.labelOffset;
              font = tick.major ? fonts.major : fonts.minor;
              lineHeight = font.lineHeight;
              lineCount = isArray2(label) ? label.length : 1;
              if (isHorizontal) {
                x2 = pixel;
                textOffset = position === "top" ? ((!rotation ? 0.5 : 1) - lineCount) * lineHeight : (!rotation ? 0.5 : 0) * lineHeight;
              } else {
                y2 = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
              }
              items2.push({
                x: x2,
                y: y2,
                rotation,
                label,
                font,
                textOffset,
                textAlign
              });
            }
            return items2;
          },
          _drawGrid: function(chartArea) {
            var me2 = this;
            var gridLines = me2.options.gridLines;
            if (!gridLines.display) {
              return;
            }
            var ctx = me2.ctx;
            var chart = me2.chart;
            var alignPixel = helpers$1._alignPixel;
            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
            var items2 = me2._gridLineItems || (me2._gridLineItems = me2._computeGridLineItems(chartArea));
            var width2, color, i2, ilen, item;
            for (i2 = 0, ilen = items2.length; i2 < ilen; ++i2) {
              item = items2[i2];
              width2 = item.width;
              color = item.color;
              if (width2 && color) {
                ctx.save();
                ctx.lineWidth = width2;
                ctx.strokeStyle = color;
                if (ctx.setLineDash) {
                  ctx.setLineDash(item.borderDash);
                  ctx.lineDashOffset = item.borderDashOffset;
                }
                ctx.beginPath();
                if (gridLines.drawTicks) {
                  ctx.moveTo(item.tx1, item.ty1);
                  ctx.lineTo(item.tx2, item.ty2);
                }
                if (gridLines.drawOnChartArea) {
                  ctx.moveTo(item.x1, item.y1);
                  ctx.lineTo(item.x2, item.y2);
                }
                ctx.stroke();
                ctx.restore();
              }
            }
            if (axisWidth) {
              var firstLineWidth = axisWidth;
              var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items2.ticksLength - 1, 1);
              var borderValue = items2.borderValue;
              var x1, x2, y1, y2;
              if (me2.isHorizontal()) {
                x1 = alignPixel(chart, me2.left, firstLineWidth) - firstLineWidth / 2;
                x2 = alignPixel(chart, me2.right, lastLineWidth) + lastLineWidth / 2;
                y1 = y2 = borderValue;
              } else {
                y1 = alignPixel(chart, me2.top, firstLineWidth) - firstLineWidth / 2;
                y2 = alignPixel(chart, me2.bottom, lastLineWidth) + lastLineWidth / 2;
                x1 = x2 = borderValue;
              }
              ctx.lineWidth = axisWidth;
              ctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
            }
          },
          _drawLabels: function() {
            var me2 = this;
            var optionTicks = me2.options.ticks;
            if (!optionTicks.display) {
              return;
            }
            var ctx = me2.ctx;
            var items2 = me2._labelItems || (me2._labelItems = me2._computeLabelItems());
            var i2, j, ilen, jlen, item, tickFont, label, y2;
            for (i2 = 0, ilen = items2.length; i2 < ilen; ++i2) {
              item = items2[i2];
              tickFont = item.font;
              ctx.save();
              ctx.translate(item.x, item.y);
              ctx.rotate(item.rotation);
              ctx.font = tickFont.string;
              ctx.fillStyle = tickFont.color;
              ctx.textBaseline = "middle";
              ctx.textAlign = item.textAlign;
              label = item.label;
              y2 = item.textOffset;
              if (isArray2(label)) {
                for (j = 0, jlen = label.length; j < jlen; ++j) {
                  ctx.fillText("" + label[j], 0, y2);
                  y2 += tickFont.lineHeight;
                }
              } else {
                ctx.fillText(label, 0, y2);
              }
              ctx.restore();
            }
          },
          _drawTitle: function() {
            var me2 = this;
            var ctx = me2.ctx;
            var options2 = me2.options;
            var scaleLabel = options2.scaleLabel;
            if (!scaleLabel.display) {
              return;
            }
            var scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);
            var scaleLabelFont = helpers$1.options._parseFont(scaleLabel);
            var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
            var halfLineHeight = scaleLabelFont.lineHeight / 2;
            var position = options2.position;
            var rotation = 0;
            var scaleLabelX, scaleLabelY;
            if (me2.isHorizontal()) {
              scaleLabelX = me2.left + me2.width / 2;
              scaleLabelY = position === "bottom" ? me2.bottom - halfLineHeight - scaleLabelPadding.bottom : me2.top + halfLineHeight + scaleLabelPadding.top;
            } else {
              var isLeft = position === "left";
              scaleLabelX = isLeft ? me2.left + halfLineHeight + scaleLabelPadding.top : me2.right - halfLineHeight - scaleLabelPadding.top;
              scaleLabelY = me2.top + me2.height / 2;
              rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
            }
            ctx.save();
            ctx.translate(scaleLabelX, scaleLabelY);
            ctx.rotate(rotation);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = scaleLabelFontColor;
            ctx.font = scaleLabelFont.string;
            ctx.fillText(scaleLabel.labelString, 0, 0);
            ctx.restore();
          },
          draw: function(chartArea) {
            var me2 = this;
            if (!me2._isVisible()) {
              return;
            }
            me2._drawGrid(chartArea);
            me2._drawTitle();
            me2._drawLabels();
          },
          _layers: function() {
            var me2 = this;
            var opts = me2.options;
            var tz = opts.ticks && opts.ticks.z || 0;
            var gz = opts.gridLines && opts.gridLines.z || 0;
            if (!me2._isVisible() || tz === gz || me2.draw !== me2._draw) {
              return [{
                z: tz,
                draw: function() {
                  me2.draw.apply(me2, arguments);
                }
              }];
            }
            return [{
              z: gz,
              draw: function() {
                me2._drawGrid.apply(me2, arguments);
                me2._drawTitle.apply(me2, arguments);
              }
            }, {
              z: tz,
              draw: function() {
                me2._drawLabels.apply(me2, arguments);
              }
            }];
          },
          _getMatchingVisibleMetas: function(type) {
            var me2 = this;
            var isHorizontal = me2.isHorizontal();
            return me2.chart._getSortedVisibleDatasetMetas().filter(function(meta) {
              return (!type || meta.type === type) && (isHorizontal ? meta.xAxisID === me2.id : meta.yAxisID === me2.id);
            });
          }
        });
        Scale.prototype._draw = Scale.prototype.draw;
        var core_scale = Scale;
        var isNullOrUndef$1 = helpers$1.isNullOrUndef;
        var defaultConfig = {
          position: "bottom"
        };
        var scale_category = core_scale.extend({
          determineDataLimits: function() {
            var me2 = this;
            var labels = me2._getLabels();
            var ticksOpts = me2.options.ticks;
            var min2 = ticksOpts.min;
            var max2 = ticksOpts.max;
            var minIndex = 0;
            var maxIndex = labels.length - 1;
            var findIndex2;
            if (min2 !== void 0) {
              findIndex2 = labels.indexOf(min2);
              if (findIndex2 >= 0) {
                minIndex = findIndex2;
              }
            }
            if (max2 !== void 0) {
              findIndex2 = labels.indexOf(max2);
              if (findIndex2 >= 0) {
                maxIndex = findIndex2;
              }
            }
            me2.minIndex = minIndex;
            me2.maxIndex = maxIndex;
            me2.min = labels[minIndex];
            me2.max = labels[maxIndex];
          },
          buildTicks: function() {
            var me2 = this;
            var labels = me2._getLabels();
            var minIndex = me2.minIndex;
            var maxIndex = me2.maxIndex;
            me2.ticks = minIndex === 0 && maxIndex === labels.length - 1 ? labels : labels.slice(minIndex, maxIndex + 1);
          },
          getLabelForIndex: function(index2, datasetIndex) {
            var me2 = this;
            var chart = me2.chart;
            if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me2.id) {
              return me2.getRightValue(chart.data.datasets[datasetIndex].data[index2]);
            }
            return me2._getLabels()[index2];
          },
          _configure: function() {
            var me2 = this;
            var offset2 = me2.options.offset;
            var ticks = me2.ticks;
            core_scale.prototype._configure.call(me2);
            if (!me2.isHorizontal()) {
              me2._reversePixels = !me2._reversePixels;
            }
            if (!ticks) {
              return;
            }
            me2._startValue = me2.minIndex - (offset2 ? 0.5 : 0);
            me2._valueRange = Math.max(ticks.length - (offset2 ? 0 : 1), 1);
          },
          getPixelForValue: function(value2, index2, datasetIndex) {
            var me2 = this;
            var valueCategory, labels, idx;
            if (!isNullOrUndef$1(index2) && !isNullOrUndef$1(datasetIndex)) {
              value2 = me2.chart.data.datasets[datasetIndex].data[index2];
            }
            if (!isNullOrUndef$1(value2)) {
              valueCategory = me2.isHorizontal() ? value2.x : value2.y;
            }
            if (valueCategory !== void 0 || value2 !== void 0 && isNaN(index2)) {
              labels = me2._getLabels();
              value2 = helpers$1.valueOrDefault(valueCategory, value2);
              idx = labels.indexOf(value2);
              index2 = idx !== -1 ? idx : index2;
              if (isNaN(index2)) {
                index2 = value2;
              }
            }
            return me2.getPixelForDecimal((index2 - me2._startValue) / me2._valueRange);
          },
          getPixelForTick: function(index2) {
            var ticks = this.ticks;
            return index2 < 0 || index2 > ticks.length - 1 ? null : this.getPixelForValue(ticks[index2], index2 + this.minIndex);
          },
          getValueForPixel: function(pixel) {
            var me2 = this;
            var value2 = Math.round(me2._startValue + me2.getDecimalForPixel(pixel) * me2._valueRange);
            return Math.min(Math.max(value2, 0), me2.ticks.length - 1);
          },
          getBasePixel: function() {
            return this.bottom;
          }
        });
        var _defaults = defaultConfig;
        scale_category._defaults = _defaults;
        var noop2 = helpers$1.noop;
        var isNullOrUndef$2 = helpers$1.isNullOrUndef;
        function generateTicks(generationOptions, dataRange) {
          var ticks = [];
          var MIN_SPACING = 1e-14;
          var stepSize = generationOptions.stepSize;
          var unit = stepSize || 1;
          var maxNumSpaces = generationOptions.maxTicks - 1;
          var min2 = generationOptions.min;
          var max2 = generationOptions.max;
          var precision = generationOptions.precision;
          var rmin = dataRange.min;
          var rmax = dataRange.max;
          var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
          var factor, niceMin, niceMax, numSpaces;
          if (spacing < MIN_SPACING && isNullOrUndef$2(min2) && isNullOrUndef$2(max2)) {
            return [rmin, rmax];
          }
          numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
          if (numSpaces > maxNumSpaces) {
            spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
          }
          if (stepSize || isNullOrUndef$2(precision)) {
            factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
          } else {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
          }
          niceMin = Math.floor(rmin / spacing) * spacing;
          niceMax = Math.ceil(rmax / spacing) * spacing;
          if (stepSize) {
            if (!isNullOrUndef$2(min2) && helpers$1.almostWhole(min2 / spacing, spacing / 1e3)) {
              niceMin = min2;
            }
            if (!isNullOrUndef$2(max2) && helpers$1.almostWhole(max2 / spacing, spacing / 1e3)) {
              niceMax = max2;
            }
          }
          numSpaces = (niceMax - niceMin) / spacing;
          if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
            numSpaces = Math.round(numSpaces);
          } else {
            numSpaces = Math.ceil(numSpaces);
          }
          niceMin = Math.round(niceMin * factor) / factor;
          niceMax = Math.round(niceMax * factor) / factor;
          ticks.push(isNullOrUndef$2(min2) ? niceMin : min2);
          for (var j = 1; j < numSpaces; ++j) {
            ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
          }
          ticks.push(isNullOrUndef$2(max2) ? niceMax : max2);
          return ticks;
        }
        var scale_linearbase = core_scale.extend({
          getRightValue: function(value2) {
            if (typeof value2 === "string") {
              return +value2;
            }
            return core_scale.prototype.getRightValue.call(this, value2);
          },
          handleTickRangeOptions: function() {
            var me2 = this;
            var opts = me2.options;
            var tickOpts = opts.ticks;
            if (tickOpts.beginAtZero) {
              var minSign = helpers$1.sign(me2.min);
              var maxSign = helpers$1.sign(me2.max);
              if (minSign < 0 && maxSign < 0) {
                me2.max = 0;
              } else if (minSign > 0 && maxSign > 0) {
                me2.min = 0;
              }
            }
            var setMin = tickOpts.min !== void 0 || tickOpts.suggestedMin !== void 0;
            var setMax = tickOpts.max !== void 0 || tickOpts.suggestedMax !== void 0;
            if (tickOpts.min !== void 0) {
              me2.min = tickOpts.min;
            } else if (tickOpts.suggestedMin !== void 0) {
              if (me2.min === null) {
                me2.min = tickOpts.suggestedMin;
              } else {
                me2.min = Math.min(me2.min, tickOpts.suggestedMin);
              }
            }
            if (tickOpts.max !== void 0) {
              me2.max = tickOpts.max;
            } else if (tickOpts.suggestedMax !== void 0) {
              if (me2.max === null) {
                me2.max = tickOpts.suggestedMax;
              } else {
                me2.max = Math.max(me2.max, tickOpts.suggestedMax);
              }
            }
            if (setMin !== setMax) {
              if (me2.min >= me2.max) {
                if (setMin) {
                  me2.max = me2.min + 1;
                } else {
                  me2.min = me2.max - 1;
                }
              }
            }
            if (me2.min === me2.max) {
              me2.max++;
              if (!tickOpts.beginAtZero) {
                me2.min--;
              }
            }
          },
          getTickLimit: function() {
            var me2 = this;
            var tickOpts = me2.options.ticks;
            var stepSize = tickOpts.stepSize;
            var maxTicksLimit = tickOpts.maxTicksLimit;
            var maxTicks;
            if (stepSize) {
              maxTicks = Math.ceil(me2.max / stepSize) - Math.floor(me2.min / stepSize) + 1;
            } else {
              maxTicks = me2._computeTickLimit();
              maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
              maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
          },
          _computeTickLimit: function() {
            return Number.POSITIVE_INFINITY;
          },
          handleDirectionalChanges: noop2,
          buildTicks: function() {
            var me2 = this;
            var opts = me2.options;
            var tickOpts = opts.ticks;
            var maxTicks = me2.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            var numericGeneratorOptions = {
              maxTicks,
              min: tickOpts.min,
              max: tickOpts.max,
              precision: tickOpts.precision,
              stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
            };
            var ticks = me2.ticks = generateTicks(numericGeneratorOptions, me2);
            me2.handleDirectionalChanges();
            me2.max = helpers$1.max(ticks);
            me2.min = helpers$1.min(ticks);
            if (tickOpts.reverse) {
              ticks.reverse();
              me2.start = me2.max;
              me2.end = me2.min;
            } else {
              me2.start = me2.min;
              me2.end = me2.max;
            }
          },
          convertTicksToLabels: function() {
            var me2 = this;
            me2.ticksAsNumbers = me2.ticks.slice();
            me2.zeroLineIndex = me2.ticks.indexOf(0);
            core_scale.prototype.convertTicksToLabels.call(me2);
          },
          _configure: function() {
            var me2 = this;
            var ticks = me2.getTicks();
            var start = me2.min;
            var end = me2.max;
            var offset2;
            core_scale.prototype._configure.call(me2);
            if (me2.options.offset && ticks.length) {
              offset2 = (end - start) / Math.max(ticks.length - 1, 1) / 2;
              start -= offset2;
              end += offset2;
            }
            me2._startValue = start;
            me2._endValue = end;
            me2._valueRange = end - start;
          }
        });
        var defaultConfig$1 = {
          position: "left",
          ticks: {
            callback: core_ticks.formatters.linear
          }
        };
        var DEFAULT_MIN = 0;
        var DEFAULT_MAX = 1;
        function getOrCreateStack(stacks, stacked, meta) {
          var key = [
            meta.type,
            stacked === void 0 && meta.stack === void 0 ? meta.index : "",
            meta.stack
          ].join(".");
          if (stacks[key] === void 0) {
            stacks[key] = {
              pos: [],
              neg: []
            };
          }
          return stacks[key];
        }
        function stackData(scale2, stacks, meta, data) {
          var opts = scale2.options;
          var stacked = opts.stacked;
          var stack = getOrCreateStack(stacks, stacked, meta);
          var pos = stack.pos;
          var neg = stack.neg;
          var ilen = data.length;
          var i2, value2;
          for (i2 = 0; i2 < ilen; ++i2) {
            value2 = scale2._parseValue(data[i2]);
            if (isNaN(value2.min) || isNaN(value2.max) || meta.data[i2].hidden) {
              continue;
            }
            pos[i2] = pos[i2] || 0;
            neg[i2] = neg[i2] || 0;
            if (opts.relativePoints) {
              pos[i2] = 100;
            } else if (value2.min < 0 || value2.max < 0) {
              neg[i2] += value2.min;
            } else {
              pos[i2] += value2.max;
            }
          }
        }
        function updateMinMax(scale2, meta, data) {
          var ilen = data.length;
          var i2, value2;
          for (i2 = 0; i2 < ilen; ++i2) {
            value2 = scale2._parseValue(data[i2]);
            if (isNaN(value2.min) || isNaN(value2.max) || meta.data[i2].hidden) {
              continue;
            }
            scale2.min = Math.min(scale2.min, value2.min);
            scale2.max = Math.max(scale2.max, value2.max);
          }
        }
        var scale_linear = scale_linearbase.extend({
          determineDataLimits: function() {
            var me2 = this;
            var opts = me2.options;
            var chart = me2.chart;
            var datasets = chart.data.datasets;
            var metasets = me2._getMatchingVisibleMetas();
            var hasStacks = opts.stacked;
            var stacks = {};
            var ilen = metasets.length;
            var i2, meta, data, values2;
            me2.min = Number.POSITIVE_INFINITY;
            me2.max = Number.NEGATIVE_INFINITY;
            if (hasStacks === void 0) {
              for (i2 = 0; !hasStacks && i2 < ilen; ++i2) {
                meta = metasets[i2];
                hasStacks = meta.stack !== void 0;
              }
            }
            for (i2 = 0; i2 < ilen; ++i2) {
              meta = metasets[i2];
              data = datasets[meta.index].data;
              if (hasStacks) {
                stackData(me2, stacks, meta, data);
              } else {
                updateMinMax(me2, meta, data);
              }
            }
            helpers$1.each(stacks, function(stackValues) {
              values2 = stackValues.pos.concat(stackValues.neg);
              me2.min = Math.min(me2.min, helpers$1.min(values2));
              me2.max = Math.max(me2.max, helpers$1.max(values2));
            });
            me2.min = helpers$1.isFinite(me2.min) && !isNaN(me2.min) ? me2.min : DEFAULT_MIN;
            me2.max = helpers$1.isFinite(me2.max) && !isNaN(me2.max) ? me2.max : DEFAULT_MAX;
            me2.handleTickRangeOptions();
          },
          _computeTickLimit: function() {
            var me2 = this;
            var tickFont;
            if (me2.isHorizontal()) {
              return Math.ceil(me2.width / 40);
            }
            tickFont = helpers$1.options._parseFont(me2.options.ticks);
            return Math.ceil(me2.height / tickFont.lineHeight);
          },
          handleDirectionalChanges: function() {
            if (!this.isHorizontal()) {
              this.ticks.reverse();
            }
          },
          getLabelForIndex: function(index2, datasetIndex) {
            return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index2]);
          },
          getPixelForValue: function(value2) {
            var me2 = this;
            return me2.getPixelForDecimal((+me2.getRightValue(value2) - me2._startValue) / me2._valueRange);
          },
          getValueForPixel: function(pixel) {
            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
          },
          getPixelForTick: function(index2) {
            var ticks = this.ticksAsNumbers;
            if (index2 < 0 || index2 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index2]);
          }
        });
        var _defaults$1 = defaultConfig$1;
        scale_linear._defaults = _defaults$1;
        var valueOrDefault$b = helpers$1.valueOrDefault;
        var log10 = helpers$1.math.log10;
        function generateTicks$1(generationOptions, dataRange) {
          var ticks = [];
          var tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
          var endExp = Math.floor(log10(dataRange.max));
          var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
          var exp, significand;
          if (tickVal === 0) {
            exp = Math.floor(log10(dataRange.minNotZero));
            significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
            ticks.push(tickVal);
            tickVal = significand * Math.pow(10, exp);
          } else {
            exp = Math.floor(log10(tickVal));
            significand = Math.floor(tickVal / Math.pow(10, exp));
          }
          var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
          do {
            ticks.push(tickVal);
            ++significand;
            if (significand === 10) {
              significand = 1;
              ++exp;
              precision = exp >= 0 ? 1 : precision;
            }
            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
          } while (exp < endExp || exp === endExp && significand < endSignificand);
          var lastTick = valueOrDefault$b(generationOptions.max, tickVal);
          ticks.push(lastTick);
          return ticks;
        }
        var defaultConfig$2 = {
          position: "left",
          ticks: {
            callback: core_ticks.formatters.logarithmic
          }
        };
        function nonNegativeOrDefault(value2, defaultValue2) {
          return helpers$1.isFinite(value2) && value2 >= 0 ? value2 : defaultValue2;
        }
        var scale_logarithmic = core_scale.extend({
          determineDataLimits: function() {
            var me2 = this;
            var opts = me2.options;
            var chart = me2.chart;
            var datasets = chart.data.datasets;
            var isHorizontal = me2.isHorizontal();
            function IDMatches(meta2) {
              return isHorizontal ? meta2.xAxisID === me2.id : meta2.yAxisID === me2.id;
            }
            var datasetIndex, meta, value2, data, i2, ilen;
            me2.min = Number.POSITIVE_INFINITY;
            me2.max = Number.NEGATIVE_INFINITY;
            me2.minNotZero = Number.POSITIVE_INFINITY;
            var hasStacks = opts.stacked;
            if (hasStacks === void 0) {
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== void 0) {
                  hasStacks = true;
                  break;
                }
              }
            }
            if (opts.stacked || hasStacks) {
              var valuesPerStack = {};
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                var key = [
                  meta.type,
                  opts.stacked === void 0 && meta.stack === void 0 ? datasetIndex : "",
                  meta.stack
                ].join(".");
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  if (valuesPerStack[key] === void 0) {
                    valuesPerStack[key] = [];
                  }
                  data = datasets[datasetIndex].data;
                  for (i2 = 0, ilen = data.length; i2 < ilen; i2++) {
                    var values2 = valuesPerStack[key];
                    value2 = me2._parseValue(data[i2]);
                    if (isNaN(value2.min) || isNaN(value2.max) || meta.data[i2].hidden || value2.min < 0 || value2.max < 0) {
                      continue;
                    }
                    values2[i2] = values2[i2] || 0;
                    values2[i2] += value2.max;
                  }
                }
              }
              helpers$1.each(valuesPerStack, function(valuesForType) {
                if (valuesForType.length > 0) {
                  var minVal = helpers$1.min(valuesForType);
                  var maxVal = helpers$1.max(valuesForType);
                  me2.min = Math.min(me2.min, minVal);
                  me2.max = Math.max(me2.max, maxVal);
                }
              });
            } else {
              for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                meta = chart.getDatasetMeta(datasetIndex);
                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                  data = datasets[datasetIndex].data;
                  for (i2 = 0, ilen = data.length; i2 < ilen; i2++) {
                    value2 = me2._parseValue(data[i2]);
                    if (isNaN(value2.min) || isNaN(value2.max) || meta.data[i2].hidden || value2.min < 0 || value2.max < 0) {
                      continue;
                    }
                    me2.min = Math.min(value2.min, me2.min);
                    me2.max = Math.max(value2.max, me2.max);
                    if (value2.min !== 0) {
                      me2.minNotZero = Math.min(value2.min, me2.minNotZero);
                    }
                  }
                }
              }
            }
            me2.min = helpers$1.isFinite(me2.min) ? me2.min : null;
            me2.max = helpers$1.isFinite(me2.max) ? me2.max : null;
            me2.minNotZero = helpers$1.isFinite(me2.minNotZero) ? me2.minNotZero : null;
            this.handleTickRangeOptions();
          },
          handleTickRangeOptions: function() {
            var me2 = this;
            var tickOpts = me2.options.ticks;
            var DEFAULT_MIN2 = 1;
            var DEFAULT_MAX2 = 10;
            me2.min = nonNegativeOrDefault(tickOpts.min, me2.min);
            me2.max = nonNegativeOrDefault(tickOpts.max, me2.max);
            if (me2.min === me2.max) {
              if (me2.min !== 0 && me2.min !== null) {
                me2.min = Math.pow(10, Math.floor(log10(me2.min)) - 1);
                me2.max = Math.pow(10, Math.floor(log10(me2.max)) + 1);
              } else {
                me2.min = DEFAULT_MIN2;
                me2.max = DEFAULT_MAX2;
              }
            }
            if (me2.min === null) {
              me2.min = Math.pow(10, Math.floor(log10(me2.max)) - 1);
            }
            if (me2.max === null) {
              me2.max = me2.min !== 0 ? Math.pow(10, Math.floor(log10(me2.min)) + 1) : DEFAULT_MAX2;
            }
            if (me2.minNotZero === null) {
              if (me2.min > 0) {
                me2.minNotZero = me2.min;
              } else if (me2.max < 1) {
                me2.minNotZero = Math.pow(10, Math.floor(log10(me2.max)));
              } else {
                me2.minNotZero = DEFAULT_MIN2;
              }
            }
          },
          buildTicks: function() {
            var me2 = this;
            var tickOpts = me2.options.ticks;
            var reverse = !me2.isHorizontal();
            var generationOptions = {
              min: nonNegativeOrDefault(tickOpts.min),
              max: nonNegativeOrDefault(tickOpts.max)
            };
            var ticks = me2.ticks = generateTicks$1(generationOptions, me2);
            me2.max = helpers$1.max(ticks);
            me2.min = helpers$1.min(ticks);
            if (tickOpts.reverse) {
              reverse = !reverse;
              me2.start = me2.max;
              me2.end = me2.min;
            } else {
              me2.start = me2.min;
              me2.end = me2.max;
            }
            if (reverse) {
              ticks.reverse();
            }
          },
          convertTicksToLabels: function() {
            this.tickValues = this.ticks.slice();
            core_scale.prototype.convertTicksToLabels.call(this);
          },
          getLabelForIndex: function(index2, datasetIndex) {
            return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index2]);
          },
          getPixelForTick: function(index2) {
            var ticks = this.tickValues;
            if (index2 < 0 || index2 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index2]);
          },
          _getFirstTickValue: function(value2) {
            var exp = Math.floor(log10(value2));
            var significand = Math.floor(value2 / Math.pow(10, exp));
            return significand * Math.pow(10, exp);
          },
          _configure: function() {
            var me2 = this;
            var start = me2.min;
            var offset2 = 0;
            core_scale.prototype._configure.call(me2);
            if (start === 0) {
              start = me2._getFirstTickValue(me2.minNotZero);
              offset2 = valueOrDefault$b(me2.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me2._length;
            }
            me2._startValue = log10(start);
            me2._valueOffset = offset2;
            me2._valueRange = (log10(me2.max) - log10(start)) / (1 - offset2);
          },
          getPixelForValue: function(value2) {
            var me2 = this;
            var decimal = 0;
            value2 = +me2.getRightValue(value2);
            if (value2 > me2.min && value2 > 0) {
              decimal = (log10(value2) - me2._startValue) / me2._valueRange + me2._valueOffset;
            }
            return me2.getPixelForDecimal(decimal);
          },
          getValueForPixel: function(pixel) {
            var me2 = this;
            var decimal = me2.getDecimalForPixel(pixel);
            return decimal === 0 && me2.min === 0 ? 0 : Math.pow(10, me2._startValue + (decimal - me2._valueOffset) * me2._valueRange);
          }
        });
        var _defaults$2 = defaultConfig$2;
        scale_logarithmic._defaults = _defaults$2;
        var valueOrDefault$c = helpers$1.valueOrDefault;
        var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
        var resolve$4 = helpers$1.options.resolve;
        var defaultConfig$3 = {
          display: true,
          animate: true,
          position: "chartArea",
          angleLines: {
            display: true,
            color: "rgba(0,0,0,0.1)",
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
          },
          gridLines: {
            circular: false
          },
          ticks: {
            showLabelBackdrop: true,
            backdropColor: "rgba(255,255,255,0.75)",
            backdropPaddingY: 2,
            backdropPaddingX: 2,
            callback: core_ticks.formatters.linear
          },
          pointLabels: {
            display: true,
            fontSize: 10,
            callback: function(label) {
              return label;
            }
          }
        };
        function getTickBackdropHeight(opts) {
          var tickOpts = opts.ticks;
          if (tickOpts.display && opts.display) {
            return valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
          }
          return 0;
        }
        function measureLabelSize(ctx, lineHeight, label) {
          if (helpers$1.isArray(label)) {
            return {
              w: helpers$1.longestText(ctx, ctx.font, label),
              h: label.length * lineHeight
            };
          }
          return {
            w: ctx.measureText(label).width,
            h: lineHeight
          };
        }
        function determineLimits(angle, pos, size2, min2, max2) {
          if (angle === min2 || angle === max2) {
            return {
              start: pos - size2 / 2,
              end: pos + size2 / 2
            };
          } else if (angle < min2 || angle > max2) {
            return {
              start: pos - size2,
              end: pos
            };
          }
          return {
            start: pos,
            end: pos + size2
          };
        }
        function fitWithPointLabels(scale2) {
          var plFont = helpers$1.options._parseFont(scale2.options.pointLabels);
          var furthestLimits = {
            l: 0,
            r: scale2.width,
            t: 0,
            b: scale2.height - scale2.paddingTop
          };
          var furthestAngles = {};
          var i2, textSize, pointPosition;
          scale2.ctx.font = plFont.string;
          scale2._pointLabelSizes = [];
          var valueCount = scale2.chart.data.labels.length;
          for (i2 = 0; i2 < valueCount; i2++) {
            pointPosition = scale2.getPointPosition(i2, scale2.drawingArea + 5);
            textSize = measureLabelSize(scale2.ctx, plFont.lineHeight, scale2.pointLabels[i2]);
            scale2._pointLabelSizes[i2] = textSize;
            var angleRadians = scale2.getIndexAngle(i2);
            var angle = helpers$1.toDegrees(angleRadians) % 360;
            var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
            var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            if (hLimits.start < furthestLimits.l) {
              furthestLimits.l = hLimits.start;
              furthestAngles.l = angleRadians;
            }
            if (hLimits.end > furthestLimits.r) {
              furthestLimits.r = hLimits.end;
              furthestAngles.r = angleRadians;
            }
            if (vLimits.start < furthestLimits.t) {
              furthestLimits.t = vLimits.start;
              furthestAngles.t = angleRadians;
            }
            if (vLimits.end > furthestLimits.b) {
              furthestLimits.b = vLimits.end;
              furthestAngles.b = angleRadians;
            }
          }
          scale2.setReductions(scale2.drawingArea, furthestLimits, furthestAngles);
        }
        function getTextAlignForAngle(angle) {
          if (angle === 0 || angle === 180) {
            return "center";
          } else if (angle < 180) {
            return "left";
          }
          return "right";
        }
        function fillText(ctx, text, position, lineHeight) {
          var y2 = position.y + lineHeight / 2;
          var i2, ilen;
          if (helpers$1.isArray(text)) {
            for (i2 = 0, ilen = text.length; i2 < ilen; ++i2) {
              ctx.fillText(text[i2], position.x, y2);
              y2 += lineHeight;
            }
          } else {
            ctx.fillText(text, position.x, y2);
          }
        }
        function adjustPointPositionForLabelHeight(angle, textSize, position) {
          if (angle === 90 || angle === 270) {
            position.y -= textSize.h / 2;
          } else if (angle > 270 || angle < 90) {
            position.y -= textSize.h;
          }
        }
        function drawPointLabels(scale2) {
          var ctx = scale2.ctx;
          var opts = scale2.options;
          var pointLabelOpts = opts.pointLabels;
          var tickBackdropHeight = getTickBackdropHeight(opts);
          var outerDistance = scale2.getDistanceFromCenterForValue(opts.ticks.reverse ? scale2.min : scale2.max);
          var plFont = helpers$1.options._parseFont(pointLabelOpts);
          ctx.save();
          ctx.font = plFont.string;
          ctx.textBaseline = "middle";
          for (var i2 = scale2.chart.data.labels.length - 1; i2 >= 0; i2--) {
            var extra = i2 === 0 ? tickBackdropHeight / 2 : 0;
            var pointLabelPosition = scale2.getPointPosition(i2, outerDistance + extra + 5);
            var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i2, core_defaults.global.defaultFontColor);
            ctx.fillStyle = pointLabelFontColor;
            var angleRadians = scale2.getIndexAngle(i2);
            var angle = helpers$1.toDegrees(angleRadians);
            ctx.textAlign = getTextAlignForAngle(angle);
            adjustPointPositionForLabelHeight(angle, scale2._pointLabelSizes[i2], pointLabelPosition);
            fillText(ctx, scale2.pointLabels[i2], pointLabelPosition, plFont.lineHeight);
          }
          ctx.restore();
        }
        function drawRadiusLine(scale2, gridLineOpts, radius, index2) {
          var ctx = scale2.ctx;
          var circular = gridLineOpts.circular;
          var valueCount = scale2.chart.data.labels.length;
          var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index2 - 1);
          var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index2 - 1);
          var pointPosition;
          if (!circular && !valueCount || !lineColor || !lineWidth) {
            return;
          }
          ctx.save();
          ctx.strokeStyle = lineColor;
          ctx.lineWidth = lineWidth;
          if (ctx.setLineDash) {
            ctx.setLineDash(gridLineOpts.borderDash || []);
            ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0;
          }
          ctx.beginPath();
          if (circular) {
            ctx.arc(scale2.xCenter, scale2.yCenter, radius, 0, Math.PI * 2);
          } else {
            pointPosition = scale2.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (var i2 = 1; i2 < valueCount; i2++) {
              pointPosition = scale2.getPointPosition(i2, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
            }
          }
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
        function numberOrZero(param) {
          return helpers$1.isNumber(param) ? param : 0;
        }
        var scale_radialLinear = scale_linearbase.extend({
          setDimensions: function() {
            var me2 = this;
            me2.width = me2.maxWidth;
            me2.height = me2.maxHeight;
            me2.paddingTop = getTickBackdropHeight(me2.options) / 2;
            me2.xCenter = Math.floor(me2.width / 2);
            me2.yCenter = Math.floor((me2.height - me2.paddingTop) / 2);
            me2.drawingArea = Math.min(me2.height - me2.paddingTop, me2.width) / 2;
          },
          determineDataLimits: function() {
            var me2 = this;
            var chart = me2.chart;
            var min2 = Number.POSITIVE_INFINITY;
            var max2 = Number.NEGATIVE_INFINITY;
            helpers$1.each(chart.data.datasets, function(dataset, datasetIndex) {
              if (chart.isDatasetVisible(datasetIndex)) {
                var meta = chart.getDatasetMeta(datasetIndex);
                helpers$1.each(dataset.data, function(rawValue, index2) {
                  var value2 = +me2.getRightValue(rawValue);
                  if (isNaN(value2) || meta.data[index2].hidden) {
                    return;
                  }
                  min2 = Math.min(value2, min2);
                  max2 = Math.max(value2, max2);
                });
              }
            });
            me2.min = min2 === Number.POSITIVE_INFINITY ? 0 : min2;
            me2.max = max2 === Number.NEGATIVE_INFINITY ? 0 : max2;
            me2.handleTickRangeOptions();
          },
          _computeTickLimit: function() {
            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
          },
          convertTicksToLabels: function() {
            var me2 = this;
            scale_linearbase.prototype.convertTicksToLabels.call(me2);
            me2.pointLabels = me2.chart.data.labels.map(function() {
              var label = helpers$1.callback(me2.options.pointLabels.callback, arguments, me2);
              return label || label === 0 ? label : "";
            });
          },
          getLabelForIndex: function(index2, datasetIndex) {
            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index2]);
          },
          fit: function() {
            var me2 = this;
            var opts = me2.options;
            if (opts.display && opts.pointLabels.display) {
              fitWithPointLabels(me2);
            } else {
              me2.setCenterPoint(0, 0, 0, 0);
            }
          },
          setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
            var me2 = this;
            var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
            var radiusReductionRight = Math.max(furthestLimits.r - me2.width, 0) / Math.sin(furthestAngles.r);
            var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
            var radiusReductionBottom = -Math.max(furthestLimits.b - (me2.height - me2.paddingTop), 0) / Math.cos(furthestAngles.b);
            radiusReductionLeft = numberOrZero(radiusReductionLeft);
            radiusReductionRight = numberOrZero(radiusReductionRight);
            radiusReductionTop = numberOrZero(radiusReductionTop);
            radiusReductionBottom = numberOrZero(radiusReductionBottom);
            me2.drawingArea = Math.min(
              Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
              Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)
            );
            me2.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
          },
          setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
            var me2 = this;
            var maxRight = me2.width - rightMovement - me2.drawingArea;
            var maxLeft = leftMovement + me2.drawingArea;
            var maxTop = topMovement + me2.drawingArea;
            var maxBottom = me2.height - me2.paddingTop - bottomMovement - me2.drawingArea;
            me2.xCenter = Math.floor((maxLeft + maxRight) / 2 + me2.left);
            me2.yCenter = Math.floor((maxTop + maxBottom) / 2 + me2.top + me2.paddingTop);
          },
          getIndexAngle: function(index2) {
            var chart = this.chart;
            var angleMultiplier = 360 / chart.data.labels.length;
            var options2 = chart.options || {};
            var startAngle = options2.startAngle || 0;
            var angle = (index2 * angleMultiplier + startAngle) % 360;
            return (angle < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;
          },
          getDistanceFromCenterForValue: function(value2) {
            var me2 = this;
            if (helpers$1.isNullOrUndef(value2)) {
              return NaN;
            }
            var scalingFactor = me2.drawingArea / (me2.max - me2.min);
            if (me2.options.ticks.reverse) {
              return (me2.max - value2) * scalingFactor;
            }
            return (value2 - me2.min) * scalingFactor;
          },
          getPointPosition: function(index2, distanceFromCenter) {
            var me2 = this;
            var thisAngle = me2.getIndexAngle(index2) - Math.PI / 2;
            return {
              x: Math.cos(thisAngle) * distanceFromCenter + me2.xCenter,
              y: Math.sin(thisAngle) * distanceFromCenter + me2.yCenter
            };
          },
          getPointPositionForValue: function(index2, value2) {
            return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value2));
          },
          getBasePosition: function(index2) {
            var me2 = this;
            var min2 = me2.min;
            var max2 = me2.max;
            return me2.getPointPositionForValue(
              index2 || 0,
              me2.beginAtZero ? 0 : min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0
            );
          },
          _drawGrid: function() {
            var me2 = this;
            var ctx = me2.ctx;
            var opts = me2.options;
            var gridLineOpts = opts.gridLines;
            var angleLineOpts = opts.angleLines;
            var lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
            var lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);
            var i2, offset2, position;
            if (opts.pointLabels.display) {
              drawPointLabels(me2);
            }
            if (gridLineOpts.display) {
              helpers$1.each(me2.ticks, function(label, index2) {
                if (index2 !== 0) {
                  offset2 = me2.getDistanceFromCenterForValue(me2.ticksAsNumbers[index2]);
                  drawRadiusLine(me2, gridLineOpts, offset2, index2);
                }
              });
            }
            if (angleLineOpts.display && lineWidth && lineColor) {
              ctx.save();
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = lineColor;
              if (ctx.setLineDash) {
                ctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
                ctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0]);
              }
              for (i2 = me2.chart.data.labels.length - 1; i2 >= 0; i2--) {
                offset2 = me2.getDistanceFromCenterForValue(opts.ticks.reverse ? me2.min : me2.max);
                position = me2.getPointPosition(i2, offset2);
                ctx.beginPath();
                ctx.moveTo(me2.xCenter, me2.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
              }
              ctx.restore();
            }
          },
          _drawLabels: function() {
            var me2 = this;
            var ctx = me2.ctx;
            var opts = me2.options;
            var tickOpts = opts.ticks;
            if (!tickOpts.display) {
              return;
            }
            var startAngle = me2.getIndexAngle(0);
            var tickFont = helpers$1.options._parseFont(tickOpts);
            var tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);
            var offset2, width2;
            ctx.save();
            ctx.font = tickFont.string;
            ctx.translate(me2.xCenter, me2.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            helpers$1.each(me2.ticks, function(label, index2) {
              if (index2 === 0 && !tickOpts.reverse) {
                return;
              }
              offset2 = me2.getDistanceFromCenterForValue(me2.ticksAsNumbers[index2]);
              if (tickOpts.showLabelBackdrop) {
                width2 = ctx.measureText(label).width;
                ctx.fillStyle = tickOpts.backdropColor;
                ctx.fillRect(
                  -width2 / 2 - tickOpts.backdropPaddingX,
                  -offset2 - tickFont.size / 2 - tickOpts.backdropPaddingY,
                  width2 + tickOpts.backdropPaddingX * 2,
                  tickFont.size + tickOpts.backdropPaddingY * 2
                );
              }
              ctx.fillStyle = tickFontColor;
              ctx.fillText(label, 0, -offset2);
            });
            ctx.restore();
          },
          _drawTitle: helpers$1.noop
        });
        var _defaults$3 = defaultConfig$3;
        scale_radialLinear._defaults = _defaults$3;
        var deprecated$1 = helpers$1._deprecated;
        var resolve$5 = helpers$1.options.resolve;
        var valueOrDefault$d = helpers$1.valueOrDefault;
        var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
        var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        var INTERVALS = {
          millisecond: {
            common: true,
            size: 1,
            steps: 1e3
          },
          second: {
            common: true,
            size: 1e3,
            steps: 60
          },
          minute: {
            common: true,
            size: 6e4,
            steps: 60
          },
          hour: {
            common: true,
            size: 36e5,
            steps: 24
          },
          day: {
            common: true,
            size: 864e5,
            steps: 30
          },
          week: {
            common: false,
            size: 6048e5,
            steps: 4
          },
          month: {
            common: true,
            size: 2628e6,
            steps: 12
          },
          quarter: {
            common: false,
            size: 7884e6,
            steps: 4
          },
          year: {
            common: true,
            size: 3154e7
          }
        };
        var UNITS = Object.keys(INTERVALS);
        function sorter(a2, b) {
          return a2 - b;
        }
        function arrayUnique(items2) {
          var hash = {};
          var out = [];
          var i2, ilen, item;
          for (i2 = 0, ilen = items2.length; i2 < ilen; ++i2) {
            item = items2[i2];
            if (!hash[item]) {
              hash[item] = true;
              out.push(item);
            }
          }
          return out;
        }
        function getMin(options2) {
          return helpers$1.valueOrDefault(options2.time.min, options2.ticks.min);
        }
        function getMax(options2) {
          return helpers$1.valueOrDefault(options2.time.max, options2.ticks.max);
        }
        function buildLookupTable(timestamps, min2, max2, distribution) {
          if (distribution === "linear" || !timestamps.length) {
            return [
              { time: min2, pos: 0 },
              { time: max2, pos: 1 }
            ];
          }
          var table = [];
          var items2 = [min2];
          var i2, ilen, prev, curr, next;
          for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
            curr = timestamps[i2];
            if (curr > min2 && curr < max2) {
              items2.push(curr);
            }
          }
          items2.push(max2);
          for (i2 = 0, ilen = items2.length; i2 < ilen; ++i2) {
            next = items2[i2 + 1];
            prev = items2[i2 - 1];
            curr = items2[i2];
            if (prev === void 0 || next === void 0 || Math.round((next + prev) / 2) !== curr) {
              table.push({ time: curr, pos: i2 / (ilen - 1) });
            }
          }
          return table;
        }
        function lookup(table, key, value2) {
          var lo = 0;
          var hi2 = table.length - 1;
          var mid, i0, i1;
          while (lo >= 0 && lo <= hi2) {
            mid = lo + hi2 >> 1;
            i0 = table[mid - 1] || null;
            i1 = table[mid];
            if (!i0) {
              return { lo: null, hi: i1 };
            } else if (i1[key] < value2) {
              lo = mid + 1;
            } else if (i0[key] > value2) {
              hi2 = mid - 1;
            } else {
              return { lo: i0, hi: i1 };
            }
          }
          return { lo: i1, hi: null };
        }
        function interpolate$1(table, skey, sval, tkey) {
          var range2 = lookup(table, skey, sval);
          var prev = !range2.lo ? table[0] : !range2.hi ? table[table.length - 2] : range2.lo;
          var next = !range2.lo ? table[1] : !range2.hi ? table[table.length - 1] : range2.hi;
          var span = next[skey] - prev[skey];
          var ratio = span ? (sval - prev[skey]) / span : 0;
          var offset2 = (next[tkey] - prev[tkey]) * ratio;
          return prev[tkey] + offset2;
        }
        function toTimestamp(scale2, input) {
          var adapter = scale2._adapter;
          var options2 = scale2.options.time;
          var parser = options2.parser;
          var format2 = parser || options2.format;
          var value2 = input;
          if (typeof parser === "function") {
            value2 = parser(value2);
          }
          if (!helpers$1.isFinite(value2)) {
            value2 = typeof format2 === "string" ? adapter.parse(value2, format2) : adapter.parse(value2);
          }
          if (value2 !== null) {
            return +value2;
          }
          if (!parser && typeof format2 === "function") {
            value2 = format2(input);
            if (!helpers$1.isFinite(value2)) {
              value2 = adapter.parse(value2);
            }
          }
          return value2;
        }
        function parse2(scale2, input) {
          if (helpers$1.isNullOrUndef(input)) {
            return null;
          }
          var options2 = scale2.options.time;
          var value2 = toTimestamp(scale2, scale2.getRightValue(input));
          if (value2 === null) {
            return value2;
          }
          if (options2.round) {
            value2 = +scale2._adapter.startOf(value2, options2.round);
          }
          return value2;
        }
        function determineUnitForAutoTicks(minUnit, min2, max2, capacity) {
          var ilen = UNITS.length;
          var i2, interval, factor;
          for (i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
            interval = INTERVALS[UNITS[i2]];
            factor = interval.steps ? interval.steps : MAX_INTEGER;
            if (interval.common && Math.ceil((max2 - min2) / (factor * interval.size)) <= capacity) {
              return UNITS[i2];
            }
          }
          return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(scale2, numTicks, minUnit, min2, max2) {
          var i2, unit;
          for (i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
            unit = UNITS[i2];
            if (INTERVALS[unit].common && scale2._adapter.diff(max2, min2, unit) >= numTicks - 1) {
              return unit;
            }
          }
          return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
          for (var i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
            if (INTERVALS[UNITS[i2]].common) {
              return UNITS[i2];
            }
          }
        }
        function generate(scale2, min2, max2, capacity) {
          var adapter = scale2._adapter;
          var options2 = scale2.options;
          var timeOpts = options2.time;
          var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min2, max2, capacity);
          var stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize, 1]);
          var weekday = minor === "week" ? timeOpts.isoWeekday : false;
          var first2 = min2;
          var ticks = [];
          var time;
          if (weekday) {
            first2 = +adapter.startOf(first2, "isoWeek", weekday);
          }
          first2 = +adapter.startOf(first2, weekday ? "day" : minor);
          if (adapter.diff(max2, min2, minor) > 1e5 * stepSize) {
            throw min2 + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor;
          }
          for (time = first2; time < max2; time = +adapter.add(time, stepSize, minor)) {
            ticks.push(time);
          }
          if (time === max2 || options2.bounds === "ticks") {
            ticks.push(time);
          }
          return ticks;
        }
        function computeOffsets(table, ticks, min2, max2, options2) {
          var start = 0;
          var end = 0;
          var first2, last2;
          if (options2.offset && ticks.length) {
            first2 = interpolate$1(table, "time", ticks[0], "pos");
            if (ticks.length === 1) {
              start = 1 - first2;
            } else {
              start = (interpolate$1(table, "time", ticks[1], "pos") - first2) / 2;
            }
            last2 = interpolate$1(table, "time", ticks[ticks.length - 1], "pos");
            if (ticks.length === 1) {
              end = last2;
            } else {
              end = (last2 - interpolate$1(table, "time", ticks[ticks.length - 2], "pos")) / 2;
            }
          }
          return { start, end, factor: 1 / (start + 1 + end) };
        }
        function setMajorTicks(scale2, ticks, map2, majorUnit) {
          var adapter = scale2._adapter;
          var first2 = +adapter.startOf(ticks[0].value, majorUnit);
          var last2 = ticks[ticks.length - 1].value;
          var major, index2;
          for (major = first2; major <= last2; major = +adapter.add(major, 1, majorUnit)) {
            index2 = map2[major];
            if (index2 >= 0) {
              ticks[index2].major = true;
            }
          }
          return ticks;
        }
        function ticksFromTimestamps(scale2, values2, majorUnit) {
          var ticks = [];
          var map2 = {};
          var ilen = values2.length;
          var i2, value2;
          for (i2 = 0; i2 < ilen; ++i2) {
            value2 = values2[i2];
            map2[value2] = i2;
            ticks.push({
              value: value2,
              major: false
            });
          }
          return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale2, ticks, map2, majorUnit);
        }
        var defaultConfig$4 = {
          position: "bottom",
          distribution: "linear",
          bounds: "data",
          adapters: {},
          time: {
            parser: false,
            unit: false,
            round: false,
            displayFormat: false,
            isoWeekday: false,
            minUnit: "millisecond",
            displayFormats: {}
          },
          ticks: {
            autoSkip: false,
            source: "auto",
            major: {
              enabled: false
            }
          }
        };
        var scale_time = core_scale.extend({
          initialize: function() {
            this.mergeTicksOptions();
            core_scale.prototype.initialize.call(this);
          },
          update: function() {
            var me2 = this;
            var options2 = me2.options;
            var time = options2.time || (options2.time = {});
            var adapter = me2._adapter = new core_adapters._date(options2.adapters.date);
            deprecated$1("time scale", time.format, "time.format", "time.parser");
            deprecated$1("time scale", time.min, "time.min", "ticks.min");
            deprecated$1("time scale", time.max, "time.max", "ticks.max");
            helpers$1.mergeIf(time.displayFormats, adapter.formats());
            return core_scale.prototype.update.apply(me2, arguments);
          },
          getRightValue: function(rawValue) {
            if (rawValue && rawValue.t !== void 0) {
              rawValue = rawValue.t;
            }
            return core_scale.prototype.getRightValue.call(this, rawValue);
          },
          determineDataLimits: function() {
            var me2 = this;
            var chart = me2.chart;
            var adapter = me2._adapter;
            var options2 = me2.options;
            var unit = options2.time.unit || "day";
            var min2 = MAX_INTEGER;
            var max2 = MIN_INTEGER;
            var timestamps = [];
            var datasets = [];
            var labels = [];
            var i2, j, ilen, jlen, data, timestamp, labelsAdded;
            var dataLabels = me2._getLabels();
            for (i2 = 0, ilen = dataLabels.length; i2 < ilen; ++i2) {
              labels.push(parse2(me2, dataLabels[i2]));
            }
            for (i2 = 0, ilen = (chart.data.datasets || []).length; i2 < ilen; ++i2) {
              if (chart.isDatasetVisible(i2)) {
                data = chart.data.datasets[i2].data;
                if (helpers$1.isObject(data[0])) {
                  datasets[i2] = [];
                  for (j = 0, jlen = data.length; j < jlen; ++j) {
                    timestamp = parse2(me2, data[j]);
                    timestamps.push(timestamp);
                    datasets[i2][j] = timestamp;
                  }
                } else {
                  datasets[i2] = labels.slice(0);
                  if (!labelsAdded) {
                    timestamps = timestamps.concat(labels);
                    labelsAdded = true;
                  }
                }
              } else {
                datasets[i2] = [];
              }
            }
            if (labels.length) {
              min2 = Math.min(min2, labels[0]);
              max2 = Math.max(max2, labels[labels.length - 1]);
            }
            if (timestamps.length) {
              timestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);
              min2 = Math.min(min2, timestamps[0]);
              max2 = Math.max(max2, timestamps[timestamps.length - 1]);
            }
            min2 = parse2(me2, getMin(options2)) || min2;
            max2 = parse2(me2, getMax(options2)) || max2;
            min2 = min2 === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min2;
            max2 = max2 === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max2;
            me2.min = Math.min(min2, max2);
            me2.max = Math.max(min2 + 1, max2);
            me2._table = [];
            me2._timestamps = {
              data: timestamps,
              datasets,
              labels
            };
          },
          buildTicks: function() {
            var me2 = this;
            var min2 = me2.min;
            var max2 = me2.max;
            var options2 = me2.options;
            var tickOpts = options2.ticks;
            var timeOpts = options2.time;
            var timestamps = me2._timestamps;
            var ticks = [];
            var capacity = me2.getLabelCapacity(min2);
            var source = tickOpts.source;
            var distribution = options2.distribution;
            var i2, ilen, timestamp;
            if (source === "data" || source === "auto" && distribution === "series") {
              timestamps = timestamps.data;
            } else if (source === "labels") {
              timestamps = timestamps.labels;
            } else {
              timestamps = generate(me2, min2, max2, capacity);
            }
            if (options2.bounds === "ticks" && timestamps.length) {
              min2 = timestamps[0];
              max2 = timestamps[timestamps.length - 1];
            }
            min2 = parse2(me2, getMin(options2)) || min2;
            max2 = parse2(me2, getMax(options2)) || max2;
            for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
              timestamp = timestamps[i2];
              if (timestamp >= min2 && timestamp <= max2) {
                ticks.push(timestamp);
              }
            }
            me2.min = min2;
            me2.max = max2;
            me2._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me2.min, me2.max, capacity) : determineUnitForFormatting(me2, ticks.length, timeOpts.minUnit, me2.min, me2.max));
            me2._majorUnit = !tickOpts.major.enabled || me2._unit === "year" ? void 0 : determineMajorUnit(me2._unit);
            me2._table = buildLookupTable(me2._timestamps.data, min2, max2, distribution);
            me2._offsets = computeOffsets(me2._table, ticks, min2, max2, options2);
            if (tickOpts.reverse) {
              ticks.reverse();
            }
            return ticksFromTimestamps(me2, ticks, me2._majorUnit);
          },
          getLabelForIndex: function(index2, datasetIndex) {
            var me2 = this;
            var adapter = me2._adapter;
            var data = me2.chart.data;
            var timeOpts = me2.options.time;
            var label = data.labels && index2 < data.labels.length ? data.labels[index2] : "";
            var value2 = data.datasets[datasetIndex].data[index2];
            if (helpers$1.isObject(value2)) {
              label = me2.getRightValue(value2);
            }
            if (timeOpts.tooltipFormat) {
              return adapter.format(toTimestamp(me2, label), timeOpts.tooltipFormat);
            }
            if (typeof label === "string") {
              return label;
            }
            return adapter.format(toTimestamp(me2, label), timeOpts.displayFormats.datetime);
          },
          tickFormatFunction: function(time, index2, ticks, format2) {
            var me2 = this;
            var adapter = me2._adapter;
            var options2 = me2.options;
            var formats2 = options2.time.displayFormats;
            var minorFormat = formats2[me2._unit];
            var majorUnit = me2._majorUnit;
            var majorFormat = formats2[majorUnit];
            var tick = ticks[index2];
            var tickOpts = options2.ticks;
            var major = majorUnit && majorFormat && tick && tick.major;
            var label = adapter.format(time, format2 ? format2 : major ? majorFormat : minorFormat);
            var nestedTickOpts = major ? tickOpts.major : tickOpts.minor;
            var formatter = resolve$5([
              nestedTickOpts.callback,
              nestedTickOpts.userCallback,
              tickOpts.callback,
              tickOpts.userCallback
            ]);
            return formatter ? formatter(label, index2, ticks) : label;
          },
          convertTicksToLabels: function(ticks) {
            var labels = [];
            var i2, ilen;
            for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
              labels.push(this.tickFormatFunction(ticks[i2].value, i2, ticks));
            }
            return labels;
          },
          getPixelForOffset: function(time) {
            var me2 = this;
            var offsets = me2._offsets;
            var pos = interpolate$1(me2._table, "time", time, "pos");
            return me2.getPixelForDecimal((offsets.start + pos) * offsets.factor);
          },
          getPixelForValue: function(value2, index2, datasetIndex) {
            var me2 = this;
            var time = null;
            if (index2 !== void 0 && datasetIndex !== void 0) {
              time = me2._timestamps.datasets[datasetIndex][index2];
            }
            if (time === null) {
              time = parse2(me2, value2);
            }
            if (time !== null) {
              return me2.getPixelForOffset(time);
            }
          },
          getPixelForTick: function(index2) {
            var ticks = this.getTicks();
            return index2 >= 0 && index2 < ticks.length ? this.getPixelForOffset(ticks[index2].value) : null;
          },
          getValueForPixel: function(pixel) {
            var me2 = this;
            var offsets = me2._offsets;
            var pos = me2.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            var time = interpolate$1(me2._table, "pos", pos, "time");
            return me2._adapter._create(time);
          },
          _getLabelSize: function(label) {
            var me2 = this;
            var ticksOpts = me2.options.ticks;
            var tickLabelWidth = me2.ctx.measureText(label).width;
            var angle = helpers$1.toRadians(me2.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
            var cosRotation = Math.cos(angle);
            var sinRotation = Math.sin(angle);
            var tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
            return {
              w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
              h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
            };
          },
          getLabelWidth: function(label) {
            return this._getLabelSize(label).w;
          },
          getLabelCapacity: function(exampleTime) {
            var me2 = this;
            var timeOpts = me2.options.time;
            var displayFormats = timeOpts.displayFormats;
            var format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
            var exampleLabel = me2.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me2, [exampleTime], me2._majorUnit), format2);
            var size2 = me2._getLabelSize(exampleLabel);
            var capacity = Math.floor(me2.isHorizontal() ? me2.width / size2.w : me2.height / size2.h);
            if (me2.options.offset) {
              capacity--;
            }
            return capacity > 0 ? capacity : 1;
          }
        });
        var _defaults$4 = defaultConfig$4;
        scale_time._defaults = _defaults$4;
        var scales = {
          category: scale_category,
          linear: scale_linear,
          logarithmic: scale_logarithmic,
          radialLinear: scale_radialLinear,
          time: scale_time
        };
        var FORMATS2 = {
          datetime: "MMM D, YYYY, h:mm:ss a",
          millisecond: "h:mm:ss.SSS a",
          second: "h:mm:ss a",
          minute: "h:mm a",
          hour: "hA",
          day: "MMM D",
          week: "ll",
          month: "MMM YYYY",
          quarter: "[Q]Q - YYYY",
          year: "YYYY"
        };
        core_adapters._date.override(typeof moment2 === "function" ? {
          _id: "moment",
          formats: function() {
            return FORMATS2;
          },
          parse: function(value2, format2) {
            if (typeof value2 === "string" && typeof format2 === "string") {
              value2 = moment2(value2, format2);
            } else if (!(value2 instanceof moment2)) {
              value2 = moment2(value2);
            }
            return value2.isValid() ? value2.valueOf() : null;
          },
          format: function(time, format2) {
            return moment2(time).format(format2);
          },
          add: function(time, amount, unit) {
            return moment2(time).add(amount, unit).valueOf();
          },
          diff: function(max2, min2, unit) {
            return moment2(max2).diff(moment2(min2), unit);
          },
          startOf: function(time, unit, weekday) {
            time = moment2(time);
            if (unit === "isoWeek") {
              return time.isoWeekday(weekday).valueOf();
            }
            return time.startOf(unit).valueOf();
          },
          endOf: function(time, unit) {
            return moment2(time).endOf(unit).valueOf();
          },
          _create: function(time) {
            return moment2(time);
          }
        } : {});
        core_defaults._set("global", {
          plugins: {
            filler: {
              propagate: true
            }
          }
        });
        var mappers = {
          dataset: function(source) {
            var index2 = source.fill;
            var chart = source.chart;
            var meta = chart.getDatasetMeta(index2);
            var visible = meta && chart.isDatasetVisible(index2);
            var points = visible && meta.dataset._children || [];
            var length = points.length || 0;
            return !length ? null : function(point, i2) {
              return i2 < length && points[i2]._view || null;
            };
          },
          boundary: function(source) {
            var boundary = source.boundary;
            var x2 = boundary ? boundary.x : null;
            var y2 = boundary ? boundary.y : null;
            if (helpers$1.isArray(boundary)) {
              return function(point, i2) {
                return boundary[i2];
              };
            }
            return function(point) {
              return {
                x: x2 === null ? point.x : x2,
                y: y2 === null ? point.y : y2
              };
            };
          }
        };
        function decodeFill(el, index2, count) {
          var model = el._model || {};
          var fill = model.fill;
          var target;
          if (fill === void 0) {
            fill = !!model.backgroundColor;
          }
          if (fill === false || fill === null) {
            return false;
          }
          if (fill === true) {
            return "origin";
          }
          target = parseFloat(fill, 10);
          if (isFinite(target) && Math.floor(target) === target) {
            if (fill[0] === "-" || fill[0] === "+") {
              target = index2 + target;
            }
            if (target === index2 || target < 0 || target >= count) {
              return false;
            }
            return target;
          }
          switch (fill) {
            case "bottom":
              return "start";
            case "top":
              return "end";
            case "zero":
              return "origin";
            case "origin":
            case "start":
            case "end":
              return fill;
            default:
              return false;
          }
        }
        function computeLinearBoundary(source) {
          var model = source.el._model || {};
          var scale2 = source.el._scale || {};
          var fill = source.fill;
          var target = null;
          var horizontal;
          if (isFinite(fill)) {
            return null;
          }
          if (fill === "start") {
            target = model.scaleBottom === void 0 ? scale2.bottom : model.scaleBottom;
          } else if (fill === "end") {
            target = model.scaleTop === void 0 ? scale2.top : model.scaleTop;
          } else if (model.scaleZero !== void 0) {
            target = model.scaleZero;
          } else if (scale2.getBasePixel) {
            target = scale2.getBasePixel();
          }
          if (target !== void 0 && target !== null) {
            if (target.x !== void 0 && target.y !== void 0) {
              return target;
            }
            if (helpers$1.isFinite(target)) {
              horizontal = scale2.isHorizontal();
              return {
                x: horizontal ? target : null,
                y: horizontal ? null : target
              };
            }
          }
          return null;
        }
        function computeCircularBoundary(source) {
          var scale2 = source.el._scale;
          var options2 = scale2.options;
          var length = scale2.chart.data.labels.length;
          var fill = source.fill;
          var target = [];
          var start, end, center, i2, point;
          if (!length) {
            return null;
          }
          start = options2.ticks.reverse ? scale2.max : scale2.min;
          end = options2.ticks.reverse ? scale2.min : scale2.max;
          center = scale2.getPointPositionForValue(0, start);
          for (i2 = 0; i2 < length; ++i2) {
            point = fill === "start" || fill === "end" ? scale2.getPointPositionForValue(i2, fill === "start" ? start : end) : scale2.getBasePosition(i2);
            if (options2.gridLines.circular) {
              point.cx = center.x;
              point.cy = center.y;
              point.angle = scale2.getIndexAngle(i2) - Math.PI / 2;
            }
            target.push(point);
          }
          return target;
        }
        function computeBoundary(source) {
          var scale2 = source.el._scale || {};
          if (scale2.getPointPositionForValue) {
            return computeCircularBoundary(source);
          }
          return computeLinearBoundary(source);
        }
        function resolveTarget(sources, index2, propagate) {
          var source = sources[index2];
          var fill = source.fill;
          var visited = [index2];
          var target;
          if (!propagate) {
            return fill;
          }
          while (fill !== false && visited.indexOf(fill) === -1) {
            if (!isFinite(fill)) {
              return fill;
            }
            target = sources[fill];
            if (!target) {
              return false;
            }
            if (target.visible) {
              return fill;
            }
            visited.push(fill);
            fill = target.fill;
          }
          return false;
        }
        function createMapper(source) {
          var fill = source.fill;
          var type = "dataset";
          if (fill === false) {
            return null;
          }
          if (!isFinite(fill)) {
            type = "boundary";
          }
          return mappers[type](source);
        }
        function isDrawable(point) {
          return point && !point.skip;
        }
        function drawArea(ctx, curve0, curve1, len0, len1) {
          var i2, cx, cy, r2;
          if (!len0 || !len1) {
            return;
          }
          ctx.moveTo(curve0[0].x, curve0[0].y);
          for (i2 = 1; i2 < len0; ++i2) {
            helpers$1.canvas.lineTo(ctx, curve0[i2 - 1], curve0[i2]);
          }
          if (curve1[0].angle !== void 0) {
            cx = curve1[0].cx;
            cy = curve1[0].cy;
            r2 = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));
            for (i2 = len1 - 1; i2 > 0; --i2) {
              ctx.arc(cx, cy, r2, curve1[i2].angle, curve1[i2 - 1].angle, true);
            }
            return;
          }
          ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
          for (i2 = len1 - 1; i2 > 0; --i2) {
            helpers$1.canvas.lineTo(ctx, curve1[i2], curve1[i2 - 1], true);
          }
        }
        function doFill(ctx, points, mapper, view, color, loop) {
          var count = points.length;
          var span = view.spanGaps;
          var curve0 = [];
          var curve1 = [];
          var len0 = 0;
          var len1 = 0;
          var i2, ilen, index2, p0, p1, d0, d1, loopOffset;
          ctx.beginPath();
          for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
            index2 = i2 % count;
            p0 = points[index2]._view;
            p1 = mapper(p0, index2, view);
            d0 = isDrawable(p0);
            d1 = isDrawable(p1);
            if (loop && loopOffset === void 0 && d0) {
              loopOffset = i2 + 1;
              ilen = count + loopOffset;
            }
            if (d0 && d1) {
              len0 = curve0.push(p0);
              len1 = curve1.push(p1);
            } else if (len0 && len1) {
              if (!span) {
                drawArea(ctx, curve0, curve1, len0, len1);
                len0 = len1 = 0;
                curve0 = [];
                curve1 = [];
              } else {
                if (d0) {
                  curve0.push(p0);
                }
                if (d1) {
                  curve1.push(p1);
                }
              }
            }
          }
          drawArea(ctx, curve0, curve1, len0, len1);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
        }
        var plugin_filler = {
          id: "filler",
          afterDatasetsUpdate: function(chart, options2) {
            var count = (chart.data.datasets || []).length;
            var propagate = options2.propagate;
            var sources = [];
            var meta, i2, el, source;
            for (i2 = 0; i2 < count; ++i2) {
              meta = chart.getDatasetMeta(i2);
              el = meta.dataset;
              source = null;
              if (el && el._model && el instanceof elements.Line) {
                source = {
                  visible: chart.isDatasetVisible(i2),
                  fill: decodeFill(el, i2, count),
                  chart,
                  el
                };
              }
              meta.$filler = source;
              sources.push(source);
            }
            for (i2 = 0; i2 < count; ++i2) {
              source = sources[i2];
              if (!source) {
                continue;
              }
              source.fill = resolveTarget(sources, i2, propagate);
              source.boundary = computeBoundary(source);
              source.mapper = createMapper(source);
            }
          },
          beforeDatasetsDraw: function(chart) {
            var metasets = chart._getSortedVisibleDatasetMetas();
            var ctx = chart.ctx;
            var meta, i2, el, view, points, mapper, color;
            for (i2 = metasets.length - 1; i2 >= 0; --i2) {
              meta = metasets[i2].$filler;
              if (!meta || !meta.visible) {
                continue;
              }
              el = meta.el;
              view = el._view;
              points = el._children || [];
              mapper = meta.mapper;
              color = view.backgroundColor || core_defaults.global.defaultColor;
              if (mapper && color && points.length) {
                helpers$1.canvas.clipArea(ctx, chart.chartArea);
                doFill(ctx, points, mapper, view, color, el._loop);
                helpers$1.canvas.unclipArea(ctx);
              }
            }
          }
        };
        var getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;
        var noop$12 = helpers$1.noop;
        var valueOrDefault$e = helpers$1.valueOrDefault;
        core_defaults._set("global", {
          legend: {
            display: true,
            position: "top",
            align: "center",
            fullWidth: true,
            reverse: false,
            weight: 1e3,
            onClick: function(e, legendItem) {
              var index2 = legendItem.datasetIndex;
              var ci2 = this.chart;
              var meta = ci2.getDatasetMeta(index2);
              meta.hidden = meta.hidden === null ? !ci2.data.datasets[index2].hidden : null;
              ci2.update();
            },
            onHover: null,
            onLeave: null,
            labels: {
              boxWidth: 40,
              padding: 10,
              generateLabels: function(chart) {
                var datasets = chart.data.datasets;
                var options2 = chart.options.legend || {};
                var usePointStyle = options2.labels && options2.labels.usePointStyle;
                return chart._getSortedDatasetMetas().map(function(meta) {
                  var style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                  return {
                    text: datasets[meta.index].label,
                    fillStyle: style.backgroundColor,
                    hidden: !chart.isDatasetVisible(meta.index),
                    lineCap: style.borderCapStyle,
                    lineDash: style.borderDash,
                    lineDashOffset: style.borderDashOffset,
                    lineJoin: style.borderJoinStyle,
                    lineWidth: style.borderWidth,
                    strokeStyle: style.borderColor,
                    pointStyle: style.pointStyle,
                    rotation: style.rotation,
                    datasetIndex: meta.index
                  };
                }, this);
              }
            }
          },
          legendCallback: function(chart) {
            var list = document.createElement("ul");
            var datasets = chart.data.datasets;
            var i2, ilen, listItem, listItemSpan;
            list.setAttribute("class", chart.id + "-legend");
            for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
              listItem = list.appendChild(document.createElement("li"));
              listItemSpan = listItem.appendChild(document.createElement("span"));
              listItemSpan.style.backgroundColor = datasets[i2].backgroundColor;
              if (datasets[i2].label) {
                listItem.appendChild(document.createTextNode(datasets[i2].label));
              }
            }
            return list.outerHTML;
          }
        });
        function getBoxWidth(labelOpts, fontSize) {
          return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
        }
        var Legend = core_element.extend({
          initialize: function(config) {
            var me2 = this;
            helpers$1.extend(me2, config);
            me2.legendHitBoxes = [];
            me2._hoveredItem = null;
            me2.doughnutMode = false;
          },
          beforeUpdate: noop$12,
          update: function(maxWidth, maxHeight, margins) {
            var me2 = this;
            me2.beforeUpdate();
            me2.maxWidth = maxWidth;
            me2.maxHeight = maxHeight;
            me2.margins = margins;
            me2.beforeSetDimensions();
            me2.setDimensions();
            me2.afterSetDimensions();
            me2.beforeBuildLabels();
            me2.buildLabels();
            me2.afterBuildLabels();
            me2.beforeFit();
            me2.fit();
            me2.afterFit();
            me2.afterUpdate();
            return me2.minSize;
          },
          afterUpdate: noop$12,
          beforeSetDimensions: noop$12,
          setDimensions: function() {
            var me2 = this;
            if (me2.isHorizontal()) {
              me2.width = me2.maxWidth;
              me2.left = 0;
              me2.right = me2.width;
            } else {
              me2.height = me2.maxHeight;
              me2.top = 0;
              me2.bottom = me2.height;
            }
            me2.paddingLeft = 0;
            me2.paddingTop = 0;
            me2.paddingRight = 0;
            me2.paddingBottom = 0;
            me2.minSize = {
              width: 0,
              height: 0
            };
          },
          afterSetDimensions: noop$12,
          beforeBuildLabels: noop$12,
          buildLabels: function() {
            var me2 = this;
            var labelOpts = me2.options.labels || {};
            var legendItems = helpers$1.callback(labelOpts.generateLabels, [me2.chart], me2) || [];
            if (labelOpts.filter) {
              legendItems = legendItems.filter(function(item) {
                return labelOpts.filter(item, me2.chart.data);
              });
            }
            if (me2.options.reverse) {
              legendItems.reverse();
            }
            me2.legendItems = legendItems;
          },
          afterBuildLabels: noop$12,
          beforeFit: noop$12,
          fit: function() {
            var me2 = this;
            var opts = me2.options;
            var labelOpts = opts.labels;
            var display = opts.display;
            var ctx = me2.ctx;
            var labelFont = helpers$1.options._parseFont(labelOpts);
            var fontSize = labelFont.size;
            var hitboxes = me2.legendHitBoxes = [];
            var minSize = me2.minSize;
            var isHorizontal = me2.isHorizontal();
            if (isHorizontal) {
              minSize.width = me2.maxWidth;
              minSize.height = display ? 10 : 0;
            } else {
              minSize.width = display ? 10 : 0;
              minSize.height = me2.maxHeight;
            }
            if (!display) {
              me2.width = minSize.width = me2.height = minSize.height = 0;
              return;
            }
            ctx.font = labelFont.string;
            if (isHorizontal) {
              var lineWidths = me2.lineWidths = [0];
              var totalHeight = 0;
              ctx.textAlign = "left";
              ctx.textBaseline = "middle";
              helpers$1.each(me2.legendItems, function(legendItem, i2) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var width2 = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                if (i2 === 0 || lineWidths[lineWidths.length - 1] + width2 + 2 * labelOpts.padding > minSize.width) {
                  totalHeight += fontSize + labelOpts.padding;
                  lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
                }
                hitboxes[i2] = {
                  left: 0,
                  top: 0,
                  width: width2,
                  height: fontSize
                };
                lineWidths[lineWidths.length - 1] += width2 + labelOpts.padding;
              });
              minSize.height += totalHeight;
            } else {
              var vPadding = labelOpts.padding;
              var columnWidths = me2.columnWidths = [];
              var columnHeights = me2.columnHeights = [];
              var totalWidth = labelOpts.padding;
              var currentColWidth = 0;
              var currentColHeight = 0;
              helpers$1.each(me2.legendItems, function(legendItem, i2) {
                var boxWidth = getBoxWidth(labelOpts, fontSize);
                var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                if (i2 > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {
                  totalWidth += currentColWidth + labelOpts.padding;
                  columnWidths.push(currentColWidth);
                  columnHeights.push(currentColHeight);
                  currentColWidth = 0;
                  currentColHeight = 0;
                }
                currentColWidth = Math.max(currentColWidth, itemWidth);
                currentColHeight += fontSize + vPadding;
                hitboxes[i2] = {
                  left: 0,
                  top: 0,
                  width: itemWidth,
                  height: fontSize
                };
              });
              totalWidth += currentColWidth;
              columnWidths.push(currentColWidth);
              columnHeights.push(currentColHeight);
              minSize.width += totalWidth;
            }
            me2.width = minSize.width;
            me2.height = minSize.height;
          },
          afterFit: noop$12,
          isHorizontal: function() {
            return this.options.position === "top" || this.options.position === "bottom";
          },
          draw: function() {
            var me2 = this;
            var opts = me2.options;
            var labelOpts = opts.labels;
            var globalDefaults = core_defaults.global;
            var defaultColor2 = globalDefaults.defaultColor;
            var lineDefault = globalDefaults.elements.line;
            var legendHeight = me2.height;
            var columnHeights = me2.columnHeights;
            var legendWidth = me2.width;
            var lineWidths = me2.lineWidths;
            if (!opts.display) {
              return;
            }
            var rtlHelper = getRtlHelper$1(opts.rtl, me2.left, me2.minSize.width);
            var ctx = me2.ctx;
            var fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);
            var labelFont = helpers$1.options._parseFont(labelOpts);
            var fontSize = labelFont.size;
            var cursor;
            ctx.textAlign = rtlHelper.textAlign("left");
            ctx.textBaseline = "middle";
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = fontColor;
            ctx.fillStyle = fontColor;
            ctx.font = labelFont.string;
            var boxWidth = getBoxWidth(labelOpts, fontSize);
            var hitboxes = me2.legendHitBoxes;
            var drawLegendBox = function(x2, y2, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0) {
                return;
              }
              ctx.save();
              var lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);
              ctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor2);
              ctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);
              ctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);
              ctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor2);
              if (ctx.setLineDash) {
                ctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));
              }
              if (labelOpts && labelOpts.usePointStyle) {
                var radius = boxWidth * Math.SQRT2 / 2;
                var centerX = rtlHelper.xPlus(x2, boxWidth / 2);
                var centerY = y2 + fontSize / 2;
                helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);
              } else {
                ctx.fillRect(rtlHelper.leftForLtr(x2, boxWidth), y2, boxWidth, fontSize);
                if (lineWidth !== 0) {
                  ctx.strokeRect(rtlHelper.leftForLtr(x2, boxWidth), y2, boxWidth, fontSize);
                }
              }
              ctx.restore();
            };
            var fillText2 = function(x2, y2, legendItem, textWidth) {
              var halfFontSize = fontSize / 2;
              var xLeft = rtlHelper.xPlus(x2, boxWidth + halfFontSize);
              var yMiddle = y2 + halfFontSize;
              ctx.fillText(legendItem.text, xLeft, yMiddle);
              if (legendItem.hidden) {
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(xLeft, yMiddle);
                ctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);
                ctx.stroke();
              }
            };
            var alignmentOffset = function(dimension, blockSize) {
              switch (opts.align) {
                case "start":
                  return labelOpts.padding;
                case "end":
                  return dimension - blockSize;
                default:
                  return (dimension - blockSize + labelOpts.padding) / 2;
              }
            };
            var isHorizontal = me2.isHorizontal();
            if (isHorizontal) {
              cursor = {
                x: me2.left + alignmentOffset(legendWidth, lineWidths[0]),
                y: me2.top + labelOpts.padding,
                line: 0
              };
            } else {
              cursor = {
                x: me2.left + labelOpts.padding,
                y: me2.top + alignmentOffset(legendHeight, columnHeights[0]),
                line: 0
              };
            }
            helpers$1.rtl.overrideTextDirection(me2.ctx, opts.textDirection);
            var itemHeight = fontSize + labelOpts.padding;
            helpers$1.each(me2.legendItems, function(legendItem, i2) {
              var textWidth = ctx.measureText(legendItem.text).width;
              var width2 = boxWidth + fontSize / 2 + textWidth;
              var x2 = cursor.x;
              var y2 = cursor.y;
              rtlHelper.setWidth(me2.minSize.width);
              if (isHorizontal) {
                if (i2 > 0 && x2 + width2 + labelOpts.padding > me2.left + me2.minSize.width) {
                  y2 = cursor.y += itemHeight;
                  cursor.line++;
                  x2 = cursor.x = me2.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);
                }
              } else if (i2 > 0 && y2 + itemHeight > me2.top + me2.minSize.height) {
                x2 = cursor.x = x2 + me2.columnWidths[cursor.line] + labelOpts.padding;
                cursor.line++;
                y2 = cursor.y = me2.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);
              }
              var realX = rtlHelper.x(x2);
              drawLegendBox(realX, y2, legendItem);
              hitboxes[i2].left = rtlHelper.leftForLtr(realX, hitboxes[i2].width);
              hitboxes[i2].top = y2;
              fillText2(realX, y2, legendItem, textWidth);
              if (isHorizontal) {
                cursor.x += width2 + labelOpts.padding;
              } else {
                cursor.y += itemHeight;
              }
            });
            helpers$1.rtl.restoreTextDirection(me2.ctx, opts.textDirection);
          },
          _getLegendItemAt: function(x2, y2) {
            var me2 = this;
            var i2, hitBox, lh2;
            if (x2 >= me2.left && x2 <= me2.right && y2 >= me2.top && y2 <= me2.bottom) {
              lh2 = me2.legendHitBoxes;
              for (i2 = 0; i2 < lh2.length; ++i2) {
                hitBox = lh2[i2];
                if (x2 >= hitBox.left && x2 <= hitBox.left + hitBox.width && y2 >= hitBox.top && y2 <= hitBox.top + hitBox.height) {
                  return me2.legendItems[i2];
                }
              }
            }
            return null;
          },
          handleEvent: function(e) {
            var me2 = this;
            var opts = me2.options;
            var type = e.type === "mouseup" ? "click" : e.type;
            var hoveredItem;
            if (type === "mousemove") {
              if (!opts.onHover && !opts.onLeave) {
                return;
              }
            } else if (type === "click") {
              if (!opts.onClick) {
                return;
              }
            } else {
              return;
            }
            hoveredItem = me2._getLegendItemAt(e.x, e.y);
            if (type === "click") {
              if (hoveredItem && opts.onClick) {
                opts.onClick.call(me2, e.native, hoveredItem);
              }
            } else {
              if (opts.onLeave && hoveredItem !== me2._hoveredItem) {
                if (me2._hoveredItem) {
                  opts.onLeave.call(me2, e.native, me2._hoveredItem);
                }
                me2._hoveredItem = hoveredItem;
              }
              if (opts.onHover && hoveredItem) {
                opts.onHover.call(me2, e.native, hoveredItem);
              }
            }
          }
        });
        function createNewLegendAndAttach(chart, legendOpts) {
          var legend2 = new Legend({
            ctx: chart.ctx,
            options: legendOpts,
            chart
          });
          core_layouts.configure(chart, legend2, legendOpts);
          core_layouts.addBox(chart, legend2);
          chart.legend = legend2;
        }
        var plugin_legend = {
          id: "legend",
          _element: Legend,
          beforeInit: function(chart) {
            var legendOpts = chart.options.legend;
            if (legendOpts) {
              createNewLegendAndAttach(chart, legendOpts);
            }
          },
          beforeUpdate: function(chart) {
            var legendOpts = chart.options.legend;
            var legend2 = chart.legend;
            if (legendOpts) {
              helpers$1.mergeIf(legendOpts, core_defaults.global.legend);
              if (legend2) {
                core_layouts.configure(chart, legend2, legendOpts);
                legend2.options = legendOpts;
              } else {
                createNewLegendAndAttach(chart, legendOpts);
              }
            } else if (legend2) {
              core_layouts.removeBox(chart, legend2);
              delete chart.legend;
            }
          },
          afterEvent: function(chart, e) {
            var legend2 = chart.legend;
            if (legend2) {
              legend2.handleEvent(e);
            }
          }
        };
        var noop$2 = helpers$1.noop;
        core_defaults._set("global", {
          title: {
            display: false,
            fontStyle: "bold",
            fullWidth: true,
            padding: 10,
            position: "top",
            text: "",
            weight: 2e3
          }
        });
        var Title = core_element.extend({
          initialize: function(config) {
            var me2 = this;
            helpers$1.extend(me2, config);
            me2.legendHitBoxes = [];
          },
          beforeUpdate: noop$2,
          update: function(maxWidth, maxHeight, margins) {
            var me2 = this;
            me2.beforeUpdate();
            me2.maxWidth = maxWidth;
            me2.maxHeight = maxHeight;
            me2.margins = margins;
            me2.beforeSetDimensions();
            me2.setDimensions();
            me2.afterSetDimensions();
            me2.beforeBuildLabels();
            me2.buildLabels();
            me2.afterBuildLabels();
            me2.beforeFit();
            me2.fit();
            me2.afterFit();
            me2.afterUpdate();
            return me2.minSize;
          },
          afterUpdate: noop$2,
          beforeSetDimensions: noop$2,
          setDimensions: function() {
            var me2 = this;
            if (me2.isHorizontal()) {
              me2.width = me2.maxWidth;
              me2.left = 0;
              me2.right = me2.width;
            } else {
              me2.height = me2.maxHeight;
              me2.top = 0;
              me2.bottom = me2.height;
            }
            me2.paddingLeft = 0;
            me2.paddingTop = 0;
            me2.paddingRight = 0;
            me2.paddingBottom = 0;
            me2.minSize = {
              width: 0,
              height: 0
            };
          },
          afterSetDimensions: noop$2,
          beforeBuildLabels: noop$2,
          buildLabels: noop$2,
          afterBuildLabels: noop$2,
          beforeFit: noop$2,
          fit: function() {
            var me2 = this;
            var opts = me2.options;
            var minSize = me2.minSize = {};
            var isHorizontal = me2.isHorizontal();
            var lineCount, textSize;
            if (!opts.display) {
              me2.width = minSize.width = me2.height = minSize.height = 0;
              return;
            }
            lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;
            textSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + opts.padding * 2;
            me2.width = minSize.width = isHorizontal ? me2.maxWidth : textSize;
            me2.height = minSize.height = isHorizontal ? textSize : me2.maxHeight;
          },
          afterFit: noop$2,
          isHorizontal: function() {
            var pos = this.options.position;
            return pos === "top" || pos === "bottom";
          },
          draw: function() {
            var me2 = this;
            var ctx = me2.ctx;
            var opts = me2.options;
            if (!opts.display) {
              return;
            }
            var fontOpts = helpers$1.options._parseFont(opts);
            var lineHeight = fontOpts.lineHeight;
            var offset2 = lineHeight / 2 + opts.padding;
            var rotation = 0;
            var top = me2.top;
            var left = me2.left;
            var bottom = me2.bottom;
            var right = me2.right;
            var maxWidth, titleX, titleY;
            ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor);
            ctx.font = fontOpts.string;
            if (me2.isHorizontal()) {
              titleX = left + (right - left) / 2;
              titleY = top + offset2;
              maxWidth = right - left;
            } else {
              titleX = opts.position === "left" ? left + offset2 : right - offset2;
              titleY = top + (bottom - top) / 2;
              maxWidth = bottom - top;
              rotation = Math.PI * (opts.position === "left" ? -0.5 : 0.5);
            }
            ctx.save();
            ctx.translate(titleX, titleY);
            ctx.rotate(rotation);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            var text = opts.text;
            if (helpers$1.isArray(text)) {
              var y2 = 0;
              for (var i2 = 0; i2 < text.length; ++i2) {
                ctx.fillText(text[i2], 0, y2, maxWidth);
                y2 += lineHeight;
              }
            } else {
              ctx.fillText(text, 0, 0, maxWidth);
            }
            ctx.restore();
          }
        });
        function createNewTitleBlockAndAttach(chart, titleOpts) {
          var title2 = new Title({
            ctx: chart.ctx,
            options: titleOpts,
            chart
          });
          core_layouts.configure(chart, title2, titleOpts);
          core_layouts.addBox(chart, title2);
          chart.titleBlock = title2;
        }
        var plugin_title = {
          id: "title",
          _element: Title,
          beforeInit: function(chart) {
            var titleOpts = chart.options.title;
            if (titleOpts) {
              createNewTitleBlockAndAttach(chart, titleOpts);
            }
          },
          beforeUpdate: function(chart) {
            var titleOpts = chart.options.title;
            var titleBlock = chart.titleBlock;
            if (titleOpts) {
              helpers$1.mergeIf(titleOpts, core_defaults.global.title);
              if (titleBlock) {
                core_layouts.configure(chart, titleBlock, titleOpts);
                titleBlock.options = titleOpts;
              } else {
                createNewTitleBlockAndAttach(chart, titleOpts);
              }
            } else if (titleBlock) {
              core_layouts.removeBox(chart, titleBlock);
              delete chart.titleBlock;
            }
          }
        };
        var plugins = {};
        var filler = plugin_filler;
        var legend = plugin_legend;
        var title = plugin_title;
        plugins.filler = filler;
        plugins.legend = legend;
        plugins.title = title;
        core_controller.helpers = helpers$1;
        core_helpers();
        core_controller._adapters = core_adapters;
        core_controller.Animation = core_animation;
        core_controller.animationService = core_animations;
        core_controller.controllers = controllers;
        core_controller.DatasetController = core_datasetController;
        core_controller.defaults = core_defaults;
        core_controller.Element = core_element;
        core_controller.elements = elements;
        core_controller.Interaction = core_interaction;
        core_controller.layouts = core_layouts;
        core_controller.platform = platform2;
        core_controller.plugins = core_plugins;
        core_controller.Scale = core_scale;
        core_controller.scaleService = core_scaleService;
        core_controller.Ticks = core_ticks;
        core_controller.Tooltip = core_tooltip;
        core_controller.helpers.each(scales, function(scale2, type) {
          core_controller.scaleService.registerScaleType(type, scale2, scale2._defaults);
        });
        for (var k in plugins) {
          if (plugins.hasOwnProperty(k)) {
            core_controller.plugins.register(plugins[k]);
          }
        }
        core_controller.platform.initialize();
        var src2 = core_controller;
        if (typeof window !== "undefined") {
          window.Chart = core_controller;
        }
        core_controller.Chart = core_controller;
        core_controller.Legend = plugins.legend._element;
        core_controller.Title = plugins.title._element;
        core_controller.pluginService = core_controller.plugins;
        core_controller.PluginBase = core_controller.Element.extend({});
        core_controller.canvasHelpers = core_controller.helpers.canvas;
        core_controller.layoutService = core_controller.layouts;
        core_controller.LinearScaleBase = scale_linearbase;
        core_controller.helpers.each(
          [
            "Bar",
            "Bubble",
            "Doughnut",
            "Line",
            "PolarArea",
            "Radar",
            "Scatter"
          ],
          function(klass) {
            core_controller[klass] = function(ctx, cfg) {
              return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
                type: klass.charAt(0).toLowerCase() + klass.slice(1)
              }));
            };
          }
        );
        return src2;
      });
    })(Chart);
    let WaveMenu$1 = class WaveMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        this.state = {
          counter: this.props.from,
          interval: this.props.interval ?? 1e3
        };
        this.interval;
      }
      componentDidMount() {
        this.interval = setInterval(() => {
          const { counter } = this.state;
          if (counter === 0) {
            this.props.whenDone();
            clearInterval(this.interval);
            return;
          }
          this.setState({ counter: counter - 1 });
        }, this.state.interval);
      }
      componentWillUnmount() {
        clearInterval(this.interval);
      }
      render() {
        return this.smoothly(
          /* @__PURE__ */ jsx("div", { children: this.state.counter })
        );
      }
    };
    const calculateAccuracy = (wave) => {
      return (1 - wave.shotsMissed / wave.shotsFired) * 100;
    };
    const calculateWpm = (wave) => {
      let shotsHit = wave.shotsFired - wave.shotsMissed;
      let waveTime = (wave.waveEnd - wave.waveStart) / 1e3 / 60;
      return shotsHit / 5 / waveTime;
    };
    class WaveMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        __publicField(this, "handleNextWave", () => {
          events.emit("nextWave");
        });
        this.chart = React.createRef();
        this.graph;
      }
      componentDidMount() {
        let waves = this.props.waveData;
        this.graph = new Chart.exports.Chart(this.chart.current, {
          type: "line",
          data: {
            labels: waves.map((_2, idx) => idx + 1),
            datasets: [
              {
                data: waves.map((wave) => calculateAccuracy(wave)),
                label: "Accuracy",
                borderColor: "#3e95cd",
                fill: false
              },
              {
                data: waves.map((wave) => calculateWpm(wave)),
                label: "Wpm",
                borderColor: "#78ebcc",
                fill: false
              }
            ]
          },
          options: {
            legend: {
              display: false
            },
            scales: {
              xAxes: [{
                display: false,
                gridLines: {
                  color: "rgba(0, 0, 0, 0)"
                }
              }],
              yAxes: [{
                display: false,
                gridLines: {
                  color: "rgba(0, 0, 0, 0)"
                }
              }]
            },
            layout: {
              padding: {
                left: 10,
                right: 10,
                top: 10,
                bottom: 10
              }
            }
          }
        });
      }
      render() {
        const { waveData, score } = this.props;
        const finishedWave = waveData.length;
        const wave = _.last(waveData);
        const accuracy = calculateAccuracy(wave).toFixed(2);
        const wpm = calculateWpm(wave).toFixed(2);
        const abbreviatedScore = abbreviateNumber(score);
        return this.smoothly(
          /* @__PURE__ */ jsxs("div", { className: "hud", children: [
            /* @__PURE__ */ jsxs("div", { className: "wave", children: [
              /* @__PURE__ */ jsxs("div", { className: "waveNumber", children: [
                "wave",
                /* @__PURE__ */ jsx("br", {}),
                finishedWave
              ] }),
              /* @__PURE__ */ jsx("div", { className: "score", children: abbreviatedScore })
            ] }),
            /* @__PURE__ */ jsxs("div", { className: "waveStats", children: [
              /* @__PURE__ */ jsxs("div", { className: "stat", children: [
                /* @__PURE__ */ jsx("div", { className: "marker accuracy" }),
                /* @__PURE__ */ jsx("span", { className: "faded", children: "accuracy" }),
                "",
                accuracy,
                "%"
              ] }),
              /* @__PURE__ */ jsxs("div", { className: "stat", children: [
                /* @__PURE__ */ jsx("div", { className: "marker wpm" }),
                /* @__PURE__ */ jsx("span", { className: "faded", children: "wpm " }),
                "",
                wpm
              ] })
            ] }),
            /* @__PURE__ */ jsx("div", { className: "chartContainer", children: /* @__PURE__ */ jsx("canvas", { width: "300", height: "150", ref: this.chart }) }),
            /* @__PURE__ */ jsxs("div", { className: "timer", children: [
              /* @__PURE__ */ jsx("header", { children: "next wave in" }),
              /* @__PURE__ */ jsx(WaveMenu$1, { from: 5, whenDone: this.handleNextWave })
            ] })
          ] })
        );
      }
    }
    class GameOverMenu extends AnimatedComponent {
      constructor(props) {
        super(props);
        __publicField(this, "restartGame", () => {
          events.emit("restartGame");
        });
      }
      render() {
        return this.smoothly(
          /* @__PURE__ */ jsxs("div", { className: "gameOverMenu menu", children: [
            /* @__PURE__ */ jsx("h1", { className: "gameOverHeader header", children: "Game Over" }),
            /* @__PURE__ */ jsx(Button, { danger: true, hint: "ret", text: "Back to Menu", onClick: this.restartGame })
          ] })
        );
      }
    }
    class App extends react.exports.Component {
      constructor(props) {
        super(props);
        __publicField(this, "_handleKeyDown", (e) => {
          if (!this.state.started) {
            return;
          }
          switch (e.key) {
            case "Escape":
              this.handlePause();
              break;
          }
        });
        __publicField(this, "handlePause", () => {
          if (this.state.intermission) {
            return;
          }
          this.toggleMenu();
          this.setState((old) => {
            this.game.pause(!old.paused);
            return {
              paused: !old.paused
            };
          });
        });
        __publicField(this, "toggleMenu", () => {
          this.setState((old) => {
            return {
              inMenu: !old.inMenu
            };
          });
        });
        __publicField(this, "nextWave", () => {
          this.setState((old) => {
            return {
              wave: old.wave + 1,
              intermission: false
            };
          });
          this.game.nextWave(this.state.wave);
          this.handlePause();
        });
        this.game = Game$1;
        this.state = {
          inMenu: true,
          paused: false,
          started: false,
          inSettings: false,
          inLeaderboard: false,
          intermission: false,
          gameOver: false,
          playerName: storage.get("playerName") || "0x20F",
          wave: 1
        };
        this.score = 0;
        this.waveData = [];
      }
      componentDidMount() {
        document.addEventListener("keydown", this._handleKeyDown, false);
        events.on("shotFired", (missed) => {
          if (this.score >= 10 && missed) {
            this.score -= 10;
          } else {
            this.score += 1;
          }
        });
        events.on("enemyDeath", () => {
          this.score += 100;
        });
        events.on("nextWave", this.nextWave);
        events.on("waveEnd", (data) => {
          this.waveData.push(data);
          this.handlePause();
          this.setState({
            intermission: true
          });
        });
        events.on("settingsOpened", () => this.setState({ inSettings: true }));
        events.on("settingsSaved", (playerName) => {
          this.setState({
            playerName,
            inSettings: false
          });
          storage.set("playerName", playerName);
        });
        events.on("leaderboardOpened", () => this.setState({ inLeaderboard: true }));
        events.on("leaderboardClosed", () => this.setState({ inLeaderboard: false }));
        events.on("gameStarted", async () => {
          const { wave, playerName } = this.state;
          await this.game.start(playerName, this.emitter);
          this.game.nextWave(wave);
          this.toggleMenu();
          this.setState((old) => {
            return {
              started: !old.started
            };
          });
        });
        events.on("unpause", this.handlePause);
        events.on("gameOver", (lastWave) => {
          this.waveData.push(lastWave);
          let totalWaves = this.waveData.length;
          let accuracy = this.waveData.map((w2) => calculateAccuracy(w2)).reduce((a2, b) => a2 + b, 0);
          let wpm = this.waveData.map((w2) => calculateWpm(w2)).reduce((a2, b) => a2 + b, 0);
          let score = this.score;
          addEntry(
            this.state.playerName,
            (accuracy / totalWaves).toFixed(2),
            (wpm / totalWaves).toFixed(2),
            abbreviateNumber(score),
            totalWaves
          );
          this.setState({
            gameOver: true,
            inMenu: true
          });
        });
        events.on("restartGame", () => {
          this.setState({
            started: false,
            inMenu: true,
            paused: false,
            inSettings: false,
            intermission: false,
            gameOver: false,
            inLeaderboard: false,
            wave: 1
          });
          this.waveData = [];
          this.score = 0;
          Game$1.reset();
        });
      }
      componentWillUnmount() {
        document.removeEventListener("keydown", this._handleKeyDown, false);
      }
      render() {
        const { inMenu, paused: paused2, started, inSettings, inLeaderboard, gameOver, playerName, intermission } = this.state;
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          gameOver && /* @__PURE__ */ jsx(GameOverMenu, {}),
          !started && inLeaderboard && /* @__PURE__ */ jsx(LeaderboardMenu, {}),
          !started && !inSettings && !inLeaderboard && /* @__PURE__ */ jsx(StartMenu, { playerName }),
          paused2 && !intermission && /* @__PURE__ */ jsx(PauseMenu, {}),
          inSettings && /* @__PURE__ */ jsx(SettingsMenu, { playerName }),
          intermission && paused2 && /* @__PURE__ */ jsx(WaveMenu, { waveData: this.waveData, score: this.score }),
          /* @__PURE__ */ jsx(Background, { hidden: !inMenu })
        ] });
      }
    }
    const app = "";
    ReactDOM.render(/* @__PURE__ */ jsx(App, {}), document.getElementById("root"));
  }
});
export default require_index_001();
